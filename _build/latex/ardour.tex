%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
%% turn off hyperref patch of \index as sphinx.xdy xindy module takes care of
%% suitable \hyperpage mark-up, working around hyperref-xindy incompatibility
\PassOptionsToPackage{hyperindex=false}{hyperref}

\PassOptionsToPackage{warn}{textcomp}

\catcode`^^^^00a0\active\protected\def^^^^00a0{\leavevmode\nobreak\ }
\usepackage{cmap}
\usepackage{fontspec}
\usepackage{amsmath,amssymb,amstext}
\usepackage{polyglossia}
\setmainlanguage{english}

\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=auto}
\usepackage{geometry}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\addto\captionsenglish{\renewcommand{\figurename}{Fig.\@ }}
\makeatletter
\def\fnum@figure{\figurename\thefigure{}}
\makeatother
\addto\captionsenglish{\renewcommand{\tablename}{Table }}
\makeatletter
\def\fnum@table{\tablename\thetable{}}
\makeatother
\addto\captionsenglish{\renewcommand{\literalblockname}{Listing}}

\addto\captionsenglish{\renewcommand{\literalblockcontinuedname}{continued from previous page}}
\addto\captionsenglish{\renewcommand{\literalblockcontinuesname}{continues on next page}}
\addto\captionsenglish{\renewcommand{\sphinxnonalphabeticalgroupname}{Non-alphabetical}}
\addto\captionsenglish{\renewcommand{\sphinxsymbolsname}{Symbols}}
\addto\captionsenglish{\renewcommand{\sphinxnumbersname}{Numbers}}

\def\pageautorefname{page}





\title{Ardour Documentation}
\date{Jun 05, 2019}
\release{}
\author{nicolas}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}







\subsubsection*{The Ardour Manual}

{\hyperref[\detokenize{index:introduction-to-ardour}]{\emph{Introduction to Ardour}}}
{\hyperref[\detokenize{index:welcome-to-ardour}]{\emph{1 - Welcome to Ardour}}}
\begin{itemize}
\item {} 
{\hyperref[\detokenize{index:about-ardour-doc}]{\emph{1.1 - About Ardour’s documentation}}}

\item {} 
{\hyperref[\detokenize{index:ardour-overview}]{\emph{1.2 - Ardour Overview}}}

\item {} 
{\hyperref[\detokenize{index:why-is-it-called-ardour}]{\emph{1.3 - Why is it called Ardour?}}}

\item {} 
{\hyperref[\detokenize{index:why-write-a-daw-for-linux}]{\emph{1.4 - Why Write a DAW for Linux?}}}

\item {} 
{\hyperref[\detokenize{index:isnt-this-a-really-complicated-program}]{\emph{1.5 - Isn’t This a Really Complicated
Program?}}}

\item {} 
{\hyperref[\detokenize{index:creating-music-with-ardour}]{\emph{1.6 - Creating Music with Ardour}}}

\item {} 
{\hyperref[\detokenize{index:additional-resources}]{\emph{1.7 - Additional Resources}}}

\end{itemize}

{\hyperref[\detokenize{index:ardour-basics}]{\emph{2 - Ardour Basics}}}
\begin{itemize}
\item {} 
{\hyperref[\detokenize{index:starting-ardour}]{\emph{2.1 - Starting Ardour}}}

\item {} 
{\hyperref[\detokenize{index:understanding-basic-concepts-and-terminology}]{\emph{2.2 - Understanding Basic Concepts and
Terminology}}}

\item {} 
{\hyperref[\detokenize{index:using-the-mouse}]{\emph{2.3 - Using the Mouse}}}

\item {} 
{\hyperref[\detokenize{index:basic-gui-operations}]{\emph{2.4 - Basic GUI Operations}}}

\end{itemize}

{\hyperref[\detokenize{index:keyboard-and-mouse-shortcuts}]{\emph{3 - Keyboard and Mouse Shortcuts}}}
\begin{itemize}
\item {} 
{\hyperref[\detokenize{index:default-keyboard-bindings}]{\emph{3.1 - Default Keyboard Bindings}}}

\item {} 
{\hyperref[\detokenize{index:mnemonic-bindings-for-linux}]{\emph{3.2 - Mnemonic Bindings for Linux}}}

\item {} 
{\hyperref[\detokenize{index:mnemonic-bindings-for-os-x}]{\emph{3.3 - Mnemonic Bindings for OS X}}}

\end{itemize}

{\hyperref[\detokenize{index:ardour-configuration}]{\emph{Ardour Configuration}}}
{\hyperref[\detokenize{index:ardour-systems}]{\emph{4 - Ardour Systems}}}
\begin{itemize}
\item {} 
{\hyperref[\detokenize{index:the-right-computer-system-for-digital-audio}]{\emph{4.1 - The Right Computer System for Digital
Audio}}}

\item {} 
{\hyperref[\detokenize{index:mouse}]{\emph{4.2 - The Right Mouse}}}

\end{itemize}

{\hyperref[\detokenize{index:setting-up-your-system}]{\emph{5 - System Specific Setup}}}
\begin{itemize}
\item {} 
{\hyperref[\detokenize{index:ubuntu-linux}]{\emph{5.1 - Ubuntu Linux}}}

\item {} 
{\hyperref[\detokenize{index:microsoft-windows}]{\emph{5.2 - Microsoft Windows}}}

\item {} 
{\hyperref[\detokenize{index:kde-plasma-5}]{\emph{5.3 - KDE Plasma 5}}}

\end{itemize}

{\hyperref[\detokenize{index:io-setup}]{\emph{6 - I/O Setup}}}
\begin{itemize}
\item {} 
{\hyperref[\detokenize{index:connecting-audio-and-midi-devices}]{\emph{6.1 - Connecting Audio and MIDI
Devices}}}

\item {} 
{\hyperref[\detokenize{index:using-more-than-one-audio-device}]{\emph{6.2 - Using More Than One Audio
Device}}}

\item {} 
{\hyperref[\detokenize{index:monitor-setup-in-ardour}]{\emph{6.3 - Monitor Setup in Ardour}}}

\end{itemize}

{\hyperref[\detokenize{index:working-with-synchronization}]{\emph{7 - Synchronization}}}
\begin{itemize}
\item {} 
{\hyperref[\detokenize{index:on-clock-and-time}]{\emph{7.1 - On Clock and Time}}}

\item {} 
{\hyperref[\detokenize{index:latency-and-latency-compensation}]{\emph{7.2 - Latency and
Latency-Compensation}}}

\item {} 
{\hyperref[\detokenize{index:timecode-generators-and-slaves}]{\emph{7.3 - Timecode Generators and
Slaves}}}

\item {} 
{\hyperref[\detokenize{index:overview-of-all-timecode-related-settings}]{\emph{7.4 - Overview of all Timecode related
settings}}}

\end{itemize}

{\hyperref[\detokenize{index:preferences}]{\emph{8 - Preferences}}}
{\hyperref[\detokenize{index:session-properties-dialog}]{\emph{9 - Session Properties}}}
\begin{itemize}
\item {} 
{\hyperref[\detokenize{index:timecode-tab}]{\emph{9.1 - Timecode Tab}}}

\item {} 
{\hyperref[\detokenize{index:sync-tab}]{\emph{9.2 - Sync Tab}}}

\item {} 
{\hyperref[\detokenize{index:fades-tab}]{\emph{9.3 - Fades Tab}}}

\item {} 
{\hyperref[\detokenize{index:media-tab}]{\emph{9.4 - Media Tab}}}

\item {} 
{\hyperref[\detokenize{index:locations-tab}]{\emph{9.5 - Locations Tab}}}

\item {} 
{\hyperref[\detokenize{index:filenames-tab}]{\emph{9.6 - Filenames Tab}}}

\item {} 
{\hyperref[\detokenize{index:monitoring-tab}]{\emph{9.7 - Monitoring Tab}}}

\item {} 
{\hyperref[\detokenize{index:meterbridge-tab}]{\emph{9.8 - Meterbridge Tab}}}

\item {} 
{\hyperref[\detokenize{index:session-misc-tab}]{\emph{9.9 - Session Misc Tab}}}

\end{itemize}

{\hyperref[\detokenize{index:configuring-midi}]{\emph{10 - Configuring MIDI}}}
\begin{itemize}
\item {} 
{\hyperref[\detokenize{index:midi-on-linux}]{\emph{10.1 - MIDI on Linux}}}

\item {} 
{\hyperref[\detokenize{index:midi-on-os-x}]{\emph{10.2 - MIDI on OS X}}}

\end{itemize}

{\hyperref[\detokenize{index:ardours-interface}]{\emph{Ardour’s Interface}}}
{\hyperref[\detokenize{index:about-ardours-interface}]{\emph{11 - Ardour’s Interface Overview}}}
{\hyperref[\detokenize{index:main-menu}]{\emph{12 - Main Menu}}}
\begin{itemize}
\item {} 
{\hyperref[\detokenize{index:the-session-menu}]{\emph{12.1 - The Session Menu}}}

\item {} 
{\hyperref[\detokenize{index:the-transport-menu}]{\emph{12.2 - The Transport Menu}}}

\item {} 
{\hyperref[\detokenize{index:the-edit-menu}]{\emph{12.3 - The Edit Menu}}}

\item {} 
{\hyperref[\detokenize{index:the-region-menu}]{\emph{12.4 - The Region Menu}}}

\item {} 
{\hyperref[\detokenize{index:the-track-menu}]{\emph{12.5 - The Track Menu}}}

\item {} 
{\hyperref[\detokenize{index:the-view-menu}]{\emph{12.6 - The View Menu}}}

\item {} 
{\hyperref[\detokenize{index:the-window-menu}]{\emph{12.7 - The Window Menu}}}

\item {} 
{\hyperref[\detokenize{index:the-help-menu}]{\emph{12.8 - The Help Menu}}}

\end{itemize}

{\hyperref[\detokenize{index:status-bar}]{\emph{13 - Status Bar}}}
{\hyperref[\detokenize{index:transport-bar}]{\emph{14 - Transport Bar}}}
{\hyperref[\detokenize{index:transport-clocks}]{\emph{15 - Transport Clocks}}}
{\hyperref[\detokenize{index:selection-and-punch-clocks}]{\emph{16 - Selection and Punch Clocks}}}
{\hyperref[\detokenize{index:mini-timeline}]{\emph{17 - Mini-Timeline}}}
{\hyperref[\detokenize{index:other-toolbar-items}]{\emph{18 - Other Toolbar Items}}}
{\hyperref[\detokenize{index:toolbox}]{\emph{19 - Toolbox}}}
{\hyperref[\detokenize{index:controls}]{\emph{20 - Controls}}}
\begin{itemize}
\item {} 
{\hyperref[\detokenize{index:zoom-controls}]{\emph{20.1 - Zoom Controls}}}

\item {} 
{\hyperref[\detokenize{index:grid-controls}]{\emph{20.2 - Grid Controls}}}

\item {} 
{\hyperref[\detokenize{index:edit-point-control}]{\emph{20.3 - Edit Point Control}}}

\item {} 
{\hyperref[\detokenize{index:nudge-controls}]{\emph{20.4 - Nudge Controls}}}

\end{itemize}

{\hyperref[\detokenize{index:ruler}]{\emph{21 - Ruler}}}
{\hyperref[\detokenize{index:summary}]{\emph{22 - Summary}}}
{\hyperref[\detokenize{index:editor-lists}]{\emph{23 - Editor Lists}}}
\begin{itemize}
\item {} 
{\hyperref[\detokenize{index:the-region-list}]{\emph{23.1 - The Region List}}}

\item {} 
{\hyperref[\detokenize{index:the-tracks-and-busses-list}]{\emph{23.2 - The Tracks and Busses List}}}

\item {} 
{\hyperref[\detokenize{index:the-snapshot-list}]{\emph{23.3 - The Snapshot List}}}

\item {} 
{\hyperref[\detokenize{index:the-track-and-bus-group-list}]{\emph{23.4 - The Track and Bus Group
List}}}

\item {} 
{\hyperref[\detokenize{index:the-ranges-and-marks-lists}]{\emph{23.5 - The Ranges and Marks Lists}}}

\end{itemize}

{\hyperref[\detokenize{index:favorite-plugins-window}]{\emph{24 - Favorite Plugins Window}}}
{\hyperref[\detokenize{index:strips-list}]{\emph{25 - Strips list}}}
{\hyperref[\detokenize{index:groups-list}]{\emph{26 - Groups list}}}
{\hyperref[\detokenize{index:mixer-strips}]{\emph{27 - Mixer Strips}}}
\begin{itemize}
\item {} 
{\hyperref[\detokenize{index:audiomidi-mixer-strips}]{\emph{27.1 - Audio/MIDI Mixer Strips}}}

\item {} 
{\hyperref[\detokenize{index:audiomidi-busses-mixer-strips}]{\emph{27.2 - Audio/MIDI Busses Mixer
Strips}}}

\item {} 
{\hyperref[\detokenize{index:control-masters-mixer-strips}]{\emph{27.3 - VCA Mixer Strips}}}

\item {} 
{\hyperref[\detokenize{index:master-bus-strip}]{\emph{27.4 - Master Bus Strip}}}

\end{itemize}

{\hyperref[\detokenize{index:track-controls}]{\emph{28 - Editor Tracks}}}
\begin{itemize}
\item {} 
{\hyperref[\detokenize{index:audio-track-controls}]{\emph{28.1 - Audio Track Controls}}}

\item {} 
{\hyperref[\detokenize{index:midi-track-controls}]{\emph{28.2 - MIDI Track Controls}}}

\item {} 
{\hyperref[\detokenize{index:bus-controls}]{\emph{28.3 - Bus Controls}}}

\end{itemize}

{\hyperref[\detokenize{index:track-and-bus-groups}]{\emph{29 - Track and Bus Groups}}}
{\hyperref[\detokenize{index:monitor-section}]{\emph{30 - Monitor Section}}}
{\hyperref[\detokenize{index:sessions-tracks}]{\emph{Sessions \& Tracks}}}
{\hyperref[\detokenize{index:sessions}]{\emph{31 - Sessions}}}
\begin{itemize}
\item {} 
{\hyperref[\detokenize{index:whats-in-a-session}]{\emph{31.1 - What’s in a Session?}}}

\item {} 
{\hyperref[\detokenize{index:where-are-sessions-stored}]{\emph{31.2 - Where Are Sessions Stored?}}}

\item {} 
{\hyperref[\detokenize{index:newopen-session-dialog}]{\emph{31.3 - New/Open Session Dialog}}}

\item {} 
{\hyperref[\detokenize{index:renaming-a-session}]{\emph{31.4 - Renaming a Session}}}

\item {} 
{\hyperref[\detokenize{index:metadata}]{\emph{31.5 - Session Metadata}}}

\item {} 
{\hyperref[\detokenize{index:backup-and-sharing-of-sessions}]{\emph{31.6 - Backup and Sharing of
Sessions}}}

\end{itemize}

{\hyperref[\detokenize{index:tracks}]{\emph{32 - Tracks}}}
\begin{itemize}
\item {} 
{\hyperref[\detokenize{index:track-types}]{\emph{32.1 - Track Types}}}

\item {} 
{\hyperref[\detokenize{index:adding-tracks-busses-and-vcas}]{\emph{32.2 - Adding Tracks, Busses and
VCAs}}}

\item {} 
{\hyperref[\detokenize{index:controlling-track-ordering}]{\emph{32.3 - Controlling Track Ordering}}}

\item {} 
{\hyperref[\detokenize{index:track-context-menu}]{\emph{32.4 - Track Context Menu}}}

\end{itemize}

{\hyperref[\detokenize{index:controlling-track-appearance}]{\emph{33 - Controlling Track Appearance}}}
\begin{itemize}
\item {} 
{\hyperref[\detokenize{index:layering-display}]{\emph{33.1 - Layering Display}}}

\item {} 
{\hyperref[\detokenize{index:track-color}]{\emph{33.2 - Track Color}}}

\item {} 
{\hyperref[\detokenize{index:track-height}]{\emph{33.3 - Track Height}}}

\item {} 
{\hyperref[\detokenize{index:waveform-display}]{\emph{33.4 - Waveform display}}}

\end{itemize}

{\hyperref[\detokenize{index:importing-and-exporting-session-data}]{\emph{34 - Importing and Exporting Session
Data}}}
\begin{itemize}
\item {} 
{\hyperref[\detokenize{index:import-dialog}]{\emph{34.1 - Import Dialog}}}

\item {} 
{\hyperref[\detokenize{index:supported-file-formats}]{\emph{34.2 - Supported File Formats}}}

\item {} 
{\hyperref[\detokenize{index:adding-pre-existing-material}]{\emph{34.3 - Adding Pre-existing
Material}}}

\item {} 
{\hyperref[\detokenize{index:copying-versus-linking}]{\emph{34.4 - Copying Versus Linking}}}

\item {} 
{\hyperref[\detokenize{index:searching-for-files-using-tags}]{\emph{34.5 - Searching for Files Using
Tags}}}

\item {} 
{\hyperref[\detokenize{index:stem-exports}]{\emph{34.6 - Stem Exports}}}

\end{itemize}

{\hyperref[\detokenize{index:file-and-session-management-and-compatibility}]{\emph{35 - File and Session Management and
Compatibility}}}
\begin{itemize}
\item {} 
{\hyperref[\detokenize{index:session-templates}]{\emph{35.1 - Session Templates}}}

\item {} 
{\hyperref[\detokenize{index:snapshots}]{\emph{35.2 - Snapshots}}}

\item {} 
{\hyperref[\detokenize{index:cleaning-up-sessions}]{\emph{35.3 - Cleaning Up Sessions}}}

\item {} 
{\hyperref[\detokenize{index:interchange-with-other-daws}]{\emph{35.4 - Interchange with other DAWs}}}

\end{itemize}

{\hyperref[\detokenize{index:recording}]{\emph{Playback \& Recording}}}
{\hyperref[\detokenize{index:playing-back-track-material}]{\emph{36 - Playing Back Track Material}}}
\begin{itemize}
\item {} 
{\hyperref[\detokenize{index:controlling-playback}]{\emph{36.1 - Controlling Playback}}}

\item {} 
{\hyperref[\detokenize{index:using-key-bindings}]{\emph{36.2 - Using Key Bindings}}}

\end{itemize}

{\hyperref[\detokenize{index:audio-recording}]{\emph{37 - Audio Recording}}}
\begin{itemize}
\item {} 
{\hyperref[\detokenize{index:monitoring}]{\emph{37.1 - Monitoring}}}

\item {} 
{\hyperref[\detokenize{index:latency-considerations}]{\emph{37.2 - Latency Considerations}}}

\item {} 
{\hyperref[\detokenize{index:monitor-signal-flow}]{\emph{37.3 - Monitor Signal Flow}}}

\end{itemize}

{\hyperref[\detokenize{index:punch-recording-modes}]{\emph{38 - Punch Recording Modes}}}
\begin{itemize}
\item {} 
{\hyperref[\detokenize{index:working-with-markers}]{\emph{38.1 - Working With Markers}}}

\item {} 
{\hyperref[\detokenize{index:creating-location-markers}]{\emph{38.2 - Creating Location Markers}}}

\item {} 
{\hyperref[\detokenize{index:creating-range-markers}]{\emph{38.3 - Creating Range Markers}}}

\item {} 
{\hyperref[\detokenize{index:moving-markers}]{\emph{38.4 - Moving Markers}}}

\item {} 
{\hyperref[\detokenize{index:the-loop-range}]{\emph{38.5 - The Loop Range}}}

\item {} 
{\hyperref[\detokenize{index:marker-context-menu}]{\emph{38.6 - Marker Context Menu}}}

\item {} 
{\hyperref[\detokenize{index:punch-range}]{\emph{38.7 - Punch Range}}}

\end{itemize}

{\hyperref[\detokenize{index:editing-and-arranging}]{\emph{Editing}}}
{\hyperref[\detokenize{index:navigating-the-editor}]{\emph{39 - Navigating the Editor}}}
{\hyperref[\detokenize{index:editing-basics}]{\emph{40 - Editing Basics}}}
\begin{itemize}
\item {} 
{\hyperref[\detokenize{index:working-with-regions}]{\emph{40.1 - Working With Regions}}}

\item {} 
{\hyperref[\detokenize{index:region-naming}]{\emph{40.2 - Region Naming}}}

\item {} 
{\hyperref[\detokenize{index:corresponding-regions-selection}]{\emph{40.3 - Corresponding Regions
Selection}}}

\item {} 
{\hyperref[\detokenize{index:region-context-menu}]{\emph{40.4 - Region Context Menu}}}

\item {} 
{\hyperref[\detokenize{index:common-region-edit-operations}]{\emph{40.5 - Common Region Edit
Operations}}}

\item {} 
{\hyperref[\detokenize{index:copy-regions}]{\emph{40.6 - Copy Regions}}}

\item {} 
{\hyperref[\detokenize{index:move-regions-with-the-mouse}]{\emph{40.7 - Move Regions With the Mouse}}}

\item {} 
{\hyperref[\detokenize{index:align-spot-regions}]{\emph{40.8 - Align (Spot) Regions}}}

\end{itemize}

{\hyperref[\detokenize{index:edit-mode-and-tools}]{\emph{41 - Edit Mode and Tools}}}
\begin{itemize}
\item {} 
{\hyperref[\detokenize{index:editing-clocks}]{\emph{41.1 - Editing Clocks}}}

\item {} 
{\hyperref[\detokenize{index:which-regions-are-affected}]{\emph{41.2 - Which Regions Are Affected?}}}

\end{itemize}

{\hyperref[\detokenize{index:select-regions}]{\emph{42 - Making Selections}}}
{\hyperref[\detokenize{index:editing-regions-and-selections}]{\emph{43 - Editing Regions and
Selections}}}
\begin{itemize}
\item {} 
{\hyperref[\detokenize{index:trimming-regions}]{\emph{43.1 - Trimming Regions}}}

\item {} 
{\hyperref[\detokenize{index:pushpull-trimming}]{\emph{43.2 - Push/Pull Trimming}}}

\item {} 
{\hyperref[\detokenize{index:stretching}]{\emph{43.3 - Stretching}}}

\item {} 
{\hyperref[\detokenize{index:separate-under}]{\emph{43.4 - Separate Under}}}

\item {} 
{\hyperref[\detokenize{index:strip-silence-from-audio-regions}]{\emph{43.5 - Strip Silence from Audio
Regions}}}

\item {} 
{\hyperref[\detokenize{index:insert-remove-time}]{\emph{43.6 - Insert/Remove Time}}}

\item {} 
{\hyperref[\detokenize{index:region-properties}]{\emph{43.7 - Region Properties}}}

\end{itemize}

{\hyperref[\detokenize{index:create-region-fades-and-crossfades}]{\emph{44 - Fades and Crossfades}}}
{\hyperref[\detokenize{index:gain-envelopes}]{\emph{45 - Gain Envelopes}}}
{\hyperref[\detokenize{index:playlists}]{\emph{46 - Playlists}}}
\begin{itemize}
\item {} 
{\hyperref[\detokenize{index:understanding-playlists}]{\emph{46.1 - Understanding Playlists}}}

\item {} 
{\hyperref[\detokenize{index:playlist-operations}]{\emph{46.2 - Playlist Operations}}}

\item {} 
{\hyperref[\detokenize{index:playlist-usecases}]{\emph{46.3 - Playlist Usecases}}}

\end{itemize}

{\hyperref[\detokenize{index:rhythm-ferret}]{\emph{47 - Rhythm Ferret}}}
{\hyperref[\detokenize{index:midi}]{\emph{MIDI}}}
\begin{itemize}
\item {} 
{\hyperref[\detokenize{index:edit-midi}]{\emph{48 - MIDI Editing}}}

\item {} 
{\hyperref[\detokenize{index:create-midi-tracks}]{\emph{49 - Creating MIDI Tracks}}}

\item {} 
{\hyperref[\detokenize{index:create-midi-regions}]{\emph{50 - Creating MIDI Regions}}}

\item {} 
{\hyperref[\detokenize{index:add-new-notes}]{\emph{51 - Adding New Notes}}}

\item {} 
{\hyperref[\detokenize{index:change-note-properties}]{\emph{52 - Changing Note Properties}}}

\item {} 
{\hyperref[\detokenize{index:handling-overlapping-notes}]{\emph{53 - Handling Overlapping Notes}}}

\item {} 
{\hyperref[\detokenize{index:note-cut-copy-and-paste}]{\emph{54 - Note Cut, Copy and Paste}}}

\item {} 
{\hyperref[\detokenize{index:note-selection}]{\emph{55 - Note Selection}}}

\item {} 
{\hyperref[\detokenize{index:quantize-midi}]{\emph{56 - Quantizing MIDI}}}

\item {} 
{\hyperref[\detokenize{index:step-entry}]{\emph{57 - Step Entry}}}

\item {} 
{\hyperref[\detokenize{index:patch-change}]{\emph{58 - Patch Change}}}

\item {} 
{\hyperref[\detokenize{index:independent-and-dependent-midi-region-copies}]{\emph{59 - Independent and Dependent MIDI Region
Copies}}}

\item {} 
{\hyperref[\detokenize{index:transposing-midi}]{\emph{60 - Transposing MIDI}}}

\item {} 
{\hyperref[\detokenize{index:automating-midi---pitch-bending-and-aftertouch}]{\emph{61 - Automating MIDI-Pitch bending and
aftertouch}}}

\item {} 
{\hyperref[\detokenize{index:transforming-midi---mathematical-operations}]{\emph{62 - Transforming MIDI-Mathematical
operations}}}

\item {} 
{\hyperref[\detokenize{index:midi-list-editor}]{\emph{63 - MIDI List Editor}}}

\item {} 
{\hyperref[\detokenize{index:midi-tracer}]{\emph{64 - MIDI Tracer}}}

\item {} 
{\hyperref[\detokenize{index:midi-recording}]{\emph{65 - MIDI Recording}}}

\item {} 
{\hyperref[\detokenize{index:midi-scene-automation}]{\emph{66 - MIDI Scene Automation}}}

\end{itemize}

{\hyperref[\detokenize{index:arranging}]{\emph{Arranging}}}
{\hyperref[\detokenize{index:time-tempo-and-meter}]{\emph{67 - Time, Tempo and Meter}}}
\begin{itemize}
\item {} 
{\hyperref[\detokenize{index:tempo-and-meter}]{\emph{67.1 - Tempo and Meter}}}

\item {} 
{\hyperref[\detokenize{index:techniques-for-working-with-tempo-and-meter}]{\emph{67.2 - Techniques for Working with Tempo and
Meter}}}

\end{itemize}

{\hyperref[\detokenize{index:mixing}]{\emph{Mixing}}}
{\hyperref[\detokenize{index:basic-mixing}]{\emph{68 - Basic Mixing}}}
\begin{itemize}
\item {} 
{\hyperref[\detokenize{index:metering-in-ardour}]{\emph{68.1 - Metering in Ardour}}}

\item {} 
{\hyperref[\detokenize{index:signal-routing}]{\emph{68.2 - Signal Routing}}}

\item {} 
{\hyperref[\detokenize{index:aux-sends}]{\emph{68.3 - Aux Sends}}}

\item {} 
{\hyperref[\detokenize{index:comparing-aux-sends-and-subgroups}]{\emph{68.4 - Comparing Aux Sends and
Subgroups}}}

\item {} 
{\hyperref[\detokenize{index:external-sends}]{\emph{68.5 - External Sends}}}

\item {} 
{\hyperref[\detokenize{index:inserts}]{\emph{68.6 - Inserts}}}

\item {} 
{\hyperref[\detokenize{index:subgrouping}]{\emph{68.7 - Subgrouping}}}

\item {} 
{\hyperref[\detokenize{index:patchbay}]{\emph{68.8 - Patchbay}}}

\item {} 
{\hyperref[\detokenize{index:trackbus-signal-flow}]{\emph{68.9 - Track/Bus Signal Flow}}}

\item {} 
{\hyperref[\detokenize{index:sidechaining}]{\emph{68.10 - Sidechaining}}}

\item {} 
{\hyperref[\detokenize{index:muting-and-soloing}]{\emph{68.11 - Muting and Soloing}}}

\item {} 
{\hyperref[\detokenize{index:panning}]{\emph{68.12 - Panning}}}

\item {} 
{\hyperref[\detokenize{index:mono-panner}]{\emph{68.13 - Mono Panner}}}

\item {} 
{\hyperref[\detokenize{index:balance-control}]{\emph{68.14 - Balance Control}}}

\item {} 
{\hyperref[\detokenize{index:stereo-panner}]{\emph{68.15 - Stereo Panner}}}

\item {} 
{\hyperref[\detokenize{index:vbap-panner}]{\emph{68.16 - VBAP Panner}}}

\end{itemize}

{\hyperref[\detokenize{index:plugin-and-hardware-inserts}]{\emph{69 - Plugin and Hardware Inserts}}}
\begin{itemize}
\item {} 
{\hyperref[\detokenize{index:working-with-plugins}]{\emph{69.1 - Working With Plugins}}}

\item {} 
{\hyperref[\detokenize{index:processor-box}]{\emph{69.2 - Processor Box}}}

\item {} 
{\hyperref[\detokenize{index:plugin-manager}]{\emph{69.3 - Plugin Manager}}}

\item {} 
{\hyperref[\detokenize{index:managing-plugin-presets}]{\emph{69.4 - Managing Plugin Presets}}}

\item {} 
{\hyperref[\detokenize{index:working-with-ardour-built-plugin-editors}]{\emph{69.5 - Working with Ardour-built Plugin
Editors}}}

\item {} 
{\hyperref[\detokenize{index:plugins-bundled-with-ardour}]{\emph{69.6 - Plugins Bundled With Ardour}}}

\item {} 
{\hyperref[\detokenize{index:getting-more-plugins}]{\emph{69.7 - Getting More Plugins}}}

\item {} 
{\hyperref[\detokenize{index:using-windows-vst-plugins-on-linux}]{\emph{69.8 - Using Windows VST Plugins on
Linux}}}

\end{itemize}

{\hyperref[\detokenize{index:automation}]{\emph{70 - Automation}}}
\begin{itemize}
\item {} 
{\hyperref[\detokenize{index:automation-nomenclature}]{\emph{70.1 - Automation Nomenclature}}}

\item {} 
{\hyperref[\detokenize{index:automation-modes}]{\emph{70.2 - Automation Modes}}}

\item {} 
{\hyperref[\detokenize{index:automation-lanes}]{\emph{70.3 - Automation Lanes}}}

\item {} 
{\hyperref[\detokenize{index:automation-curves}]{\emph{70.4 - Automation Curves}}}

\item {} 
{\hyperref[\detokenize{index:track-automation}]{\emph{70.5 - Controlling a Track with Automation}}}

\end{itemize}

{\hyperref[\detokenize{index:mixdown}]{\emph{71 - Mixdown}}}
\begin{itemize}
\item {} 
{\hyperref[\detokenize{index:export-dialog}]{\emph{71.1 - Export Dialog}}}

\item {} 
{\hyperref[\detokenize{index:export-format-profiles}]{\emph{71.2 - Export Format Profiles}}}

\end{itemize}

{\hyperref[\detokenize{index:video}]{\emph{Video}}}
\begin{itemize}
\item {} 
{\hyperref[\detokenize{index:video-timeline-and-monitoring}]{\emph{72 - Video Timeline and
Monitoring}}}

\item {} 
{\hyperref[\detokenize{index:video-timeline-setup}]{\emph{73 - Video Timeline Setup}}}

\item {} 
{\hyperref[\detokenize{index:transcoding-formats-amp-codecs}]{\emph{74 - Transcoding, Formats \&
Codecs}}}

\item {} 
{\hyperref[\detokenize{index:workflow-amp-operations}]{\emph{75 - Workflow \& Operations}}}

\end{itemize}

{\hyperref[\detokenize{index:control-surfaces}]{\emph{Control Surfaces}}}
{\hyperref[\detokenize{index:controlling-ardour-with-osc}]{\emph{76 - Controlling Ardour with OSC}}}
\begin{itemize}
\item {} 
{\hyperref[\detokenize{index:osc58-controlling-ardour-with-osc}]{\emph{76.1 - OSC: Controlling Ardour with
OSC}}}

\item {} 
{\hyperref[\detokenize{index:osc58-using-the-setup-dialog}]{\emph{76.2 - OSC: Using the Setup
Dialog}}}

\item {} 
{\hyperref[\detokenize{index:osc58-querying-ardour}]{\emph{76.3 - OSC: Querying Ardour}}}

\item {} 
{\hyperref[\detokenize{index:osc58-feedback}]{\emph{76.4 - OSC: Feedback}}}

\item {} 
{\hyperref[\detokenize{index:osc58-feedback-and-strip-types-values}]{\emph{76.5 - OSC: Feedback and Strip-types
Values}}}

\item {} 
{\hyperref[\detokenize{index:osc58-jog-modes}]{\emph{76.6 - OSC: Jog Modes}}}

\item {} 
{\hyperref[\detokenize{index:osc58-automation}]{\emph{76.7 - OSC: Automation}}}

\item {} 
{\hyperref[\detokenize{index:osc58-personal-monitoring-control}]{\emph{76.8 - OSC: Personal Monitoring
Control}}}

\item {} 
{\hyperref[\detokenize{index:osc58-parameter-types}]{\emph{76.9 - OSC: Parameter Types}}}

\item {} 
{\hyperref[\detokenize{index:osc58-selection-and-expansion-considerations}]{\emph{76.10 - OSC: Selection and Expansion
Considerations}}}

\item {} 
{\hyperref[\detokenize{index:osc-control-for-ardour-4.7-and-prior}]{\emph{76.11 - OSC control for Ardour 4.7 and
Prior}}}

\end{itemize}

{\hyperref[\detokenize{index:controlling-ardour-with-mackie-control-devices}]{\emph{77 - Controlling Ardour with Mackie Control
Devices}}}
\begin{itemize}
\item {} 
{\hyperref[\detokenize{index:devices-using-mackielogic-control-protocol}]{\emph{77.1 - Devices Using Mackie/Logic Control
Protocol}}}

\item {} 
{\hyperref[\detokenize{index:ssl-nucleus}]{\emph{77.2 - SSL Nucleus}}}

\item {} 
{\hyperref[\detokenize{index:behringer-devices-in-mackielogic-control-mode}]{\emph{77.3 - Behringer Devices in Mackie/Logic Control
Mode}}}

\item {} 
{\hyperref[\detokenize{index:what-to-do-if-your-device-is-not-listed}]{\emph{77.4 - What to do if your Device is not
Listed}}}

\item {} 
{\hyperref[\detokenize{index:working-with-extenders}]{\emph{77.5 - Working With Extenders}}}

\end{itemize}

{\hyperref[\detokenize{index:generic-midi}]{\emph{78 - Generic MIDI}}}
\begin{itemize}
\item {} 
{\hyperref[\detokenize{index:generic-midi-binding-maps}]{\emph{78.1 - Generic MIDI Binding Maps}}}

\item {} 
{\hyperref[\detokenize{index:generic-midi-learn}]{\emph{78.2 - Generic MIDI Learn}}}

\item {} 
{\hyperref[\detokenize{index:generic-midi-and-encoders}]{\emph{78.3 - Generic MIDI and Encoders}}}

\end{itemize}

{\hyperref[\detokenize{index:using-the-presonus-faderport}]{\emph{79 - Using the PreSonus FaderPort}}}
{\hyperref[\detokenize{index:using-the-presonus-faderport8}]{\emph{80 - Using the PreSonus FaderPort 8}}}
{\hyperref[\detokenize{index:using-the-ableton-push-2}]{\emph{81 - Using the Ableton Push 2}}}
{\hyperref[\detokenize{index:scripting}]{\emph{Scripting}}}
\begin{itemize}
\item {} 
{\hyperref[\detokenize{index:lua-scripting}]{\emph{82 - Lua Scripting}}}

\item {} 
{\hyperref[\detokenize{index:class-reference}]{\emph{83 - Lua Bindings Class Reference}}}

\end{itemize}

{\hyperref[\detokenize{index:appendix}]{\emph{Appendix}}}
\begin{itemize}
\item {} 
{\hyperref[\detokenize{index:list-of-menu-actions}]{\emph{84 - List of Menu Actions}}}

\item {} 
{\hyperref[\detokenize{index:ardour-monitor-modes}]{\emph{85 - Ardour Monitor Modes}}}

\item {} 
{\hyperref[\detokenize{index:files-and-directories-ardour-knows-about}]{\emph{86 - Files and Directories Ardour Knows
About}}}

\item {} 
{\hyperref[\detokenize{index:midi-notes-ref}]{\emph{87 - MIDI notes reference}}}

\end{itemize}




\subsubsection*{Part I - Introduction to Ardour}
\subsubsection*{1 - Welcome to Ardour}
\subsubsection*{1.1 - About Ardour’s documentation}
\subsubsection*{Conventions Used In This Manual}

This section covers some of the typographical and language conventions
used in this manual.
\subsubsection*{Keyboards and Modifiers}

Keyboard bindings are shown like this: s or x.

x means “press the key, keep it pressed and then also press the x key”.

Combinations such as e may be seen, which means “hold down the key \sphinxstyleemphasis{and}
the key, and then, while keeping them both down, press the e key”.

Different platforms have different conventions for which modifier key
(Control or Command) to use as the primary or most common modifier. When
viewing this manual from a machine identifying itself as running OS X,
Cmd will be seen where appropriate (for instance in the first example
above). On other machines Ctrl will be seen instead.
\subsubsection*{Mouse Buttons}

{\hyperref[\detokenize{index:mouse}]{\emph{Mouse buttons}}} are referred to as Left, Middle and Right.
Ardour can use additional buttons, but they have no default behaviour in
the program.
\subsubsection*{Mouse Click Modifiers}

Many editing functions are performed by clicking the mouse while holding
a modifier key, for example Left.
\subsubsection*{Mouse Wheel}

Some GUI elements can optionally be controlled with the mouse wheel when
the pointer is hovering over them. The notation for mouse wheel action
is ⇑ ⇐ ⇓ ⇒.
\subsubsection*{Context-click}

The term context-click is used to indicate a Right-click on a particular
element of the graphical user interface. Although right-click is the
common, default way to do this, there are other ways to accomplish the
same thing—this term refers to any of them, and the result is always
that a menu specific to the item clicked on will be displayed.
\subsubsection*{“The Pointer”}

When the manual refers to the “pointer”, it means the on-screen
representation of the mouse position or the location of a touch action
if touch interface is being used.
\subsubsection*{Other User Input}

Ardour supports hardware controllers, such as banks of faders, knobs, or
buttons.
\subsubsection*{Menu Items}

Menu items are indicated like this: Top \textgreater{} Next \textgreater{} Deeper. Each
“\textgreater{}”-separated item indicates one level of a nested menu or sub-menu.
\subsubsection*{OSC Messages}

OSC messages, whether sent or received, are displayed like this:
/transport\_stop.
\subsubsection*{Preference/Dialog Options}

Choices in various dialogs, notably the Preferences and Properties
dialog, are indicated thus:

Edit \textgreater{} Preferences \textgreater{} Audio \textgreater{} Some Option.

Each successive item indicates either a menu, sub-menu, or a tabbed
dialog navigation. The final item is the one to choose or select.

If an option is deselected, it will look like this:

Edit \textgreater{} Preferences \textgreater{} Audio \textgreater{} Some other Option.
\subsubsection*{User Input}

Some dialogs or features may require the user to input data such as
this. In rare cases, certain operations will be required to be performed
at the command line of the operating system:

cat /proc/cpuinfo sleep 3600 ping www.google.com
.. rubric:: Program Output
\begin{quote}
\begin{quote}\begin{description}
\item[{name}] \leavevmode
program-output

\end{description}\end{quote}
\end{quote}

Important messages from Ardour or other programs will be displayed like
this.
\subsubsection*{Notes}

Important notes about things that might not otherwise be obvious are
shown in this format.
\subsubsection*{Warnings}

Hairy issues that might cause things to go wrong, lose data, impair
sound quality, or eat your proverbial goldfish, are displayed in this
way.
\subsubsection*{1.2 - Ardour Overview}

Ardour is a professional digital workstation for working with audio and
MIDI.
\subsubsection*{Ardour is meant for…}
\subsubsection*{Audio Engineers}

Ardour’s core user group: people who want to record, edit, mix and
master audio and MIDI projects. When you need complete control over your
tools, when the limitations of other designs get in the way, when you
plan to spend hours or days working on a session, Ardour is there to
make things work the way you want them to.
\subsubsection*{Musicians}

Being the best tool to record talented performers on actual instruments
has always been a top priority for Ardour. Rather than being focused on
electronic and pop music idioms, Ardour steps out of the way to
encourage the creative process to remain where it always has been: a
musician playing a carefully designed and well built instrument.
\subsubsection*{Soundtrack Editors}

Sample accurate sync and shared transport control with video playback
tools allows Ardour to provide a fast and natural environment for
creating and editing soundtracks for film and video projects.
\subsubsection*{Composers}

Arrange audio and MIDI using the same tools and same workflow. Use
external hardware synthesizers or software instruments as sound sources.
From sound design to electro-acoustic composition to dense multitrack
MIDI editing, Ardour can help.
\subsubsection*{Ardour features…}
\subsubsection*{Audio and MIDI Multi-Track Recording and Editing}

Any number of tracks and busses. Non-linear editing. Non-destructive
(and destructive!) recording. Any bit depth, any sample rate. Dozens of
file formats.
\subsubsection*{Plugins with Full Sample Accurate Automation}

AudioUnit, LV2, LinuxVST and LADSPA formats. FX plugins. Software
instruments. MIDI processors. Automate any parameters. Physically
manipulate them via control surfaces. Distribute processing across as
many (or as few) cores as you want.
\subsubsection*{Transport Sync and External Control Surfaces}

Best-in-industry sync to MIDI timecode and LTC. Send and receive MIDI
Machine Control. Sync with JACK transport and MIDI clock. Dedicated
Mackie Control protocol support, pre-defined mappings for many MIDI
controllers plus dynamic MIDI learn. Use OSC to drive almost any
operation in Ardour.
\subsubsection*{Powerful Anywhere-to-Anywhere Signal Routing}

Complex signal flows are simple and elegant. Inputs and outputs connect
to your hardware and/or other applications. Use sends, inserts and
returns freely. Connections can be one-to-many, many-to-one or
many-to-many. Tap signal flows at any point. If you can’t connect in the
way you want with Ardour, it probably can’t be done.
\subsubsection*{Video Timeline}

Import a single video and optionally extract the soundtrack from it.
Display a frame-by-frame (thumbnail) timeline of the video. Use a
Video-monitor window, or full-screen display, of the imported video in
sync with any of the available ardour timecode sources. Lock
audio-regions to the video: Move audio-regions with the video at
video-frame granularity. Export the video, cut start/end, add blank
frames and/or mux it with the soundtrack of the current-session.
\subsubsection*{1.3 - Why is it called Ardour?}

The name “Ardour” came from considerations of how to pronounce the
acronym HDR. The most obvious attempt sounds like a vowel-less “harder”
and it then was then a short step to an unrelated but slightly
homophonic word:
\begin{quote}

\begin{DUlineblock}{0em}
\item[] ardour \sphinxstyleemphasis{n} 1: a feeling of strong eagerness (usually in favor of a
person or cause); “they were imbued with a revolutionary ardor”;
“he felt a kind of religious zeal” {[}syn: ardor, elan, zeal{]}
\item[] 2: intense feeling of love {[}syn: ardor{]}
\item[] 3: feelings of great warmth and intensity; “he spoke with great
ardor” {[}syn: ardor, fervor, fervour, fervency, fire, fervidness{]}
\end{DUlineblock}
\end{quote}

Given the work required to develop Ardour, and the personality of its
primary author, the name seemed appropriate even without the vague
relationship to HDR.

Years later, another interpretation of “Ardour” appeared, this time
based on listening to non-native English speakers attempt to pronounce
the word. Rather than “Ardour”, it became “Our DAW”, which seemed
poetically fitting for a Digital Audio Workstation whose source code and
design belongs to a group of collaborators.
\subsubsection*{1.4 - Why Write a DAW for Linux?}

There are already a number of excellent digital audio workstations. To
mention just a few: ProTools, Nuendo, Samplitude, Digital Performer,
Logic, Cubase (SX), Sonar, along with several less well known systems
such as SADIE, SAWStudio and others. Each of these programs has its
strengths and weaknesses, although over the last few years most of them
have converged on a very similar set of core features. However, each of
them suffers from two problems when seen from the perspective of
Ardour’s development group:
\begin{itemize}
\item {} 
they do not run natively on Linux

\item {} 
they are not available in source code form, making modifications,
improvements, bugfixes by technically inclined users or their friends
or consultants impossible.

\end{itemize}

It is fairly understandable that most existing proprietary DAWs do not
run on Linux, given the rather small (but growing) share of the desktop
market that Linux has. However, when surveying the landscape of “popular
operating systems”, we find:
\begin{itemize}
\item {} 
older versions of Windows: plagued by abysmal stability and appalling
security

\item {} 
newer versions of Windows seem stable but still suffer from security
problems

\item {} 
OS X: a nice piece of engineering that is excellent for audio work
but only runs on proprietary hardware and still lacks the flexibility
and adaptability of Linux.

\end{itemize}

Security matters today, and will matter more in the future as more and
more live or semi-live network based collaborations take place.

Let’s contrast this with Linux, an operating system which:
\begin{itemize}
\item {} 
can stay up for months (or even years) without issues

\item {} 
is endlessly configurable down to the tiniest detail

\item {} 
is not owned by any single corporate entity, ensuring its life and
direction are not intertwined with that of a company (for a contrary
example, consider BeOS)

\item {} 
is fast and efficient

\item {} 
runs on almost any computing platform ever created, including old
“slow” systems and new “tiny” systems (e.g. Raspberry Pi)

\item {} 
is one of the most secure operating systems “out of the box”

\end{itemize}

More than anything, however, Ardour’s primary author uses Linux and
wanted a DAW that ran there.

Having written a DAW for Linux, it turned out to be relatively easy to
port Ardour to OS X, mostly because of the excellent work done by the
JACK OS X group that ported JACK to OS X.
\subsubsection*{1.5 - Isn’t This a Really Complicated Program?}

There is no point in pretending that Ardour is a simple, easy to use
program. The development group has worked hard to try to make simple
things reasonably easy, common tasks quick, and hard and/or uncommon
things possible. There is no doubt that there is more to do in this
area, as well as polishing the user interface to improve its
intuitiveness and work flow characteristics.

At the same time, multi-track, multi-channel, non-linear,
non-destructive audio editing is a far from simple process. Doing it
right requires not only a good ear, but a solid appreciation of basic
audio concepts and a robust mental model/metaphor of what one is doing.
Ardour is not a simple “audio recorder”—it can certainly be used to
record stereo (or even mono) material in a single track, but the program
has been designed around much richer capabilities than this.

Some people complain that Ardour is not “intuitive” to use—its lead
developer has \sphinxhref{https://community.ardour.org/node/3322}{some thoughts on
that}.
\subsubsection*{1.6 - Creating Music with Ardour}

Ardour can be used in many different ways, from extremely simple to
extremely complex. Many projects can be handled using the following kind
of workflow:
\subsubsection*{Stage 1: Creating The Project}

The first step is to create a new session, or open an existing one. A
session consists of a folder containing a session file that defines all
the information about the session. All media files used by the session
are usually stored within the session folder.

More details on sessions can be found in {\hyperref[\detokenize{index:sessions}]{\emph{Sessions}}}
chapter.
\subsubsection*{Stage 2: Creating and Importing Audio and MIDI Data}

Once a session has been created, it will be necessary to add some audio
and/or MIDI material to it—which can be done in one of 3 ways:
\begin{itemize}
\item {} 
Record incoming audio or MIDI data, either via audio or MIDI hardware
connected to the computer, or from other applications

\item {} 
Create new MIDI data using the mouse and/or various dialogs

\item {} 
Import existing media files into the session

\end{itemize}

MIDI recordings consist of performance data (“play note X at time T”)
rather than actual sound. As a result, they are more flexible than
actual audio, since the precise sound that they will generate when
played depends on where the MIDI data is sent to. Two different
synthesizers may produce very different sounds in response to the same
incoming MIDI data.

Audio recordings can be made from external instruments with electrical
outputs (keyboards, guitars, etc.), or via microphones or other sound
capturing equipment.

Ardour can use the JACK Audio Connection Kit for all audio and MIDI I/O,
making recording audio/MIDI from other applications fundamentally
identical to recording audio/MIDI from audio/MIDI hardware.
\subsubsection*{Stage 3: Editing and Arranging}

Once there is material within the session, it can be arranged in time.
This is done in one of the two main windows of Ardour: the Editor
window.

Audio/MIDI data appears in chunks called regions, which are arranged
into horizontal lanes called tracks. Tracks are stacked vertically in
the Editor window. Regions can be copied, shortened, moved, and deleted
without changing the actual data stored in the session at all—Ardour is
a non-destructive editor. (Almost) nothing done while editing will ever
modify the files stored on disk (with the exception of the session file
itself).

Many transformations can be done to the contents of regions, again
without altering anything on disk. It is possible to alter, move, delete
and remove silence from audio regions, for example.

MIDI regions can also be copied, moved, shortened, or deleted without
altering the MIDI files, though any edit like adding, suppressing or
moving \sphinxstyleemphasis{notes} inside a region results in a modification of the
underlying MIDI file.
\subsubsection*{Stage 4: Mixing and Adding Effects}

Once the arrangement of the session mostly complete, the next step is
the mixing phase. Mixing is a broad term to cover the way the audio
signals that the session generates during playback are processed and
added together into a final result that is actually heard. It can
involve altering the relative levels of various parts of the session,
adding effects that improve or transform certain elements, and others
that bring the sound of the whole session to a new level.

Ardour allows automation of changes to any mixing parameters (such as
volume, panning, and effects controls)—it will record the changes made
over time, using a mouse or keyboard or some external control device,
and can play back those changes later. This is very useful because often
the settings needed will vary in one part of a session compared to
another—rather than using a single setting for the volume of a track, it
may need increases followed by decreases (for example, to track the
changing volume of a singer). Using automation can make all of this
relatively easy.
\subsubsection*{Stage 5: Export}

Once the arrangement and mix of the session is finalized, a single audio
file that contains a ready-to-listen to version of the work is usually
desired. Ardour allows the exporting of audio files in a variety of
formats (simultaneously in some cases). This exported file would
typically be used in creating a CD, or be the basis for digital
distribution of the work.

Of course it is sometimes desirable to export material that isn’t
finished yet—for example, to give a copy to another party to mix on
their own system. Ardour allows exporting as much of a session as
desired, at any time, in any supported format.
\subsubsection*{1.7 - Additional Resources}

In addition to this documentation, there are a variety of other
resources:
\begin{itemize}
\item {} 
the \sphinxhref{https://ardour.org/whatsnew.html}{Ardour release notes}

\item {} 
the \sphinxhref{https://community.ardour.org/forums}{Ardour Forums}

\item {} 
information about \sphinxhref{https://community.ardour.org/community}{Ardour
Support} via mailing lists
and IRC (chat)

\end{itemize}

The IRC channels in particular are where most of the day-to-day
development and debugging is done, and there are plenty of experienced
users to help if problems are encountered when using Ardour.

Please be prepared to hang around for a few hours, the chat is usually
busiest from 19:00 UTC to 04:00 UTC. It is best to keep one’s IRC client
window open if possible, so that a belated answer can be seen.
\subsubsection*{2 - Ardour Basics}
\subsubsection*{2.1 - Starting Ardour}

There are several ways of starting Ardour, which may vary depending on
which platform it is being used on:
\begin{itemize}
\item {} 
by double-clicking the Ardour icon in the platform’s file manager
(e.g. Nautilus on Linux, Finder on OS X)

\item {} 
by double-clicking on an Ardour session file in the platform’s file
manager

\item {} 
on Linux, Ardour can also be started via the command line (see below)

\end{itemize}

When Ardour is run for the very first time, a special dialog is
displayed that will ask several questions about the system’s setup. The
questions will not be asked again, but the choices thus made can always
be modified via the Edit \textgreater{} Preferences dialog.

If JACK is needed, in general, it is sensible to start it \sphinxstyleemphasis{before}
Ardour is run. Though this is not strictly necessary, it will provide
more control and options over JACK’s operation. JACK can be started
through the CLI of a terminal, or by using a GUI program, like
\sphinxhref{https://qjackctl.sourceforge.io/}{QjackCtl} or
\sphinxhref{http://kxstudio.linuxaudio.org/Applications:Cadence}{Cadence}.

If Ardour is opened without specifying an existing session, it will
display the Session \textgreater{} New… dialog and the Audio/MIDI Setup dialog. See
{\hyperref[\detokenize{index:newopen-session-dialog}]{\emph{New/Open Session Dialog}}} for a description
of those dialogs.
\subsubsection*{Starting Ardour From the Command Line (Linux)}

Like (almost) any other program on Linux, Ardour can be started on the
command line. Type the following command in a terminal window:

Ardour5
To start Ardour with an existing session, use:

Ardour5 \sphinxstyleemphasis{/path/to/session}
Replace /path/to/session with the actual path of the session. Either the
session folder or any session file inside the folder can be specified,
including snapshots.

To start Ardour with a new, named session, use:

Ardour5 -N \sphinxstyleemphasis{/path/to/session}
.. rubric:: 2.2 - Understanding Basic Concepts and Terminology
\begin{quote}
\begin{quote}\begin{description}
\item[{name}] \leavevmode
understanding-basic-concepts-and-terminology

\item[{class}] \leavevmode
clear

\end{description}\end{quote}
\end{quote}

In order to fully grasp the terms used in Ardour (and this manual), it
is necessary to understand what things like sessions, tracks, busses,
regions and so on—as used in Ardour—are.
\subsubsection*{Sessions}

An Ardour session is a container for an entire project. A session may
contain an arbitrary number of tracks and busses consisting of audio and
MIDI data, along with information on processing those tracks, a mix of
levels, and everything else related to the project. A session might
typically contain a song, an entire album, or a complete live recording.

Ardour sessions are kept in directories; these directories contain one
or more session files, some or all of the audio and MIDI data, and a
number of other state files that Ardour requires. The session file
describes the structure of the session, and holds automation data and
other details.

Ardour’s session file is written in XML format, which is advantageous as
it is \sphinxstyleemphasis{somewhat} human-readable and human-editable in a crisis. Sound
files are stored in one of a number of optional formats, and MIDI files
as SMF.

It is also possible for Ardour sessions to reference sound and MIDI
files outside the session directory, to conserve disk space and avoid
unnecessary copying if the data is available elsewhere on the disk.

Ardour has a single current session at all times; if Ardour is started
without specifying one, it will offer to load or create one.

More details can be found in the {\hyperref[\detokenize{index:sessions}]{\emph{Sessions}}} chapter.
\subsubsection*{Tracks}

A track is a concept common to most DAWs, and also used in Ardour.
Tracks can record audio or MIDI data to disk, and then replay it with
processing. They also allow the audio or MIDI data to be edited in a
variety of different ways.

In a typical pop production, one track might be used for the kick drum,
another for the snare, more perhaps for the drum overheads and others
for bass, guitars and vocals.

Ardour can record to any number of tracks at one time, and then play
those tracks back. On playback, a track’s recordings may be processed by
any number of plugins, panned, and/or its level altered to achieve a
suitable mix.

A track’s type is really only related to the type of data that it stores
on disk. It is possible, for example, to have a MIDI track with a
synthesizer plugin which converts MIDI to audio. Even though the track
remains MIDI (in the sense that its on-disk recordings are MIDI), its
output may be audio-only.

More details can be found in the {\hyperref[\detokenize{index:tracks}]{\emph{Tracks}}} chapter.
\subsubsection*{Busses}

Busses are another common concept in both DAWs and hardware mixers. They
are similar in many ways to tracks; they process audio or MIDI, and can
run processing plugins. The only difference is that their input is
obtained from other tracks or busses, rather than from disk.

A bus might typically be used to collect together the outputs of related
tracks. Consider, for example, a three track recording of a drum kit;
given kick, snare and overhead tracks, it may be helpful to connect the
output of each to a bus called “drums”, so that the drum kit’s level can
be set as a unit, and processing (such as equalization or compression)
can be applied to the mix of all the tracks. Such busses are also called
groups.
\subsubsection*{Regions}

A track may contain many segments of audio or MIDI. Ardour contains
these segments in things called regions, which are self-contained
snippets of audio or MIDI data. Any recording pass, for example,
generates a region on each track that is enabled for recording. Regions
can be subjected to many editing operations; they may be moved around,
split, trimmed, copied, and so on.

More details can be found at {\hyperref[\detokenize{index:working-with-regions}]{\emph{Working With
Regions}}}.
\subsubsection*{Playlists}

The details of what exactly each track should play back is described by
a playlist. A playlist is simply a list of regions; each track always
has an active playlist, and can have other playlists which can be
switched in and out as required.

More details can be found in the {\hyperref[\detokenize{index:playlists}]{\emph{Playlists}}} chapter.
\subsubsection*{Plugins}

Ardour allows processing audio and MIDI using any number of plugins.
These are external pieces of code, commonly seen as VST plugins on
Windows or AU plugins on Mac OS X. Ardour supports the following plugin
standards:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

LADSPA
&
the first major plugin standard
for Linux. Many LADSPA plugins
are available, mostly free and
open-source.
\\
\hline
LV2
&
the successor to LADSPA. Lots of
plugins have been ported from
LADSPA to LV2, and also many new
plugins written.
\\
\hline
VST
&
Ardour supports VST plugins that
have been compiled for Linux.
\\
\hline
AU
&
Mac OS X versions of Ardour
support AudioUnit plugins.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

Ardour has some support for running Windows VST plugins on Linux, but
this is rather complicated, extremely difficult for the Ardour
developers to debug, and generally unreliable, as it requires running a
large amount of Windows code in an emulated environment. If it is at all
possible, it is strongly advisable to use native LADSPA, LV2 or Linux
VST plugins on Linux, or AU on Mac OS X.

More details can be found at {\hyperref[\detokenize{index:working-with-plugins}]{\emph{Working With
Plugins}}}.
\subsubsection*{2.3 - Using the Mouse}
\subsubsection*{Clicking}

Throughout this manual, the term click refers to the act of pressing and
releasing the Left mouse button. This action is used to select objects,
activate buttons, turn choices on and off, pop up menus and so forth. On
touch surfaces, it also corresponds to a single, one-finger tap on the
GUI.
\subsubsection*{Right Clicking}

The term right-click refers to the act of pressing and releasing the
Right mouse button. This action is used to pop up context menus (hence
the term “context click”, which will also be seen). It is also used by
default in combination with the shift key to delete objects within the
editor window.

Some mice designed for use with Mac OS X may have only one button. By
convention, pressing and holding the Control key while clicking is
interpreted as a right-click by many applications.
\subsubsection*{Middle Clicking}

A middle-click refers to the act of pressing and releasing the Middle
mouse button. Not all mice have a middle click button (see the
{\hyperref[\detokenize{index:mouse}]{\emph{Mouse}}} chapter for details). Sometimes the scroll wheel acts
as a clickable middle button. This action is used for time-constrained
region copying and mapping MIDI bindings.

Internally, your operating system may identify the mouse buttons as
Button1, Button2, and Button3, respectively. It may be possible to
invert the order of buttons to accommodate left-handed users, or to
re-assign them arbitrarily. This manual assumes the canonical order.
\subsubsection*{Double Clicking}

A double click refers to two rapid press/release cycles on the leftmost
mouse button. The time interval between the two actions that determines
whether this is seen as two clicks or one double click is controlled by
your system preferences, not by Ardour.
\subsubsection*{Dragging}

A drag primarily refers to the act of pressing the leftmost mouse
button, moving the mouse with the button held down, and then releasing
the button. On touch surfaces, this term also corresponds to a single
one-finger touch-move-release action.

Ardour also uses the middle mouse button for certain kinds of drags,
which will be referred to as a middle-drag.
\subsubsection*{Modifiers}

There are many actions in Ardour that can be carried out using a mouse
button in combination with a modifier key. When the manual refers to
Left, it means that you should first press the key, carry out a left
click while is held down, and then finally release the key.

Available modifiers depend on your platform:
\subsubsection*{Linux Modifiers}
\begin{itemize}
\item {} 
Ctrl (Control)

\item {} 
Shift

\item {} 
Alt

\item {} 
Win (Super/Windows)

\end{itemize}
\subsubsection*{OS X Modifiers}
\begin{itemize}
\item {} 
Cmd (Command, “windmill”)

\item {} 
Ctrl (Control)

\item {} 
Alt (Option)

\item {} 
Shift

\end{itemize}
\subsubsection*{Scroll Wheel}

Ardour can make good use of a scroll wheel on the mouse (assuming it has
one), which can be utilized for a variety of purposes. Scroll wheels
generate vertical scroll events, ⇑ (ScrollUp) and ⇓ (ScrollDown). Some
also emit horizontal events, ⇐ (ScrollLeft) and ⇒ (ScrollRight).

When appropriate, Ardour will differentiate between these two different
scroll axes. Otherwise it will interpret ScrollDown and ScrollLeft as
equivalent and similarly interpret ScrollUp and ScrollRight as
equivalent.

Typically, scroll wheel input is used to adjust continuous controls such
as faders and knobs, or to scroll vertically or horizontally inside a
window.
\subsubsection*{2.4 - Basic GUI Operations}

By default, Ardour will show helpful tooltips about the purpose and use
of each GUI element if the pointer is positioned over it and hovered
there for a short while. These little pop-up messages can be a good way
to discover the purpose of many aspects of the GUI.

Pop-ups can also be distracting for experienced users, who may wish to
disable them via Edit \textgreater{} Preferences \textgreater{} GUI \textgreater{} Show tooltip if mouse hovers
over a control.
\subsubsection*{Selection Techniques}

Ardour follows the conventions used by most other computer software
(including other DAWs) for selecting objects in the GUI.
\subsubsection*{Selecting individual objects}

Clicking on an object (sometimes on a particular part of its on-screen
representation) will select the object, and deselect other similar
objects.
\subsubsection*{Selecting multiple (similar) objects}

A left-click on an object toggles its selected status, so using left on
a series of objects will select (or deselect) each one of them. A
completely arbitrary set of selections can be constructed with this
technique.
\subsubsection*{Selecting a range of objects}

In cases where the idea of “select all objects between this one and that
one” makes sense, select one object and then left-click on another to
select both of them as well as all objects in between.
\subsubsection*{Time range selection}

To select a time range in the Editor, Left-click and drag the mouse. A
Left drag then lets you create other ranges and a left-click extends a
range to cover a wider area.
\subsubsection*{Selection Undo}

The set of objects (including time range) that are selected at any one
time is known as the selection. Each time an object is selected or
deselected, the new selection is stored in an undo/redo stack. This
stack is cleared each time the content of the timeline changes.

If a complex selection has been built up and then accidentally cleared
it, choosing Edit \textgreater{} Undo Selection Change will restore the previous
selection. If a selection is undone and a return to the state before the
undo is desired, choosing Edit \textgreater{} Redo Selection Change will take the
selection back to where it was before Edit \textgreater{} Undo Selection Change was
chosen.
\subsubsection*{Cut and Paste Operations}

The clipboard is a holder for various kinds of objects (regions, control
events, plugins) that is used during cut-and-paste operations.
\subsubsection*{Cut}

A cut operation removes selected objects and places them in the
clipboard. The existing contents of the clipboard are overwritten. The
default key binding is x.
\subsubsection*{Copy}

A copy of the selected objects are placed in clipboard. There is no
effect on the selected objects themselves. The existing contents of the
clipboard are overwritten. The default key binding is c.
\subsubsection*{Paste}

The current contents of the clipboard are pasted (inserted) into the
session, using the current edit point as the destination. The contents
of the clipboard remain unchanged—the same item can be pasted multiple
times. The default key binding is v.
\subsubsection*{Deleting Objects}

Within the Editor window (and to some extent within the Mixer window
too), there are several techniques for deleting objects (regions,
control points, and more).
\subsubsection*{Using the mouse and keyboard}

Select the object(s) to be deleted and then press the Del key. This does
\sphinxstylestrong{not} put the deleted object(s) in the clipboard, so they cannot be
pasted elsewhere.
\subsubsection*{Using normal cut and paste shortcuts}

Select the object(s) and then press x. This puts the deleted object(s)
in the clipboard so that they can be pasted elsewhere.
\subsubsection*{Using just the mouse}

By default, Shift Right will delete the clicked-upon object. Like the
Del key, this does \sphinxstylestrong{not} put the deleted object(s) in the clipboard.

The modifier and mouse button used for this can be controlled via Edit \textgreater{}
Preferences \textgreater{} User Interaction \textgreater{} Delete using …. Any modifier and mouse
button combination can be used.
\subsubsection*{Undo/Redo for Editing}

While editing, it sometimes happens that an unintended change is made,
or a choice is made that is later decided to be wrong. All changes to
the arrangement of session components (regions, control points) along
the timeline can be undone (and redone if necessary).

The default keybindings are Z for Undo and R for Redo. These match the
conventions of most other applications that provide undo/redo.

Changes are also saved to the session history file, so that undo/redo is
possible even if the session is closed and reopened later, even if
Ardour is exited in between.

The maximum number of changes that can be undone can be configured under
Edit \textgreater{} Preferences \textgreater{} Misc \textgreater{} Undo. The maximum number of changes stored
in the history file is a separate parameter, and can also be set in the
same place.

In addition to the normal undo (which works only on actions that change
the timeline), there is a visual undo which will revert any command that
affects the display of the editor window. Its shortcut is Z. There is
also an undo for selection; see “Selection Techniques” above.
\subsubsection*{3 - Keyboard and Mouse Shortcuts}
\subsubsection*{3.1 - Default Keyboard Bindings}

Almost every available function in Ardour can be bound to a keyboard
shortcut (and those few that cannot will usually respond to an {\hyperref[\detokenize{index:controlling-ardour-with-osc}]{\emph{OSC
command}}}). Ardour comes with a rich set
of default key bindings for the most commonly used functions.

These bindings strive to be mnemonic, that is, easy and intuitive to
remember, and follow widely accepted conventions. As a general rule, the
first letter of an operation will be used for as a shortcut, if
available. This does not necessarily lead to the best ergonomics for
rapid editing—there are alternative binding sets for that—but it does
make it simpler for newcomers to remember some of the most useful ones,
for example:

S for Region \textgreater{} Edit \textgreater{} Split or P for Transport \textgreater{} Playhead \textgreater{} Playhead to
Mouse.

Existing key bindings in menus are listed on the right side of the menu
items.

Almost every key binding in Ardour can be looked for and/or changed in
Window \textgreater{} Key Bindings (which is bound to K).

Ardour will silently reassign the binding of a key combination that is
already in use, possibly removing a standard keyboard shortcut without
any warning. This might lead to confusion when asking for help—when the
explanation is given in terms of a standard key binding—which will have
a completely different effect on the system with the modified key
bindings.

The conventions for using modifier keys (, , , etc.) differ among
platforms, so different default bindings for each are provided.
\subsubsection*{3.2 - Mnemonic Bindings for Linux}

A printable cheat-sheet with the mnemonic bindings for Linux is
available for download in \sphinxhref{/files/a3\_mnemonic\_cheatsheet.pdf}{US
Letter} and
\sphinxhref{/files/a3\_mnemonic\_cheatsheet-a4.pdf}{A4} paper format.

This set of bindings assumes an en\_US keyboard. However, most if not all
bindings will also work on other keyboards when the AltGr key is used to
compose those glyphs that are not directly accessible.
\subsubsection*{Transport \& Recording Control}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

destroy last recording
&
Del
\\
\hline
engage record
&
r
\\
\hline
fast forward
&
\(\rightarrow\)
\\
\hline
loop play (the loop range)
&
l
\\
\hline
rewind
&
←
\\
\hline
set playhead position
&
p
\\
\hline
start recording
&
Space
\\
\hline
stop (keep loop/range play)
&
Space
\\
\hline
stop and destroy
&
Space
\\
\hline
toggle auto play
&
5
\\
\hline
toggle auto return
&
6
\\
\hline
toggle click (metronome)
&
7
\\
\hline
toggle playhead follows edits
&
F
\\
\hline
toggle playhead tracking
&
F
\\
\hline
toggle roll
&
Space
\\
\hline
toggle selected track rec-enable
&
b
\\
\hline
toggle selected track solo status
&
s
\\
\hline
transition to reverse
&
↓
\\
\hline
transition to roll
&
↑
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\subsubsection*{Session \& File Handling}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

add track(s) or bus(ses)
&
n
\\
\hline
export session
&
e
\\
\hline
import audio files
&
i
\\
\hline
open a new session
&
n
\\
\hline
open a recent session
&
o
\\
\hline
open an existing session
&
o
\\
\hline
quit
&
q
\\
\hline
save session
&
s
\\
\hline
snapshot session
&
s
\\
\hline
toggle selected track MIDI input
&
i
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\subsubsection*{Changing What’s Visible}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|*{2}{\X{1}{2}|}}
\hline

fit tracks vertically
&
f
\\
\hline
move selected tracks down
&
↓
\\
\hline
move selected tracks up
&
↑
\\
\hline
scroll down (page)
&
PgDn
\\
\hline
scroll down (step)
&
↓
\\
\hline
scroll up (page)
&
PgUp
\\
\hline
scroll up (step)
&
↑
\\
\hline
toggle editor window mixer
&
e
\\
\hline
visual undo
&
z
\\
\hline
zoom height to selected region(s)
&
z
\\
\hline
zoom height and time to selected region
&
z
\\
\hline
zoom in
&
=
\\
\hline
zoom out
&\begin{itemize}
\item {} 
\end{itemize}
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}
\subsubsection*{Window Visibility}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

toggle locations dialog
&
l
\\
\hline
focus on main clock
&
÷
\\
\hline
maximise editor space
&
f
\\
\hline
switch between editor \& mixer window
&
m
\\
\hline
show rhythm ferret window
&
f
\\
\hline
toggle big clock
&
b
\\
\hline
toggle color manager
&
c
\\
\hline
toggle editor window
&
e
\\
\hline
toggle global audio patchbay
&
p
\\
\hline
toggle global midi patchbay
&
p
\\
\hline
toggle key bindings editor
&
k
\\
\hline
toggle preferences dialog
&
o
\\
\hline
toggle preferences dialog
&
p
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\subsubsection*{Editing with Edit Point}

Most edit functions operate on a single Edit Point (EP). The edit point
can be any of: playhead (default), the mouse or an active marker. The
choice of edit point (by default) also sets the Zoom Focus.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

EP to next region sync
&
;
\\
\hline
EP to prev region sync
&
‘
\\
\hline
cycle to next grid snap mode
&
2
\\
\hline
cycle to next zoom focus
&
1
\\
\hline
insert from region list
&
i
\\
\hline
insert time
&
t
\\
\hline
move EP to playhead
&
↵
\\
\hline
next EP w/marker
&
{}`
\\
\hline
next EP w/o marker
&
{}`
\\
\hline
trim back
&
k
\\
\hline
trim front
&
j
\\
\hline
trim region end to edit point
&
\}
\\
\hline
trim region start to edit point
&
\{
\\
\hline
trim region to end of prev region
&
j
\\
\hline
trim region to start of next region
&
k
\\
\hline
use previous grid unit
&
3
\\
\hline
use next grid unit
&
4
\\
\hline
use previous grid unit
&
3
\\
\hline
use next musical grid unit
&
4
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\subsubsection*{Aligning with the Edit Point}

Align operations move regions so that their start/end/sync point is at
the edit point. Relative operations just align the first region and
moves other selected regions to maintain relative positioning.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

align end(s)
&
a
\\
\hline
align start(s)
&
a
\\
\hline
align start(s) relative
&
a
\\
\hline
align sync points
&
a
\\
\hline
align sync points (relative)
&
a
\\
\hline
range end to next prev edge
&
\textgreater{}
\\
\hline
range end to next region edge
&
\textgreater{}
\\
\hline
range start to next region edge
&
\textless{}
\\
\hline
range start to prev region edge
&
\textless{}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\subsubsection*{Edit Point Playback}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

play edit range
&
Space
\\
\hline
play from EP \& return
&
Space
\\
\hline
play selected region(s)
&
h
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\subsubsection*{Region Operations}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|*{2}{\X{1}{2}|}}
\hline

duplicate region (multi)
&
d
\\
\hline
duplicate region (once)
&
d
\\
\hline
export selected region(s)
&
e
\\
\hline
increase region gain
&
\textasciicircum{}
\\
\hline
move to original position
&
o
\\
\hline
mute/unmute
&
m
\\
\hline
normalize
&
n
\\
\hline
nudge backward
&
\textendash{}
\\
\hline
nudge forward
&\begin{itemize}
\item {} 
\end{itemize}
\\
\hline
quantize MIDI notes
&
q
\\
\hline
reduce region gain
&
\&
\\
\hline
reverse
&
r
\\
\hline
set fade in length
&
/
\\
\hline
set fade out length
&
\textbackslash{}
\\
\hline
set region sync point
&
v
\\
\hline
split
&
s
\\
\hline
toggle fade in active
&
/
\\
\hline
toggle fade out active
&
\textbackslash{}
\\
\hline
transpose
&
t
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}
\subsubsection*{Generic Editing}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

copy
&
c
\\
\hline
cut
&
x
\\
\hline
delete
&
Del
\\
\hline
paste
&
v
\\
\hline
redo
&
r
\\
\hline
undo
&
z
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\subsubsection*{Selecting}

There are a few functions that refer to an Edit Range. The current edit
range is defined using combinations of the possible edit points:
playhead, active marker, or mouse.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

all after playhead
&
p
\\
\hline
all before playhead
&
p
\\
\hline
all enclosed by edit range
&
u
\\
\hline
all present in edit range
&
u
\\
\hline
convert edit range to range
&
F6
\\
\hline
invert selection
&
i
\\
\hline
select all after EP
&
e
\\
\hline
select all before EP
&
e
\\
\hline
select all in loop range
&
l
\\
\hline
select all in punch range
&
d
\\
\hline
select everything
&
a
\\
\hline
select next track/bus
&
↓
\\
\hline
select previous track/bus
&
↑
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\subsubsection*{Defining Loop, Punch Range and Tempo Changes}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

set loop range from edit range
&
{]}
\\
\hline
set loop range from region(s)
&
{]}
\\
\hline
set punch range from edit range
&
{[}
\\
\hline
set punch range from region(s)
&
{[}
\\
\hline
set tempo (1 bar) from edit range
&
0
\\
\hline
set tempo (1 bar) from region(s)
&
9
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\subsubsection*{3.3 - Mnemonic Bindings for OS X}

A \sphinxhref{/files/a3\_mnemonic\_cheat\_sheet\_osx.pdf}{printable cheat sheet} for
these bindings is available for download.
\subsubsection*{Transport \& Recording Control}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

destroy last recording
&
Del
\\
\hline
engage record
&
r
\\
\hline
fast forward
&
\(\rightarrow\)
\\
\hline
loop play (the loop range)
&
l
\\
\hline
rewind
&
←
\\
\hline
set playhead position
&
p
\\
\hline
start recording
&
space
\\
\hline
stop (keep loop/range play)
&
space
\\
\hline
stop and destroy
&
space
\\
\hline
toggle auto play
&
5
\\
\hline
toggle auto return
&
6
\\
\hline
toggle click (metronome)
&
7
\\
\hline
toggle playhead follows edits
&
f
\\
\hline
toggle playhead tracking
&
f
\\
\hline
toggle roll
&
space
\\
\hline
toggle track rec-enable
&
b
\\
\hline
toggle track solo status
&
s
\\
\hline
transition to reverse
&
↓
\\
\hline
transition to roll
&
↑
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\subsubsection*{Session \& File Handling}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

add track(s) or bus(ses)
&
n
\\
\hline
export session
&
e
\\
\hline
import audio files
&
i
\\
\hline
open a new session
&
n
\\
\hline
open a recent session
&
o
\\
\hline
open an existing session
&
o
\\
\hline
quit
&
q
\\
\hline
save session
&
s
\\
\hline
snapshot session
&
s
\\
\hline
toggle sel. track MIDI input
&
i
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\subsubsection*{Changing What’s Visible}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|*{2}{\X{1}{2}|}}
\hline

fit tracks vertically
&
f
\\
\hline
move selected tracks down
&
↓
\\
\hline
move selected tracks up
&
↑
\\
\hline
scroll down (page)
&
PgDn
\\
\hline
scroll down (step)
&
↓
\\
\hline
scroll up (page)
&
PageUp
\\
\hline
scroll up (step)
&
↑
\\
\hline
toggle editor window mixer
&
e
\\
\hline
toggle last 2 zoom states
&
z
\\
\hline
zoom height to selected region(s)
&
Control+z
\\
\hline
zoom height and time to selected region
&
z
\\
\hline
zoom in
&
=
\\
\hline
zoom out
&\begin{itemize}
\item {} 
\end{itemize}
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}
\subsubsection*{Window Visibility}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

toggle locations dialog
&
l
\\
\hline
focus on main clock
&
÷
\\
\hline
maximise editor space
&
f
\\
\hline
rotate editor \& mixer window
&
m
\\
\hline
show rhythm ferret window
&
f
\\
\hline
toggle big clock
&
b
\\
\hline
toggle color manager
&
c
\\
\hline
toggle editor window
&
e
\\
\hline
toggle global audio patchbay
&
p
\\
\hline
toggle global midi patchbay
&
p
\\
\hline
toggle key bindings editor
&
k
\\
\hline
toggle preferences dialog
&
o
\\
\hline
toggle preferences dialog
&
p
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\subsubsection*{Editing with Edit Point}

Most edit functions operate on a single Edit Point (EP). The edit point
can be any of: playhead (default), the mouse or an active marker. The
choice of edit point (by default) also sets the Zoom Focus.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

EP to next region sync
&
;
\\
\hline
EP to prev region sync
&
‘
\\
\hline
cycle to next grid snap mode
&
2
\\
\hline
cycle to next zoom focus
&
1
\\
\hline
insert from region list
&
i
\\
\hline
insert time
&
t
\\
\hline
move EP to playhead
&
Return
\\
\hline
next EP w/marker
&
\textasciicircum{}
\\
\hline
next EP w/o marker
&
{}`
\\
\hline
trim back
&
k
\\
\hline
trim front
&
j
\\
\hline
trim region end to edit point
&
\}
\\
\hline
trim region start to edit point
&
\{
\\
\hline
trim region to end of prev region
&
j
\\
\hline
trim region to start of next region
&
k
\\
\hline
use previous grid unit
&
3
\\
\hline
use next grid unit
&
4
\\
\hline
use previous grid unit
&
3
\\
\hline
use next musical grid unit
&
4
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\subsubsection*{Aligning with the Edit Point}

Align operations move regions so that their start/end/sync point is at
the edit point. Relative operations just align the first region and
moves other selected regions to maintain relative positioning.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

align end(s)
&
a
\\
\hline
align start(s)
&\\
\hline
align start(s) relative
&\\
\hline
align sync points
&
a
\\
\hline
align sync points (relative)
&
a
\\
\hline
range end to next prev edge
&
\textgreater{}
\\
\hline
range end to next region edge
&
\textgreater{}
\\
\hline
range start to next region edge
&
\textless{}
\\
\hline
range start to prev region edge
&
\textless{}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\subsubsection*{Edit Point Playback}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

play edit range
&
Space
\\
\hline
play from EP \& return
&
Space
\\
\hline
play selected region(s)
&
h
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\subsubsection*{Region Operations}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|*{2}{\X{1}{2}|}}
\hline

duplicate region (multi)
&
d
\\
\hline
duplicate region (once)
&
d
\\
\hline
export selected region(s)
&\\
\hline
increase region gain
&
\textasciicircum{}
\\
\hline
move to original position
&
o
\\
\hline
mute/unmute
&
m
\\
\hline
normalize
&
n
\\
\hline
nudge backward
&
\textendash{}
\\
\hline
nudge forward
&\begin{itemize}
\item {} 
\end{itemize}
\\
\hline
quantize MIDI notes
&
q
\\
\hline
reduce region gain
&
\&
\\
\hline
reverse
&
r
\\
\hline
set fade in length
&
/
\\
\hline
set fade out length
&
\textbackslash{}
\\
\hline
set region sync point
&
v
\\
\hline
split
&
s
\\
\hline
toggle fade in active
&
/
\\
\hline
toggle fade out active
&
\textbackslash{}
\\
\hline
transpose
&
t
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}
\subsubsection*{Generic Editing}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

copy
&
c
\\
\hline
cut
&
x
\\
\hline
delete
&
Del
\\
\hline
paste
&
v
\\
\hline
redo
&
r
\\
\hline
undo
&
z
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\subsubsection*{Selecting}

There are a few functions that refer to an Edit Range. The current edit
range is defined using combinations of the possible edit points:
playhead, active marker, or mouse.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

all after playhead
&
p
\\
\hline
all before playhead
&
p
\\
\hline
all enclosed by edit range
&
u
\\
\hline
all present in edit range
&
u
\\
\hline
convert edit range to range
&
F6
\\
\hline
invert selection
&
i
\\
\hline
select all after EP
&
Shift+e
\\
\hline
select all before EP
&
e
\\
\hline
select all in loop range
&
l
\\
\hline
select all in punch range
&
d
\\
\hline
select everything
&
a
\\
\hline
select next track/bus
&
↓
\\
\hline
select previous track/bus
&
↑
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\subsubsection*{Defining Loop, Punch Range and Tempo Changes}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

set loop range from edit range
&
{]}
\\
\hline
set loop range from region(s)
&
{]}
\\
\hline
set punch range from edit range
&
{[}
\\
\hline
set punch range from region(s)
&
{[}
\\
\hline
set tempo (1 bar) from edit range
&
0
\\
\hline
set tempo (1 bar) from region(s)
&
9
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\subsubsection*{Part II - Ardour Configuration}
\subsubsection*{4 - Ardour Systems}

Using a general purpose computer for the recording and playback of
digital audio is not trivial. This chapter covers some of the most
common pitfalls encountered on the way to creating a reliable and
powerful audio workstation.
\subsubsection*{4.1 - The Right Computer System for Digital Audio}

It is nice to think that one could just go and buy any computer, install
a bit of software on it and start using it to record and create music.
This idea isn’t necessarily wrong, but there are some important details
that it misses. Any computer that that can be bought today (since
somewhere around the end of 2012) is capable of recording and processing
a lot of audio data. It will come with a builtin audio interface that
can accept inputs from microphones and/or electrical instruments; it
will have a disk with a huge amount of space for storing audio files.

However, when recording, editing and mixing music, it is generally
desirable to have very little latency between the time a sound is
generated and when it can be heard. When the audio signal flows through
a computer, that means that the computer has to be able to receive the
signal, process it and send it back out again as quickly as possible.
And this is where it becomes very important \sphinxstyleemphasis{what} computer system is
being used for this task, because it is \sphinxstylestrong{absolutely not} the case that
\sphinxstyleemphasis{any} computer can do it well.

Routing audio through a computer will always cause some delay, but if it
is small, it will generally never be noticed. There are also ways to
work in which the delay does not matter at all (for example, not sending
the output from the computer to speakers).

The latency that is typically needed for working with digital audio is
in the 1\textendash{}5 ms range. For comparison, if one is sitting 1 m (3 ft) from a
set of speakers, the time the sound takes to reach the ears is about
3 ms. Any modern computer can limit the delay to 100 ms; most can keep
it under 50 ms. Many will be able to get down to 10 ms without too much
effort. Attempting to reduce the latency on a computer that cannot
physically do it will cause clicks and glitches in the audio, which is
clearly undesirable.
\subsubsection*{Hardware-related Considerations}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

Video interface
&
Poorly engineered video
interfaces (and/or their device
drivers) can “steal” computer
resources for a long time,
preventing the audio interface
from keeping up with the flow of
data.
\\
\hline
Wireless interface
&
Poorly engineered wireless
networking interfaces (and/or
their device drivers) can also
block the audio interface from
keeping up with the flow of data.
\\
\hline
USB ports
&
When using an audio interface
connected via USB, and sometimes
even if not, the precise
configuration of the system’s USB
ports can make a big difference.
There are many cases where
plugging the interface into one
port will work, but using
different USB port results in
much worse performance. This has
been seen even on Apple systems.
\\
\hline
Internal USB Hubs
&
Ideally, all USB ports should
connect directly to the main bus
inside the computer. Some laptops
(and possibly some desktop
systems) come wired with an
internal USB hub between the
ports and the system bus, which
can then cause problems for
various kinds of external USB
devices, including some models of
audio interfaces. It is very
difficult to discover whether
this is true or not, without
simply trying it out.
\\
\hline
CPU speed control
&
Handling audio with low latency
requires that the processor keeps
running at its highest speed at
all times. Many portable systems
try to regulate processor speed
in order to save power—for low
latency audio, this should be
totally disabled, either in the
BIOS or at the OS level.
\\
\hline
Excessive Interrupt Sharing
&
If the audio interface is forced
by the computer to share an
interrupt line (basically a way
to tell the CPU that something
needs its attention) with too
many other (or wrong) devices,
this can also prevent the audio
interface from keeping up with
the flow of data. In laptops it
is generally impossible to do
anything about this. In many
desktop systems, it is possible
at the BIOS level to reassign
interrupts to work around the
problem.
\\
\hline
SMIs
&
SMIs are interrupts sent by the
motherboard to tell the computer
about the state of various
hardware. They cannot safely be
disabled, and they can take a
relatively long time to process.
It is better to have a
motherboard which never sends
SMIs at all—this is also a
requirement for realtime stock
trading systems, which have
similar issues with latency.
\\
\hline
Hyperthreading
&
This technology is becoming less
common as actual multi-core CPUs
become the norm, but it still
exists and is generally not good
for realtime performance.
Sometimes this can be disabled in
the BIOS, sometimes it cannot. A
processor that uses
hyperthreading will be less
stable in very low latency
situations than one without.
\\
\hline
Excessive vibration
&
This doesn’t affect the flow of
data to or from the audio
interface, but it can cause the
flow of data to and from disk
storage to become \sphinxstyleemphasis{much} slower.
If a computer going to be used in
an environment with loud live
sound (specifically, high bass
volume), make sure it is placed
so that the disk is not subjected
to noticeable vibration. The
vibrations will physically
displace the read-write heads of
disk, and the resulting errors
will force a retry of the reading
from the disk. Retrying over and
over massively reduces the rate
at which data can be read from
the disk. Avoid this.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

Richard Ames presents a long (28 minute)
\sphinxhref{https://www.youtube.com/watch?v=GUsLLEkswzE}{video} that is very
helpful if you want to understand these issues in more depth. It is a
little bit Windows-centric, but the explanations to all types of
computers and operating systems.
\subsubsection*{4.2 - The Right Mouse}

Ardour is designed to work best with a three button mouse equipped with
a scroll wheel. While it can be used with a two button mouse or
touchpad, at least two key operations will not be (easily) available:
\begin{itemize}
\item {} 
time-constrained region copying

\item {} 
{\hyperref[\detokenize{index:generic-midi-learn}]{\emph{MIDI bindings}}} created by “learning” them
from incoming MIDI data

\end{itemize}

It is strongly encouraged to invest in a three-button mouse. A good
quality mouse (especially one with a weighted, latchable scroll wheel)
will make the use of Ardour vastly more efficient. They are cheap, and
time is not.

For information on how to use the mouse in Ardour, see {\hyperref[\detokenize{index:using-the-mouse}]{\emph{Using the
mouse}}}.
\subsubsection*{5 - System Specific Setup}

It is unfortunate, but some OSes and/or Desktop Environments will cause
problems that are beyond the capability of Ardour to address. The
following covers some of the known problems and how to work around them.
\subsubsection*{5.1 - Ubuntu Linux}

Ubuntu Linux is the most popular variety of Linux in use on desktop and
laptop systems. It has the backing of a for-profit corporation
(Canonical Inc.), a defined philosophy and a huge and worldwide user
base. As a result, it is a common platform for people who want to use
Ardour and other tools for music creation and pro-audio work.
\subsubsection*{High Level Recommendations for Ubuntu Users}

Currently, installing pro audio applications on vanilla Ubuntu requires
some configuration, in order for the user to gain realtime privilege
(read below). Ubuntu Studio, which is an official flavor of Ubuntu, and
thus shares the repositories with Ubuntu, has this already configured.
Other distributions, such as KXStudio, and Dreamstudio are largely based
on Ubuntu, and like Ubuntu Studio, has these settings pre-configured,
while also containing customized versions of Ubuntu packages, which
often are more up to date.
\subsubsection*{Installing Ardour}

There may be unintended differences, and even bugs in Ubuntu native
packages, as a result of a different building method. For this reason,
Ardour developers highly recommend installing the official ready-to-run
version of the program that can be downloaded from
\sphinxhref{https://community.ardour.org/download}{ardour.org}, as Ubuntu native
packages are not supported in the official Ardour forums or other
support channels.

Follow these steps to install the latest version of Ardour:
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
Download the latest release from
\sphinxhref{https://community.ardour.org/download}{ardour.org}.

\item {} 
Right-click the downloaded file and choose properties.

\item {} 
Click the Permissions tab and check the option “Allow this file to
run as a program”.

\item {} 
Close the dialog and double-click the file.

\item {} 
Follow the prompts.

\end{enumerate}
\subsubsection*{Problems with the interaction between PulseAudio and JACK}
\subsubsection*{Background Info}

Like many distributions, Ubuntu has decided to use PulseAudio as the
default audio system. PulseAudio is a rich and capable system that
provides excellent services for typical users of Linux on the desktop.
However, it is not capable of the type of performance that tools like
Ardour require and in particular does not offer the possibility of
sending audio between applications that can make the Linux audio
environment a very interesting one.

This would not be a problem if it were not for the fact that JACK will
not run correctly (if at all) if it needs to use the same
soundcard/audio interface that PulseAudio is using. And since,
PulseAudio on Ubuntu is configured by default to always use the
(typically single) audio interface on the computer, this is a bit of a
problem.

The developers of JACK and PulseAudio got together in 2009 and agreed
upon a mechanism by which PulseAudio and JACK could cooperate in their
use of a single soundcard. Whether or not PulseAudio is running by
default, when JACK starts up it sends out a request to use the
soundcard. If PulseAudio is running, it will give up its use of the
soundcard to allow JACK to take over (and can optionally be told to
route its own audio through JACK). When JACK finishes, it sends out
another message, and PulseAudio can once again use the soundcard
directly.
\subsubsection*{What is the problem?}

The specific issues known at this time for all flavors of Ubuntu 12.04
and 12.10 are:
\begin{itemize}
\item {} 
a bug in PulseAudio that causes it not to give up the soundcard when
JACK asks (\sphinxhref{https://bugs.launchpad.net/ubuntu/+source/pulseaudio/+bug/1163638}{LP:
\#1163638},
fixed in Ubuntu 13.04).

\end{itemize}
\subsubsection*{Symptoms}

A message like Cannot start JACK in the output from JACK as it starts up
(though see the next section for other causes of this). This output may
be hidden in the Messages window of QJackCtl (aka JACK Control), so one
should check there.
\subsubsection*{How to fix}

These bugs do not affect releases from 13.04, and earlier releases
(12.04 and 12.10) are in the process of being fixed.
\subsubsection*{Problems with JACK configuration}
\subsubsection*{What is the problem?}

To function as intended, JACK needs to run with access to two operating
system facilities called realtime scheduling and memory locking. This
means that the user who starts JACK \sphinxstyleemphasis{must} be allowed access to these
facilities. By default, Ubuntu does create a user group that has this
permission but—it does not put new users into this group by default.
Read more about why
\sphinxhref{https://wiki.ubuntu.com/Audio/TheAudioGroup}{here}. Consequently,
the user will not have permission to run JACK in the way they should.
\subsubsection*{Symptoms}

A message like Cannot lock down memory in the output from JACK as it
starts up. This output may be hidden in the Messages window of QJackCtl
(aka JACK Control), so one should check there.
\subsubsection*{How to fix}

Make sure the file /etc/security/limits.d/audio.conf exists. If it is
named /etc/security/limits.d/audio.conf.disabled, rename it to the
former. Run the command:

sudo usermod -a -G audio \sphinxstyleemphasis{YOUR-LOGIN-NAME}
Then log out and log in again. On Ubuntu Studio the user is a member of
audio group by default, but not on other official flavors.
\subsubsection*{Reporting Issues}

Given the difficulties in supporting Ubuntu and the limited time and
resources of the Ardour team, the Ubuntu Studio Project has requested
that issues and bug reports related to Ubuntu, Ubuntu Studio and other
derivatives be directed to them.
\subsubsection*{Contact Information for Ubuntu Studio}

\sphinxhref{http://ubuntustudio.org}{The Ubuntu Studio Homepage}

\sphinxhref{http://ubuntuforums.org/forumdisplay.php?f=335}{The Ubuntu Studio
Forums.}

\sphinxhref{https://help.ubuntu.com/community/UbuntuStudio/MailLists}{Information on the Ubuntu Studio Mailing
Lists.}

\sphinxhref{https://help.ubuntu.com/community/UbuntuStudio/IRC}{Information on the Ubuntu Studio IRC
channel.}
\#ubuntustudio on irc.freenode.net
\subsubsection*{5.2 - Microsoft Windows}

Microsoft Windows is officially supported since version 5.0 (2016).
\subsubsection*{Installing Ardour}
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
Download the latest windows build from \sphinxhref{https://community.ardour.org/download}{the download
page}.

\item {} 
Run the installer and follow the prompts.

\end{enumerate}
\subsubsection*{How to help}
\begin{itemize}
\item {} 
Hang out in
\sphinxhref{http://webchat.freenode.net/?channels=ardour}{\#ardour} on
irc.freenode.net. One may ask questions there and if possible, answer
questions that others have.

\item {} 
Keep an eye on the \sphinxhref{https://discourse.ardour.org/c/installation-configuration/windows}{Windows
forum}
and contribute to the discussions there.

\item {} 
Update this manual via pull requests on
\sphinxhref{https://github.com/Ardour/manual}{github}.

\end{itemize}
\subsubsection*{5.3 - KDE Plasma 5}

Under KDE Plasma 5, plugin and various other windows will not stay on
top of any main window; therefore a workaround is required.
\subsubsection*{Workaround for ancillary windows not staying on top in KDE
Plasma 5}

In order to force ancillary windows in Ardour to stay on top, the
following steps are necessary:
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
Launch the System Settings application.

\item {} 
Open Workspace \textgreater{} Window Management.

\item {} 
Select Window Rules in the left-hand sidebar. It should default to
the Window matching tab.

\item {} 
Click on the New… button.

\item {} 
On the line that says Window class (application), set the combo box
to Substring Match and type ardour in the text entry field.

\item {} 
In the list box that is labeled Window types:, click on the option
Dialog Window, then press and hold Ctrl while clicking on the second
option Utility Window.

\item {} 
Select the Arrangement \& Access tab.

\item {} 
Check the box next to the Keep above option. On the same line, select
Force from the combo box, then click on the Yes radio button for that
line.

\item {} 
Click on the OK button to dismiss the dialog.

\end{enumerate}

At this point the System Settings application can be closed.
\subsubsection*{Background Info}

\sphinxhref{https://bugs.kde.org/show\_bug.cgi?id=172615\#c26}{According to one of the lead KDE
developers}, they
are not willing to follow the ICCCM standard for utility windows.
Apparently they are alone in this understanding, as plugin windows on
Ardour under Linux work out of the box on every other WM out there.

Under KDE 4, there was a workaround in Ardour (Preferences \textgreater{} Theme \textgreater{} All
floating windows are dialogs) that would “trick” KDE into forcing
certain window types to be on top of their parent windows, but this no
longer works under KDE Plasma 5.
\subsubsection*{6 - I/O Setup}
\subsubsection*{6.1 - Connecting Audio and MIDI Devices}

Normally Ardour does not care about how audio and MIDI gets into the
computer—it pretty much deals only with its own inputs and outputs; it
is up to the user to ensure that all external routing is sound. After
all, Ardour has no way to know how signals from the outside world get to
it. However, there are some things that Ardour can do to help
troubleshoot problems with audio and MIDI connections—at least on the
computer side.

For example, a typical setup might include a microphone that feeds a
mixer that then feeds the computer. A failure can occur anywhere in that
signal chain, including the cables that connect everything together. As
far as Ardour is concerned, the most important connection is the one
coming from the sound source to the physical audio input of the
computer—in this example, the cable connecting between the mixer and the
computer.

Common sense and basic troubleshooting skills are needed when problems
arise, and in the above example, one would have to go through the entire
signal chain to ensure that each component was working as it should.
\subsubsection*{Common Problems}

Ardour tries to set things up in a sane manner by automatically
connecting the hardware inputs of the computer to its master input and
the hardware outputs to the master output. If the signal coming into the
hardware inputs is active, the meters on Ardour’s master channel should
move. If they don’t, some things to check include:
\begin{itemize}
\item {} 
Making sure there is actually an input signal

\item {} 
Making sure the input signal is getting into the computer

\item {} 
Making sure that Ardour is talking to the correct sound card

\item {} 
Making sure that the sound card in use by Ardour is working properly

\end{itemize}
\subsubsection*{6.2 - Using More Than One Audio Device}

Ardour will only ever deal with a single audio device. When it is
desired to use more than one audio device at the same time, there are
two choices:
\begin{itemize}
\item {} 
Use Ardour to start JACK (which handles all audio I/O), and create a
“fake” audio device which represents all the multiple devices to be
used. How to do this is platform dependent and described below.

\item {} 
Use a different tool to start JACK and manage all the devices.

\end{itemize}

Ardour is fundamentally designed to be a component in a pro-audio/music
creation environment. Standard operating practice for such setups
involves using only a single digital sample clock (something counting
off the time between audio samples). This means that trying to use
multiple independent soundcards is problematic, because each soundcard
has its own sample clock, running independently from the others. Over
time, these different clocks drift out of sync with each other, which
causes glitches in the audio. This drift cannot be stopped, although in
some cases the effects may be insignificant enough that they might not
be noticeable.

Thus, in an ideal world, a single device with a single clock and all the
inputs, outputs and other features needed should be used. Of course,
there are those who like to point out that this is not an ideal world,
and believe that software should make up for this.
\subsubsection*{OS X}

In CoreAudio, aggregate devices provide a method to use multiple
soundcards as a single device. For example, two eight-channel devices
can be aggregated so that 16 channels can be recorded in Ardour.



When using a \sphinxstyleemphasis{single} typical 3rd party audio interface (such as those
from Apogee, RME, Presonus, and many others), \sphinxstyleemphasis{or} using JackPilot or a
similar application to start JACK, there is no need to worry about any
of this. An aggregate device only needs to be set up if any of the
following conditions are true:
\begin{itemize}
\item {} 
Two entirely separate devices are used \sphinxstyleemphasis{and} JACK is started using
Ardour

\item {} 
A builtin audio device is used \sphinxstyleemphasis{and} JACK is started using Ardour

\item {} 
More than two entirely separate devices are used

\end{itemize}



In the case of a builtin audio device, an aggregate device that combines
“Builtin Input” and “Builtin Output” into one device needs to be
created.

The precise instructions for creating an aggregate device on OS X have
varied from one released to another. Please read
\sphinxurl{https://support.apple.com/en-us/HT202000}.
\subsubsection*{Linux}

Please see the instructions at
\sphinxhref{http://jackaudio.org/faq/}{http://jackaudio.org/faq}.
\subsubsection*{6.3 - Monitor Setup in Ardour}

Ardour has three main settings which affect how monitoring is performed.
The first is Edit \textgreater{} Preferences \textgreater{} Signal Flow \textgreater{} Record monitoring
handled by. There are two or three options here, depending on the
capabilities of the hardware.

The other two settings are more complex. One is Tape machine mode, found
in the same dialog, and the other is the Session \textgreater{} Properties \textgreater{}
Monitoring automatically follows transport state setting.

Monitoring also depends on the state of the track’s record-enable
button, the session record-enable button, and on whether or not the
transport is rolling.
\subsubsection*{Software or Hardware Monitoring Modes}

If Ardour is set to external monitoring, Ardour does not do any
monitoring.
\subsubsection*{Monitoring in Non-Tape-Machine Mode}

When Tape-Machine mode is off, and a track is armed, Ardour \sphinxstyleemphasis{always}
monitors the live input, except in one case: if the transport is
rolling, the session is not recording, and auto-input is active, the
playback from an armed track will be heard.

Unarmed tracks will play back their contents from disc, unless the
transport is stopped \sphinxstyleemphasis{and} auto-input is enabled. In this case, the
track monitors its live input.
\subsubsection*{Monitoring in Tape-Machine Mode}

In Tape-Machine mode, when a track is armed, its behaviour is the same
as in non-tape-machine mode.

Unarmed tracks however will always just play back their contents from
disk; the live input will never be monitored.
\subsubsection*{7 - Synchronization}
\subsubsection*{7.1 - On Clock and Time}

Synchronization in multimedia involves two concepts which are often
confused: clock (or speed) and time (location in time).

A clock determines the speed at which one or more systems operate. In
the audio world this is generally referred to as \sphinxhref{https://en.wikipedia.org/wiki/Word\_clock}{Word
Clock}. It does not carry
any absolute reference to a point in time: A clock is used to keep a
system’s sample rate regular and accurate. Word clock is usually at the
frequency of the sample rate—at 48 kHz, its period is about 20 \(\mu\)s. Word
Clock is the most common sample rate based clock but other clocks do
exist such as Black and Burst, Tri-Level and DARS. Sample rates can be
derived from these clocks as well.

Time or timecode specifies an absolute position on a timeline, such as
\sphinxcode{\sphinxupquote{01:02:03:04}} (expressed as Hours:Mins:Secs:Frames). It is actual
\sphinxstyleemphasis{data} and not a clock \sphinxstyleemphasis{signal} per se. The granularity of timecode is
Video Frames and is an order of magnitude lower than, say, Word Clock
which is counted in samples. A typical frame rate is 25 fps with a
period of 40 ms. In the case of 48 kHz and 25 fps, there are 1920 audio
samples per video frame.

The concepts of clock and timecode are reflected in JACK and Ardour:

JACK provides clock synchronization and is not concerned with time code
(this is not entirely true, more on jack-transport later). On the
software side, jackd provides sample-accurate synchronization between
all JACK applications. On the hardware side, JACK uses the clock of the
audio-interface. Synchronization of multiple interfaces requires
hardware support to sync the clocks. If two interfaces run at different
clocks the only way to align the signals is via re-sampling (SRC—Sample
Rate Conversion), which is expensive in terms of CPU usage and may
decrease fidelity if done incorrectly.

Timecode is used to align systems already synchronized by a clock to a
common point in time, this is application specific and various standards
and methods exist to do this.

To make things confusing, there are possibilities to synchronize clocks
using timecode. e.g. using mechanism called jam-sync and a phase-locked
loop.

An interesting point to note is that LTC (Linear Time Code) is a
Manchester encoded, frequency modulated signal that carries both clock
and time. It is possible to extract absolute position data and speed
from it.
\subsubsection*{7.2 - Latency and Latency-Compensation}

\sphinxhref{http://en.wikipedia.org/wiki/Latency\_\%28audio\%29}{Latency} is a
system’s reaction time to a given stimulus. There are many factors that
contribute to the total latency of a system. In order to achieve exact
time synchronization all sources of latency need to be taken into
account and compensated for.
\subsubsection*{Sources of Latency}
\subsubsection*{Sound propagation through the air}

Since sound is a mechanical perturbation in a fluid, it travels at
comparatively slow
\sphinxhref{http://en.wikipedia.org/wiki/Speed\_of\_sound}{speed} of about 340
m/s. As a consequence, an acoustic guitar or piano has a latency of
about 1\textendash{}2 ms, due to the propagation time of the sound between the
instrument and the player’s ear.
\subsubsection*{Digital-to-Analog and Analog-to-Digital conversion}

Electric signals travel quite fast (on the order of the speed of light),
so their propagation time is negligible in this context. But the
conversions between the analog and digital domain take a comparatively
long time to perform, so their contribution to the total latency may be
considerable on otherwise very low-latency systems. Conversion delay is
usually below 1 ms.
\subsubsection*{Digital Signal Processing}

Digital processors tend to process audio in chunks, and the size of that
chunk depends on the needs of the algorithm and performance/cost
considerations. This is usually the main cause of latency when using a
computer and the one that can be predicted and optimized.
\subsubsection*{Computer I/O Architecture}

A computer is a general purpose processor, not a digital audio
processor. This means the audio data has to jump a lot of fences in its
path from the outside to the CPU and back, contending in the process
with some other parts of the system vying for the same resources (CPU
time, bus bandwidth, etc.)
\subsubsection*{The Latency chain}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{latency-chain}.png}
\caption{Latency chain}\label{\detokenize{index:id473}}\end{figure}

The numbers are an example for a typical PC. With professional gear and
an optimized system the total round-trip latency is usually lower. The
important point is that latency is always additive and a sum of many
independent factors.

Processing latency is usually divided into capture latency (the time it
takes for the digitized audio to be available for digital processing,
usually one audio period), and playback latency (the time it takes for
In practice, the combination of both matters. It is called round-trip
latency: the time necessary for a certain audio event to be captured,
processed and played back.

It is important to note that processing latency in a jackd is a matter
of choice. It can be lowered within the limits imposed by the hardware
(audio device, CPU and bus speed) and audio driver. Lower latencies
increase the load on the system because it needs to process the audio in
smaller chunks which arrive much more frequently. The lower the latency,
the more likely the system will fail to meet its processing deadline and
the dreaded xrun (short for buffer over- or under-run) will make its
appearance more often, leaving its merry trail of clicks, pops and
crackles.

The digital I/O latency is usually negligible for integrated or PCI
audio devices, but for USB or FireWire interfaces the bus clocking and
buffering can add some milliseconds.
\subsubsection*{Low Latency use cases}

Low latency is \sphinxstylestrong{not} always a feature one wants to have. It comes with
a couple of drawbacks: the most prominent is increased power consumption
because the CPU needs to process many small chunks of audio data, it is
constantly active and can not enter power-saving mode (think fan noise).
Since each application that is part of the signal chain must run in
every audio cycle, low-latency systems will undergo context switches
between applications more often, which incur a significant overhead.
This results in a much higher system load and an increased chance of
xruns.

For a few applications, low latency is critical:
\subsubsection*{Playing virtual instruments}

A large delay between the pressing of the keys and the sound the
instrument produces will throw off the timing of most instrumentalists
(save church organists, whom we believe to be awesome
latency-compensation organic systems.)
\subsubsection*{Software audio monitoring}

If a singer is hearing her own voice through two different paths, her
head bones and headphones, even small latencies can be very disturbing
and manifest as a tinny, irritating sound.
\subsubsection*{Live effects}

Low latency is important when using the computer as an effect rack for
inline effects such as compression or EQ. For reverbs, slightly higher
latency might be tolerable, if the direct sound is not routed through
the computer.
\subsubsection*{Live mixing}

Some sound engineers use a computer for mixing live performances.
Basically that is a combination of the above: monitoring on stage,
effects processing and EQ.

In many other cases, such as playback, recording, overdubbing, mixing,
mastering, etc. latency is not important, since it can easily be
compensated for.

To explain that statement: During mixing or mastering, one doesn’t care
if it takes 10ms or 100ms between the instant the play button is pressed
and the sound coming from the speaker. The same is true when recording
with a count in.
\subsubsection*{Latency compensation}

During tracking it is important that the sound that is currently being
played back is internally aligned with the sound that is being recorded.

This is where latency compensation comes into play. There are two ways
to compensate for latency in a DAW, read-ahead and write-behind. The DAW
starts playing a bit early (relative to the playhead), so that when the
sound arrives at the speakers a short time later, it is exactly aligned
with the material that is being recorded. Since we know that playback
has latency, the incoming audio can be delayed by the same amount to
line things up again.

The second approach is prone to various implementation issues regarding
timecode and transport synchronization. Ardour uses read-ahead to
compensate for latency. The time displayed in the Ardour clock
corresponds to the audio signal that is heared on the speakers (and is
not where Ardour reads files from disk).

As a side note, this is also one of the reasons why many projects start
at timecode 01:00:00:00. When compensating for output latency the DAW
will need to read data from before the start of the session, so that the
audio arrives in time at the output when the timecode hits 01:00:00:00.
Ardour does handle the case of 00:00:00:00 properly but not all
systems/software/hardware that you may inter-operate with may behave the
same.
\subsubsection*{Latency Compensation And Clock Sync}

To achieve sample accurate timecode synchronization, the latency
introduced by the audio setup needs to be known and compensated for.

In order to compensate for latency, JACK or JACK applications need to
know exactly how long a certain signal needs to be read-ahead or
delayed:

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{jack-latency-excerpt}.png}
\caption{Jack Latency Compensation}\label{\detokenize{index:id474}}\end{figure}

In the figure above, clients A and B need to be able to answer the
following two questions:
\begin{itemize}
\item {} 
How long has it been since the data read from port Ai or Bi arrived
at the edge of the JACK graph (capture)?

\item {} 
How long will it be until the data written to port Ao or Bo arrives
at the edge of the JACK graph (playback)?

\end{itemize}

JACK features an API that allows applications to determine the answers
to above questions. However JACK can not know about the additional
latency that is introduced by the computer architecture, operating
system and soundcard. These values can be specified by the JACK command
line parameters -I and -O and vary from system to system but are
constant on each. On a general purpose computer system the only way to
accurately learn about the total (additional) latency is to measure it.
\subsubsection*{Calibrating JACK Latency}

Linux DSP guru Fons Adriaensen wrote a tool called jack\_delay to
accurately measure the round-trip latency of a closed loop audio chain,
with sub-sample accuracy. JACK itself includes a variant of this tool
called jack\_iodelay.

Jack\_iodelay allows to measure the total latency of the system,
subtracts the known latency of JACK itself and suggests values for
jackd’s audio-backend parameters.

jack\_{[}io{]}delay works by emitting some rather annoying tones, capturing
them again after a round trip through the whole chain, and measuring the
difference in phase so it can estimate with great accuracy the time
taken.

The loop can be closed in a number of ways:
\begin{itemize}
\item {} 
Putting a speaker close to a microphone. This is rarely done, as air
propagation latency is well known so there is no need to measure it.

\item {} 
Connecting the output of the audio interface to its input using a
patch cable. This can be an analog or a digital loop, depending on
the nature of the input/output used. A digital loop will not factor
in the AD/DA converter latency.

\end{itemize}

Once the loop has been closed, one must:
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
Launch jackd with the configuration to test.

\item {} 
Launch jack\_delay on the command line.

\item {} 
Make the appropriate connections between the jack ports so the loop
is closed.

\item {} 
Adjust the playback and capture levels in the mixer.

\end{enumerate}
\subsubsection*{7.3 - Timecode Generators and Slaves}

Ardour supports three common timecode formats: LTC, MTC, and MIDI Clock,
as well as JACK-transport, a JACK-specific timecode implementation.

\begin{DUlineblock}{0em}
\item[] Ardour can generate timecode and thus act as timecode master,
providing timecode information to other applications. Ardour can also
be slaved to some external source in which case the playhead follows
the incoming timecode.
\item[] Combining the timecode slave and generator modes, Ardour can also
translate timecode. e.g create LTC timecode from incoming MTC.
\end{DUlineblock}
\subsubsection*{Ardour Timecode Configuration}

Each Ardour session has a specific timecode frames-per-second setting
which is configured in session \textgreater{} properties \textgreater{} timecode. The selected
timecode affects the timecode ruler in the main window as well as the
clock itself.

Note that some timecode formats do not support all of Ardour’s available
fps settings. MTC is limited to 24, 25, 29.97 and 30 fps.

The video pull-up modes change the effective samplerate of Ardour to
allow for changing a film soundtrack from one frame rate to another. The
concept is beyond the scope of this manual, but Wikipedia’s entry on
\sphinxhref{http://en.wikipedia.org/wiki/Telecine}{Telecine} may be a good
start.
\subsubsection*{Ardour Timecode Generator Configuration}

This is pretty straightforward: simply turn it on. The MTC and
MIDI-Clock generator do not have any options. The LTC generator has a
configurable output level. JACK-transport cannot be \sphinxstyleemphasis{generated}. Jack
itself is always synced to its own cycle and cannot do varispeed—it will
always be synced to a hardware clock or another JACK master.

The relevant settings for timecode generator can be found in Edit \textgreater{}
Preferences \textgreater{} MIDI Preferences (for MTC, MC) and Edit \textgreater{} Preferences \textgreater{}
Transport Preferences (for LTC).

The timecode is sent to jack-ports \sphinxcode{\sphinxupquote{ardour:MTC out}},
\sphinxcode{\sphinxupquote{ardour:MIDI clock out}} and \sphinxcode{\sphinxupquote{ardour:LTC-out}}. Multiple generators
can be active simultaneously.

Note that, as of Jan 2014, only the LTC generator supports latency
compensation. This is due to the fact the Ardour MIDI ports are not yet
latency compensated.

In Session \textgreater{} Properties, it is possible to define an offset between
Ardour’s internal time and the timecode sent. Currently only the LTC
generator honors this offset.

Both LTC and MTC are limited to 30 fps. Using frame rates larger than
that will disable the generator. In both cases also only 24, 25, 29.97df
(drop-frame) and 30 fps are well defined by specifications (such as
SMPTE-12M, EU and the MIDI standard).
\subsubsection*{MTC Generator}

The MTC generator has no options. Ardour sends full MTC frames whenever
the transport is relocated or changes state (start/stop). MTC quarter
frames are sent when the transport is rolling and the transport speed is
within 93\% and 107\%.
\subsubsection*{LTC Generator}

The level of the LTC generator output signal can be configured in in the
Preferences \textgreater{} Transport dialog. By default it is set to -18 dBFS, which
corresponds to 0dBu in an EBU calibrated system.

The LTC generator has an additional option to keep sending timecode even
when the transport is stopped. This mode is intended to drive analog
tape machines which unspool the tape if no LTC timecode is received.

LTC is send regardless of Ardour’s transport speed. It is accurately
generated even for very slow speeds (\textless{}5\%) and only limited by the
soundcard’s sampling-rate and filter (see \sphinxhref{http://en.wikipedia.org/wiki/Gibbs\_phenomenon\#Signal\_processing\_explanation}{Gibbs
phenomenon})
for high speeds.
\subsubsection*{Ardour Slave Configuration}

The timecode source can be switched with the button just right of
Ardour’s main clock. By default it is set to Internal in which case
Ardour will ignore any external timecode. The button allows to toggle
between Internal and the configured timecode source which is chosen in
Edit \textgreater{} Preferences \textgreater{} Transport.

When Ardour is chasing (synchronizing to) an external timecode source,
the following cases need to be distinguished:
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
the timecode source shares the clock

\item {} 
the timecode source is independent (no wordclock sync)

\end{enumerate}

and
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
the timecode source uses the same FPS setting as Ardour

\item {} 
the timecode source runs at different frames-per-second

\end{enumerate}

In both cases the first option is preferred: clock sync + same FPS
setting.
\subsubsection*{Frames-per-second}

If the frames-per-second do not match, Ardour can either re-calculate
and map the frames, or the configured FPS (Session \textgreater{} Properties) can be
changed automatically while the slave is active. The behavior is
configured with the checkbox Edit \textgreater{} Preferences \textgreater{} Transport \textgreater{} Match
session video frame rate to external timecode.

When enabled, the session video frame rate will be changed to match that
of the selected external timecode source. When disabled, the session
video frame rate will not be changed to match that of the selected
external timecode source. Instead the frame rate indication in the main
clock will flash red, and Ardour will convert between the external
timecode standard and the session standard.

\begin{DUlineblock}{0em}
\item[] 29.97 drop-frame timecode is another corner case. While the SMPTE
12M-1999 specifies 29.97df as 30000/1001 frames per second, not all
hardware devices follow that standard. The checkbox Lock to 29.9700
fps instead of 30000/1001 allows to use a compatibility mode for those
devices.
\item[] When enabled, the external timecode source is assumed to use 29.970000
fps instead of 30000/1001. SMPTE 12M-1999 specifies 29.97df as
30000/1001. The spec further mentions that drop-frame timecode has an
accumulated error of -86 ms over a 24-hour period. Drop-frame timecode
would compensate exactly for a NTSC color frame rate of 30 * 0.9990
(ie 29.970000). That is \sphinxstyleemphasis{not} the actual rate. However, some vendors
use that rate—despite it being against the specs—because the variant
of using exactly 29.97 fps yields zero timecode drift.
\end{DUlineblock}
\subsubsection*{Clock Sync Lock}

As described in the \sphinxhref{http://manual.ardour.org/synchronization/on-clock-and-time/}{On Clock and
Time}
chapter, timecode and clock are independent. If the external timecode
source is not in sample-sync with the audio hardware (and JACK), Ardour
needs to run at varispeed to adjust for the discrepancy.

The checkbox External timecode is sync locked allows to select the
behavior according to the setup. When enabled, it indicates that the
selected external timecode source shares sync (Black \& Burst, Wordclock,
etc) with the audio interface.

In other words: if enabled, Ardour will only perform initial
synchronization and keep playing at speed 1.0 instead of vari-speed
adjusting to compensate for drift.

Note that vari-speed is unavailable when recording in Ardour, and all
tracking happens at speed 1.0. So in order to record in sync with
external timecode it must be sample-locked or it will drift over time.
\subsubsection*{MIDI Clock}

MIDI Clock is not a timecode format but tempo-based time. The absolute
reference point is expressed as beats-per-minute and Bar, Beat and Tick.
There is no concept of sample-locking for MIDI clock signals. Ardour
will vari-speed if necessary to chase the incoming signal.

Note that the MIDI Clock source must be connected to the
\sphinxcode{\sphinxupquote{ardour:MIDI clock in}} port.
\subsubsection*{LTC—Linear Timecode}

The LTC slave decodes an incoming LTC signal on a JACK audio port. It
will auto-detect the frame rate and start locking to the signal once two
consecutive LTC frames have been received.

The incoming timecode signal needs to arrive at the \sphinxcode{\sphinxupquote{ardour:LTC-in}}
port. Port-connections are restored for each session and the preference
dialog offers an option to select it for all sessions.

Ardour’s transport is aligned to LTC-frame start/end positions according
to the SMPTE 12M-1999 specification, which means that the first bit of
an LTC-Frame is aligned to different Lines of a Video-Frame, depending
on the TV standard used. Only for Film (24fps) does the LTC-Frame
directly match the video Frame boundaries.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{ltc-transport-alignment}.png}
\caption{LTC frame alignment for the 525/60 TV standard}\label{\detokenize{index:id475}}\end{figure}

Ardour supports vari-speed and backwards playback but will only follow
speed changes if the sync locked option is disabled.

While Ardour is chasing LTC, the main transport clock will display the
received Timecode as well as the delta between the incoming signal and
Ardour’s transport position.

A global offset between incoming timecode and Ardour’s transport can be
configured in Session \textgreater{} Properties.

The user-bits in the received LTC frame are ignored.
\subsubsection*{MTC—MIDI Timecode}

Ardour’s MTC slave parses full timecode messages as well as MTC
quarter-frame messages arriving on the \sphinxcode{\sphinxupquote{ardour:MTC in}} port. The
transport will only start rolling once a complete sequence of 8 quarter
frames has been received.

Ardour supports vari-speed and backwards playback but will only follow
MTC speed changes if the sync locked option is disabled.

When Ardour is chasing MTC, the main transport clock will display the
received Timecode as well as the delta between the incoming signal and
Ardour’s transport position.
\subsubsection*{JACK Transport}

When slaved to jack, Ardour’s transport will be identical to
JACK-transport. As opposed to other slaves, Ardour can be used to
control the JACK transport states (stopped/rolling). No port connections
need to be made for jack-transport to work.

JACK-transport does not support vari-speed, nor offsets. Ardour does not
chase the timecode but is always in perfect sample-sync with it.

JACK-transport also includes temp-based-time information in
Bar:Beats:Ticks and beats-per-minute. However, only one JACK application
can provide this information at a given time. The checkbox Session \textgreater{}
Properties \textgreater{} JACK Time Master configures Ardour to act as translator
from timecode to BBT information.
\subsubsection*{7.4 - Overview of all Timecode related settings}

Timecode settings are accessed from the menu in three places:
\begin{itemize}
\item {} 
Session \textgreater{} Properties \textgreater{} Timecode

\item {} 
Edit \textgreater{} Preferences \textgreater{} Transport

\item {} 
Edit \textgreater{} Preferences \textgreater{} MIDI

\end{itemize}
\subsubsection*{Timecode Settings}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

Timecode frames-per-second
&
Configure timecode
frames-per-second (23.976, 24,
24.975, 25, 29.97, 29.97 drop,
30, 30 drop, 59.94, 60). Note
that all fractional framerates
are actually fps*(1000.0/1001.0).
\\
\hline
Pull up/down
&
Video pull-up modes change the
effective samplerate of Ardour to
allow for changing a film
soundtrack from one frame rate to
another. See
\sphinxhref{http://en.wikipedia.org/wiki/Telecine}{Telecine}
\\
\hline
Slave Timecode offset
&
The specified offset is added to
the received timecode (MTC or
LTC).
\\
\hline
Timecode Generator offset
&
Specify an offset which is added
to the generated timecode (so far
only LTC).
\\
\hline
JACK Time Master
&
Provide Bar\textbar{}Beat\textbar{}Tick and other
information to JACK.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

These settings are session specific.
\subsubsection*{Transport Preferences}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

External timecode source
&
Select timecode source: JACK,
LTC, MTC, MIDI Clock
\\
\hline
Match session video frame rate to
external timecode
&
This option controls the value of
the video frame rate \sphinxstyleemphasis{while
chasing} an external timecode
source. When enabled, the session
video frame rate will be changed
to match that of the selected
external timecode source. When
disabled, the session video frame
rate will not be changed to match
that of the selected external
timecode source. Instead the
frame rate indication in the main
clock will flash red and Ardour
will convert between the external
timecode standard and the session
standard.
\\
\hline
External timecode is sync locked
&
Indicates that the selected
external timecode source shares
sync (Black \& Burst, Wordclock,
etc) with the audio interface.
\\
\hline
Lock to 29.9700 fps instead of
30000/1001
&
The external timecode source is
assumed to use 29.97 fps instead
of 30000/1001. SMPTE 12M-1999
specifies 29.97df as 30000/1001.
The spec further mentions that
drop-frame timecode has an
accumulated error of -86ms over a
24-hour period. Drop-frame
timecode would compensate exactly
for a NTSC color frame rate of 30
* 0.9990 (ie 29.970000). That is
not the actual rate. However,
some vendors use that
rate—despite it being against the
specs—because the variant of
using exactly 29.97 fps has zero
timecode drift.
\\
\hline
LTC incoming port
&
Offers a session agnostic way to
retain the LTC port connection.
\\
\hline
Enable LTC generator
&
Does just what it says.
\\
\hline
Send LTC while stopped
&
Enable to continue to send LTC
information even when the
transport (playhead) is not
moving. This mode is intended to
drive analog tape machines which
unspool the tape if no LTC
timecode is received.
\\
\hline
LTC generator level
&
Specify the Peak Volume of the
generated LTC signal in dbFS. A
good value is 0 dBu (which is
-18 dbFS in an EBU calibrated
system).
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

These settings are common to all sessions.
\subsubsection*{MIDI Preferences}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

Send MIDI Timecode
&
Enable MTC generator
\\
\hline
Send MIDI Clock
&
Enable MIDI Clock generator
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

These settings are also common to all sessions.
\subsubsection*{8 - Preferences}

Global preferences control general workflow and system configuration,
and should apply to all sessions. They are located in Edit \textgreater{} Preferences
and stored in Ardour’s user configuration file in the user’s home
directory.
\subsubsection*{General}
\begin{itemize}
\item {} 
DSP CPU Utilization
\begin{itemize}
\item {} 
Signal processing uses: sets how many cpu processors can be used
to do signal processing. It can be set to use one up to all
processors.

\end{itemize}

\item {} 
Memory Usage
\begin{itemize}
\item {} 
Waveform image cache (megabytes): sets the maximum amount of ram
that can be used to store the images representing the waveforms in
the editor. Past this amount, the images will be regenerated when
needed, which can significantly decrease the system’s performance.

\end{itemize}

\item {} 
Engine
\begin{itemize}
\item {} 
Try to auto-launch audio/midi engine allows Ardour to try to
automatically launch the audio and MIDI system, driver and device,
thus not showing the {\hyperref[\detokenize{index:newopen-session-dialog}]{\emph{Audio/MIDI
Setup}}} dialog. This can save a little
time if the system is always used the same way.

\end{itemize}

\item {} 
Automation
\begin{itemize}
\item {} 
\sphinxstylestrong{Thinning factor} ranges from 0 to 1000 with larger values
sending fewer automation changes. Thinning is like lossy audio
compression, removing data that is less likely to be noticed,
although the more is removed, the more likely the loss will be
noticed. The advantage to thinning is reduced CPU usage.

\item {} 
\sphinxstylestrong{Automation sampling interval} ranges from 1 to 1000 ms.
Determines how frequently the automation input is sampled. The
shorter the interval the higher the accuracy but also the higher
the CPU requirements.

\end{itemize}

\item {} 
Tempo
\begin{itemize}
\item {} 
Allow non quarter-note pulse: by default, Ardour understands the
{\hyperref[\detokenize{index:tempo-and-meter}]{\emph{tempo}}} as the number of quarter notes in a
minute. Checking this option allows to set the tempo based on any
division of the note, from whole to 1/128th. This is reflected in
the Edit Tempo window (accessed by double clicking a tempo marker)
that shows a “Pulse” menu when this option is checked.

\end{itemize}

\item {} 
GUI Lock
\begin{itemize}
\item {} 
Lock timeout (seconds):locks the GUI after this many idle seconds
(zero being ‘never lock’). The GUI can also be locked with Session
\textgreater{} Lock. When locked, a dialog will display a “Click to unlock”
button.

\end{itemize}

\end{itemize}
\subsubsection*{Session}
\begin{itemize}
\item {} 
Undo defines the behaviour of the Undo operations:
\begin{itemize}
\item {} 
\sphinxstylestrong{Limit undo history} sets how many commands can be undone using
Z or Edit \textgreater{} Undo. Unchecking will keep an endless memory of
operations to undo, at the expense of memory.

\item {} 
\sphinxstylestrong{Save undo history} sets how many commands are saved so they are
available to be undone after reopening the session. This can also
be unchecked to keep all actions undoable, at the cost of bigger
session files.

\item {} 
\sphinxstylestrong{Verify removal of last capture} when enabled prompts to verify
removal the last recording capture when Edit \textgreater{} Remove Last Capture
is executed.

\end{itemize}

\item {} 
Session Management:
\begin{itemize}
\item {} 
\sphinxstylestrong{Make periodic backups of the session file} will create a backup
session file after changes to the timeline. The backup file is the
session name followed by \sphinxstyleemphasis{.ardour.bak}. The backup can be used to
recover from crashes when the session had not been explicitly
saved.

\item {} 
\sphinxstylestrong{Always copy imported files} selects, and then disables changes
to, the \sphinxstyleemphasis{Copy files to session} option in the {\hyperref[\detokenize{index:import-dialog}]{\emph{Add Existing
Media}}} dialog.

\item {} 
\sphinxstylestrong{Default folder for new sessions:} defaults the folder where
Ardour will create new session folders. This is used in the
\sphinxstyleemphasis{Session Setup} dialog displayed by Session \textgreater{} New.

\item {} 
\sphinxstylestrong{Maximum number of recent sessions:} determines how many of the
last opened sessions shows in the \sphinxstyleemphasis{Recent Sessions} dialog
displayed by Session \textgreater{} Recent.

\end{itemize}

\end{itemize}
\subsubsection*{Translation}
\begin{itemize}
\item {} 
Internationalization
\begin{itemize}
\item {} 
Use translations sets if Ardour should use a translated version of
all the messages. The default (unchecked) is English (US). When
checked, and if a language file exists for the system language,
this file will be used to translate Ardour.

\end{itemize}

\end{itemize}
\subsubsection*{Editor}
\begin{itemize}
\item {} 
General
\begin{itemize}
\item {} 
Snap rubberband to grid when enabled uses the grid when {\hyperref[\detokenize{index:select-regions}]{\emph{selecting
regions}}} with a rubberband rectangle.

\item {} 
Prompt for new marker names when enabled, popup a dialog when a
new {\hyperref[\detokenize{index:working-with-markers}]{\emph{marker}}} is created. This allows
markers to be named as they are created.

\item {} 
Allow dragging of the playhead, when enabled, allows dragging the
playhead with the mouse in the \sphinxstylestrong{Editor} window.

\item {} 
Playhead dragging speed (\%): chooses how fast the canvas scrolls
when dragging the playhead outside of the visible canvas.

\item {} 
Limit zooming \& summary view to X minutes beyond session extents
prevents the zoom out both in the editor and the summary, to show
anything past the chosen time after the end marker, restraining
the vision to only useful content.

\item {} 
Zoom to mouse position when zooming with scroll wheel: by default,
Ardour zooms to the {\hyperref[\detokenize{index:edit-point-control}]{\emph{edit point}}}. When
this option is checked, and the zoom is done with + mousewheel,
the zoom will happen at the mouse cursor position regardless of
the edit point chosen.

\item {} 
Zoom with vertical drag in rulers allows, when checked, to click
anywhere in an empty zone of the {\hyperref[\detokenize{index:ruler}]{\emph{ruler}}} zone and drag
up to zoom in or down to zoom out.

\item {} 
Double click zooms to selection allows by double clicking, to zoom
on the selection, both on the time and tracks axes. If the
selection has been done with or , then this key should still be
pressed when double clicking for this to work, otherwise the first
click breaks the group selection.

\item {} 
Update editor window during drags of the summary: when enabled the
contents of the editor window will redraw the tracks area as the
selection rectangle in the {\hyperref[\detokenize{index:summary}]{\emph{summary}}} area is moved or
resized.

\item {} 
Auto-scroll editor window when dragging near its edges when
enabled will scroll the editor window automatically when dragging
a region. This can make it easier to see where to position the
region.

\item {} 
Show gain envelopes in audio regions: sets in which
{\hyperref[\detokenize{index:toolbox}]{\emph{modes}}} the gain envelope is displayed in audio
regions. The gain envelope is superimposed over the region in the
selected modes, and hidden otherwise for a better legibility.

\end{itemize}

\item {} 
Editor Behaviour
\begin{itemize}
\item {} 
Move relevant automation when audio regions are moved, when
enabled, causes automation data to stay with a region when the
region is moved inside the playlist. When disabled, the automation
is not affected by movement of regions.

\item {} 
Ignore Y-axis click position when adding new automation-points
allows to create new automation points at the x-position of the
mouse, without using the Y-position as the value, hence creating a
new automation point at its present value.

\item {} 
Default fade shape: sets which {\hyperref[\detokenize{index:create-region-fades-and-crossfades}]{\emph{fade
shape}}} is the default.

\item {} 
Regions in edit groups are edited together: sets the criteria to
see if editing actions apply to tracks grouped together in an
group.

\item {} 
Layering model: Ardour allows {\hyperref[\detokenize{index:layering-display}]{\emph{layering}}}
multiple regions in the same track. This selector defines how
these layers are managed, either manually or by placing the latest
on top.

\item {} 
After splitting selected regions, select: determines which, if
any, regions are selected after a split operation. The options are
no regions, the regions created by the split, and if more than one
region was selected to start with, the existing selection and the
new regions.

\end{itemize}

\end{itemize}
\subsubsection*{Modifiers}

This page allows to choose how things are done in the editor. This is a
very flexible way for Ardour to match an existing workflow, or speed up
the editing process based on the user’s most used actions.

The Reset to recommended defaults button at the bottom provides a way to
revert any user made change to its default value.
\subsubsection*{Mixer}
\begin{itemize}
\item {} 
Solo contains settings that affect the use of {\hyperref[\detokenize{index:muting-and-soloing}]{\emph{solo,
muting}}}, and {\hyperref[\detokenize{index:panning}]{\emph{panning}}}.
\begin{itemize}
\item {} 
Solo controls are Listen controls: when enabled, the soloed track
is soloed only on the monitor bus, the master fader mix is not
affected by the solo. This option can also be set by enabling
pre-fader listen or after-fader listen in the \sphinxstylestrong{Mixer} monitor
section.

\item {} 
Exclusive solo when enabled will only solo the last track selected
for solo. Previously soloed tracks will be un-soloed. This setting
is also available from the \sphinxstylestrong{Mixer} monitor section.

\item {} 
Show solo muting when enabled outlines the mute button on tracks
and busses when another track is soloed.

\item {} 
Soloing overrides muting when enabled allows a track to be heard
when it is soloed while muted. This setting is also available from
the \sphinxstylestrong{Mixer} monitor section.

\item {} 
Solo-in-place mute cut (dB): sets the attenuation of the other
tracks when another track is soloed in place. This setting is also
available from the \sphinxstylestrong{Mixer} monitor section. The default is
“−inf” for −\(\infty\), meaning the other tracks are totally muted.

\item {} 
Listen Position: determines what is listened to when the solo
controls are used as listen controls. The options are after-fader
or pre-fader.

\item {} 
PFL signals come from: determines whether the pre-fader listen
position is before or after the pre-fader processors.

\item {} 
AFL signals come from: determines whether the after-fader listen
position is before or after the after-fader processors.

\end{itemize}

\item {} 
Default Track / Bus Muting Options sets the muting options for a
newly created tracks or bus. The mute options for an existing track
or bus are changed by the right-click context menu on a mute button.
\begin{itemize}
\item {} 
Mute affects pre-fader sends when enabled pre-fader sends will be
muted by default.

\item {} 
Mute affects post-fader sends when enabled post-fader sends will
be muted by default.

\item {} 
Mute affects control outputs when enabled control outputs are
muted by default.

\item {} 
Mute affects main outputs when enabled main outputs are muted by
default.

\end{itemize}

\item {} 
Send Routing affects {\hyperref[\detokenize{index:aux-sends}]{\emph{aux and external sends}}}.
\begin{itemize}
\item {} 
Link panners of Aux and External Sends with main panner by default
when enabled, sends follow the channel panner. When disabled,
sends can panned independently of the channel panner and fader.
Double clicking the send in the processor box toggles the main
panner and fader between the aux send and the channel.

\end{itemize}

\end{itemize}
\subsubsection*{Signal Flow}
\begin{itemize}
\item {} 
Monitoring
\begin{itemize}
\item {} 
Record monitoring handled by: determines whether Ardour provides
monitoring of incoming audio or whether monitoring is provided by
hardware. See {\hyperref[\detokenize{index:monitoring}]{\emph{Monitoring}}} for more information.

\item {} 
Tape machine mode when enabled defaults new audio tracks to tape
machine mode. See {\hyperref[\detokenize{index:track-types}]{\emph{Track Types}}} for more
information.

\end{itemize}

\item {} 
Track and Bus Connections
\begin{itemize}
\item {} 
Auto-connect main output (master or monitor) bus to physical ports
auto-connects the outputs to the first N physical ports. In a
session without a {\hyperref[\detokenize{index:monitor-section}]{\emph{monitor section}}}, the
master-bus is connected to the system’s playback ports, and if a
monitor section exists, the monitor-bus’ output are connected.

\item {} 
Connect track inputs: allows to choose when a new track is created
whether its inputs will be automatically connected to the physical
inputs of the system or not (hence the user has to manually
connect it).

\item {} 
Connect track and bus outputs: allows to choose, for any new track
or bus created, whether its output will automatically be connected
to the master bus, directly to the physical outputs or to nothing
(the user has to manually connect it).

\item {} 
Use ‘Strict-I/O’ for new tracks or busses determines the default
choice for the {\hyperref[\detokenize{index:trackbus-signal-flow}]{\emph{signal flow}}} of a newly
created track or bus. This can be overridden in the {\hyperref[\detokenize{index:adding-tracks-busses-and-vcas}]{\emph{Add
Track/Bus/VCA}}} dialog

\end{itemize}

\end{itemize}
\subsubsection*{Audio}
\begin{itemize}
\item {} 
Buffering settings determine how many seconds of audio off of disk
will be buffered in memory. Longer settings reduce the risk of buffer
under-runs but consume more memory.
\begin{itemize}
\item {} 
Preset: will automatically choose the values for the playback and
recording buffer based on the chosen size of the session. The
\sphinxstylestrong{Custom} option allows to manually select the buffers with the
two sliders below.

\item {} 
Playback (seconds of buffering): sets how many seconds of audio
Ardour will buffer during playback.

\item {} 
Recording (seconds of buffering): sets how many seconds of audio
Ardour will buffer during recording.

\end{itemize}

\item {} 
Denormals are a specific type of very small numbers that can cause
issues with CPU consumption when using some plugins in some
circumstances. Ardour provides two methods of handling the issue.
Trying different combinations of these settings may minimize CPU
consumption.
\begin{itemize}
\item {} 
Use DC bias to protect against denormals adds a small constant
value to numbers to move the numbers away from zero.

\item {} 
Processor handling:, if the computer’s hardware supports it,
offers two methods that can be used individually or combined.
Flush to zero and denormals are zero.

\end{itemize}

\item {} 
Regions
\begin{itemize}
\item {} 
Enable automatic analysis of audio generates the transient values
(used in e.g. the {\hyperref[\detokenize{index:rhythm-ferret}]{\emph{Rhythm Ferret}}})
automatically. When unchecked, the transient values will be
generated on demand.

\item {} 
Replicate missing region channels: if a track is N-channel, and
the region has fewer channels, this option copies the existing
channel’s data for this non-existent one. If left unchecked, the
missing channels will stay silent.

\end{itemize}

\end{itemize}
\subsubsection*{MIDI}
\begin{itemize}
\item {} 
Buffering
\begin{itemize}
\item {} 
MIDI read-ahead time (seconds): defines how much time of MIDI data
must be read in advance by Ardour and put in the buffer. More time
means more stability while playing back, at the expense of more
time to buffer the data. This should be set to a low value for a
reasonably capable machine.

\end{itemize}

\item {} 
Session
\begin{itemize}
\item {} 
Initial program change: Ardour will send a MIDI program change
message on the \sphinxcode{\sphinxupquote{ardour:MMC out}} JACK port when a session is
loaded and whenever this field is changed. A value of -1 means
don’t send any program change message.

\end{itemize}

\item {} 
Audition
\begin{itemize}
\item {} 
Sound MIDI notes as they are selected in the editor will play any
selected or added MIDI note when in Draw or Internal Edit modes.
The note is sent as MIDI as if Ardour was playing it withe the
session, so the processors and signal routing will be applied.

\item {} 
Midi Audition Synth (LV2): allows to select in the list of LV2
instruments, which one will be used to audition MIDI when e.g. in
the {\hyperref[\detokenize{index:import-dialog}]{\emph{import dialog}}}.

\end{itemize}

\end{itemize}
\subsubsection*{Metronome}
\begin{itemize}
\item {} 
Metronome handles the way Ardour’s metronome is played when enabled
in the {\hyperref[\detokenize{index:transport-bar}]{\emph{Transport Bar}}}.
\begin{itemize}
\item {} 
Emphasis on first beat plays a different sound when the first beat
is played (e.g. 1/4 in 4/4, 1/3 in 3/4,…). When unchecked, all the
beats are indistinguishable.

\item {} 
Use built-in default sounds when checked, uses Ardour’s own sounds
for the metronome click. Unchecking this allows to set some custom
sounds below.

\item {} 
Audio file: selects an audio file for the beats, in any
{\hyperref[\detokenize{index:supported-file-formats}]{\emph{format}}} Ardour supports.

\item {} 
Emphasis audio file: in conjunction with Emphasis on first beat,
selects an audio file for the first beats of each bar.

\item {} 
Gain level: allows the metronome’s click sounds to be boosted or
attenuated.

\end{itemize}

\item {} 
Options
\begin{itemize}
\item {} 
Enable Metronome only while recording: when enabled, the metronome
will remain silent unless Ardour is recording.

\end{itemize}

\end{itemize}
\subsubsection*{Metering}
\begin{itemize}
\item {} 
Metering
\begin{itemize}
\item {} 
Peak hold time: allows the meter to keep displaying the highest
signal level for a period of time before reverting to showing the
actual instantaneous value (unless an even higher peak occurs).
The longer this time is, the easier it is to spot peaks, at the
expense of instantaneous accuracy.

\item {} 
DPM fall-off: describes how fast the Digital Peak Meters can go
from a high value to a lower one. Faster values are more accurate
but less readable.

\item {} 
Meter line-up level; 0 dBu: chooses a standard for the conversion
between dBFS (Full Scale) which represent the numeric signal
level, and dBu which represents the analog signal level. This
value is used to configure meter-marks and color knee-points, or
set the reference levels for various meter-types.

\item {} 
IEC1/DIN Meter line-up level; 0 dBu: sets the reference level for
the IEC1/DIN Meter

\item {} 
VU Meter standard: selects which standard to use for the zero
value of the vu-meters, i.e. the analog dBu value that will show
as 0 on the VU-meter.

\item {} 
Peak indicator threshold {[}dBFS{]}: at that value and over, the
signal will make the peak meter to turn red, indicating a level
too high.

\end{itemize}

\item {} 
Default Meter Types sets the default meters when creating a session
or track. These meters can be changed afterwards by right-clicking a
meter.
\begin{itemize}
\item {} 
Default Meter Type for Master Bus: defines which kind of
{\hyperref[\detokenize{index:metering-in-ardour}]{\emph{meter}}} will be used when creating a new
session (does not apply to the current session).

\item {} 
Default Meter Type for busses: defines which kind of meter will be
used when creating a new bus (applies to the bus created after
changing the value).

\item {} 
Default Meter Type for tracks: same as above, for tracks.

\end{itemize}

\item {} 
Post Export Analysis
\begin{itemize}
\item {} 
Save loudness analysis as image file allows, when the Analyze
Exported Audio is checked in the {\hyperref[\detokenize{index:export-dialog}]{\emph{Export
dialog}}}, to save the analysis graph as a file
named \sphinxcode{\sphinxupquote{session.png}} alongside the exported audio file(s) (in the
same folder).

\end{itemize}

\end{itemize}
\subsubsection*{Transport}
\begin{itemize}
\item {} 
General
\begin{itemize}
\item {} 
Stop at the end of the session causes the transport to stop during
playback when it reaches the end marker. Behavior during recording
is not changed.

\item {} 
Keep record-enable engaged on stop leaves the global record-enable
engaged after transport is stopped. Does not affect track level
record-enable which is never changed on stop.

\item {} 
Disable per-track record disarm while rolling, when enabled, will
not allow the any track’s record-enable to be disarmed during
record, preventing accidentally stopping the recording of a take.

\item {} 
12dB gain reduction during fast-forward and fast-rewind when
enabled will reduce the unpleasant increase in perceived volume
that occurs when fast-forwarding or rewinding through some kinds
of audio.

\item {} 
Preroll: sets the duration of the preroll for playing and
recording when using a preroll. Can be a musical duration (in
bars) or a duration in seconds.

\end{itemize}

\item {} 
Looping
\begin{itemize}
\item {} 
Play loop is a transport mode changes the behavior of the loop
button, turning it into a toggle. When enabled, the loop button
does not start playback but forces playback to always play the
loop. Looping stays engaged when the transport is stopped.
Playback continues where the transport stopped and continues to
loop. When disabled, the loop button starts playing the loop but
stop then cancels loop playback.

\item {} 
Do seamless looping removes any clicks that might otherwise be
audible when the transport moves from the end of the loop range
back to the beginning.

\end{itemize}

\item {} 
Dropout (xrun) Handling
\begin{itemize}
\item {} 
Stop recording when an xrun occurs will stop the transport when an
xrun occurs during recording, ensuring no audible glitches are
recorded.

\item {} 
Create markers where xruns occur will create a new
{\hyperref[\detokenize{index:working-with-markers}]{\emph{marker}}} when an xrun occurs during
recording at the location of the xrun. This marks where possible
xruns might produce audible glitches.

\end{itemize}

\end{itemize}
\subsubsection*{Sync}
\begin{itemize}
\item {} 
External Synchronization
\begin{itemize}
\item {} 
External timecode source determines which external source to use
when Ardour is using an external
{\hyperref[\detokenize{index:working-with-synchronization}]{\emph{synchronization}}} source.
Depending on the timecode source chosen, the additional preference
options below are available.

\item {} 
Match session video frame rate to external timecode controls the
value of the video frame rate \sphinxstyleemphasis{while chasing} an external timecode
source. When enabled, the session video frame rate will be changed
to match that of the selected external timecode source. When
disabled, the session video frame rate will not be changed to
match that of the selected external timecode source. Instead, the
frame rate indication in the main clock will flash red and Ardour
will convert between the external timecode standard and the
session standard.

\item {} 
Sync-lock timecode to clock (disable drift compensation) When
enabled, Ardour will never varispeed when slaved to external
timecode. Sync Lock indicates that the selected external timecode
source shares clock-sync (Black \& Burst, Wordclock, etc) with the
audio interface. This options disables drift compensation. The
transport speed is fixed at 1.0. Vari-speed LTC will be ignored
and cause drift. When disabled, Ardour will compensate for
potential drift regardless if the timecode sources shares clock
sync.

\item {} 
Lock to 29.9700 fps instead of 30000/1001, when enabled, will
force Ardour to assume the external timecode source uses 29.97 fps
instead of 30000/1001. SMPTE 12M-1999 specifies 29.97 df as
30000/1001. The spec further mentions that drop-frame timecode has
an accumulated error of -86 ms over a 24 hour period. Drop-frame
timecode would compensate exactly for an NTSC color frame rate of
30 × 0.9990 (i.e. 29.970000). That is not the actual rate.
However, some vendors use that rate—despite it being against the
specs—because the variant of using exactly 29.97 fps has zero
timecode drift.

\end{itemize}

\end{itemize}
\subsubsection*{LTC}
\begin{itemize}
\item {} 
Linear Timecode (LTC) Reader
\begin{itemize}
\item {} 
LTC incoming port: specifies which physical incoming port of the
system will provide the LTC signal.

\end{itemize}

\item {} 
Linear Timecode (LTC) Generator
\begin{itemize}
\item {} 
Enable LTC generator when enabled Ardour will output an LTC
timecode signal on its \sphinxstyleemphasis{LTC-out} port. If this option is checked,
the two options below are active:

\item {} 
Send LTC while stopped, when enabled Ardour will continue to send
LTC information even while the transport (playhead) is not moving.

\item {} 
LTC generator level {[}dBFS{]}: specifies the peak volume of the
generated LTC signal in dbFS. A good value is 0dBu=−18dbFS in an
EBU calibrated system.

\end{itemize}

\end{itemize}
\subsubsection*{MIDI}
\begin{itemize}
\item {} 
MIDI Beat Clock (Mclk) Generator
\begin{itemize}
\item {} 
Enable Mclk generator when enabled Ardour will generate a (tempo
dependant) beat clock at a rate of 24 pulses per quarter note on
the \sphinxcode{\sphinxupquote{ardour:MIDI clock out}} JACK port.

\end{itemize}

\item {} 
MIDI Time Code (MTC) Generator
\begin{itemize}
\item {} 
Enable MTC Generator when enabled Ardour will generate MIDI time
code on the \sphinxcode{\sphinxupquote{ardour:MTC out}} JACK port.

\item {} 
Percentage either side of normal transport speed to transmit MTC:
MIDI time code generation will be disabled when the transport
speed is greater than normal speed plus this percentage or less
than normal minus this percentage.

\end{itemize}

\item {} 
MIDI Machine Control (MMC)
\begin{itemize}
\item {} 
Respond to MMC commands when enabled Ardour will respond to MIDI
Machine Control commands received on the \sphinxcode{\sphinxupquote{ardour:MMC in}} JACK
port.

\item {} 
Send MMC commands when enabled Ardour will send MIDI Machine
Control commands on the \sphinxcode{\sphinxupquote{ardour:MMC out}} JACK port.

\item {} 
Inbound MMC device ID: is the only device ID Ardour will respond
to when an MMC command is received on the \sphinxcode{\sphinxupquote{ardour:MMC in}} JACK
port.

\item {} 
Outbound MMC device ID: is the MIDI device ID Ardour will use when
it sends MMC commands.

\end{itemize}

\end{itemize}
\subsubsection*{Control Surfaces}

This tab contains settings for {\hyperref[\detokenize{index:control-surfaces}]{\emph{control surfaces}}}.

It lists all the Control Surface protocols Ardour knows. To enable a
Control Surface Protocol, the Enable checkbox next to its name should be
ticked. Editing the settings related to this protocol can be done by
double-clicking its name or clicking the Show protocol settings (only
for Generic MIDI and Open Sound Control).
\subsubsection*{MIDI Ports}
\begin{itemize}
\item {} 
MIDI Port Options
\begin{itemize}
\item {} 
MIDI input follows MIDI track selection allows Ardour to
automatically connect the MIDI input to the selected track.
Selecting a different MIDI track results in Ardour disconnecting
the MIDI device from the former track and connecting it to the
newly selected one, so that the MIDI device is always connected to
the selected track. Which MIDI device will follow selection can be
chosen below.

\end{itemize}

\item {} 
MIDI Inputs This is a list of all the MIDI devices connected as
inputs (capture devices) to Ardour. For each devices, there are 3
checkboxes:
\begin{itemize}
\item {} 
Music Data if checked, Ardour will consider this device as a
source for musical data input (notes, etc…)

\item {} 
Control Data if checked, Ardour will consider this device as a
source for control data input (play/stop, etc…)

\item {} 
Follow selection if the above MIDI input follows MIDI track
selection is checked, Ardour will make this device follow track
selection.

\end{itemize}

\item {} 
MIDI Outputs This is a list of all the MIDI devices connected as
outputs (playback devices) to Ardour. For each devices, there are 2
checkboxes:
\begin{itemize}
\item {} 
Music Data if checked, Ardour will consider this device as a
target for musical data output (notes, etc…)

\item {} 
Control Data if checked, Ardour will take this device as a target
for control data output (play/stop, etc…)

\end{itemize}

\end{itemize}
\subsubsection*{Plugins}

The content of this preference page varies heavily between versions or
Ardour: both the platform and the build-time options can make Ardour
support some types of plugins and not others. While this documentation
tries to show all possible options, most systems will only show a subset
of the options hereunder, e.g. AudioUnits are macOS only…
\begin{itemize}
\item {} 
Scan/Discover
\begin{itemize}
\item {} 
Scan for Plugins will initiate an immediate scan of the system for
available plugins. Useful to get a newly installed plugin
recognised by Ardour.

\end{itemize}

\item {} 
General
\begin{itemize}
\item {} 
Always Display Plugin Scan Progress When enabled a popup window
showing plugin scan progress is displayed for indexing (cache
load) and discovery (detect new plugins).

\item {} 
Silence plugins when the transport is stopped when stopping
playback or recording, if this option is checked, the plugins that
still emit sound (reverbs, etc…) will be stopped. If unchecked,
the plugins will continue playing after the transport stop.

\item {} 
Make new plugins active when enabled, any plugin added to a track
will be in active mode. If unchecked, the plugins will be added in
inactive mode by default, hence have no processing effect on the
track/bus.

\item {} 
Limit automatable parameters per plugin: as some plugins
(synthesizers, …) have a lot of parameters, and those parameters
can be automated by Ardour, checking this will limit the number of
parameters that are listed as automatable, hence making the lists
shorter and the GUI more responsive.

\end{itemize}

\item {} 
Plugin GUI
\begin{itemize}
\item {} 
Automatically open the plugin GUI when adding a new plugin shows
the plugins GUI as soon as it is added to the processing box. If
unchecked, the plugin will be added in the processor box but the
GUI will only be shown when double clicking it.

\item {} 
Show Plugin Inline Display on Mixer strip by default allows Ardour
to show, in the {\hyperref[\detokenize{index:audiomidi-mixer-strips}]{\emph{mixer strips}}}, a
visual rendering of the effect. These Inline Display are a special
feature of Ardour, so not all plugins are able to show this
display. Most of Ardour’s {\hyperref[\detokenize{index:plugins-bundled-with-ardour}]{\emph{own
plugins}}} have an Inline Display.
At any time, the plugin’s Inline Display can be toggled on or off
by double-clicking it.

\item {} 
Don’t automatically open the plugin GUI when the plugin has an
inline display mode: this option, available only if Automatically
open the plugin GUI when adding a new plugin is checked,
supercedes it and hides the plugin GUI at creation if it has an
Inline Display, like Ardour’s own \sphinxcode{\sphinxupquote{a-*}} plugins.

\end{itemize}

\item {} 
Instrument
\begin{itemize}
\item {} 
Ask to replace existing instrument plugin: if a MIDI track already
has an instrument (i.e. MIDI to audio converter of some sort) and
this option is checked, Ardour will detect it and offer to replace
the existing instrument with the newly added one, avoiding a
possible conflict.

\item {} 
Interactively configure instrument plugins on insert: when
inserting a multichannel instrument plugin, if this option is
checked, prompts the user for the channel configuration for this
plugin.

\end{itemize}

\end{itemize}
\subsubsection*{VST}
\begin{itemize}
\item {} 
VST
\begin{itemize}
\item {} 
Enable Mac VST support (requires restart or re-scan) makes a MacOs
system able to run VST-Mac plugins. As stated, a new scan for
plugins is required, be it manually or by restarting Ardour.

\item {} 
Scan for {[}new{]} VST Plugins on Application Start When enabled new
VST plugins are searched, tested and added to the cache index on
application start. When disabled new plugins will only be
available after triggering a ‘Scan’ manually.

\item {} 
Verbose Plugin Scan: adds information about the plugin in the {\hyperref[\detokenize{index:status-bar}]{\emph{Log
window}}}.

\item {} 
Scan Time Out Specifies the default timeout for plugin
instantiation. Plugins that require more time to load will be
blacklisted. A value of \&infinity; disables the timeout.

\item {} 
VST Cache: Clicking the Clear button removes all VST plugins from
the list of plugins available to be inserted into the processor
box. A new VST plugin scan is then required.

\item {} 
VST Blacklist: Clicking the Clear button makes blacklisted VST
plugins available to be added to the processor box.

\item {} 
Linux VST Path: Clicking the Edit button pops up a dialog to
manage the directories that will be searched for Linux VST
plugins. When modified, Ardour will offer to scan those paths for
plugins.

\item {} 
Path: are the paths chosen above.

\item {} 
Windows VST Path: Clicking the Edit button pops up a dialog to
manage the directories that will be searched for Windows VST
plugins. When modified, Ardour will offer to scan those paths for
plugins.

\item {} 
Path: are the paths chosen above.

\end{itemize}

\end{itemize}
\subsubsection*{Audio Unit}
\begin{itemize}
\item {} 
Audio Unit
\begin{itemize}
\item {} 
Scan for {[}new{]} AudioUnit Plugins on Application Start When
enabled, new AU plugins are searched, tested and added to the
cache index on application start. When disabled, new plugins will
only be available after triggering a ‘Scan’ manually.

\item {} 
AU Cache: Clicking the Clear button removes all AU plugins from
the list of plugins available to be inserted into the processor
box. A new AU plugins scan is then required.

\item {} 
AU Blacklist: Clicking the Clear button makes blacklisted AU
plugins available to be added to the processor box.

\end{itemize}

\end{itemize}
\subsubsection*{Appearance}
\begin{itemize}
\item {} 
Graphics Acceleration
\begin{itemize}
\item {} 
Possibly improve slow graphical performance (requires restart)
Ardour uses hardware accelerated gradient creation by default for
speed. Sometimes though, a buggy driver can cause this to make the
system slow or unstable. Checking this will make Ardour draw its
own gradients without hardware acceleration, improving stability
and responsiveness on those buggy systems.

\end{itemize}

\item {} 
Graphical User Interface
\begin{itemize}
\item {} 
Highlight widgets on mouseover, when checked, makes Ardour’s
widgets (buttons, sliders, …) slightly change color when the mouse
hovers them, visually indicating what a mouse action would
interact with.

\item {} 
Show tooltips if mouse hovers over a control when checked,
displays a little help bubble about the control the mouse hovers.
The mouse pointer needs to stay idle for about 1 sec for the
tooltip to appear.

\item {} 
Update clocks at TC Frame rate: Ardour updates its clocks every
100 ms. Checking this will make the clock refresh at every
TimeCode frame which is more responsive, at the cost of a bit more
system stress.

\item {} 
Blink Rec-Arm buttons: when enabled, the record-armed buttons on
tracks will blink when they are armed but not currently recording.
When disabled, the record-armed buttons on tracks will be outlined
in red instead of blinking. The global record-arm button in the
{\hyperref[\detokenize{index:transport-bar}]{\emph{Transport bar}}} is unaffected.

\item {} 
Blink Alert indicators: when enabled, the Alert indicators (like
the Error Log or the Feedback button) will blink when they are
active (when an error or feedback has been detected,
respectively). When disabled, the indicators will turn red instead
of blinking.

\item {} 
GUI and Font scaling: allows the display size of most of the text
and buttons in the user interface to be scaled up or down. May
require a restart to take effect.

\end{itemize}

\end{itemize}
\subsubsection*{Editor}
\begin{itemize}
\item {} 
General
\begin{itemize}
\item {} 
Use name highlight bars in region displays (requires a restart):
when enabled, the region name is displayed, in the editor, in its
own opaque bar at the bottom of the region. When disabled, the
region name is overlaid at the top of the region, possibly over
audio waveforms or MIDI notes.

\item {} 
Region color follows track color: when enabled, the background
color of regions in the editor will be displayed using the color
assigned to the track. When disabled the default region background
color will be used.

\end{itemize}

\item {} 
Waveforms
\begin{itemize}
\item {} 
Show waveforms in regions when enabled shows a visual
representation of the region’s audio waveform.

\item {} 
Show waveform while recording when enabled, will draw the audio
waveform in regions being recorded, in near real time. When
disabled, only a region block will be drawn while recording,
reducing CPU requirements.

\item {} 
Show waveform clipping: when enabled the waveform displayed will
show peaks marked in red if they exceed the clip level.

\item {} 
Waveform Clip Level (dBFS): sets the level at which the waveform
shown in an audio region will be drawn in red to indicate
clipping. Setting lower than 0.0 dBFS can be useful if any tool in
the audio chain has problems near 0.0 dBFS.

\item {} 
Waveform scale: when waveforms are shown in audio regions, they
can be displayed using a \sphinxstyleemphasis{linear} or a \sphinxstyleemphasis{logarithmic} scale. See
{\hyperref[\detokenize{index:waveform-display}]{\emph{Waveform display}}}.

\item {} 
Waveform shape: when waveforms are shown in audio regions, they
can be displayed using a \sphinxstyleemphasis{traditional} or a \sphinxstyleemphasis{rectified} shape. See
{\hyperref[\detokenize{index:waveform-display}]{\emph{Waveform display}}}.

\end{itemize}

\item {} 
Editor Meters
\begin{itemize}
\item {} 
Show meters in track headers, when enabled, shows a small meter in
the Editor’s {\hyperref[\detokenize{index:audio-track-controls}]{\emph{track headers}}}. The meter
is shown on the right side area of the header and provides an
instant, if unprecise, view of the levels on this track/bus.

\item {} 
Limit track header meters to stereo: if a track has more than two
outputs (e.g. with a drum plugin), limits the number of meters in
the track header to the first two ones. Only affects audio meters,
not MIDI.

\end{itemize}

\item {} 
MIDI Regions
\begin{itemize}
\item {} 
Display first MIDI bank/program as 0: when patches and bank
changes are displayed in the editor, if this option is checked,
the numbering will be zero-based instead of one-based, i.e.
banks/programs will be numbered O, 1 ,2… instead of 1, 2, 3…

\item {} 
Don’t display periodic (MTC, MMC) SysEx messages in MIDI Regions:
if checked, will hide these control messages from the MIDI regions
for better legibility.

\end{itemize}

\end{itemize}
\subsubsection*{Mixer}
\begin{itemize}
\item {} 
Mixer Strip
\begin{itemize}
\item {} 
This table enables (checked) or disables (unchecked) the display
of controls in the {\hyperref[\detokenize{index:audiomidi-mixer-strips}]{\emph{mixer strip}}}.
Controls whose display can be toggled are: \sphinxstylestrong{Input},
\sphinxstylestrong{Phase Invert}, \sphinxstylestrong{Record \& Monitor}, \sphinxstylestrong{Solo Iso/Lock},
\sphinxstylestrong{Output}, \sphinxstylestrong{Comments} and VCA Assigns.

\item {} 
Use narrow strips in the mixer for new strips by default When
enabled, new mixer strips are created in narrow format. When
disabled, they are created in wide format. Existing mixer strips
width can be toggled with the width control at the top left of the
mixer strip.

\end{itemize}

\end{itemize}
\subsubsection*{Toolbar}
\begin{itemize}
\item {} 
Main Transport Toolbar Items: this section allows to toggle the
visibility of some elements of the main toolbar:
\begin{itemize}
\item {} 
Display Record/Punch Options toggles the visibility of the {\hyperref[\detokenize{index:selection-and-punch-clocks}]{\emph{punch
and record}}} slice of the main
toolbar.

\item {} 
Display Monitor Options toggles the visibility of the {\hyperref[\detokenize{index:other-toolbar-items}]{\emph{monitor
options}}} slice of the main toolbar.

\item {} 
Display Selection Clock toggles the visibility of the {\hyperref[\detokenize{index:selection-and-punch-clocks}]{\emph{selection
clocks}}} slice of the main toolbar.

\item {} 
Display Secondary Clock toggles the visibility of the {\hyperref[\detokenize{index:transport-clocks}]{\emph{secondary
clocks}}} slice of the main toolbar.

\item {} 
Display Navigation Timeline toggles the visibility of the
{\hyperref[\detokenize{index:mini-timeline}]{\emph{navigation/mini timeline}}} slice of the main
toolbar.

\item {} 
Display Master Level Meter toggles the visibility of the
{\hyperref[\detokenize{index:other-toolbar-items}]{\emph{selection clocks}}} slice of the main
toolbar.

\end{itemize}

\item {} 
Lua Action Script Button Visibility enables or disables the
visibility of the four columns of {\hyperref[\detokenize{index:other-toolbar-items}]{\emph{Lua script
buttons}}}. Each columns contains two
user-assignable buttons.

\end{itemize}
\subsubsection*{Theme}
\begin{itemize}
\item {} 
Theme
\begin{itemize}
\item {} 
Draw “flat” buttons: when enabled, button controls in the user
interface will be drawn with a flat look. When disabled button
controls will have a slight 3D appearance.

\item {} 
LED meter style if checked, the bar meters in the editor and mixer
will be styled to look like if they were made of LEDs, with a
dotted bar. Unchecking this option makes the bars flat and
continuous.

\item {} 
Waveforms color gradient depth: determines how much gradient
effect is applied to the inner of audio waveforms displayed in the
editor. Values range from 0.0, no gradient effect, to 1.0, maximum
effect.

\item {} 
Timeline item gradient depth: Determines how much gradient effect
is applied to the backgrounds of regions displayed in the editor.
Values range from 0.0, no gradient effect, to 1.0, maximum effect.

\item {} 
Icon Set: Changes the mouse cursor icons used to indicate
different tool modes in the editor. An example would be the icons
used to indicate whether the cursor will select a region or change
the length of a region.

\end{itemize}

\end{itemize}
\subsubsection*{Colors}
\begin{itemize}
\item {} 
Colors
\begin{itemize}
\item {} 
Color Theme allows to switch between some presets bundled with
Ardour, changing both the palette and items colors, hence styling
Ardour all at once.

\item {} 
The table allows to change the color settings in Ardour by acting
on three parameters:
\begin{itemize}
\item {} 
Items that allow to choose any color from the palette (see
below) to color a UI element. Clicking on a color sample in the
\sphinxstylestrong{Color} column bring up the Palette, to choose from.

\item {} 
Palette that allows to create a set of colors that will be used
in the UI. Using a palette allows for better consistency,
instead of picking “free” colors for each UI element. Clicking
on a color patch brings up a full color selector, to assign
this color to this patch of the palette.

\item {} 
Transparency where possible, allows to select, with a slider,
the transparency of the UI element, with 0 (slider to the left)
being fully opaque.

\end{itemize}

\item {} 
Restore Defaults turns all the palette, item colors and
transparency back to Ardour’s default base setting, in case
Ardour’s appearance has turned into a toddler’s toy.

\end{itemize}

\end{itemize}
\subsubsection*{Quirks}
\begin{itemize}
\item {} 
Various Workarounds for Windowing Systems: As Ardour is available on
a number of platforms and windowing systems, some specific
workarounds are sometimes required to provide a smooth experience to
the user.
\begin{itemize}
\item {} 
Use visibility information provided by your Window Manager/Desktop
allows the system window manager’s rules for the windows
visibility to supercede Ardour’s.

\item {} 
All floating windows are dialogs: when enabled, Ardour will use
type “Dialog” for all floating windows instead of using type
“Utility” for some of them. This may help usability with some
window managers. This setting requires a restart of Ardour to take
effect.

\item {} 
Transient windows follow front window.: when enabled, transient
windows will follow the front window when toggling between the
editor and mixer. This setting requires a restart of Ardour to
take effect.

\item {} 
Float detached monitor-section window: as the {\hyperref[\detokenize{index:monitor-section}]{\emph{monitor
section}}} can be detached from the mixer, this
option makes it a floating window, which may be handled
differently by the windowing system and easier to access.

\end{itemize}

\end{itemize}
\subsubsection*{Video}
\begin{itemize}
\item {} 
Video Server
\begin{itemize}
\item {} 
Show Video Export Info before export Shows a warning message when
exporting a video about licensing and offers to open the {\hyperref[\detokenize{index:workflow-amp-operations}]{\emph{export
video}}} section of this manual.

\item {} 
Show Video Server Startup Dialog: when using video inside Ardour,
this video is accessed via Xjadeo from a source file through a
Video Server. This options shows the server’s startup dialog
(useful for debugging a malfunctioning video).

\item {} 
Advanced Setup (remote video server) can be used when the setup is
more complex than opening a local file with Ardour. The tools used
behind the scene by Ardour allow a lot of flexibility, so for a
competent user, the options below are provided to access a distant
file (i.e. on another machine). The default options for the two
following fields (“\sphinxurl{http://localhost:1554}” and “/”) are suitable
for local files.

\item {} 
Video Server URL: Base URL of the video server delivering the
video through the network (\sphinxcode{\sphinxupquote{http://IP-or-address:port}}).

\item {} 
Video folder is the server’s local path to the document-root, i.e.
the files that can be delivered by the server.

\end{itemize}

\item {} 
Video Monitor
\begin{itemize}
\item {} 
Custom Path to Video Monitor (xjadeo) - leave empty for default:
Ardour bundles offer xjadeo bundled, so it should run flawlessly.
Though, for custom builds or if a newer version of xjadeo is
available, one can specify a path to the wanted version of xjadeo.

\end{itemize}

\end{itemize}
\subsubsection*{9 - Session Properties}

Session properties control aspects of the workflow or configuration that
pertain to the current session only; these settings are initially set
from the template used to create the session. They can be found in
Session \textgreater{} Properties, and are stored in the session file.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{a4_session_properties_timecode}.png}
\caption{The Session Properties dialog.}\label{\detokenize{index:id476}}\end{figure}
\subsubsection*{9.1 - Timecode Tab}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{a4_session_properties_timecode}.png}
\caption{Session properties timecode tab}\label{\detokenize{index:id477}}\end{figure}

This tab is used to change how Ardour interprets and manipulates
timecode.
\begin{itemize}
\item {} 
Timecode Settings lets you set the number of frames per second and
pull up/down to match the timecode used other synchronized systems.

\item {} 
External Timecode Offsets allows Ardour to a fixed offset from other
synchronized systems. Slave Timecode offset adds the specified offset
to the received timecode (MTC or LTC). Timecode Generator offset adds
the specified offset to the timecode generated by Ardour (so far only
LTC).

\item {} 
Jack Transport / Time Settings determines whether Ardour controls
Bar\textbar{}Beat\textbar{}Tick and other information for Jack.

\end{itemize}
\subsubsection*{9.2 - Sync Tab}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{a4_session_properties_sync}.png}
\caption{Session properties sync tab}\label{\detokenize{index:id478}}\end{figure}

This tab is used to modify the timecode settings when working with video
to use the imported video’s timecode settings instead of the session
defaults.
\subsubsection*{9.3 - Fades Tab}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{a4_session_properties_fades}.png}
\caption{Session properties fades tab}\label{\detokenize{index:id479}}\end{figure}

Change how Ardour works with region crossfades.
\begin{itemize}
\item {} 
Destructive crossfade length is used when an operation on a region is
destructive, such as when recording in a track is in tape mode.

\item {} 
When Region fades \sphinxstylestrong{active} is checked, the region fades set up in
the mixer are used during playback. When unchecked, the fades are
ignored.

\item {} 
When \sphinxstylestrong{Region fades visible} is checked the region fades are visible
in the the \sphinxstylestrong{Editor}.

\end{itemize}
\subsubsection*{9.4 - Media Tab}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{a4_session_properties_media}.png}
\caption{Session properties media tab}\label{\detokenize{index:id480}}\end{figure}

Change how sound is stored on disk. These options do not change how
sound is handled internally.
\begin{itemize}
\item {} 
Sample format defaults to 32-bit floating point, the same as the
internal representation. 24 and 16-bit integer representation are
also available.

\item {} 
\sphinxstylestrong{File type} options are WAVE, WAVE-64, and CAF.

\end{itemize}
\subsubsection*{9.5 - Locations Tab}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{a4_session_properties_locations}.png}
\caption{Session properties locations tab}\label{\detokenize{index:id481}}\end{figure}

These options add file locations that will be searched to find the audio
and midi files used by the session. This is useful when the files have
been imported into the session but not copied into the session.

To add a location, navigate to the directory where the files are stored.
Drill down into the directory and then click open. The directory will
show up in the dialog. The remove button next to the added directory can
be used to remove it from the search path.
\subsubsection*{9.6 - Filenames Tab}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{a4_session_properties_filenames}.png}
\caption{Session properties filenames tab}\label{\detokenize{index:id482}}\end{figure}

This tab is used to change how Ardour names recorded regions. If Prefix
track number is selected a unique number will appear on each track in
the Editor window and will prefix the region name. If the track number
is 2 and the region would have been Gtr-1.1 with track number prefix
turned on the region will be named 2\_Gtr-1.1 instead. See XX for base of
the region name.

If Prefix take name is selected and the Take name has Take1 the region
will have the name Take1\_Gtr-1.1 instead. If both boxes are checked the
name will be Take1\_2\_Gtr-1.1 instead.

When Prefix take name is enabled, the first time a track is recorded it
will have the specified take name. When recording is stopped, any
trailing number on the end of the take name will incremented by 1. If
the track name specified doesn’t have a number on the end, the number 1
will be suffixed.
\subsubsection*{9.7 - Monitoring Tab}

Provides options affecting monitoring.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{a4_session_properties_monitoring}.png}
\caption{The session properties ‘monitoring’ tab}\label{\detokenize{index:id483}}\end{figure}

The \sphinxstylestrong{Track Input Monitoring automatically follows transport state}
affects how input monitoring is handling. See {\hyperref[\detokenize{index:monitor-setup-in-ardour}]{\emph{Monitor Setup in
Ardour}}}.

The ‘Use monitor section’ displays an extra section in the \sphinxstylestrong{Mixer}
window that is modelled on the similarly named section on large analog
consoles. More information can be found on the {\hyperref[\detokenize{index:monitor-section}]{\emph{Monitor
Section}}} page.
\subsubsection*{9.8 - Meterbridge Tab}

The meters from audio tracks always display in the Meterbridge. This tab
changes what additional controls are also displayed.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{a4_session_properties_meterbridge}.png}
\caption{Session properties meterbridge tab}\label{\detokenize{index:id484}}\end{figure}
\begin{itemize}
\item {} 
Route Display has options for showing midi tracks, busses, and the
master bus.

\item {} 
Button Area has options for adding record enable, mute, solo, and
input monitor buttons.

\item {} 
Name Labels adds the track name and, if numbers are enabled on the
filenames tab, the number.

\end{itemize}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{a4_meterbridge_full}.png}
\caption{Meterbidge with all options on}\label{\detokenize{index:id485}}\end{figure}
\subsubsection*{9.9 - Session Misc Tab}

This tab has several things that don’t fit on the other tabs.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{a4_session_properties_misc}.png}
\caption{Session properties misc tab}\label{\detokenize{index:id486}}\end{figure}
\begin{itemize}
\item {} 
MIDI Options
\begin{itemize}
\item {} 
If MIDI region copies are independent is selected, when a MIDI
region is copied or duplicated, the new region is not linked to
the region it was copied from. If it is not selected, the copied
regions are linked and any editing of one of the linked regions
changes all of the linked regions.

\item {} 
The Editor can be configured to handle overlapping MIDI notes
several ways.
\begin{itemize}
\item {} 
never allow them

\item {} 
don’t do anything in particular

\item {} 
replace any overlapped existing notes

\item {} 
shorten the overlapped existing note

\item {} 
shorten the overlapped new note

\item {} 
replace both overlapping notes with a single note

\end{itemize}

\end{itemize}

\item {} 
Glue to bars and beats
\begin{itemize}
\item {} 
New markers can be glued to bars and beats

\item {} 
New regions can be glued to bars and beats

\end{itemize}

\item {} 
Settings from the session properties dialogs can be saved to the
default session template.

\end{itemize}
\subsubsection*{10 - Configuring MIDI}

MIDI is a way to describe musical performances and to control music
hardware and software.

Ardour can import and record MIDI data, and perform a variety of editing
operations on it. Furthermore, MIDI can be used to control various
functions of Ardour.
\subsubsection*{MIDI Handling Frameworks}

MIDI input and output for Ardour are handled by the same “engine” that
handles audio input and output.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

OS X
&
CoreMIDI is the standard MIDI
framework on OSX systems.
\\
\hline
Linux
&
ALSA MIDI is the standard MIDI
framework on Linux systems.
\\
\hline
Windows
&
There is no single standard MIDI
framework on Windows, but Ardour
can work with ASIO and others.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

On Linux systems, QJackCtl control software displays ALSA MIDI ports
under its “ALSA” tab (it does not currently display CoreMIDI ports). By
contrast, JACK MIDI ports show up under the MIDI tab in QJackCtl.
\subsubsection*{JACK MIDI Configuration}

By default, JACK will \sphinxstylestrong{not} automatically detect and use existing MIDI
ports. One of several ways of bridging between the native MIDI
frameworks (e.g. CoreMIDI or ALSA) and JACK MIDI must be chosen, as
described in the following sections.
\subsubsection*{10.1 - MIDI on Linux}

The right approach for using MIDI on Linux depends on which version of
JACK is in use. The world divides into:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

Systems using JACK 1, versions
0.124 or later
&
On these systems, JACK must be
started with the \sphinxcode{\sphinxupquote{-X alsa\_midi}}
server argument. To support
legacy control applications, the
\sphinxcode{\sphinxupquote{-X   seq}} argument to the ALSA
backend of JACK can also be used
to get the exact same results.
\\
\hline
All others
&
Using a2jmidid acts as a bridge
between ALSA MIDI and JACK. The
\sphinxcode{\sphinxupquote{-X seq}} or \sphinxcode{\sphinxupquote{-X raw}}
arguments should \sphinxstyleemphasis{not} be
used—the timing and performance
of these options is unacceptable.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\subsubsection*{Using a2jmidid}

a2jmidid is an application that bridges between the system MIDI ports
and JACK.

First it must be ensured that there is no ALSA sequencer support enabled
in JACK. To check that, one must open QJackCtl’s Setup window and set
Settings \textgreater{} MIDI Driver to none, then uncheck the Misc \textgreater{} Enable ALSA
Sequencer support option. The jack server must then be restarted before
going on.
\subsubsection*{Checking for a2jmidid availability}

Next, it must be checked whether a2jmidid is already installed. This is
done by starting the JACK server, then going to the command line and
typing:

a2jmidid -e
If a2jmidid does not exist, it must be installed with the software
manager of the Linux distribution in use until this command responds.
\subsubsection*{Checking available MIDI ports}

If JACK is correctly configured for MIDI, then the MIDI ports should
appear in qjackctl under Connections \textgreater{} MIDI.
\subsubsection*{Making it automatic}

Once it has been verified that the ports appear in JACK as expected,
this can be made to happen whenever JACK is started:
\begin{itemize}
\item {} 
If a newer version of JACK 1 is in use, by just making sure the
\sphinxcode{\sphinxupquote{-X   alsa\_midi}} or \sphinxcode{\sphinxupquote{-X seq}} options are enabled for whatever
technique is being used to start JACK.

\item {} 
For other versions of JACK, by adding \sphinxcode{\sphinxupquote{a2jmidid -e \&}} as an “after
start-up” script in the Setup \textgreater{} Options tab of QJackCtl, so that it
is started automatically whenever JACK is started.

\end{itemize}
\subsubsection*{10.2 - MIDI on OS X}

In order for CoreMIDI to work with Jack MIDI, a CoreMIDI-to-JACK-MIDI
bridge is required. This feature is available on versions equal to or
greater than version 0.89 of JackOSX.
\subsubsection*{Routing MIDI}
\subsubsection*{Inside Ardour}

MIDI ports show up in Ardour’s MIDI connection matrix in multiple
locations. Bridged CoreMIDI ports as well as JACK MIDI ports that have
been created by other software clients will show up under the “Other”
tab. Bridged CoreMIDI hardware ports show up under the “Hardware” tab.
\subsubsection*{External Applications}

There are multiple options for connecting MIDI ports outside of Ardour.
\begin{itemize}
\item {} 
\sphinxhref{http://www.snoize.com/MIDIMonitor/}{MIDI Monitor} is a handy tool
for doing various MIDI-related tasks.

\item {} 
\sphinxhref{http://notahat.com/midi\_patchbay/}{MIDI Patchbay} allows
connection of ports and filters MIDI data.

\end{itemize}
\subsubsection*{Part III - Ardour’s Interface}
\subsubsection*{11 - Ardour’s Interface Overview}

In Ardour, work is done in two main windows: the Editor and the Mixer.



{}` \textless{}\#main-menu\textgreater{}{}`\_\_





{}` \textless{}\#status-bar\textgreater{}{}`\_\_





{}` \textless{}\#transport-bar\textgreater{}{}`\_\_





{}` \textless{}\#selection-and-punch-clocks\textgreater{}{}`\_\_





{}` \textless{}\#other-toolbar-items\textgreater{}{}`\_\_





{}` \textless{}\#other-toolbar-items\textgreater{}{}`\_\_





{}` \textless{}\#transport-clocks\textgreater{}{}`\_\_





{}` \textless{}\#other-toolbar-items\textgreater{}{}`\_\_





{}` \textless{}\#selection-and-punch-clocks\textgreater{}{}`\_\_





{}` \textless{}\#mini-timeline\textgreater{}{}`\_\_





{}` \textless{}\#other-toolbar-items\textgreater{}{}`\_\_





{}` \textless{}\#audiomidi-mixer-strips\textgreater{}{}`\_\_





{}` \textless{}\#toolbox\textgreater{}{}`\_\_





{}` \textless{}\#zoom-controls\textgreater{}{}`\_\_





{}` \textless{}\#grid-controls\textgreater{}{}`\_\_





{}` \textless{}\#edit-point-control\textgreater{}{}`\_\_





{}` \textless{}\#nudge-controls\textgreater{}{}`\_\_





{}` \textless{}\#selection-and-punch-clocks\textgreater{}{}`\_\_





{}` \textless{}\#editor-lists\textgreater{}{}`\_\_





{}` \textless{}\#ruler\textgreater{}{}`\_\_





{}` \textless{}\#summary\textgreater{}{}`\_\_





{}` \textless{}\#track-and-bus-groups\textgreater{}{}`\_\_





{}` \textless{}\#bus-controls\textgreater{}{}`\_\_





{}` \textless{}\#audio-track-controls\textgreater{}{}`\_\_





{}` \textless{}\#automation\textgreater{}{}`\_\_





{}` \textless{}\#audio-track-controls\textgreater{}{}`\_\_





{}` \textless{}\#midi-track-controls\textgreater{}{}`\_\_





{}` \textless{}\#midi-track-controls\textgreater{}{}`\_\_









{}` \textless{}\#main-menu\textgreater{}{}`\_\_





{}` \textless{}\#status-bar\textgreater{}{}`\_\_





{}` \textless{}\#transport-bar\textgreater{}{}`\_\_





{}` \textless{}\#selection-and-punch-clocks\textgreater{}{}`\_\_





{}` \textless{}\#other-toolbar-items\textgreater{}{}`\_\_





{}` \textless{}\#other-toolbar-items\textgreater{}{}`\_\_





{}` \textless{}\#transport-clocks\textgreater{}{}`\_\_





{}` \textless{}\#other-toolbar-items\textgreater{}{}`\_\_





{}` \textless{}\#selection-and-punch-clocks\textgreater{}{}`\_\_





{}` \textless{}\#mini-timeline\textgreater{}{}`\_\_





{}` \textless{}\#other-toolbar-items\textgreater{}{}`\_\_





{}` \textless{}\#favorite-plugins-window\textgreater{}{}`\_\_





{}` \textless{}\#strips-list\textgreater{}{}`\_\_





{}` \textless{}\#groups-list\textgreater{}{}`\_\_





{}` \textless{}\#track-and-bus-groups\textgreater{}{}`\_\_





{}` \textless{}\#master-bus-strip\textgreater{}{}`\_\_





{}` \textless{}\#monitor-section\textgreater{}{}`\_\_





{}` \textless{}\#control-masters-mixer-strips\textgreater{}{}`\_\_





{}` \textless{}\#audiomidi-busses-mixer-strips\textgreater{}{}`\_\_





{}` \textless{}\#audiomidi-mixer-strips\textgreater{}{}`\_\_





{}` \textless{}\#audiomidi-mixer-strips\textgreater{}{}`\_\_







The Editor and Mixer windows. Click on a section to access its
description.
The Editor and the Mixer share the same toolbar (the top of the window).
The sections displayed in this toolbar can be customized to the user’s
workflow, by checking options in Preferences \textgreater{} Appearance \textgreater{} Toolbar.

Switching between the Editor and the Mixer windows is done:
\begin{itemize}
\item {} 
with the {\hyperref[\detokenize{index:other-toolbar-items}]{\emph{Mode Selector buttons}}} in the
upper right

\item {} 
with the M shortcut

\item {} 
with the menu Window \textgreater{} Editor \sphinxstyleemphasis{(or Mixer)} \textgreater{} Show.

\end{itemize}

Both windows can be visible at the same time (e.g. for a multi-monitor
setup) using Window \textgreater{} Editor \sphinxstyleemphasis{(or Mixer)} \textgreater{} Detach option in the same
submenu.
\subsubsection*{The Editor}

The Editor window includes the editor track canvas where audio and MIDI
data can be arranged along a timeline. This is the window where editing
and arranging a project is done. The window has a general “horizontal”
sense to it: the timeline flows from left to right, the playhead showing
the current position in the session moves from left to right—the window
really represents time in a fairly literal way.

It is possible to show a single channel strip in the editor window, and
some people find this enough to work on mixing without actually opening
the mixer window. Most of the time though, both of these windows will be
needed at various stages of a session’s lifetime.
\subsubsection*{The Mixer}

The Mixer window represents signal flow and is the window that will
probably be used most when mixing a session. It includes channel strips
for each track and bus in the session. It has a general “vertical” sense
to it: signals flow from the top of each channel strip through the
processing elements in the strip to reach the output listed at the
bottom.

To learn more about the process of mixing, see
{\hyperref[\detokenize{index:basic-mixing}]{\emph{Mixing}}}.
\subsubsection*{12 - Main Menu}

The Main Menu is made of 8 menus that allow the user to interact with
Ardour, and below is a reference of all the menu actions.

Notice that a lot of this menus, and probably all of the most used ones
have keyboard shortcuts to ease and fasten the work. A sum-up of these
shortcuts can be found on the {\hyperref[\detokenize{index:default-keyboard-bindings}]{\emph{Defaults Keyboard
Bindings}}} page, and every menu in Ardour
can be reassigned to an user defined key binding, or used via
{\hyperref[\detokenize{index:controlling-ardour-with-osc}]{\emph{OSC}}} with a control surface.
\subsubsection*{12.1 - The Session Menu}

The Session menu groups together everything related to the session and
the file operations.


\begin{savenotes}\sphinxatlongtablestart\begin{longtable}{|l|l|}
\hline

\endfirsthead

\multicolumn{2}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} -- continued from previous page}}}\\
\hline

\endhead

\hline
\multicolumn{2}{r}{\makebox[0pt][r]{\sphinxtablecontinued{Continued on next page}}}\\
\endfoot

\endlastfoot

New…
&
Creates a
{\hyperref[\detokenize{index:newopen-session-dialog}]{\emph{new}}}
session
\\
\hline
Open…
&
Opens an existing session
\\
\hline
Recent…
&
Opens a list of recent sessions
that can be opened
\\
\hline
Close
&
Closes the current session (but
not Ardour)
\\
\hline
Save
&
Saves the current session
\\
\hline
Save As…
&
Saves to a new session (with
options)
\\
\hline
Rename…
&
Changes the name of the session
\\
\hline
Snapshot (\& keep working on
current version)…
&
Create a
{\hyperref[\detokenize{index:snapshots}]{\emph{Snapshot}}} but any
subsequent change will be saved
to this session
\\
\hline
Snapshot (\& switch to new
version)…
&
Same thing, and any subsequent
change will be saved to this new
snapshot session
\\
\hline
Save Template…
&
Saves the session as a
{\hyperref[\detokenize{index:session-templates}]{\emph{template}}}
,
without the audio
\\
\hline
Archive…
&
Exports the session as a
{\hyperref[\detokenize{index:backup-and-sharing-of-sessions}]{\emph{compressed
file}}}
for archiving or sharing
purposes, optionally compressing
the audio to FLAC
\\
\hline
Metadata
&\\
\hline
Edit Metadata…
&
Opens the
{\hyperref[\detokenize{index:metadata}]{\emph{Metadata}}} window,
where information about the
session can be saved
\\
\hline
Import Metadata…
&
Creates the metadata by
extracting them from another
session
\\
\hline
Add Track, Bus or VCA…
&
Adds a {\hyperref[\detokenize{index:adding-tracks-busses-and-vcas}]{\emph{new
track/bus/VCA}}}
to the session, same as the Track
\textgreater{} Add Track, Bus or VCA…
\\
\hline
Import
&
Opens the
{\hyperref[\detokenize{index:adding-pre-existing-material}]{\emph{Import}}}
windows, to add media to the
session
\\
\hline
Import PT session
&
Import a ProTools© session file.
Not everything in the original
session can be imported.
\\
\hline
Scripting
&\\
\hline
Add Lua Script…
&
Loads or adds a {\hyperref[\detokenize{index:lua-scripting}]{\emph{Lua Session
script}}} to the
current session
\\
\hline
Remove Lua Script
&
Removes a loaded Lua Session
script from the session
\\
\hline
Open Video…
&
Imports a {\hyperref[\detokenize{index:video-timeline-and-monitoring}]{\emph{video
file}}}
in the session
\\
\hline
Remove Video
&
Removes the video part of the
session (the video timeline
disappears)
\\
\hline
Export
&\\
\hline
Export to Audio File(s)…
&
{\hyperref[\detokenize{index:mixdown}]{\emph{Export}}} all or part
of the session in audio form
\\
\hline
Stem export…
&
{\hyperref[\detokenize{index:export-dialog}]{\emph{Exports each
track}}} as its
own audio file (for e.g. DAW
interchange)
\\
\hline
Export to Video File
&
Exports the session to a {\hyperref[\detokenize{index:workflow-amp-operations}]{\emph{video
file}}}
\_
\\
\hline
Clean-Up
&\\
\hline
Bring all media into session
folder
&
Copies all the media files
imported from outside the session
folder in that folder, see
\sphinxtitleref{Cleaning up
Sessions \textless{}\#cleaning-up-sessions\textgreater{}}
\_\_
\\
\hline
Reset Peak Files
&
Reinitializes the buffered images
representing the audio files
\\
\hline
Clean-up Unused Sources…
&
Quarantines all the media files
not used in the session to a
specific sub-folder of the
session
\\
\hline
Flush Wastebasket
&
Deletes those quarantined files
\\
\hline
{[}{]} Properties
&
Shows the {\hyperref[\detokenize{index:session-properties-dialog}]{\emph{Session
Properties}}}
dialog, allowing to fine-tune the
parameters of the current session
\\
\hline
Lock
&
Locks the session by showing an
Unlock window that (until
clicked) blocks every action on
Ardour’s window
\\
\hline
Quit
&
Exits Ardour. Prompts for saving
the session if it has been
modified.
\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}
\subsubsection*{12.2 - The Transport Menu}

The Transport menu handles how Ardour handles the playback and playhead.


\begin{savenotes}\sphinxatlongtablestart\begin{longtable}{|l|l|}
\hline

\endfirsthead

\multicolumn{2}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} -- continued from previous page}}}\\
\hline

\endhead

\hline
\multicolumn{2}{r}{\makebox[0pt][r]{\sphinxtablecontinued{Continued on next page}}}\\
\endfoot

\endlastfoot

Start/Stop
&
Starts or stops the playhead, and
recording if it is armed
\\
\hline
Play
&\\
\hline
Play Selection
&
Only plays the selected part of
the session, be it a range or
selected regions
\\
\hline
Play Selection w/Preroll
&
As the previous menu, except it
starts the playback a few bars or
seconds before the beginning of
the selection (the amount of time
can be set in the
{\hyperref[\detokenize{index:preferences}]{\emph{Preferences}}})
\\
\hline
Start/Continue/Stop
&
Leaves loop play or range play
mode but without stopping the
transport
\\
\hline
Play from Edit Point and Return
&
Starts the playback at the {\hyperref[\detokenize{index:edit-point-control}]{\emph{Edit
point}}},
and when stopped, goes back to
the original location
\\
\hline
Play Loop Range
&
If a {\hyperref[\detokenize{index:the-loop-range}]{\emph{Loop
range}}} is
defined, play it and loop until
stopped
\\
\hline
Start Recording
&
This is a shortcut to trigger the
global recording, and start
playback at once
\\
\hline
Stop and Forget Capture
&
Stops the recording, removes the
newly created material, and goes
back to the original position
\\
\hline
Enable Record
&
Triggers the global recording.
Next time “Play” is pressed, it
will record on the track(s) that
are armed for recording
\\
\hline
Record w/Preroll
&
As the Start Recording menu,
except it starts the recording a
few bars or seconds before the
playhead’s position (the amount
of time can be set in the
{\hyperref[\detokenize{index:preferences}]{\emph{Preferences}}})
\\
\hline
Record w/Count-In
&
As the Start Recording menu,
except it waits for 2 bars before
the playhead’s position. The
Metronome will tick (even if
disabled) during the count-in
\\
\hline
Set Loop from Selection
&
Converts the selection into a
{\hyperref[\detokenize{index:the-loop-range}]{\emph{Loop range}}}
by placing loop markers at the
start and end of the selected
range
\\
\hline
Set Punch from Selection
&
Same thing, for
{\hyperref[\detokenize{index:punch-range}]{\emph{Punch}}}
\\
\hline
Set Session Start/End from
Selection
&
Same thing, for the start and end
markers of the session, defining
the session’s length
\\
\hline
Forward
&
Plays the audio forwards from the
playhead on. If the audio is
already playing forwards,
increment its speed by 50\%.
\\
\hline
Rewind
&
Plays the audio backwards from
the playhead on. If the audio is
already playing backwards,
increment its speed by 50\%.
\\
\hline
Transition to Roll
&
Plays the audio forwards, with a
speed of 1 (real time)
\\
\hline
Transition to Reverse
&
Plays the audio backwards, with a
speed of 1 (real time)
\\
\hline
Playhead
&\\
\hline
Playhead to Mouse
&
Set the position of the playhead
at the current position of the
mouse cursor
\\
\hline
Playhead to Active Mark
&
If a marker is selected, set the
position of the playhead at the
position of the marker
\\
\hline
Center Playhead
&
Centers the view on the playhead
without changing the zoom level
(putting the playhead in the
middle of the screen)
\\
\hline
Nudge Playhead Forward
&
Shifts the position of the
playhead to the right by the
amount shown in the {\hyperref[\detokenize{index:nudge-controls}]{\emph{nudge
timer}}}
\\
\hline
Nudge Playhead Backward
&
Same thing, to the left
\\
\hline
Move to Next Transient
&
When transient have been set,
moves the playhead to the next
one to the right
\\
\hline
Move to Previous Transient
&
Same, to the left
\\
\hline
Playhead to Next Grid
&
Regardless of the state of the
Grid Mode, goes to the next grid
to the right, as set by the
{\hyperref[\detokenize{index:grid-controls}]{\emph{Snap/Grid
unit}}}
\\
\hline
Playhead to Previous Grid
&
Same, to the left
\\
\hline
Playhead to Next Region Boundary
&
Moves the playhead to the right
to the next beginning or end of
region on the selected track or,
if no track is selected, on all
tracks
\\
\hline
Playhead to Previous Region
Boundary
&
Same, to the left
\\
\hline
Playhead to Next Region Boundary
(No Track Selection)
&
Moves the playhead to next
beginning or end of region, be it
on the selected track or any
other
\\
\hline
Playhead to Previous Region
Boundary (No Track Selection)
&
Same, to the left
\\
\hline
Playhead to Next Region Sync
&
Moves the playhead to next Region
Sync Point, that is by default
the beginning of a region but
{\hyperref[\detokenize{index:grid-controls}]{\emph{can be moved}}}
\\
\hline
Playhead to Previous Region Sync
&
Same, to the left
\\
\hline
Jump to Next Mark
&
moves the playhead to the next
{\hyperref[\detokenize{index:creating-location-markers}]{\emph{marker}}}
on the Ruler
\\
\hline
Jump to Previous Mark
&
Same, to the left
\\
\hline
Go to Zero
&
Sends the playhead to the
00:00:00:00 time, regardless of
the sessions Start marker
\\
\hline
Go to Start
&
Sends the playhead to the Start
marker of the session
\\
\hline
Go to End
&
Sends the playhead to the End
marker of the session
\\
\hline
Go to Wall Clock
&
Sends the playhead to the current
value of system time, as shown on
the top right of the {\hyperref[\detokenize{index:status-bar}]{\emph{Status
bar}}}
\\
\hline
Active Mark
&\\
\hline
To Next Region Boundary
&
Moves the currently selected
{\hyperref[\detokenize{index:working-with-markers}]{\emph{marker}}}
\_
to the next region beginning or
end
\\
\hline
To Previous Region Boundary
&
Same, to the left
\\
\hline
To Next Region Sync
&
Moves the currently selected to
the next region sync point (by
default: beginning or end of the
region)
\\
\hline
To Previous Region Sync
&
Same, to the left
\\
\hline
Markers
&\\
\hline
Add Mark from Playhead
&
Creates a Marker at the position
of the playhead
\\
\hline
Remove Mark at Playhead
&
Removes any marker at the
position of the playhead
\\
\hline
Toggle Mark at Playhead
&
Combine the 2 previous: if a
marker exists, deletes it,
otherwise create it
\\
\hline
Locate to Mark \sphinxstyleemphasis{n}
&
If it exists, goes to the \sphinxstyleemphasis{n-th}
marker
\\
\hline
Set Session Start from Playhead
&
Puts the Start of the session
marker at the playhead’s position
\\
\hline
Set Session End from Playhead
&
Puts the End of the session
marker at the playhead’s position
\\
\hline
{[}{]} Time Master
&
Sets Ardour as the Time master,
i.e. Ardour sends the time
information to the audio system
\\
\hline
{[}{]} Punch In/Out
&
Based on the Punch in and Punch
out markers if they exist, tells
Ardour to record only between
those two points
\\
\hline
{[}{]} Punch In
&
Based on the Punch in marker,
only allow to record from this
point on
\\
\hline
{[}{]} Punch Out
&
Based on the Punch out marker,
forbids recording before this
point
\\
\hline
{[}{]} Audio Input
&
If checked, automatically switch
the
{\hyperref[\detokenize{index:monitor-setup-in-ardour}]{\emph{monitor}}}
from \sphinxstyleemphasis{input} to \sphinxstyleemphasis{playback}mode
when playing
\\
\hline
{[}{]} Follow Edits
&
If checked, selecting a region
moves the playhead to its
beginning
\\
\hline
{[}{]} Auto Play
&
If checked, moving the playhead
in the ruler starts the playback
\\
\hline
{[}{]} Auto Return
&
If checked, when the playback is
stopped, go back to the previous
position of the playhead. If not,
the playhead stays where it is
when the playback is stopped
\\
\hline
{[}{]} Click
&
Activates/deactivates the click
track (metronome)
\\
\hline
{[}{]} Follow Playhead
&
If checked, while playing, when
the playhead reaches the right of
the screen, Ardour scrolls one
screen to the right to keep the
playhead visible at all times
\\
\hline
{[}{]} Stationary Playhead
&
If checked \sphinxstyleemphasis{and} if Follow
playhead is checked, on playback,
the playhead stays at the center
of the screen, and the session
scrolls
\\
\hline
Panic
&
Immediately stops all MIDI
playback (useful e.g. when a MIDI
bug in encountered)
\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}
\subsubsection*{12.3 - The Edit Menu}

The Edit menu groups together the actions related to the edition, and so
will be mostly used while in Editor mode.


\begin{savenotes}\sphinxatlongtablestart\begin{longtable}{|l|l|}
\hline

\endfirsthead

\multicolumn{2}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} -- continued from previous page}}}\\
\hline

\endhead

\hline
\multicolumn{2}{r}{\makebox[0pt][r]{\sphinxtablecontinued{Continued on next page}}}\\
\endfoot

\endlastfoot

Undo (\sphinxstyleemphasis{action})
&
Reverts the last editing
operation, namely \sphinxstyleemphasis{action}
\\
\hline
Redo
&
Does the last editing operation
again, after an Undo
\\
\hline
Undo Selection Change
&
Reverts the last selection
operation
\\
\hline
Redo Selection Change
&
Does the last selection operation
again after an Undo Selection
Change
\\
\hline
Cut
&
Deletes the current selection,
but puts it in memory ready to be
pasted
\\
\hline
Copy
&
Copies the current selection to
memory
\\
\hline
Paste
&
Pastes the memory at the {\hyperref[\detokenize{index:edit-point-control}]{\emph{edit
point}}},
after a Cut or Copy operation
\\
\hline
Select
&\\
\hline
Select All Objects
&
Selects all the regions and
automation points in the session
\\
\hline
Select All Tracks
&
Selects all the tracks, busses
and control masters in the
session
\\
\hline
Deselect All
&
Deselects all objects or tracks,
nothing is selected
\\
\hline
Invert Selection
&
Select the previously unselected
regions, and deselect the
previously selected ones
\\
\hline
Set Range to Loop Range
&
Creates a range selection on the
selected tracks, based on the
selected loop markers, and
switches to {\hyperref[\detokenize{index:toolbox}]{\emph{Range Mode
tool}}}
\\
\hline
Set Range to Punch Range
&
Same as above, based on the
selected punch markers
\\
\hline
Set Range to Selected Regions
&
Same as above, based on the
selected regions (i.e. from the
start of the earliest region to
the end of the latest one)
\\
\hline
Select All After Edit Point
&
Select all the regions and
automation points that exist
after the Edit Point, even if the
region starts before it. If some
tracks are selected, only selects
on these tracks.
\\
\hline
Select All Before Edit Point
&
Same as above, but before the
Edit point (i.e. to the left of
it)
\\
\hline
Select All Overlapping Edit Range
&
Select all the regions and
automation points of which at
least a part is in the current
selection range
\\
\hline
Select All Inside Edit Range
&
Selects all the regions that are
completely inside the selection
range, i.e. their start and end
are inside the range. If some
tracks are selected, only selects
on these tracks.
\\
\hline
Select All in Punch Range
&
Selects all the regions of which
a part in in the punch range. If
some tracks are selected, only
selects on these tracks.
\\
\hline
Select All in Loop Range
&
Same as above, based on the loop
range
\\
\hline
Move Range Start to Previous
Region Boundary
&
Extends the left boundary of the
range to the left to the next
region start or end. The region
must be in the range.
\\
\hline
Move Range Start to Next Region
Boundary
&
Same as above, to the right
(reduces the selection)
\\
\hline
Move Range End to Previous Region
Boundary
&
Same as above, with the right
edge of the range, to the left
(reduces the selection)
\\
\hline
Move Range End to Next Region
Boundary
&
Same as above, with the right
edge, to the right (extends the
selection)
\\
\hline
Start Range
&
Sets the left edge of the range
to the Edit point
\\
\hline
Finish Range
&
Sets the right edge of the range
to the Edit point
\\
\hline
Select Next Track or Bus
&
Select the track or bus under the
currently selected one. If
multiple tracks are selected,
only the first one is considered
\\
\hline
Select Previous Track or Bus
&
Same as above, with the track/bus
above the first one selected.
\\
\hline
Delete
&
Deletes all that is currently
selected
\\
\hline
Crop
&
Cuts the parts of the regions
that are outside the range
boundaries. Only applies on the
regions that belong at least in
part to the range.
\\
\hline
Split/Separate
&
Cuts the selected regions at the
Edit point, separating them in
two regions
\\
\hline
Separate
&\\
\hline
Separate Under
&
Removes all the parts of the
regions that are under the
selected one. Once done, the
selected region is alone on its
part of the track.
\\
\hline
Separate Using Loop Range
&
Cuts the selected regions or the
regions on the selected tracks
along the Loop range’s start and
end markers. If nothing is
selected, acts on all tracks at
once.
\\
\hline
Separate Using Punch Range
&
Same as above, with the Punch
range markers
\\
\hline
Align
&\\
\hline
Align Start
&
Moves the selected regions to
align the beginning of the
regions to the Edit point
\\
\hline
Align Start Relative
&
When multiple regions are
selected, moves all the regions
together as a block to align the
beginning of the earliest one to
the Edit point.
\\
\hline
Align End
&
Moves the selected regions to
align the end of the regions to
the Edit point
\\
\hline
Align End Relative
&
When multiple regions are
selected, moves all the regions
together as a block to align the
end of the latest one to the Edit
point.
\\
\hline
Align Sync
&
Moves the selected regions to
align the Sync point of the
regions to the Edit point
\\
\hline
Align Sync Relative
&
When multiple regions are
selected, moves all the regions
together as a block to align the
earliest Sync point to the Edit
point.
\\
\hline
Fade
&\\
\hline
Fade Range Selection
&
For all the regions that either
begin or end in the range, create
a fade in or out on the regions
length.
\\
\hline
Set Fade In Length
&
If the edit point is withing the
region boundaries, adjusts
selected audio regions’ fade in
to end at the edit point.
\\
\hline
{[}{]} Fade In
&
Toggles the fade in on the
selected region on or off
\\
\hline
Set Fade Out Length
&
Same as above, for the fade out
\\
\hline
{[}{]} Fade Out
&
Toggles the fade out on the
selected region on or off
\\
\hline
Remove Last Capture
&
Destroy the last recording. A
prompt reminds the user this
\sphinxstyleemphasis{cannot} be undone.
\\
\hline
Edit point
&\\
\hline
Change Edit Point
&
Toggles between the mouse and the
playhead as the Edit point
\\
\hline
Change Edit Point Including
Marker
&
Toggles between the mouse, the
playhead and marker as the Edit
point
\\
\hline
Snap Mode
&\\
\hline
() No Grid
&
Disables
{\hyperref[\detokenize{index:grid-controls}]{\emph{snapping}}},
i.e. allows free movement of
regions and boundaries
\\
\hline
() Grid
&
Forces snapping, so any move of
region boundary will be lined to
the grid as chosen
\\
\hline
() Magnetic
&
If the movement of the region or
boundary happens near a grid
line, snaps, otherwise, allow
free movement
\\
\hline
Next Snap Mode
&
Toggles between the No Grid, Grid
and Magnetic snap modes
\\
\hline
Next Snap Choice
&
Circles through the snap choices,
as detailed below
\\
\hline
Previous Snap Choice
&
Circles through the snap choices,
as detailed below, in reverse
order
\\
\hline
Next Musical Snap Choice
&
Circles through the musical snap
choices, e.g. those expressed in
bars and beats
\\
\hline
Previous Musical Snap Choice
&
Same as previous, but in reverse
order
\\
\hline
Snap To
&\\
\hline
Snap to CD Frame
&
The grid unit will be 1/75th of a
second
\\
\hline
Snap to Timecode
Frame/Second/Minute
&
The grid unit will be based on
the timecode settings for the
session
\\
\hline
Snap to Second/Minute
&
The grid unit will be based on
absolute times
\\
\hline
Snap to \sphinxstyleemphasis{n}th
&
The grid unit will be 1/\sphinxstyleemphasis{n}
beats and will depend on the
tempo and meter in effect at that
point in the timeline.
\\
\hline
Snap to Beat
&
Same as above, whole beat
\\
\hline
Snap to Bar
&
Same as above, whole bar
\\
\hline
Snap to Mark
&
The grid will be made of markers
\\
\hline
Snap to Region Start
&
No grid, the regions will snap to
the closest region start on any
track
\\
\hline
Snap to Region End
&
Same as above with the regions’
ends
\\
\hline
Snap to Regions Sync
&
Same as above, with the Sync
points (by default, start of the
region)
\\
\hline
Snap to Region Boundaries
&
Same as above, for both the
starts and ends of regions
\\
\hline
Tempo
&\\
\hline
Set Tempo from Region = Bar
&
Computes the tempo so that the
duration of the first selected
region is 1 bar. Ardour prompts
if the user wants it to be the
global tempo, or a tempo marker
at the beginning of the region
used
\\
\hline
Set Tempo from Edit Range = Bar
&
Same thing, with the current
Range instead of a region
\\
\hline
{[}{]} Smart Object Mode
&
Toggles the Smart Mode, allowing
the mouse to be in Range Mode in
the upper half of a region, and
in Grab Mode in the lower half
\\
\hline
Scripted Actions
&\\
\hline
{[}{]} Script Manager
&
Shows the {\hyperref[\detokenize{index:lua-scripting}]{\emph{Script
manager}}},
allowing to use and manage the
Lua scripts in the session
\\
\hline
Unset \#\sphinxstyleemphasis{n}
&
Deactivate the \sphinxstyleemphasis{n}th script
\\
\hline
Preferences
&
Displays the
{\hyperref[\detokenize{index:preferences}]{\emph{Preferences}}}
panels, allowing to change
Ardour’s behaviour
\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}
\subsubsection*{12.4 - The Region Menu}

The Region Menu is where the user can tweak its regions, the parts of
audio or MIDI that sit on the timeline.


\begin{savenotes}\sphinxatlongtablestart\begin{longtable}{|l|l|}
\hline

\endfirsthead

\multicolumn{2}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} -- continued from previous page}}}\\
\hline

\endhead

\hline
\multicolumn{2}{r}{\makebox[0pt][r]{\sphinxtablecontinued{Continued on next page}}}\\
\endfoot

\endlastfoot

Insert Region from Region List
&
If a region is selected in the
Editor List, add it at the Edit
point
\\
\hline
Play
&
Starts playback at the beginning
of the selected region(s), and
stops at its(their) end
\\
\hline
Loop
&
Creates a loop range on the
selected region’s boundaries, and
starts the looped playback
\\
\hline
Rename…
&
Changes the name of the region,
that appears in its top left area
\\
\hline
Properties…
&
Shows the Region properties
window, that displays detailed
information about the region and
allow for some modifications
\\
\hline
Loudness Analysis…
&
Shows the Audio Report/Analysis
window, that displays detailed
{\color{red}\bfseries{}{}`}dBFS
information \textless{}\#metering-in-ardour\textgreater{}
{\color{red}\bfseries{}{}`}\_\_
as well as a spectrogram (dBFS of
frequency against time)
\\
\hline
Spectral Analysis…
&
Shows the Audio Report/Analysis
window, that displays a
integrated spectral view of the
region (dBFS against frequency)
\\
\hline
Edit
&\\
\hline
Combine
&
Creates a new region by joining
the selected audio regions in the
same track, and replaces those
region with the newly created
compound. The same rules are
applied to create the compound as
for playback regarding e.g.
layering
\\
\hline
Uncombine
&
Splits back the compound created
by \sphinxstyleemphasis{combining} into its original
audio regions
\\
\hline
Pitch Shift…
&
Changes the tune of the audio
region, by octave, semitones or
percentage, based on spectral
analysis. Optionally, and if they
have been set for the region,
preserves the formants
\\
\hline
Split/Separate
&
Cuts the selected regions at the
Edit point, separating them in
two regions
\\
\hline
Split at Percussion Onset
&
Allows splitting the selected
regions on its Percussion Onsets
marker as set by the Rhythm
Ferret (Not usable as of 5.5)
\\
\hline
Make Mono Regions
&
Creates mono regions out of a
stereo or multichannel region by
splitting it into its discrete
channels. The created regions are
added to the Editor List
\\
\hline
Close Gaps
&
Extends (or reduces) the selected
regions to be perfectly aligned.
Optionally, sets up a crossfade
duration, or a pull-back (spacing
between regions)
\\
\hline
Place Transient
&
Places a transient at the Edit
Point. Used e.g. for the Pitch
Shift… action
\\
\hline
Rhythm Ferret…
&
Opens the Rhythm Ferret which is
a powerful tool to sequence audio
files
\\
\hline
Strip Silence…
&
Opens the Strip Silence window
which is a very handy tool to
remove all audio under a
user-chosen threshold (with a
preview)
\\
\hline
Reverse
&
Mirrors the audio horizontally
\\
\hline
Layering
&\\
\hline
Raise to Top
&
On overlapping regions, puts the
selected one(s) on top
\\
\hline
Raise
&
On overlapping region, makes the
selected one(s) one layer higher
\\
\hline
Lower
&
Makes the selected region(s) one
layer lower
\\
\hline
Lower to Bottom
&
Sends the selected region to the
background
\\
\hline
MIDI
&\\
\hline
Transpose…
&
On a MIDI region, shows the
{\hyperref[\detokenize{index:transposing-midi}]{\emph{Transpose MIDI
window}}},
allowing to shift the pitch of
the whole MIDI region by \(\pm\) \sphinxstyleemphasis{n}
semitones or octaves
\\
\hline
Insert Patch Change…
&
Inserts a patch change at the
Edit Point, allowing a change of
patch, channel, program and/or
bank
\\
\hline
Quantize…
&
Shows the {\hyperref[\detokenize{index:quantize-midi}]{\emph{Quantize
window}}},
allowing to perfectly align the
MIDI notes to the musical grid
\\
\hline
Legatize
&
Shortens or elongates the MIDI
notes to make them perfectly
sequential, i.e. the end of a
note is the start of the
following one
\\
\hline
Remove Overlap
&
Shortens or elongates the MIDI
notes to make them perfectly
sequential, i.e. the end of a
note is the start of the
following one
\\
\hline
Transform…
&
{\hyperref[\detokenize{index:transforming-midi---mathematical-operations}]{\emph{Transform
window}}},
that allows for mathematical
operations on the midi notes
\\
\hline
Unlink from Other copies
&
Makes the selected MIDI region
independent, e.g. editing this
region won’t affect any other
one.
\\
\hline
List Editor…
&
Shows the {\hyperref[\detokenize{index:midi-list-editor}]{\emph{List
Editor}}}
which sequentially lists all the
MIDI events in the region, and
allows for precise modifications
\\
\hline
Gain
&\\
\hline
{[}{]} Opaque
&
When checked, makes the region
opaque audio-wise, i.e., the
underlying regions won’t be
audible
\\
\hline
{[}{]} Mute
&
When checked, mutes \sphinxstyleemphasis{only} the
selected region on the track,
without muting the track. The
muted regions will have \sphinxstyleemphasis{!!}
prepended to their name and will
be semi-transparent
\\
\hline
Normalize…
&
Shows the Normalize region
dialog, which allows to scale the
region level by setting its
maximum level, optionally
constraining the RMS
\\
\hline
Boost Gain
&
Increases the gain on the
selected region by boosting the
audio, without touching the
envelope or automation
\\
\hline
Cut Gain
&
Reduces the gain without touching
the envelope or automation
\\
\hline
Reset Envelope
&
If the gain envelope has been
edited, resets it to its initial
value (constant at 0 dB)
\\
\hline
{[}{]} Envelope Active
&
When unchecked, disables any
envelope editing that has been
made. The envelope will be
displayed in yellow instead of
green.
\\
\hline
Position
&\\
\hline
Move to Original Position
&
Moves the region where it was
initially recorded or inserted in
the session
\\
\hline
Snap Position to Grid
&
If the Grid Mode is set to
\sphinxstyleemphasis{Grid}, snaps the region to the
nearest grid line
\\
\hline
{[}{]} Lock
&
Locks the selected regions at
their current positions in time
and tracks, avoiding any movement
on the timeline. The region name
will be surrounded by \sphinxstyleemphasis{\textgreater{}} and \sphinxstyleemphasis{\textless{}}
brackets
\\
\hline
{[}{]} Glue to Bars and Beats
&
Locks the region position to
relative to the musical grid,
i.e. a change of tempo will move
the region to keep it on the same
bar/beat
\\
\hline
{[}{]} Lock to Video
&
Same as above, relative to the
position in the video
\\
\hline
Set Sync Position
&
Creates or move the Sync
position, i.e. the point of the
region that will be aligned or
snapped to the grid, and that is
(by default) the beginning of the
region.
\\
\hline
Remove Sync
&
Removes any user defined Sync
point, and resets the sync
position to the beginning of the
region
\\
\hline
Nudge Later
&
Moves the region to the right by
the amount shown in the {\hyperref[\detokenize{index:nudge-controls}]{\emph{nudge
timer}}}
\\
\hline
Nudge Earlier
&
Same as above, to the left
\\
\hline
Nudge Later by Capture Offset
&
Moves the region to the right by
the capture latency computed by
Ardour based on the user’s
settings regarding latency
\\
\hline
Nudge Earlier by Capture Offset
&
Same as above, to the left
\\
\hline
Sequence Regions
&
Puts the selected regions one
after the other, so that the end
of one region is the beginning of
the next one, removing any
overlap or silence. The reference
point is the earliest region.
\\
\hline
Trim
&\\
\hline
Trim Start at Edit Point
&
If the Edit Point is within the
region boundaries, shortens the
region to align its start with
the Edit Point
\\
\hline
Trim End at Edit Point
&
Same as above, for the end of the
region
\\
\hline
Trim to Loop
&
Uses both the start and end Loop
markers to shorten the region
\\
\hline
Trim to Punch
&
Same as above with the Punch
markers
\\
\hline
Trim to Previous
&
On overlapping regions, shortens
the selected one so that the
previous region is complete, i.e.
the new start point for the
selected region is the end point
of the previous region on the
timeline
\\
\hline
Trim to Next
&
Same as above, with the end of
the selected region aligned to
the start of the following one.
\\
\hline
Ranges
&\\
\hline
Set Loop Range
&
Creates a Loop range based on the
selected regions, i.e. the start
of the loop range is the start of
the earliest region, and the end
of the loop is the end of the
latest region.
\\
\hline
Set Punch
&
Same as above, for the Punch
range
\\
\hline
Add Single Range Marker
&
Same as above, for the Edit range
\\
\hline
Add Range Marker Per Region
&
For each selected region, creates
its own Edit range based on the
boundaries of each region
\\
\hline
Set Range Selection
&
Creates a range selection based
on the boundaries of the selected
regions
\\
\hline
Fades
&\\
\hline
{[}{]} Fade In
&
Activates/deactivates the Fade In
at the start of the region
\\
\hline
{[}{]} Fade Out
&
Same as above, for the Fade out
at the end of the region
\\
\hline
{[}{]} Fades
&
Shortcut to activate/deactivate
both the fade in and fade out
\\
\hline
Duplicate
&\\
\hline
Duplicate
&
Creates a copy of the selected
region(s) and appends it to the
original
\\
\hline
Multi-Duplicate…
&
Shows the Duplicate dialog,
allowing to create multiple
copies, or a not-integer number
of copies (the last one will then
be truncated)
\\
\hline
Fill Track
&
Creates duplicates until it fills
the session, i.e. reaches the End
marker of the session. The last
duplicate may be truncated to fit
in
\\
\hline
Export…
&
Shows the {\hyperref[\detokenize{index:export-dialog}]{\emph{Export
dialog}}}, with
all parameters set to export only
the selected region(s)
\\
\hline
Bounce (without processing)
&
Creates a bounce, i.e. a version
of the region with all the edits
(boundaries, envelope), as a new
region in the Editor List,
without any of the effects of the
mixer strip
\\
\hline
Bounce (with processing)
&
Same as above, \sphinxstyleemphasis{with} the effects
of the mixer strip
\\
\hline
Remove
&
Deletes the region from the edit
(no file is harmed in the
process, and the region stays in
the Editor for later use)
\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}
\subsubsection*{12.5 - The Track Menu}

The Track menu is where one can deal with the tracks, busses and control
masters.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

Add Track, Bus or VCA…
&
Shows the {\hyperref[\detokenize{index:adding-tracks-busses-and-vcas}]{\emph{Add Track, Bus or VCA…
window}}},
where one can add one or more
tracks, busses or control masters
to the session and define its
parameters
\\
\hline
Duplicate Tracks/Busses…
&
Shows the Duplicate Tracks and
Busses window, allowing to
duplicate the selected track(s)
and optionally, its playlist
\\
\hline
Toggle Record Enable
&
Sets the Record Enable mode On on
the selected track(s). These
tracks will record audio/midi
next time the global record is
active and playback is started.
\\
\hline
Toggle Solo
&
Sets the solo On on the selected
tracks, so only these tracks will
play
\\
\hline
Toggle Mute
&
Mutes the selected tracks, they
won’t play until unmuted
\\
\hline
Insert Time
&
Shows the {\hyperref[\detokenize{index:insert-remove-time}]{\emph{Insert Time
window}}},
allowing to insert a blank time
in the selected tracks’ playlist
\\
\hline
Remove Time
&
Same as
{\hyperref[\detokenize{index:insert-remove-time}]{\emph{above}}},
but to remove time
\\
\hline
Move Selected Tracks Up
&
Changes the position of the
selected tracks one track up
towards the top. In the mixer,
the tracks will be moved to the
left.
\\
\hline
Move Selected Tracks Down
&
Same as above, towards the bottom
\\
\hline
Height
&\\
\hline
Fit Selection (Vertical)
&
Will fit the selected track(s) in
the window. If too many tracks
are selected, they’ll be reduced
to their minimum height.
\\
\hline
Largest
&
Sets the selected tracks height
to a very high value, hence
making the tracks wide on screen
\\
\hline
Larger
&
Same as above, but a little less
high
\\
\hline
Large
&
Same as above, but again less
high
\\
\hline
Normal
&
Sets the height of the track to
its default value which is a
trade-off between readability and
number of tracks displayed
\\
\hline
Small
&
Reduces the size of the tracks to
a low value, increasing the
number of on screen tracks
\\
\hline
Toggle Active
&
Toggles the active state of a
track. An inactive track will be
grayed and won’t play any sound.
That can be seen in the A column
of the {\color{red}\bfseries{}{}`Tracks and Busses
List \textless{}\#the-tracks-and-busses-list
\textgreater{}{}`\_\_}
\\
\hline
Remove
&
Deletes this track and its
playlist (no file is harmed in
the process, and the regions from
the playlist stay in the Editor
for later use)
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\subsubsection*{12.6 - The View Menu}

The View menu sets how the session is seen, and what’s visible or not.


\begin{savenotes}\sphinxatlongtablestart\begin{longtable}{|l|l|}
\hline

\endfirsthead

\multicolumn{2}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} -- continued from previous page}}}\\
\hline

\endhead

\hline
\multicolumn{2}{r}{\makebox[0pt][r]{\sphinxtablecontinued{Continued on next page}}}\\
\endfoot

\endlastfoot

{[}{]} Maximise Editor Space
&
Puts the Editor window in full
screen mode
\\
\hline
{[}{]} Maximize Mixer Space
&
Puts the Mixer window in full
screen mode
\\
\hline
Primary Clock
&\\
\hline
Focus On Clock
&
Sets the focus on the {\hyperref[\detokenize{index:transport-clocks}]{\emph{main
clock}}},
allowing to type in numbers
directly to change the playhead
position
\\
\hline
Timecode
&
Sets the main clock in timecode
mode, so it displays time in the
Hours:Minutes:Seconds:Frames
format
\\
\hline
Bars \& Beats
&
Sets the main clock in musical
time mode, so it displays time in
the Bars:Beats:Ticks format
\\
\hline
Minutes \& Seconds
&
Sets the main clock in absolute
time mode, so it displays time in
the
Hours:Minutes:Seconds.Millisecond
s
format
\\
\hline
Samples
&
Sets the main clock in samples
time mode, so the time is
displayed in samples from the
absolute start
\\
\hline
Secondary Clock
&\\
\hline
Timecode
&
Same as for the main clock (see
above)
\\
\hline
Bars \& Beats
&
Same as for the main clock
\\
\hline
Minutes \& Seconds
&
Same as for the main clock
\\
\hline
Samples
&
Same as for the main clock
\\
\hline
Zoom
&\\
\hline
Zoom In
&
Zooms in, focusing the \sphinxstyleemphasis{Zoom
Focus} (see below)
\\
\hline
Zoom Out
&
Zooms out
\\
\hline
Zoom to Session
&
Adjust the zoom value so that all
the session (as defined by its
start and end markers) fit in the
window
\\
\hline
Zoom to Selection
&
Adjust the zoom value so that all
the selected regions fit in the
window
\\
\hline
Fit Selection (Vertical)
&
Fits the selected track(s) in the
window. If too many tracks are
selected, they’ll be reduced to
their minimum height.
\\
\hline
Toggle Zoom State
&
Reverts to last zoom state (kind
of “undo” for zoom, even if edits
have been made in-between)
\\
\hline
Expand Track Height
&
Increases the height of the
selected tracks. If no track is
selected, then all the tracks are
expanded
\\
\hline
Shrink Track Height
&
Same as above, but reduces the
height of the tracks
\\
\hline
Zoom Focus
&\\
\hline
Zoom Focus Left
&
Sets the screen’s left side as
the zoom target, i.e. when
zooming in, the left side of the
screen will stay at the same
place in the timeline
\\
\hline
Zoom Focus Right
&
Same, with the right of the
screen
\\
\hline
Zoom Focus Center
&
Same, with the center of the
screen
\\
\hline
Zoom Focus Playhead
&
Sets the playhead as the focus
point of the zoom, i.e. the point
in time that will stay fixed
\\
\hline
Zoom Focus Mouse
&
Same as above, with the mouse
pointer
\\
\hline
Zoom Focus Edit Point
&
Same as above, with the Edit
Point
\\
\hline
Next Zoom Focus
&
Circles between the previous
modes
\\
\hline
Rulers
&\\
\hline
{[}{]} Min:Sec
&
Shows (when checked) or hides a
line in {\hyperref[\detokenize{index:ruler}]{\emph{the Ruler}}}
with the time formatted as
Hours:Minutes:Seconds.Millisecond
s
\\
\hline
{[}{]} Timecode
&
Same as above, with the time
formatted as
Hours:Minutes:Seconds:Frames
\\
\hline
{[}{]} Samples
&
Same as the above, with the time
displayed in samples from the
absolute start
\\
\hline
{[}{]} Bars \& Beats
&
Same as the above, with the time
formatted as Bars:Beats:Ticks
\\
\hline
{[}{]} Meter
&
Shows / hides the Meter line in
the ruler, where the signature
can be adjusted along the
playline
\\
\hline
{[}{]} Tempo
&
Shows / hides the Tempo line,
where the BPM can be changed with
markers
\\
\hline
{[}{]} Ranges
&
Shows / hides the Range line,
where ranges can be defined
\\
\hline
{[}{]} Loop/Punch
&
Shows / hides the Loop/Punch
line, where loops and Punches can
be defined
\\
\hline
{[}{]} CD Markers
&
Shows / hides the Range line,
where CD Markers can be defined
\\
\hline
{[}{]} Markers
&
Shows / hides the Markers line,
where custom markers can be
defined
\\
\hline
{[}{]} Video
&
Shows / hides the Video timeline,
where frames of the video are
shown for syncing purposes
\\
\hline
Video Monitor
&\\
\hline
Original Size
&
When the {\hyperref[\detokenize{index:video-timeline-and-monitoring}]{\emph{Video
Monitor}}}
is active, resets its size to the
original size, i.e. 1 pixel in
the video is 1 pixel on screen
\\
\hline
{[}{]} Letterbox
&
When checked, forces the ratio
(width/height) to be the one of
the original video. If unchecked,
the video will be stretched to
fit the window
\\
\hline
{[}{]} Always on Top
&
Stays above all other windows,
enabling to work in Ardour
without the video windows to be
hidden in the background
\\
\hline
{[}{]} Fullscreen
&
Sets the Xjadeo window to be
fullscreen. Can be useful in a
dual monitor setup
\\
\hline
{[}{]} Timecode
&
When checked, displays a Timecode
over the video, in the
Hours:Minutes:Seconds:Frames
format
\\
\hline
{[}{]} Frame number
&
When checked, shows the absolute
frame number inside the video,
i.e. this image is the \sphinxstyleemphasis{n}th of
the video
\\
\hline
{[}{]} Timecode Background
&
Adds a black background to the
timecode for readability
\\
\hline
Scroll
&\\
\hline
Scroll Tracks Down
&
Scrolls the view toward the
bottom of the session from one
screen (vertically, so along
tracks)
\\
\hline
Scroll Tracks Up
&
Same as above, towards the top
\\
\hline
Scroll Forward
&
Scrolls the view toward the right
of the session from one screen
(horizontally, so along time)
\\
\hline
Scroll Backward
&
Same as above, to the left
\\
\hline
Views
&\\
\hline
Save View \sphinxstyleemphasis{n}
&
Saves the position on the
timeline in the memory,
horizontally and vertically
(along time and tracks)
\\
\hline
Go to View \sphinxstyleemphasis{n}
&
Loads and displays a saved
position (see above)
\\
\hline
{[}{]} Show Editor Mixer
&
When checked, the selected
tracks’ mixer strip is displayed
on the left of the editor window,
allowing for a quick access to
e.g. effects and routing
\\
\hline
{[}{]} Show Editor List
&
In the Editor window, shows the
{\hyperref[\detokenize{index:editor-lists}]{\emph{Editor List}}},
giving access to a number of
handy lists (regions, tracks, …)
\\
\hline
{[}{]} Toggle Mixer List
&
In the Mixer view, shows the
Mixer list, giving access to some
handy lists ({\color{red}\bfseries{}{}`Favorite
plugins \textless{}\#favorite-plugins-window
\textgreater{}{}`\_\_},
{\hyperref[\detokenize{index:strips-list}]{\emph{The Strip
list}}},…)
\\
\hline
{[}{]} Toggle Monitor Section
Visibility
&
If the Use monitoring section on
this session has been checked in
the {\hyperref[\detokenize{index:monitoring-tab}]{\emph{Session Properties
window}}},
shows or hides the Monitor
Section in the Mixer
\\
\hline
{[}{]} Show Measure Lines
&
If checked, in the Editor, shows
a vertical white line at each
measure start
\\
\hline
{[}{]} Show Summary
&
If checked, in the Editor, shows
the {\hyperref[\detokenize{index:summary}]{\emph{Summary}}},
allowing a faster navigation in
the session
\\
\hline
{[}{]} Show Group Tabs
&
If checked, makes the groups
visible as tabs on the left in
the Editor, and on the top in the
mixer
\\
\hline
{[}{]} Show Marker Lines
&
If checked, each marker is
extended across all the tracks in
the editor with a line of the
same color
\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}
\subsubsection*{12.7 - The Window Menu}

The Window menu deals with the layout of the different windows, and
their visibility.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

{[}{]} Audio/MIDI Setup
&
Shows the \sphinxtitleref{Audio/MIDI Setup
window \textless{}\#newopen-session-dialog\textgreater{}}
\_\_,
where the sound system
configuration can be modified
\\
\hline
Editor
&\\
\hline
Show
&
Switches to the Editor view
\\
\hline
Hide
&
Hides the Editor, hence showing
the Mixer when the windows are
attached
\\
\hline
Attach
&
If the Editor window is detached,
separated from the main window,
attach it back
\\
\hline
Detach
&
If the Editor is attached to the
main window, detach it (makes the
Editor a separated window, useful
for multi-monitor setup)
\\
\hline
Mixer
&\\
\hline
Show/Hide/Attach/Detach
&
Same as for the Editor, for the
\sphinxstyleemphasis{Mixer} window
\\
\hline
Preferences
&\\
\hline
Show/Hide/Attach/Detach
&
Same as for the Editor, for the
\sphinxstyleemphasis{Preferences} window
\\
\hline
Meterbridge
&
Shows the {\hyperref[\detokenize{index:metering-in-ardour}]{\emph{Meterbridge
window}}},
that displays all the tracks’
meter at once and their recording
status, and is very handy for
multitrack recording
\\
\hline
Scripting
&
Opens the {\hyperref[\detokenize{index:lua-scripting}]{\emph{Lua Scripting
window}}},
allowing to edit and run Lua
scripts
\\
\hline
{[}{]} Tracks and Busses
&
Opens the Tracks and Busses
window, which is a shortcut to
many tracks/busses operations
(routing, effects, …)
\\
\hline
{[}{]} Locations
&
Opens the {\hyperref[\detokenize{index:the-ranges-and-marks-lists}]{\emph{Ranges and Marks
window}}},
a single point of control for all
range and location markers
\\
\hline
{[}{]} Binding Editor
&
Opens the {\hyperref[\detokenize{index:default-keyboard-bindings}]{\emph{Key Bindings
window}}},
which allows for easy creation or
modification of any keyboard
shortcut
\\
\hline
{[}{]} Bundle Manager
&
Opens the Bundle Manager window,
allowing to create and manage
\sphinxstyleemphasis{Bundles}, which are a way to
simplify connection management,
by defining groups of ports
\\
\hline
{[}{]} Big Clock
&
Opens the {\hyperref[\detokenize{index:transport-clocks}]{\emph{Main
Clock}}} as
its own separate (and huge)
window, which is helpful when
recording
\\
\hline
{[}{]} Video Monitor
&
If a
{\hyperref[\detokenize{index:video-timeline-and-monitoring}]{\emph{video}}}
has been imported in the session,
opens a video window (namely,
\sphinxstyleemphasis{Xjadeo}), synced to the timeline
\\
\hline
Midi Tracer
&
Opens the MIDI Tracer window,
allowing to follow each and every
MIDI message entering or leaving
Ardour
\\
\hline
{[}{]} Audio Connections
&
Opens the {\hyperref[\detokenize{index:patchbay}]{\emph{Audio Connection
Manager window}}}, a
way to make connections to, from
and within Ardour’s mixer
\\
\hline
{[}{]} MIDI Connections
&
Same as above, for the MIDI
connections
\\
\hline
{[}{]} Log
&
Shows the Log window, where
Ardour lists useful information,
warnings and errors
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\subsubsection*{12.8 - The Help Menu}

The Help Menu gives access to useful information about Ardour.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

{[}{]} About
&
Shows the About Ardour window,
which contains information about
the version, config, authors,and
license of Ardour
\\
\hline
Chat
&
This is a shortcut to the webchat
version of the Freenode IRC
channel of Ardour, where the
developers meet, and questions
can be asked if the Manual is not
enough
\\
\hline
Manual
&
Link to a FLOSSManual guide to
Ardour
\\
\hline
Reference
&
Link to this manual, hosted on
ardour.org
\\
\hline
User Forums
&
Link to ardour.org’s user forum
\\
\hline
How to Report a Bug
&
Link to an helping page about
reporting bugs
\\
\hline
Report a Bug
&
Link to Ardour’s Mantis
bugtracker
\\
\hline
Ardour Website
&
Link to Ardour’s main and
official website
\\
\hline
Ardour Development
&
Link to the developers’ part of
the official website
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\subsubsection*{13 - Status Bar}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{status-bar}.png}
\caption{The Status Bar}\label{\detokenize{index:id487}}\end{figure}

The status bar is an informative bar at the top of the window, showing:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

File:
&
the file format used in the
session, including when recording
\\
\hline
TC:
&
is the timecode, i.e. the number
of frames per second used by the
session (for videos)
\\
\hline
Audio:
&
gives the sample rate used in the
session, and the latency computed
from the buffer size
\\
\hline
Buffers:
&
describe how much data is
buffered, see below
\\
\hline
DSP:
&
for Digital Sound Processing,
shows how much of the CPU is used
by Ardour and its plugins
\\
\hline
PkBld:
&
\sphinxstyleemphasis{(only shows up while creating
peaks)} displays the number of
peak files left to create
\\
\hline
X:
&
shows the number of xruns since
Ardour’s launch, see below
\\
\hline
Disk:
&
reports the remaining hard disk
space as the time that can be
recorded with the current session
setting
\\
\hline
Wall Clock
&
showing the system time
(especially useful in full screen
mode)
\\
\hline
Log button
&
that indicates if Ardour has
encountered any warning or error.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

Right clicking anywhere on the Status Bar allows to choose which of this
information we want displayed, through a checkbox menu.

The buffers are labelled as p for playback and c for capture. If the
system is fast enough, these buffers should be 100\% full at all times,
showing the system has time to precompute all the data before delivering
it to the audio system. A buffer constantly under 20\% is a sign of an
underpowered computer system or of too much processing.

An Xrun (short for buffer over- or under-run) happens when the system
has been forced to skip audio frames, e.g. if the latency asked is too
short for the computing power of the machine. It usually results in
clicks, pops and crackles if it happens while recording.

The log button turns yellow when a warning is shown, and red when an
error occurs. Clicking the log button gives access to the log.
\subsubsection*{14 - Transport Bar}
\subsubsection*{The transport controls}

The Transport Bar groups all the actions regarding the control of
playback and recording.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{transport}.png}
\caption{The transport controls}\label{\detokenize{index:id488}}\end{figure}

This bar is made of (from left to right):


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

Midi Panic
&
Immediately stops all midi
output.
\\
\hline
Enable/disable Audio Click
&
Toggles (on/off) a click track
(metronome) along the
{\hyperref[\detokenize{index:tempo-and-meter}]{\emph{tempo}}}.
Right clicking brings up the
Click submenu from the
Preferences. Scrolling with the
mouse wheel adjusts the gain of
the click.
\\
\hline
Go to Start of the Session
&
Jumps back at the beginning of
the session, as defined by the
{\hyperref[\detokenize{index:working-with-markers}]{\emph{start
marker}}}
.
\\
\hline
Go to End of the Session
&
Jumps forward to the end of the
session, as defined by the {\hyperref[\detokenize{index:working-with-markers}]{\emph{end
marker}}}
.
\\
\hline
Play Loop Range
&
Repeats the defined
{\hyperref[\detokenize{index:controlling-playback}]{\emph{loop}}}
as defined by the {\hyperref[\detokenize{index:the-loop-range}]{\emph{Loop
range}}}, until
the “Stop playback” button is
pressed. Clicking the “Play loop
Range” button while already
active switches to normal Play
mode, which exits the loop
without stopping and restarting
playback.
\\
\hline
Play Range/Selection
&
If a range has been defined using
the Range Mode button, plays the
range, of if an audio or MIDI
region is selected, plays this
region. In both cases, the
playback stops at the end of the
range or selected region.
\\
\hline
Play from playhead
&
Starts the playback and
optionally record (more below).
\\
\hline
Stop
&
Whatever the playing mode (loop,
range, …) stops all playback.
Depending on other settings, some
effects (like chorus or reverb)
might still be audible for a
while.
\\
\hline
Toggle Record
&
Global switch button to
activate/deactivate recording.
While active, the button blinks
red. The button doesn’t start
recording by itself: if one or
more tracks are marked as
record-enabled, pressing the
“Play from Playhead” starts
recording on those tracks.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

All these actions are bound to keyboard shortcuts, which allows for
speedier use and more focused work.

If Ardour is synchronized with other devices then some or all of these
control methods may be unavailable—depending on the synchronization
protocol, Ardour may respond only to commands sent from its master
device(s).

Under these buttons is the Shuttle Speed Control that allows to scrub
through the audio quickly. The slider decides the playback speed: the
further from the center it is set, the faster the playback will scrub in
both directions.

The Shuttle Speed Control supports 2 operating modes, that can be chosen
with right click \textgreater{} Mode:
\begin{itemize}
\item {} 
Sprung mode that allows for a temporary scrub: it only scrubs while
the mouse is left clicked on the control.

\item {} 
Wheel mode that allows to set a playback speed until the “Stop”
button is pressed, which stops the playback and resets its speed.

\end{itemize}

On the left of the slider is the positional sync button (which might
show Internal, or MTC or several other values), than can be used to
control whether or not the transport position and start is controlled by
Ardour, or by an external positional synchronization source, such as
MIDI Time Code (MTC), Linear Time Code (LTC) or JACK (see {\hyperref[\detokenize{index:timecode-generators-and-slaves}]{\emph{Timecode
Generators and Slaves}}}).

The current playback status (Stop, Play, or speed \%) is shown on the
right of the speed slider.
\subsubsection*{Using Key Bindings}

Ardour has many available commands for playback control that can be
bound to keys. Many of them have default bindings, some do not, so the
list below shows both the default bindings and internal command names
for some of them.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

Space
&
Switch between playback and stop.
\\
\hline
Home
&
Move playhead to session start marker
\\
\hline
End
&
Move playhead to session end marker
\\
\hline
\(\rightarrow\)
&
Playhead to next region boundary
\\
\hline
←
&
Playhead to previous region boundary
\\
\hline
0
&
Move playhead to start of the timeline
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

Go to the Transport and Transport \textgreater{} Playhead to find more.
\subsubsection*{15 - Transport Clocks}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{new_main_clocks}.png}
\caption{The transport clocks in Ardour}\label{\detokenize{index:id489}}\end{figure}

Clocks in Ardour are used to display time values precisely. In many
cases, they are also one way to edit (change) time values, and in a few
cases, the only way. All clocks share the same basic appearance and
functionality, which is described below, but a few clocks serve
particularly important roles.

In the transport bar of the editor window there are two clocks (on a
large enough screen), that display the current position of the playhead
and additional information related to transport control and the
timeline. These are called the transport clocks; the left one is the
primary transport clock and the right one is the secondary transport
clock.

All the clocks in Ardour share the same powerful way of editing time.
Refer to {\hyperref[\detokenize{index:editing-clocks}]{\emph{Editing Clocks}}} to learn how.

Editing the time in the transport clocks will reposition the playhead in
the same way that various other editing operations will.
\subsubsection*{The Special Role of the Secondary Transport Clock}

On a few occasions Ardour needs to display time values to the user, but
there is no obvious way to specify what units to use. The most common
case is the big cursor that appears when dragging regions. For this and
other similar cases, Ardour will display time using the same units as
the secondary clock.
\subsubsection*{Why are there two transport clocks?}

Having two transport clocks allows seeing the playhead position in two
different time units without having to change any settings. For example,
one can see the playhead position in both timecode units and BBT time.
\subsubsection*{Special Modes for the Transport Clocks}

In addition to the time-unit modes, each of the two transport clocks
(again, on a sufficiently large screen) can be independently set to
display Delta to Edit Point in whatever time units its current mode
indicates. This setting means that the clock shows the distance between
the playhead and the current edit point, and it may show a positive or
negative value depending on the temporal order of these two points. The
clocks will use a different color when in this mode to avoid confusion.

To switch either (or both!) of the transport clocks into this mode, use
Edit \textgreater{} Preferences \textgreater{} Transport and select the relevant checkboxes.

Note that when in Delta to Edit Point mode, the transport clocks cannot
be edited.
\subsubsection*{The Big Clock}

To show the current playhead position in a big, resizable window,
activate Window \textgreater{} Big Clock. The big clock is very useful when working
away from the screen but still wanting to see the playhead position
clearly (such as when working with a remote control device across a
room). The big clock will change its visual appearance to indicate when
active recording is taking place. Below on the left is a screenshot
showing a fairly large big clock window filling a good part of the
display, and on the right, the same clock during active recording.
\subsubsection*{16 - Selection and Punch Clocks}
\subsubsection*{The Selection Clocks}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{selection-clocks}.png}
\caption{The range clocks}\label{\detokenize{index:id490}}\end{figure}

The current selection range, as set with the {\hyperref[\detokenize{index:toolbox}]{\emph{Range Mode
tool}}}, is displayed in these three clocks: start of the
range, end of the range, and length.

Clicking on the range clocks will locate to either the beginning or end
of the punch range.

Right clicking on any of the clocks brings up a context menu allowing to
change the type of time display between the {\hyperref[\detokenize{index:editing-clocks}]{\emph{4 clock
modes}}}, and to copy the selected clock’s time to the
clipboard.
\subsubsection*{The Punch Controls \& clocks}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{punch-controls}.png}
\caption{The Punch Controls, and the related Punch clocks}\label{\detokenize{index:id491}}\end{figure}

The punch controls available in the main toolbar, work in conjunction
with the punch clocks, only visible while in Editor Mode.

The In and Out buttons relate to the Punch range, and allow to use only
one of the two punch boundaries, or both:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

In only
&
Records from the In marker on, without a end boundary
\\
\hline
Out only
&
Records until the Out marker, without a beginning boundary
\\
\hline
In \sphinxstyleemphasis{and} Out
&
Records only between the In and Out markers
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

The punch clocks can be controlled the same way as the range clocks
(moving the playhead, and changing the display mode).
\subsubsection*{Recording mode}

The Rec button affects how the tracks behave when recording:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

Non-Layered OFF \sphinxstyleemphasis{(default)}
&
Tracks in normal mode will record
non-destructively — new data is
written to new files, and when
overdubbing, new regions will be
layered on top of existing ones.
This is the recommended mode for
most workflows.
\\
\hline
Non-Layered ON
&
Tracks using non-layered mode
will record non-destructively —
new data is written to new files,
but when overdubbing, the
existing regions are trimmed so
that there are no overlaps. This
does not affect the previously
recorded audio data, and trimmed
regions can be expanded again at
will. Non-layered mode can be
very useful for spoken word
material, especially in
combination with {\hyperref[\detokenize{index:pushpull-trimming}]{\emph{push/pull
trimming}}}.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

See {\hyperref[\detokenize{index:track-types}]{\emph{Track Modes}}} for more information.
\subsubsection*{17 - Mini-Timeline}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{mini-timeline}.png}
\caption{The Mini-Timeline.}\label{\detokenize{index:id492}}\end{figure}

The mini-timeline allows, as the {\hyperref[\detokenize{index:summary}]{\emph{Summary}}} does, navigation
of a session. Its main advantage, though, is that it stays visible even
when in Mixer mode.

The range of time covered by the mini-timeline is set by right clicking
the timeline, and choosing a time span from 30 seconds up to 20 minutes.

The mini-timeline also shows all markers (start, end and any user
defined ones). Clicking a marker jumps to that point on the timeline,
allowing for quick access to key timings in the session.

While hovering with the mouse over the mini-timeline:
\begin{itemize}
\item {} 
left clicking moves the playhead to the time under the mouse cursor

\item {} 
using the scroll wheel scrolls the playhead back and forth inside the
session

\item {} 
using scroll wheel scrolls more finely inside the session

\item {} 
using scroll wheel scrolls even more finely inside the session

\end{itemize}
\subsubsection*{18 - Other Toolbar Items}
\subsubsection*{The Monitor Options}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{input-mode-buttons}.png}
\caption{The Monitor options}\label{\detokenize{index:id493}}\end{figure}

These buttons allow switching the monitoring mode globally, for all the
tracks at once. The monitoring mode allows to decide what the user wants
to be listening to, between:
\begin{itemize}
\item {} 
All In: all the tracks play what’s on their \sphinxstyleemphasis{In}puts.

\item {} 
All Disk: all the tracks play the actual content of the playlist on
\sphinxstyleemphasis{Disk}.

\end{itemize}

The Auto Input switch allows Ardour to auto-select what is played, which
is:
\begin{itemize}
\item {} 
When not playing: all tracks are on In (to listen to any connected
source)

\item {} 
When playing, all tracks are on Disk (to play whatever was recorded
on those tracks)

\item {} 
When recording, on rec-enabled tracks: In and on non rec-enabled
ones: Disk

\end{itemize}
\subsubsection*{The Playhead Options}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{playhead-options}.png}
\caption{The playhead options}\label{\detokenize{index:id494}}\end{figure}

Those 2 buttons control the behaviour of the playhead:
\begin{itemize}
\item {} 
Follow Range is a toggle that can be used to control whether or not
making a range selection will move the playhead to the start of the
range.

\item {} 
Auto Return is a toggle switch too. When active, pressing the Stop
button returns the playhead to its previous position, and when
inactive, pressing Stop keeps the playhead at its current location.
Activating Auto Return can be useful for hearing the same piece of
audio before and after tweaking it, without having to set a loop
range on it.

\end{itemize}
\subsubsection*{The Status indicators}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{status_buttons}.png}
\caption{The Status buttons}\label{\detokenize{index:id495}}\end{figure}

The Status buttons show the current session state:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

Solo
&
Blinks when one or more tracks
are being soloed, see {\hyperref[\detokenize{index:muting-and-soloing}]{\emph{Muting and
Soloing}}}.
Clicking this button disables any
active explicit and implicit solo
on all tracks and busses.
Clicking this button deactivates
the solo on every track/bus.
\\
\hline
Audition
&
Blinks when some audio is
auditioned, e.g. by using the
import dialog, or using the
Audition context menu in the
{\hyperref[\detokenize{index:the-region-list}]{\emph{Regions
List}}}.
Clicking this button stops the
auditioning.
\\
\hline
Feedback
&
Blinks when Ardour detects a
feedback loop, which happens when
the output of an audio signal
chain is plugged back to its
input. This is probably not
wanted and can be dangerous for
the hardware and the listener.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\subsubsection*{The Mode Selector}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{mode-selector_scripts_meter}.png}
\caption{The Mode Selector}\label{\detokenize{index:id496}}\end{figure}

The Mode Selector allows switching between the Editor and Mixer windows.
If a window is detached, the corresponding button is lit in blue.
Clicking the button switches the detached window visibility.

The global meter shows the levels of the master’s output. Its the same
meter that sits in the {\hyperref[\detokenize{index:master-bus-strip}]{\emph{Master’s Mixer strip}}}, and
also shows a peak indicator, that turns red when any level exceeds 0dB.
It can be reset by a Left click.

The buttons in between the Mode Selector and the global meter are script
buttons, which are user-definable buttons to attach any session
{\hyperref[\detokenize{index:lua-scripting}]{\emph{lua-script}}} to.
\subsubsection*{19 - Toolbox}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{toolbar-tools}.png}
\caption{Editor toolbar’s tools, aka toolbox}\label{\detokenize{index:id497}}\end{figure}
\subsubsection*{Global Edit mode}

Ardour has a global edit mode selector at the left of the Editing
toolbar, which affect how regions are moved or copied:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

Slide
&
Regions move freely. Ardour
creates overlaps when necessary.
\\
\hline
Ripple
&
Editing affects the regions to
the “right” of the edit (see
below).
\\
\hline
Lock
&
No region motion is permitted
(except for “nudge”).
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

Ripple Edit mode provides the following conveniences:
\begin{itemize}
\item {} 
Deleting a range will move later regions to compensate for the
deleted time

\item {} 
Deleting a region will move later regions to compensate for the
deleted region’s length

\item {} 
Moving a region will move later regions to compensate for the length
of the move

\item {} 
Inserting a new region (via dragging or via Paste) will move later
regions to the right to compensate

\end{itemize}

If Snap To Grid is enabled, then regions can only move so that they
align with locations determined by the current snap settings (beats, or
seconds, or other region boundaries, etc). See {\hyperref[\detokenize{index:grid-controls}]{\emph{Snap To the
Grid}}} for details.
\subsubsection*{The \sphinxstyleemphasis{Smart} switch}

The Smart Mode button to the left of the mouse mode buttons modifies the
Grab Mode. When enabled, the mouse behaves as if it is in “Range Mode”
in the upper half of a region, and in “Grab Mode” in the lower half.
This allows avoiding constant switching between these two modes.
\subsubsection*{Mouse Modes}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

Grab Mode
&
The Grab Mode is used for
selecting, moving, deleting and
copying objects. When in object
mode, the mouse pointer appears
as a hand whenever it is over the
track canvas or the rulers. The
mouse can now be used to select
and perform operations on objects
such as regions, markers etc.
This is the most common mode to
work in, as it allows you to
select and move regions, as well
as modify automation points on
the automation tracks.
\\
\hline
Range Mode
&
When in Range Mode, the mouse
pointer appears as a vertical
line whenever it is over the
track canvas or the rulers. The
mouse will now be able to select
a point or range of time. Time
ranges can be selected over one
or several tracks, depending on
the selection of your tracks.
If none of your tracks are
selected, the Range Tool will
operate on all the session track
visualized in the Editor.
If you want to edit only
particular tracks, select them
before you apply the range tool.
\\
\hline
Cut Tool Mode
&
When in Cut Tool Mode, the mouse
pointer appears as a pair of
scissors whenever it is over the
track canvas or the rulers. This
tools allows to cut any region
into 2 regions at the mouse
cursor, regardless of the Edit
Point.
If one or more track(s) is
selected, then all the regions on
these tracks will be split at the
mouse cursor position.
If no track is selected, then
only the region hovered by the
mouse cursor will be split.
\\
\hline
Stretch Mode
&
When in time fx mode, the mouse
pointer appears as a distinctive
expanding square symbol whenever
it is over the track canvas or
the rulers. This mode is used to
resize regions using a
timestretch algorithm. Click on
an edge of a region of audio and
drag it one way or the other to
stretch or shrink the region.
\\
\hline
Audition Tool
&
Clicking a region using the
audition tool will play this
region to the control room
outputs.
You can also scrub with this tool
by clicking and dragging in the
direction you wish to listen. The
amount you drag in one direction
or the other will determine the
playback speed.
\\
\hline
Draw Tool
&
When in Draw Tool mode, the mouse
pointer will change to a pencil.
You can then click within an
audio region to change the gain
envelope for that region. This
curve is separate from fader
automation for individual tracks.
It will remain locked to the
region’s time, so if the region
is moved, the region gain
envelope is moved along with it.
The draw tool works on automation
too, allowing the creation and
modification of control points on
the automation curves.
Last, it is used on a MIDI region
to edit the notes.
\\
\hline
Internal/Region Edit Mode
&
When in Internal Edit mode, the
mouse pointer will change to
cross-hairs. This tool acts on
region gain and automation as the
Draw tool.
On a MIDI region, it allows to
lasso-select multiple notes at a
time.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\subsubsection*{20 - Controls}
\subsubsection*{20.1 - Zoom Controls}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{toolbar-zoom}.png}
\caption{Editor toolbar’s zoom}\label{\detokenize{index:id498}}\end{figure}

The zoom controls allow to navigate the session along both the time and
track axes.

The drop down Zoom Focus menu allows to select a focus point for the
zoom, i.e. the center of the zoom. The choices are:
\begin{itemize}
\item {} 
Left of the screen

\item {} 
Right of the screen

\item {} 
Center of the screen

\item {} 
Playhead

\item {} 
Mouse

\item {} 
Edit Point as set in the {\hyperref[\detokenize{index:edit-point-control}]{\emph{Edit point}}}
control.

\end{itemize}

The two leftmost zoom buttons (− and +) use this zoom focus to zoom out
and in respectively.

The Zoom to session button is a handy shortcut to zoom out or in until
all the session (as defined by its {\hyperref[\detokenize{index:working-with-markers}]{\emph{start/end
markers}}}) fits horizontally.

Changing the Number of visible tracks dropdown menu allows to fit this
number of tracks vertically in the screen.

There \sphinxstyleemphasis{is} a minimal track height to keep it visible, so according to
you screen vertical size, some high number can have no effect.

Inside this menu are two handy choices:
\begin{itemize}
\item {} 
Selected tracks that focus on the selected tracks. If the selected
tracks are not contiguous, the unselected tracks inbetween will be
hidden, see the {\hyperref[\detokenize{index:the-tracks-and-busses-list}]{\emph{Track and Bus list}}}.

\item {} 
All that fits all the tracks of the sessions vertically (provided
there’s enough screen estate).

\end{itemize}

The rightmost buttons Shrink tracks and Expand tracks reduce or expand
the vertical size of the selected tracks. If no track is selected, all
the tracks will be shrunk or expanded each time the button is pushed.
\subsubsection*{20.2 - Grid Controls}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{toolbar-grid}.png}
\caption{Editor toolbar’s grid.}\label{\detokenize{index:id499}}\end{figure}

Ardour’s editor utilizes a grid to assist in the placement of regions on
the timeline, or with editing functions that need to happen at a
specific point in time. This snapping of the cursor and various objects
to the grid can be toggled on or off, as does its behaviour, and grid
units.
\subsubsection*{About Snapping}

There are two ways to think about aligning material to a grid. The first
and most obvious one is where an object’s position is clamped to grid
lines. In Ardour, this is called absolute snap and is commonly used when
working with sampled material where audio begins exactly at the
beginning of a file, note or region.

The second, relative snap, is used when an object’s position relative to
the grid lines is important. In music, this allows to move objects
around without changing the “feel” (or timing) of a performance.

Absolute snap is the default method of snapping in Ardour.

While dragging objects, pressing the absolute snap modifier key(s)
switches from absolute to relative snap.

The snap can also be entirely disabled by using the snap modifier (see
below).

Note that in relative snap mode the reference point is taken to be the
distance to the nearest grid line.

Note also that when an object lies exactly on a grid line, there will be
no difference between relative and absolute snap modes.

The relative snap and snap modifiers (along with other modifier keys)
may be set in Edit \textgreater{} Preferences \textgreater{} User Interaction

For common use patterns, it is recommended to assign a unique key for
one snap modifier and two keys for the other in such a way that they
share an otherwise unused key. For example, the snap modifier may be
chosen to be the key and the relative snap modifier to be the and keys.
\subsubsection*{Snap Modes}

Using the above modifications, Ardour supports three different modes of
snapping to the grid:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

No Grid
&
disables the grid. All objects
move freely in this mode. In No
Grid mode, the grid may be
temporarily activated by pressing
the snap modifier (for absolute
snap) or switch to relative snap
by pressing the relative snap
modifier.
\\
\hline
Grid
&
activates normal snapping. All
positions of objects snap to the
grid. (See {\hyperref[\detokenize{index:gridunits}]{\emph{Grid
Units}}} below to
change the grid). Moving an
object in “Grid”-mode, does not
change its position until the
mouse is far enough for the
object to reach the next grid
line. To maintain an objects’
position relative to the grid
line, the “snap relative”
modifier can be used. When
holding down this modifier during
a drag, the dragged object will
jump while maintaining its
original distance from the line.
New objects will always be
created at grid points. Holding
down the snap modifier will
disable the current grid setting
and allow moving the object
freely.
\\
\hline
Magnetic
&
is a less strict type of
snapping. Objects can still be
moved to any position, but
positions close to the relative
or absolute grid points will
snap. In order to move an object
very close to a snap point, it
may be necessary to zoom in to
prevent snapping to that point,
or to use the snap modifier to
disable snap completely. As with
Grid mode, the snap modifier will
disable snap completely while the
absolute snap modifier will move
the “notch” of Magnetic snap to
the grid lines.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\subsubsection*{Syncing Regions to the Grid}

By default, a region’s beginning will be used as the reference for both
types of snapping, this behaviour can be changed by setting a sync point
in the region, by selecting the region(s) and pressing V. This will set
the sync point to the current {\hyperref[\detokenize{index:edit-point-control}]{\emph{edit point}}}.
\subsubsection*{Grid Units}

The selector next to the grid mode selector defines the size of the grid
elements. The grid can be set to several different units:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

CD Frames
&
A CD Frame is 1/75th of a second.
Snapping to CD Frames (using
absolute snap) can be used to
avoid issues with CD track
lengths.
\\
\hline
Timecode Frames/Seconds/Minutes
&
The duration of a frame depends
on the timecode settings for the
session.
\\
\hline
Seconds/Minutes
&
These are absolute time units,
unaffected by sample rate or
timecode settings
\\
\hline
Beats/N
&
Set the grid to units of 1/N
beats, where N can be 128, 64,
32, 16, 8, 7, 6, 5, 4, 3, 2. The
duration of a grid unit will
depend on the tempo and meter in
effect at that point in the
timeline.
\\
\hline
Beats
&
Set the grid to whole beats. The
duration of a grid unit will
depend on the tempo and meter in
effect at that point in the
timeline.
\\
\hline
Bars
&
Set the grid to whole bars. The
duration of a grid unit will
depend on the tempo and meter in
effect at that point in the
timeline.
\\
\hline
Markers
&
The grid lines are the markers.
\\
\hline
Region Starts
&
The grid lines are constructed
from region start points (see
below).
\\
\hline
Region Ends
&
The grid lines are constructed
from region end points (see
below).
\\
\hline
Region Syncs
&
The grid lines are constructed
from region sync points.
\\
\hline
Region Bounds
&
The grid lines are constructed
from region start or end points.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

To use Region starts/ends/syncs/bounds as snap choices, it is necessary
to have either:
\begin{itemize}
\item {} 
\sphinxstyleemphasis{No} tracks selected, which means that Ardour snaps to regions on any
track, or

\item {} 
Several tracks selected, which means that Ardour only snaps to
regions on those selected tracks.

\end{itemize}

If items are moved on a track, and only the current track is selected,
then snapping will only happen with other regions on the same track.
This means that enabling Edit \textgreater{} Preferences \textgreater{} Editor \textgreater{} Link Selections
of Regions and Tracks will make the “Region” grid unit unusable. This
option should not be used in conjunction with the use any of the Region
grid units.
\subsubsection*{20.3 - Edit Point Control}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{toolbar-editpoint}.png}
\caption{Editor toolbar’s Edit Point}\label{\detokenize{index:id500}}\end{figure}

Editing operations in a Digital Audio Workstation like Ardour can be
broken down according to how many points on the timeline are required to
carry the operation out. Splitting a region for example, requires just
one position on the timeline (the one where the split will happen).
Cutting out a time range requires two positions, one for the start of
the cut and one for the end.

In Ardour the edit point is the location where most single-point editing
operations take place. It can be set to either of the following:
\begin{itemize}
\item {} 
the Playhead position

\item {} 
the selected (or “active”) Marker

\item {} 
the position of the Mouse (or touch) pointer

\end{itemize}

The default edit point is the location of the pointer.

There are two keybindings available to cycle through the edit point
options. The most common workflow tends to involve switching back and
forth between the playhead and mouse as the edit point. Pressing the
grave accent key {}` switches between these two. Using {}` cycles through
all three choices (including the selected marker). The edit point can
also be switched using the combo-selector just right of the snap/grid
unit selector.
\subsubsection*{20.4 - Nudge Controls}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{toolbar-nudge}.png}
\caption{Editor toolbar’s Nudge}\label{\detokenize{index:id501}}\end{figure}

The nudge controls will move the selected region(s) by a fixed amount of
time. The left and right buttons move either backward or forward in
time, and the small clock to the left of these buttons sets the amount
of time to nudge by. As with all other clocks, you can right-click on
the clock to choose the time representation you want to use.

If there are no selected objects, the nudge controls can be used to move
the playhead backward or forward by the amount shown on the clock.
\subsubsection*{21 - Ruler}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{ruler}.png}
\caption{Ardour’s Ruler}\label{\detokenize{index:id502}}\end{figure}

The Ruler scales the session along time, allows navigating, and can be
marked for different uses.

One of its main uses is to move the playhead: clicking anywhere on the
timeline will bring the playhead at this location in time. Also, using
the mouse’s scrollwheel while hovering the Ruler will zoom in or out
(⇑/⇓ ).

The Ruler is made of a succession of rows, each having a special role
related to time. Adding or removing rows can be done by right clicking
anywhere in the ruler’s header on the left, and ticking any of:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

Mins:Secs
&
scaling the session with the
Mins:Secs:mSec notation
\\
\hline
Timecode
&
scaling the session with the
Hours:Mins:Secs:Frames notation
\\
\hline
Samples
&
scaling the session with the
sample number notation
\\
\hline
Bars:Beats
&
slicing the time according to the
time signature of the Meter
\\
\hline
Meter
&
shows the time signature. It can
be changed along the timeline, by
Right click \textgreater{} New Meter. The
Bars:Beats ruler will reflect the
change.
\\
\hline
Tempo
&
shows the BPM. It can be changed
along the timeline, by Right
click \textgreater{} New Tempo. The Bars:Beats
ruler will reflect the change.
\\
\hline
Range Markers
&
allow to create and modify ranges
directly on the Ruler.
\\
\hline
Loop/Punch Ranges
&
are special kind of ranges
designed to be played as a loop
and to do punch recording, i.e.
recording on a precise section of
time, respectively.
\\
\hline
CD Markers
&
are markers designed to be used
while creating a recording that
has to be split in time, as an
audio CD
\\
\hline
Location Markers
&
is meant to receive any kind of
marker, user generated or from
Ardour itself.
\\
\hline
Video Timeline
&
shows thumbnails of the
{\hyperref[\detokenize{index:video-timeline-and-monitoring}]{\emph{video}}}
in the timeline
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

Most of the operations on the markers are described in {\hyperref[\detokenize{index:working-with-markers}]{\emph{Working with
Markers}}}, while the Meter, Tempo, Bars:Beats
and Timecode use are described in {\hyperref[\detokenize{index:tempo-and-meter}]{\emph{Tempo and
Meter}}}.
\subsubsection*{22 - Summary}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{summary}.png}
\caption{Ardour’s Summary}\label{\detokenize{index:id503}}\end{figure}

The Summary is a global overview of the session, allowing for a good
“bird’s eye” view of where in time and tracks the work happens.

Each horizontal line represents a track in the session, with the colored
bars being the audio and MIDI regions, colored as per their track’s
color setting.

Two yellow vertical lines show the position of the \sphinxstyleemphasis{Start} and \sphinxstyleemphasis{End}
markers, defining the session’s length. The red line shows the
playhead’s position.

The transparent white rectangle represents what’s actually displayed in
the Editor window, i.e. what part of the session is being looked at on
screen.

The Summary also doubles as a navigator:
\begin{itemize}
\item {} 
the arrow on the left allow to scroll the view horizontally to the
left, by 1 length of the view each time

\item {} 
the arrow on the right allow to scroll the view horizontally to the
right, by 1 length of the view each time

\item {} 
the white rectangle can be dragged anywhere on the session, moving
the view accordingly

\item {} 
the right and left borders of the white square can be resized,
zooming in and out accordingly

\end{itemize}
\subsubsection*{23 - Editor Lists}

At the right hand side of the editor window is an optional area which
provides one of a range of useful lists of parts of the session. It is
not shown by default when first starting using Ardour. The Editor list
can be hidden or shown using View \textgreater{} Show Editor List. The very
right-hand side of the list gives a selection of tabs which are used to
choose the list to view. The left-hand border of the list can be dragged
to vary the width of the list.
\subsubsection*{23.1 - The Region List}

The region list shows all the regions in the session. The left-hand
column gives the region name, and there are a range of times given for
information:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

Position
&
position of the start of the
region on the global timeline
\\
\hline
End
&
position of the region on the
global timeline
\\
\hline
Length
&
duration of the region
\\
\hline
Sync
&
position of the sync point,
relative to the start of region
(can be negative)
\\
\hline
Fade In
&
duration of the fade in. Can’t be
less than 1 ms, to avoid
clipping.
\\
\hline
Fade Out
&
duration of the fade out
(positive value, ≥ 1 ms).
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

The secondary clock defines the time unit used in this list. {\hyperref[\detokenize{index:editing-clocks}]{\emph{Set the
secondary clock}}} to the type of unit desired.

At the right of the list are four columns of flags that can be altered:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

L
&
whether the region position is
locked, so that it cannot be
moved.
\\
\hline
G
&
whether the region’s position is
‘glued’ to bars and beats. If so,
the region will stay at the same
position in bars and beats even
if the tempo and/or time
signature change.
\\
\hline
M
&
whether the region is muted, so
that it will not be heard.
\\
\hline
O
&
whether the region is opaque;
opaque regions ‘block’ regions
below them from being heard,
whereas ‘transparent’ regions
have their contents mixed with
whatever is underneath.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

Hovering the mouse pointer over a column heading shows a tool-tip which
can be handy to remember what the columns are for.

A handy feature of the region list is that its regions can be dragged
and dropped into a suitable track in the session.
\subsubsection*{23.2 - The Tracks and Busses List}

This lists the tracks and busses that are present in the session. The
list order reflects the order in the editor, and track or bus names can
be dragged-and-dropped in the editor list to re-order them in the
editor. The columns in the list represent the following:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

V
&
whether the track or bus is
visible; they can be hidden, in
which case they will still play,
but just not be visible in the
editor; this can be useful for
keeping the display uncluttered.
\\
\hline
A
&
whether the track or bus is
active; inactive tracks will not
play, and will not consume any
CPU.
\\
\hline
I
&
for MIDI tracks, whether the MIDI
input is enabled; this dictates
whether MIDI data from the
track’s input ports will be
passed through the track.
\\
\hline
R
&
whether the track is
record-enabled.
\\
\hline
RS
&
whether the track is record safe;
a record safe track cannot be
armed for recording, to protect
against a mistake.
\\
\hline
M
&
whether the track is muted.
\\
\hline
S
&
track solo state.
\\
\hline
SI
&
track solo-isolated state.
\\
\hline
SS
&
solo safe state.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

Each icon in these columns can be clicked to toggle the track/bus state,
which is a very fast way to set multiple tracks/busses state at once.

As with the region list, hovering the mouse pointer over a column
heading shows a tool-tip which can be handy to remember what the columns
are for.
\subsubsection*{23.3 - The Snapshot List}

This list gives the snapshots that exist of this session. Clicking on a
snapshot name will load that snapshot.

See {\hyperref[\detokenize{index:snapshots}]{\emph{Snapshots}}} for more information on snapshots.
\subsubsection*{23.4 - The Track and Bus Group List}

This shows the track/bus groups that exist in the session. These groups
allow related tracks to share various properties (such as mute or record
enable state). For full details, see the section called {\hyperref[\detokenize{index:the-track-and-bus-group-list}]{\emph{Track and Bus
Groups}}}.

The columns in this list are as follows:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

Col
&
the colour that the group uses for its tab in the editor.
\\
\hline
Name
&
the group name.
\\
\hline
V
&
whether the tracks and busses in the group are visible.
\\
\hline
On
&
whether the group is enabled.
\\
\hline
G
&
ticked if the constituents of the group are sharing gain settings.
\\
\hline
Rel
&
ticked if shared gains are relative.
\\
\hline
M
&
ticked if the constituents share mute status.
\\
\hline
S
&
ticked if the constituents share solo status.
\\
\hline
Rec
&
ticked if the constituents share record-enable status.
\\
\hline
Mon
&
whether the constituents share monitor settings.
\\
\hline
Sel
&
whether the constituents are selected together.
\\
\hline
A
&
whether the constituents share active status.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\subsubsection*{23.5 - The Ranges and Marks Lists}

The Ranges \& Marks List is a tab in the Editor Lists area on the right
of the Editor window. If the editor list area isn’t visible it can be
enabled by checking View \textgreater{} Show Editor List. The Ranges \& Marks list can
be used as a single point of control for all range and location markers
(including the punch and loop ranges), or as a supplement to other
methods of working with them.
\subsubsection*{Common elements}

Each section has a set of editable {\hyperref[\detokenize{index:editing-clocks}]{\emph{clock widgets}}}
which display the location of a marker, or the start, end, and duration
times of a range, respectively.

The Use PH buttons allows to set the corresponding clock to the current
playhead position. A Middle click on any of the clocks will move the
playhead to that location. Both functions are also available from the
clock context menus.

Right clicking on any of the clocks brings up a context menu that allows
changing of the display between Timecode, Bars:Beats, Minutes:Seconds,
and Samples.

The — (subtract) button in front of each user-defined range or marker in
the list allows that particular item to be removed. The name fields of
custom ranges and markers can be edited.

The Hide checkboxes make markers and ranges invisible on the respective
ruler to reduce visual clutter; the markers remain active however, and
can be used normally.

Selecting Lock prevents the respective marker from being moved until
unlocked. Where applicable, Glue fixes the marker position relative to
the current musical position expressed in bars and beats, rather than
the absolute time. This will make the respective marker follow changes
in the tempo map.

At the bottom of the list are buttons to add new markers or ranges.
\subsubsection*{List sections}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

Loop/Punch Ranges
&
This list shows the current loop
and punch range settings. Since
these are built-in ranges, they
cannot be renamed or removed.
\\
\hline
Markers (Including CD Index)
&
This section lists the session’s
markers. By ticking CD, Ardour is
instructed to create a CD track
index from this marker, which
will be included in the TOC or
CUE file when exporting.
\\
\hline
Ranges (Including CD Track
Ranges)
&
This is the list of ranges
(including CD track ranges).
Ticking CD will convert the range
to a CD track, which will again
be included in exported TOC or
CUE files. This is relevant for
Disk-At-Once recordings that may
contain audio data between
tracks.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\subsubsection*{24 - Favorite Plugins Window}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{favorite-plugins}.png}
\caption{The Favorite Plugins window.}\label{\detokenize{index:id504}}\end{figure}

The Favorite Plugins window is on the top-left side of the Mixer Window.
Like other elements in that window it has variable height and can be
hidden by dragging it to zero-height. If it is not visible, the
top-handle can be grabbed and dragged down to reveal it.

Plugin names that have a right facing triangle next to them have presets
associated with them; clicking on the triangle will cause all presets
associated with the plugin to show in the list.
\subsubsection*{Features}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{mixer-to-fav-dnd}.png}
\caption{Dragging a plugin to the window.}\label{\detokenize{index:id505}}\end{figure}

The Favorite Plugins window provides easy access to frequently used
plugins:
\begin{itemize}
\item {} 
Plugins can be dragged from the window to any track or bus {\hyperref[\detokenize{index:processor-box}]{\emph{processor
box}}}, which will add the plugin to that track or
bus at the given position.

\item {} 
The list includes user-presets for the plugins. Dragging a preset to
a given track or bus will load that preset after adding the plugin.

\item {} 
Double-clicking on a plugin or preset adds the given plugin to all
selected tracks/busses pre-fader. Other insert positions are
available from the context menu (right click).

\item {} 
Dragging a plugin from a track into the window will add it to the
list and optionally create a new preset from the current settings.
The horizontal line in the list shows the spot where the plugin will
land.

\item {} 
The context-menu allows the deletion of presets or removal of the
plugin from the list.

\item {} 
Plugins in the list can be re-ordered using drag \& drop. The custom
order is saved.

\end{itemize}

When favorites are added with the {\hyperref[\detokenize{index:plugin-manager}]{\emph{Plugin Manager}}},
they are appended to the bottom of the list.
\subsubsection*{25 - Strips list}

The Strips List is a quick way to manage big sessions, with lots of
tracks, where the mixer would otherwise be too crowded.

It is a list of all the tracks, busses and VCA in the session, with a
tick to allow for hiding or showing them. This visibility status also
affects the Editor view, and is exactly the same as toggling the V
checkbox in the {\hyperref[\detokenize{index:the-tracks-and-busses-list}]{\emph{Tracks and Busses}}}
panel of the Editor List.

Dragging and dropping tracks inside the Strips List allows to reorganise
the tracks in the session, both in the Mixer and the Editor. Clicking a
track scrolls the Mixer to show this track.

It is possible, by right clicking, to act on multiple tracks at once:
\begin{itemize}
\item {} 
Show All

\item {} 
Hide All

\item {} 
Show All Audio Tracks

\item {} 
Hide All Audio Tracks

\item {} 
Show All Audio Busses

\item {} 
Hide All Audio Busses

\item {} 
Show All MIDI Tracks

\item {} 
Hide All MIDI Tracks

\end{itemize}

The + button under the list is a shortcut to create a new track, bus or
VCA, as in clicking Track \textgreater{} Add Track, Bus or VCA….
\subsubsection*{26 - Groups list}

The Groups List allows to quickly manage the
{\hyperref[\detokenize{index:the-track-and-bus-group-list}]{\emph{groups}}} of the session, and make use
of them.

Each group has a Show checkbox to quickly toggle their visibility.
Clicking an already selected group allows to rename it.

The context menu, reached by right clicking a group, allows for multiple
mixing actions:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|*{2}{\X{1}{2}|}}
\hline

Create New Group From…
&
Creates a new group based on some
track properties. The choice is:
\begin{itemize}
\item {} 
Selection… to create a group
of all selected tracks

\item {} 
Record Enabled… to create a
group of all the tracks that
are record enabled

\item {} 
Soloed… to create a group of
all the soloed tracks

\end{itemize}
\\
\hline
Create New Group with Master
From…
&
Acts exactly as the previous
choice, but also creates a
Control Master tied to these
tracks.
\\
\hline
Assign Selection to Control
Master…
&
Allows to link all the selected
tracks to a chosen Control
Master, whether or not they
belong to a group.
\\
\hline
Assign Record Enabled to Control
Master…
&
Allows to link all the record
armed tracks to a chosen Control
Master.
\\
\hline
Assign Soloed to Control Master…
&
Allows to link all the soloed
tracks to a chosen Control
Master.
\\
\hline
Enable All Groups
&
Enable all the groups, i.e. their
selected properties are
synchronized.
\\
\hline
Disable All Groups
&
Disable all the groups, i.e.
changing a property in a track
won’t affect the others.
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}

When a group is selected, right clicking it adds the following menu
entries:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

Create New Group with Master
From…
&
Acts exactly as the previous
choice, but also creates a
Control Master tied to these
tracks.
\\
\hline
Edit Group…
&
Shows the Track/bus Group
{\hyperref[\detokenize{index:the-track-and-bus-group-list}]{\emph{window}}}.
\\
\hline
Collect Group
&
Rearranges the tracks/busses
order to visually group together
the tracks belonging to the same
group.
\\
\hline
Remove Group
&
Deletes the group (but not the
tracks/busses belonging to this
group).
\\
\hline
Assign Group to Control Master…
&
Allows to link all the tracks in
the group to a chosen VCA.
\\
\hline
Add/Remove Subgroup Bus
&
Creates/removes a new bus
connected to the Master, and send
the output of all the tracks in
the group to this new bus.
\\
\hline
Add New Aux Bus (pre/post-fader)
&
Creates a new bus connected to
the Master, and create {\hyperref[\detokenize{index:aux-sends}]{\emph{Aux
Sends}}} (pre or
post-fader) in all the tracks in
the group to this new bus.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

The + button under the list allows the creation of an (empty) group,
while the − button deletes the selected group (but not the tracks in
this group).
\subsubsection*{27 - Mixer Strips}
\subsubsection*{27.1 - Audio/MIDI Mixer Strips}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{mixer-1-strip-numbered}.png}
\caption{A mixer strip}\label{\detokenize{index:id506}}\end{figure}

A mixer strip in Ardour is a vertical view of the track, from a mixing
point of view. This view is convenient to deal with I/O, effects,
panning/muting, gain, etc… It has a general “top to bottom” flow.

The mixer strips breaks down into:
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
Header

\item {} 
Track name

\item {} 
Input(s)

\item {} 
Polarity \sphinxstyleemphasis{only for audio tracks}

\item {} 
Processor box

\item {} 
Panner

\item {} 
Recording options

\item {} 
Mute/Solo

\item {} 
Gain \& Meter

\item {} 
Control master

\item {} 
Fader automation/mix group/metering point

\item {} 
Output(s)

\item {} 
Comments

\end{enumerate}
\subsubsection*{Headers}

At the top of the window, is the {\hyperref[\detokenize{index:the-track-and-bus-group-list}]{\emph{group
tabs}}} (here, \sphinxstyleemphasis{recm…}). This allows to
group tracks together for common controls.

Bellow are 3 buttons:
\begin{itemize}
\item {} 
The double arrow button allows to shrink/expand the width of the
strip. Click the button will shrink/expand all the tracks at once

\item {} 
The color bar shows the color of the track in the editor

\item {} 
The X button toggles the visibility of the track OFF. To turn it back
ON, one can either go to the {\hyperref[\detokenize{index:the-tracks-and-busses-list}]{\emph{Tracks and Busses
list}}} in the Editor view and check
the “V” column on the track’s line or stay in the Mixer view and
check the Show column of this strip in the {\hyperref[\detokenize{index:strips-list}]{\emph{Strips
list}}}.

\end{itemize}

Right clicking on the color bar will bring up a context menu, which is
exactly the same as clicking on the Track name button.
\subsubsection*{Track Name}

Clicking the Track name button will bring up a menu:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

Color…
&
Changes the strip/track color
\\
\hline
Comments…
&
Shows an editor to put comments
about the track, see below the
Comments button
\\
\hline
Inputs…
&
Shows the Routing grid for the
inputs of the track
\\
\hline
Outputs…
&
Shows the Routing grid for the
outputs of the track
\\
\hline
Save As Template…
&
Allows to save the track without
its media content (I/O,
effects,…) for later reuse
\\
\hline
Rename…
&
Changes the name of the track
(effective both in the Mixer and
the Editor)
\\
\hline
Active
&
Select the active status of the
track. An inactive track won’t
output any sound
\\
\hline
Strict I/O
&
While in {\hyperref[\detokenize{index:trackbus-signal-flow}]{\emph{patchbayStrict
I/O}}}
mode, a track \sphinxstyleemphasis{always} has as
many output as it has inputs,
regardless of the effects. When
disabled, a stereo effect put on
a mono track will result in a
stereo output for the strip.
\\
\hline
Pin Connections…
&
Shows the Pin Configuration
window, that shows (and allows to
modify) all the signal flows
inside the track
\\
\hline
Adjust Latency…
&
Shows the Track Latency dialog,
that allows fine-tune the latency
to the track, in samples, msec or
period
\\
\hline
Protect Against Denormals
&
Uses a trick to get rid of
\sphinxstyleemphasis{denormals}, which are very small
numbers the CPU can have a hard
time dealing with. To be used if
the CPU consumption for plugins
is noticeably higher than
expected
\\
\hline
Duplicate…
&
Copies the track to a new one,
optionally with its playlist
\\
\hline
Remove
&
Deletes the track and its
playlist
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\subsubsection*{Inputs}

The dropdown button shows the current input port(s), i.e. what’s plugged
to the “in” of the track. By default, each audio track is connected to
the system inputs, ready for recording, as shown by the number(s).
Clicking the dropdown Inputs button will allow to change the inputs,
through a menu:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

Disconnect
&
Disconnects everything, i.e. the
track has no input
\\
\hline
In \sphinxstyleemphasis{n}
&
Those are the system inputs, e.g.
to record from the soundcard. A
mono track will have \sphinxstyleemphasis{In 1} and
\sphinxstyleemphasis{In 2} separated, while a stereo
track can have \sphinxstyleemphasis{In 1+2}
\\
\hline
\sphinxstyleemphasis{Track n output}
&
All the outputs of compatible
tracks, e.g., a mono track can
only receive a mono signal, a
MIDI track can only receive MIDI
signal, …
\\
\hline
Add Audio Port
&
Adds an audio input to the track,
i.e. a mono audio track becomes a
stereo one
\\
\hline
Add MIDI Port
&
Adds a MIDI input to the track.
Adding it to an audio track makes
it a mixed Audio/MIDI track. This
can be useful e.g. to feed some
plugins with a MIDI signal to
control the audio, like a vocoder
\\
\hline
Routing Grid
&
Shows the {\hyperref[\detokenize{index:patchbay}]{\emph{Routing Grid
window}}}, which
allows for more complex input
configuration
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

The Routing Grid can also be shown by right clicking the dropdown Inputs
button. It allows to make the connections through a matrix, and connect
things that are not listed in the menu above, or connect to multiple
sources at once, reduce the number of inputs, etc…

On audio tracks, is a Trim knob, as on traditional consoles. It set the
base input level for the track, avoiding any clipping. Notice that it
trims both any input, but (when playing back), also the level of the
playlist as displayed in the Editor. It makes sense as while playing,
the input of the track is the playlist, on which the mixer strip acts.

On midi tracks, it is replaced by a MIDI Input button, that
allows/disallows MIDI input on the track.
\subsubsection*{Polarity}

On audio tracks only, the Polarity button(s), 1 per input, allow to
reverse the signal, i.e. a negative value will be positive and
vice-versa. This can help deal with phasing issues.
\subsubsection*{Processor box}

The processor box is where the effects are added. By default, one effect
is always present: the Fader (see below). The effects can be added
\sphinxstyleemphasis{pre}-fader and appear in brown, or \sphinxstyleemphasis{post}-fader, where they will appear
in dark green. The signal flow is represented by lines, red for the MIDI
and green for the audio.

It is also where the {\hyperref[\detokenize{index:aux-sends}]{\emph{Sends}}} come from, whether external
or auxiliary.

To learn more about the processor box, see {\hyperref[\detokenize{index:processor-box}]{\emph{The Processor
Box}}}.
\subsubsection*{Panner}

The Panner visually displays how the sound will be distributed between
the different outputs. They’ll look and behave differently if the track
is mono, stereo, or has multiple channels.

Right clicking the Panner will show a menu:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

Bypass
&
When checked, the panner is
grayed, and the signal is not
affected by it
\\
\hline
Reset
&
Resets the panner to its default
settings, e.g. for a mono signal,
it is centered
\\
\hline
Edit…
&
Shows a Panner dialog, which
allows for fine tuning of the
panner
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

See {\hyperref[\detokenize{index:panning}]{\emph{Panning}}} to learn more about how to control the
panner, and what kind of panners are available inside Ardour.
\subsubsection*{Recording options}

The most noticeable button here is the Record Enable one, with a red
circle. When enabled, next time the Global record will be armed and
playback started, everything that comes from the input of the track will
be recorded. Right clicking a disabled record button allows to enable
Rec-Safe, thus protecting the track against accidental recording.

The buttons on the right, In and Disk, show what the user is listening
to by lighting up, between the \sphinxstyleemphasis{In}put and the actual content of the
playlist on \sphinxstyleemphasis{Disk}.

They also allow to override the automatic switching by pressing them to
lock one source or the other to be what the user is hearing.
\subsubsection*{Mute/Solo}

These buttons allow to Mute (or silence) the track, or Solo them,
shutting down the gain of the other tracks (totally by default, can be
set to partially in the options). See {\hyperref[\detokenize{index:muting-and-soloing}]{\emph{Muting and
Soloing}}} for more information.

Notice that by default, Solo overrides Mute, i.e. if a track is both
Soloed and Muted, it will play. That can be changed in the preferences.

The two led button above are related to solo:
\begin{itemize}
\item {} 
Solo Isolate, as the name suggests, isolates tracks or busses from
the solo system. When tracks or busses are soloed the isolated ones
will not mute.

\item {} 
Solo Lock locks the solo into its current state (i.e. solo on or solo
off). It will not allow the solo state to be changed until the lock
is released.

\end{itemize}
\subsubsection*{Gain \& Meter}

On the right of this part is a {\hyperref[\detokenize{index:metering-in-ardour}]{\emph{Meter}}},
displaying the level of the track’s output after the fader. In can be
set to display the signal at any point, see below \sphinxstyleemphasis{Metering Point}.
Right clicking this meter shows a menu allowing to switch the meter
type.

The big Gain slider on the left allows to change the gain of the track.
Its default OdB value is reminded with a white horizontal line, and its
precise value is shown in a text field above it, that doubles as a way
to type in a numeric value.

The text field above the meter shows the “Peak”, i.e. the maximum value
that has been reached during playback. To avoid distortion, the value
should stay below OdB, and if it goes above this value, the text field
will turn red. Clicking on this field will reset the Peak value (for a
new measurement or a new part of the track).

Notice that if any gain automation has been set and the automation state
is set on “Play” (see below), then the Gain fader is driven by the
automation, and not by the user. The Gain fader will turn grey to show
it is inactive.
\subsubsection*{VCAs}

If at least one {\hyperref[\detokenize{index:control-masters-mixer-strips}]{\emph{VCA}}} exists, this
button will show up, allowing the user to link this track to any control
master.

Clicking the button lists all the available control masters, and a menu
option to Unassign all. Notice that a track can be a slave to as many
VCAs as they are in the session, hence multiplying the number of VCA
buttons. The displayed number is the number of the VCA, not the count of
VCAs linked to the track. A track with no VCA assigned will show a
unique button with a “-vca-” label instead of this number.
\subsubsection*{Fader automation/mix group/metering point}
\subsubsection*{Fader automation mode}

This button allows to choose the mode used regarding automation:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

Manual
&
\sphinxstyleemphasis{(default)} The playback won’t
use the fader automation data
\\
\hline
Play
&
Enables playback/use of fader
automation data
\\
\hline
Write
&
While the transport is rolling,
all fader changes will be
recorded to the fader automation
lane
\\
\hline
Touch
&
While the transport is rolling,
touching the fader will initiate
recording all fader changes until
the fader is released. When the
fader is not being touched,
existing automation data will be
played/used to control the gain
level.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\subsubsection*{Mix group}

This button displays the mix group information as does the tab in the
header (see above). It is convenient though, as it allows to quickly
switch the track from one group to another with a drop down menu, also
allowing to affect the track to a non-adjacent group (which the tab
won’t easily allow).
\subsubsection*{Metering Point}

The metering displayed in the meter is by default is ‘Post’, i.e. Post
fader. It can be changed with this button to Any point of the signal
flow:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

In
&
The input of the track
\\
\hline
Pre
&
Pre-fader
\\
\hline
Post
&
Post-fader
\\
\hline
Out
&
The output of the track
\\
\hline
Custom
&
A \sphinxstyleemphasis{Meter} processor is added to
the processor box and can be set
anywhere (by dragging and
dropping) to probe the signal
flow at that point
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\subsubsection*{Output(s)}

This button is exactly the same as the \sphinxstyleemphasis{Input} button, but applies to
the \sphinxstyleemphasis{output} of the track.
\subsubsection*{Comments}

This buttons open up a little text editor, that can be used to add some
written notes to the track, as e.g. a particular setting. The button’s
caption is replaced by the beginning of the text, so it can be used as a
“sub” name for the track.
\subsubsection*{27.2 - Audio/MIDI Busses Mixer Strips}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{bus-mixer-strip}.png}
\caption{A bus mixer strip}\label{\detokenize{index:id507}}\end{figure}

An Ardour bus can be considered a virtual track, as in a track that
doesn’t have a playlist (so, no regions). Its use is to “group” some
audio signals to be treated the same way. One simple use case is to
group all the audio tracks containing the different drums of a drum kit.
Routing all the drum tracks’ outputs to a bus allows, once the different
levels amongst the drums have been set, to adjust the global level of
the drum kit in the mix.

Bus usage goes way beyond this simple example though: busses, as tracks,
can receive plugins for common audio treatment, and be routed themselves
as needed. This makes for a very useful tool that is very commonly used
both for musical purposes and computing ones: instead of using e.g. ten
discrete delay plugins on ten different tracks, busses are often used as
receivers of {\hyperref[\detokenize{index:aux-sends}]{\emph{sends}}}, and only one delay plugin is used
on this bus, reducing the processing power needed.

Audio Busses vs MIDI Busses
Ardour supports two types of busses: Audio and MIDI. A MIDI bus differs
from an audio bus just by:
\begin{itemize}
\item {} 
its input (which is midi, as shown by the red signal lines in the
processor box) instead of \sphinxstyleemphasis{n} audio

\item {} 
the fact that an instrument can be placed on it at creation time,
whereas it can’t easily be done for an audio bus

\item {} 
as for tracks, the MIDI bus doesn’t have a trim knob or invert phase
button(s).

\end{itemize}

MIDI busses provide a particularly efficient workflow for virtual drum
kits where the arrangement uses different MIDI tracks. Moreover, busses
with both Audio and MIDI inputs are well suited for vocoders and similar
plugins, where a MIDI signal controls an audio one.

Adding any audio input to a MIDI bus transforms it into an audio bus.
\subsubsection*{Description}

Busses look and behave exactly like tracks, so they share nearly {\hyperref[\detokenize{index:audiomidi-mixer-strips}]{\emph{all of
their controls}}}. The differences are:
\begin{itemize}
\item {} 
as the busses don’t have a playlist (and cannot host any media), they
can’t be recorded on. The recording controls are not present

\item {} 
an Aux button replaces these controls.

\end{itemize}

Clicking the Aux button makes every track that sends a signal to this
bus through {\hyperref[\detokenize{index:aux-sends}]{\emph{Aux sends}}} blink in turquoise. Right
clicking this button brings up a menu:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

Assign all tracks (prefader)
&
Creates an Aux Send in every
track, to this bus. The send is
placed just before the fader
\\
\hline
Assign all tracks and busses
(prefader)
&
Creates an Aux Send in every
track and every bus, to this bus.
The send is placed just before
the fader
\\
\hline
Assign all tracks (postfader)
&
Same as above, but the send is
placed just after the fader
\\
\hline
Assign all tracks and busses
(postfader)
&
Same as above, with tracks and
busses
\\
\hline
Assign selected tracks (prefader)
&
Same as for all tracks, but only
applies to the selected tracks
\\
\hline
Assign selected tracks and busses
(prefader)
&
Same as for all tracks and
busses, but only applies to the
selected tracks and busses
\\
\hline
Assign selected tracks
(postfader)
&
Same as above, but the send is
placed just after the fader
\\
\hline
Assign selected tracks and busses
(postfader)
&
Same as above, with tracks and
busses
\\
\hline
Set sends gain to -inf
&
For all the sends to this bus,
put the send fader to −\(\infty\) so no
signal is sent
\\
\hline
Set sends gain to 0dB
&
For all the sends to this bus,
put the send fader at the default
position, 0dB (100\% of th signal
is sent)
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\subsubsection*{Connecting a track to a bus}

Depending on the user’s workflow and the way busses are used, two
possibilities exists:
\subsubsection*{Connecting a track to a bus via its outputs}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{connecting_bus_output}.png}
\caption{Connecting a bus through a track’s outputs}\label{\detokenize{index:id508}}\end{figure}

Connecting the output(s) of a track to the input(s) of the bus sends
\sphinxstyleemphasis{all} the audio/MIDI to the bus. In the mixer strip, select (at the
bottom) the OUTPUT button (often, by default, “Master”), and in the
list, choose the input of a bus. Note that only the bus able to receive
this output will show up, e.g. a mono bus won’t be able to be connected
to the output of a stereo track).

Obviously, doing so will (by default) disconnect the output from the
Master’s input, which means all the audio/MIDI will be routed to the
bus. For more complex routing, the OUTPUT button allows to show the
Routing Grid that allows to plug the output of the track to multiple
outputs at once, be it busses, tracks, Master… The button will then
reflect these multiple connections by showing a \sphinxstyleemphasis{*number*}, number
being the number of connections made in the routing grid.
\subsubsection*{Connecting a track to a bus via Sends}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{connecting_bus_send}.png}
\caption{Connecting a bus through a send}\label{\detokenize{index:id509}}\end{figure}

This allows not to interrupt the natural flow of the signal, i.e. the
track will still output to what its connected to (e.g. Master). The
signal is “tapped” at the point of insertion of the send, to be sent to
the bus, by right clicking where in the signal flow the signal should be
tapped, and selecting New Aux Send… \textgreater{} name\_of\_the\_bus.

By left-clicking the send meter, it is possible to adjust the amount of
signal sent to the bus. This is often the way tracks are connected to an
effect bus, like a Delay bus.

Busses can be plugged to other busses, through outputs or sends. Both
example workflows discussed previously, i.e. busses for grouping tracks
and busses for effects, can both coexist, as e.g. a “grouping” drum bus
can have a send to a reverb bus, and be connected to a compressor bus.
\subsubsection*{27.3 - VCA Mixer Strips}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{vca-numbered}.png}
\caption{A VCA mixer strip}\label{\detokenize{index:id510}}\end{figure}

Although track/bus {\hyperref[\detokenize{index:the-track-and-bus-group-list}]{\emph{groups}}} offer a
certain kind of grouped-control over gain, solo, mute and more,
traditional mixing consoles have long had group master channels (“VCAs”)
which allows to combine both a single fader to control the group level
while also allowing to easily adjust the relative levels inside the
group. For large projects, this can make mixing much easier to control.

Ardour implements those VCAs in a way that allows to use either or both
of the conventions used on different traditional consoles for combining
multiple masters:
\begin{itemize}
\item {} 
Nest VCAs (VCA 2 controls VCA 1 etc.)

\item {} 
Chain VCAs (VCA 1 and VCA 2 both control track or bus \sphinxstyleemphasis{N})

\end{itemize}
\subsubsection*{Description of the VCAs}

A VCA strip is made of (from top to bottom in the screenshot):
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
Number of the VCA

\item {} 
X button: Allows to hide the VCA strip. Left clicking this button
toggles the exclusive visibility of the tracks connected to this VCA

\item {} 
Name button

\item {} 
M: mutes the VCA, S: solos the VCA

\item {} 
Level meter: allows to adjust the level of the VCA

\item {} 
\textasciitilde{}vca\textasciitilde{}: a VCA button to optionally connect to another VCA

\end{enumerate}

Right-clicking the name button shows a context menus comprised of:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

Rename
&
Renames the VCA
\\
\hline
Color…
&
Changes the color of the VCA
button in the tracks connected to
this one
\\
\hline
Drop All Slaves
&
Deletes all connections to this
VCA, i.e. no tracks are
controlled by this VCA anymore
\\
\hline
Remove
&
Deletes this VCA
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\subsubsection*{Connecting to a VCA strip}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{connecting_to_vca}.png}
\caption{Connecting to a VCA}\label{\detokenize{index:id511}}\end{figure}

Connecting a track/bus/VCA to a VCA is as simple as clicking the VCA
button that appears on any mixer strip under the main fader and choosing
the VCA to connect to.

The VCA button only shows up in mixer strips when at least one VCA
exists, i.e., a VCA must be created \sphinxstyleemphasis{before} connecting tracks to it.

Clicking the VCA button shows all the VCAs in the session, and any or
all of this VCA can be checked to link them to the track, making this
track controlled by multiple VCAs. The track will then show multiple
buttons. Disconnecting a VCA from a track is done by unchecking this VCA
in the list that pops up, or clicking Unassign All to disconnect from
all VCAs at once.
\subsubsection*{27.4 - Master Bus Strip}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{master-strip}.png}
\caption{The Master strip in the mixer}\label{\detokenize{index:id512}}\end{figure}

The Master strip in Ardour is very similar to the other busses mixer
strips. The list of differences is (from top to bottom):
\begin{itemize}
\item {} 
There is no color affected to the master strip

\item {} 
The master strip cannot be hidden, so there is not X in the top right

\item {} 
It is by definition always solo, so no Solo, Iso or Lock buttons. It
is replaced by a button to show the Monitoring section if {\hyperref[\detokenize{index:monitoring-tab}]{\emph{the
session has one}}}

\item {} 
It cannot belong to a mix group, so the button is removed.

\end{itemize}

The Master bus strip is \sphinxstyleemphasis{always} fixed, at the right end of the mixer,
regardless of the scrolling position.
\subsubsection*{28 - Editor Tracks}
\subsubsection*{28.1 - Audio Track Controls}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{typical-audio-track-controls}.png}
\caption{An audio track header section}\label{\detokenize{index:id513}}\end{figure}

At the top-left of the controls is the name of the track, which can be
edited by double-clicking on it. The new name must be unique within the
session.

Underneath the name is the track’s main level fader. Changing it will
affect the whole track :
\begin{itemize}
\item {} 
dragging will change the fader’s value as per the mouse’s position

\item {} 
clicking will set the fader to −\(\infty\)

\item {} 
clicking will reset the fader to its original 0dB position.

\end{itemize}

On the right-hand side of the headers are level meters for the outputs
of the track (1 level per output).

The control buttons are:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

● (Record)
&
The button with the pink circle
arms the track for recording.
When armed, the entire button
will turn pink, and change to
bright red as soon as the
transport is rolling and the
track is recording. Right
clicking will allow to en/disable
Rec-safe, protecting the track
against accidental recording.
\\
\hline
M (Mute)
&
Mutes the track. Right clicking
displays a menu which dictates
what particular parts of the
track should be muted.
\\
\hline
S (Solo)
&
Soloes the track. The behaviour
of the solo system is described
in detail in the section {\hyperref[\detokenize{index:muting-and-soloing}]{\emph{Muting
and
Soloing}}}.
Right clicking will allow to
en/disable Solo isolate and Solo
safe.
\\
\hline
P (Playlist)
&
Opens a playlist menu when
clicked. The menu offers various
operations related to the track’s
{\hyperref[\detokenize{index:playlists}]{\emph{playlist}}}.
\\
\hline
A (Automation)
&
Opens the automation menu for the
track. For details see
{\hyperref[\detokenize{index:automation}]{\emph{Automation}}}.
\\
\hline
G (Group)
&
Allows to assign the track to an
existing or a new group. For
details see {\hyperref[\detokenize{index:track-and-bus-groups}]{\emph{Track and bus
groups}}}
.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\subsubsection*{28.2 - MIDI Track Controls}

A typical MIDI track header looks like this:

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{typical-midi-track-controls}.png}
\caption{A MIDI track header}\label{\detokenize{index:id514}}\end{figure}

To show the full set of MIDI track controls, the {\hyperref[\detokenize{index:track-height}]{\emph{track
height}}} must be increased beyond the default. MIDI
tracks show only a few of the control elements when there is
insufficient vertical space.

A MIDI track has the same basic controls as an {\hyperref[\detokenize{index:audio-track-controls}]{\emph{audio
track}}}, with the addition of three extra
elements:
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
Some meters for the track’s outputs (MIDI in red, Audio in green)

\item {} 
The Scroomer, a zoom and scroll controller for the midi notes range

\item {} 
When the track is tall enough, the External MIDI Device selection
dropdown appears.

\end{enumerate}

Also, right clicking the ● (record) button shows the {\hyperref[\detokenize{index:step-entry}]{\emph{Step
Entry}}} dialog instead of controlling the rec-safe.
\subsubsection*{The Scroomer}

The Scroomer performs a couple of functions:
\begin{itemize}
\item {} 
The scrollbar controls the range of pitches that are visible on the
track, as visualized by the piano keyboard. Dragging the body of the
scrollbar up and down displays higher or lower pitches.

\item {} 
Dragging the scrollbar handles zooms in and out and increases or
decreases the range of visible pitches.

\item {} 
Double clicking the scrollbar auto-adjusts the zooms to make the
range of visible pitches fit the actual content of the track.

\item {} 
Clicking on the piano plays the corresponding MIDI note for
reference.

\end{itemize}
\subsubsection*{Channel and patch selection}
\subsubsection*{The Channel Selector}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{midi_channel_control}.png}
\caption{The MIDI channel control window}\label{\detokenize{index:id515}}\end{figure}

A MIDI track’s data may span any number of the 16 available MIDI
channels, and sometimes it is useful to view only a subset of those
channels; different instruments may, for example, be put on different
channels. In the context menu (right click), the Channel Selector allows
to control the MIDI channel(s) that will be visible in the editor.

This window also gives control over which channel(s) will be recorded,
and which will be played back, choosing between:
\begin{itemize}
\item {} 
All channels

\item {} 
Only selected channels —Ardour then proposes to choose amongst the 16
channels which are to be recorded/played

\item {} 
Force all to one channel —Ardour then ‘routes’ all the channels to
one user selectable channel.

\end{itemize}
\subsubsection*{The Patch Selector}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{patch_selector}.png}
\caption{The Patch Selector window}\label{\detokenize{index:id516}}\end{figure}

The Patch Selector window is an easy way to set which instrument will be
used on any of the MIDI channels. Although patches can be changed at any
time using a {\hyperref[\detokenize{index:patch-change}]{\emph{patch change}}}, this dialog provides an
easy and convenient way to preview patches in software and hardware
instruments. It integrates fully with Ardour’s support for MIDNAM (patch
definition files), so Ardour can display named programs/patches for both
General MIDI synths and those with MIDNAM files.

The window itself makes it easy to choose a channel, a bank number,
optionally choosing a bank number through its MSB and LSB numbers (CC\#00
and CC\#32) for large banks, then choosing an instrument.

The keyboard at the bottom of the window allows for a quick preview of
the selected instrument, either automatically (using the buttons on top
of the keyboard) or manually by either clicking a note or using the
computer keyboard as a piano keyboard.

To edit the contents of a MIDI track see {\hyperref[\detokenize{index:edit-midi}]{\emph{MIDI Editing}}}.
\subsubsection*{28.3 - Bus Controls}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{typical-bus-controls}.png}
\caption{A bus header section}\label{\detokenize{index:id517}}\end{figure}

The bus’ header is very similar to the {\hyperref[\detokenize{index:audio-track-controls}]{\emph{audio track
header}}}, minus :
\begin{itemize}
\item {} 
the playlist button, as a bus doesn’t have any playlists or regions
by itself, it is only a pipe to route audio or midi through

\item {} 
the record button, for the same reason.

\end{itemize}

For more information about the bus concept, see {\hyperref[\detokenize{index:understanding-basic-concepts-and-terminology}]{\emph{Understanding basic
concepts}}}.
\subsubsection*{29 - Track and Bus Groups}

Tracks and busses can be put into groups. Members of a group can share
various settings—useful for managing tracks that are closely related to
each other. Examples might include tracks that contain
multiple-microphone recordings of a single source (an acoustic guitar,
perhaps, or a drum kit).

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{track-in-group}.png}
\caption{Track headers for a group}\label{\detokenize{index:id518}}\end{figure}

Tracks and busses can be grouped in various ways. In the editor window,
a track’s controls might look like the adjacent image.

The green tab to the left of the track header indicates that this track
is in a group called Fred. These tabs can be dragged to add adjacent
tracks to a group.
\subsubsection*{Create New Groups}

There are several ways to create groups for tracks and busses:
\begin{itemize}
\item {} 
Right-clicking on the group tab and using one of the Create… options
there. A group can be created with no members, or one that starts
with the currently selected tracks, or record-enabled tracks, or
soloed tracks.

\item {} 
Alternatively, clicking the g button on a track header to open the
Group menu. The menu lists the available groups. Selecting one of
these groups will add the track or bus to that group. The menu also
allows creating a new group.

\item {} 
Finally, the {\hyperref[\detokenize{index:groups-list}]{\emph{Groups list}}} has a plus (+) button at
the bottom of the list that can be clicked on to create a new group.

\end{itemize}
\subsubsection*{Remove Groups}

Context-clicking on a group tab and selecting Remove Group from the menu
removes it. Removing a group does \sphinxstyleemphasis{not} remove the members of a group.

Groups can also be removed by selecting them in the {\hyperref[\detokenize{index:groups-list}]{\emph{Groups
list}}} and then pressing the minus (−) button at the
bottom of the list.
\subsubsection*{Add/Remove Tracks and Busses From a Group}

Clicking the g button displays a menu with a list of the available
groups. Selecting one of these groups adds the track or bus to that
group. Selecting No Group removes it.

Alternatively, a group tab can be dragged to add or remove tracks from
the group.
\subsubsection*{Activate/Deactivate Groups via the Group Tab}

Clicking on a group tab toggles the group between being active and
inactive. An inactive group has no effect when editing its members. An
active group will share its configured properties across its members.
Tabs for disabled groups are coloured grey.
\subsubsection*{Modify Group Properties}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{route-group-dialogue}.png}
\caption{The Track/bus Group dialog}\label{\detokenize{index:id519}}\end{figure}

Edit the properties of a group is done by right-clicking on its tab and
choosing Edit Group…. This opens the track/bus group dialog, which is
also used when creating new groups.
\subsubsection*{Group Color}

Clicking on the color selector button changes a group’s color. This
affects the color of the group’s tab in the editor and mixer windows.
The color does \sphinxstyleemphasis{not} affect the color of the group members unless the
shared Color property is enabled.
\subsubsection*{Shared Properties}

Gain means that the track faders will be synced to always have the same
value; Relative means that the gain changes are applied relative to each
member’s current value. If, for example, there are two tracks in a group
with relative gain sharing, and their faders are set to −3 dB and −1 dB,
a change of the first track to a gain of −6 dB will result in the second
track having a gain of −4 dB (the \sphinxstyleemphasis{difference} of the gains remains the
same).

{\hyperref[\detokenize{index:bus-controls}]{\emph{Muting}}}, {\hyperref[\detokenize{index:bus-controls}]{\emph{Soloing}}}, {\hyperref[\detokenize{index:audio-track-controls}]{\emph{record
enable}}}, {\hyperref[\detokenize{index:the-tracks-and-busses-list}]{\emph{active
state}}}, {\hyperref[\detokenize{index:track-color}]{\emph{color}}} and
{\hyperref[\detokenize{index:monitoring}]{\emph{monitoring}}} are all straightforward. They simply mean
that all member tracks or busses will share the same settings in these
respects.

Selection means that if a region is selected or deselected on one member
track, {\hyperref[\detokenize{index:corresponding-regions-selection}]{\emph{corresponding regions}}} on
other member tracks will be similarly selected. Since region editing
operations are applied to all currently selected regions, this is the
way to make edits apply across all tracks in the group.
\subsubsection*{Group Tab Context Menu}

Context-clicking on the group tab offers a further menu of group-related
actions.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

Create a New Group
&
create a new group
\\
\hline
Create New Group from…
&
create a new group and
automatically add …
\\
\hline
Selected
&
all currently selected tracks and
busses
\\
\hline
Rec-enabled
&
all currently record-enabled
tracks
\\
\hline
Soloed
&
all currently soloed tracks and
busses
\\
\hline
Collect Group
&
moves all the member tracks so
that they are together in the
editor window
\\
\hline
Remove Group
&
removes the group (and only the
group, not its members).
\\
\hline
Add New Subgroup Bus
&
creates a bus (giving it the name
of the group) and connects the
output of each member to the new
bus.
\\
\hline
Add New Aux Bus
&
adds a bus and gives each member
a send to that bus. There are two
options for this, specifying
whether the sends should be
placed pre- or post-fader.
\\
\hline
Fit to Window
&
will zoom the member tracks so
that they fill the editor window.
\\
\hline
Enable All Groups
&
makes all group active, including
any hidden groups.
\\
\hline
Disable All Groups
&
makes all groups inactive,
including any hidden groups.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\subsubsection*{30 - Monitor Section}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{monitoring-strip}.png}
\caption{The Monitoring strip}\label{\detokenize{index:id520}}\end{figure}

The Monitor section is an optional feature that provides Control
Room/Monitor Speaker outputs. It can be activated for the current
session in the {\hyperref[\detokenize{index:monitoring-tab}]{\emph{Session \textgreater{} Properties window}}} by
enabling the Use monitor section in this session option in the
Monitoring tab. By default the Monitor Section is fed with audio from
the Master Bus, but depending on solo mode and other functions such as
Auditioning, other audio sources may be temporarily heard instead.

The Monitor section appears on the right hand side of the Mixer, and
comprises:
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
Detach/attach control. This separates the Monitor section into its
own floating window

\item {} 
Status indicators for important functions

\item {} 
Solo behaviour selection

\item {} 
Show, hide and status of the Monitor Sections inline processors

\item {} 
Level controls for solo functionality

\item {} 
Level control for Monitor Dim

\item {} 
Individual monitor path controls

\item {} 
Mute, Dim and Mono functions for the monitor outputs

\item {} 
Monitor level control

\item {} 
Monitor output routing

\end{enumerate}
\subsubsection*{Status Indicators}

The Status indicators, two of which also appear in {\hyperref[\detokenize{index:about-ardours-interface}]{\emph{the Transport tool
bar}}}, flash to indicate when that function
is in operation:
\begin{itemize}
\item {} 
Soloing: This indicates when one or more tracks or busses are
currently being soloed. See {\hyperref[\detokenize{index:muting-and-soloing}]{\emph{Muting and
Soloing}}}. Clicking on this indicator cancels
all currently soloed channels or busses

\item {} 
Auditioning: This indicates when an audio file is being listened to
directly, e.g. when using the import dialogue, or using the Audition
context menu in the {\hyperref[\detokenize{index:the-region-list}]{\emph{Regions List}}}. Clicking
this indicator cancels the current audition

\item {} 
Isolated: This indicates when one or more tracks or busses are solo
isolated. See {\hyperref[\detokenize{index:muting-and-soloing}]{\emph{Muting and Soloing}}}. Clicking
on this indicator cancels any current isolation.

\end{itemize}
\subsubsection*{Solo behaviour selection}

The SiP, PFL and AFL controls inter-cancel with each other and select
the desired Solo mode. Excl. Solo and Solo Mute then modify the modes
behaviour. See {\hyperref[\detokenize{index:muting-and-soloing}]{\emph{Muting and Soloing}}}. The current
mode is indicated by the illuminated ‘LED’ on the button.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

SiP
&
This selects \sphinxstyleemphasis{Solo In Place} as
the current solo mode and cancels
the previous mode.
\\
\hline
PFL
&
This selects \sphinxstyleemphasis{Pre Fade Listen} as
the current solo mode and cancels
the previous mode.
\\
\hline
AFL
&
This selects \sphinxstyleemphasis{After Fade Listen}
as the current solo mode and
cancels the previous mode.
\\
\hline
Excl. Solo
&
This enables or disables the
\sphinxstyleemphasis{Exclusive Solo} option.
\\
\hline
Solo » Mute
&
This enables or disables the
\sphinxstyleemphasis{Solo Mute} option.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

Changing the solo mode (SiP, PFL or AFL) will update the labels on the
mixer strips’ solo controls accordingly.
\subsubsection*{The Processors button}

Clicking the Processors button show or hides the Monitor Sections
processor box. This is used in the same way as processor boxes present
in {\hyperref[\detokenize{index:audiomidi-mixer-strips}]{\emph{tracks}}} and
{\hyperref[\detokenize{index:audiomidi-busses-mixer-strips}]{\emph{busses}}}. It can be used to insert
plugins, e.g. a room correction EQ or a specific metering type.

As this processing is local to the Monitor Section it is only applied to
audio that is ultimately available at the monitor outputs.
\subsubsection*{Solo level controls}

These controls set the level of the audio when a channel or bus solo is
engaged.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

Solo Boost
&
This is the level that will be
added to the current main monitor
level when a track or bus is
soloed, providing a convenient
boost in level for the isolated
signal. The rotary control has a
range of 0dB to +10dB and can be
set at any point between these
two values. A drop down menu with
pre-defined values is also
provided for convenience.
\\
\hline
SiP Cut
&
Only relevant to Solo in Place
mode. This sets the level that
all muted tracks or busses will
be muted by. By default it is
-\&infinity; i.e. the non soloed
tracks are totally inaudible. The
level can be raised to make the
other tracks audible, though
dimmed. This is also sometimes
referred to \sphinxstyleemphasis{Solo in Front}. The
rotary control has a range of
-inf to +0dB and can be set at
any point between these two
values. A drop down menu with
pre-defined values is also
provided for convenience.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\subsubsection*{Dim level control}

The Dim level control sets the amount by which the monitoring will be
reduced when a Dim button is engaged. The rotary control has a range of
-20dB to 0dB and can be set at any point between these two values. A
drop down menu with pre-defined values is also provided for convenience.
\subsubsection*{Monitor path controls}

Each of the individual paths through the Monitor Section, (e.g. L and R
for stereo), can be controlled individually. Four functions are
available:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

Mute
&
Mutes the selected path(s)
\\
\hline
Dim
&
Reduces the selected path(s)
level by the amount set with the
Dim level control
\\
\hline
Solo
&
Solos the selected channel(s)
\\
\hline
Inv
&
Inverts the selected channel(s)
polarity
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\subsubsection*{Global Monitor controls}

Those buttons directly affect the output of the monitoring section:
\begin{itemize}
\item {} 
Mono: sums all of the paths to a single mono signal and applies it to
all Monitor Section outputs.

\item {} 
Dim: Reduces overall monitor level by the amount set with the Dim
level control.

\item {} 
Mute: Mutes all monitoring.

\end{itemize}
\subsubsection*{Global Monitor level}

This control sets the level for Monitor Section output. The rotary
control has a range of -inf to +6dB and can be set at any point between
these two values. A drop down menu with pre-defined values is also
provided for convenience.
\subsubsection*{Monitoring Output routing}

Clicking on this button shows a menu that allows quick and convenient
routing of the Monitor Section’s outputs to audio hardware outputs, e.g.
to feed control room monitors. It also has an option to open Ardour’s
routing matrix, where more detailed connectivity is available if routing
to something other than hardware is required.
\subsubsection*{Part IV - Sessions \& Tracks}
\subsubsection*{31 - Sessions}
\subsubsection*{31.1 - What’s in a Session?}

The Session is the fundamental document type that is created and
modified by the Ardour workstation. A Session is a folder on a computer
filesystem that contains all the items that pertain to a particular
project or “recording/editing/mixing session”.

The Session folder includes these files and folders:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{session\_name.ardour}} the main session snapshot

\item {} 
\sphinxcode{\sphinxupquote{*.ardour}}, any additional snapshots

\item {} 
\sphinxcode{\sphinxupquote{session\_name.ardour.bak}}, the auto-backup snapshot

\item {} 
\sphinxcode{\sphinxupquote{session\_name.history}}, the undo history for the session

\item {} 
\sphinxcode{\sphinxupquote{instant.xml}}, which records the last-used zoom scale and other
metadata

\item {} 
\sphinxcode{\sphinxupquote{interchange/}}, a folder which holds the raw audio and MIDI files
(whether imported or recorded)

\item {} 
\sphinxcode{\sphinxupquote{export/}}, a folder which contains any files created by the Session
\textgreater{} Export function

\item {} 
\sphinxcode{\sphinxupquote{peaks/}}, a folder which contains waveform renderings of all audio
files in the session

\item {} 
\sphinxcode{\sphinxupquote{analysis/}}, a folder which contains transient and pitch
information of each audio file that has been analysed

\item {} 
\sphinxcode{\sphinxupquote{dead sounds/}}, a folder which contains sound files which Ardour
has detected are no longer used in the session (during a Session \textgreater{}
Clean-up \textgreater{} Clean-up Unused Sources operation, will be purged by Flush
Waste Basket, see {\hyperref[\detokenize{index:cleaning-up-sessions}]{\emph{Cleaning Up Sessions}}})

\end{itemize}

A session combines some setup information (such as audio and MIDI
routing, musical tempo \& meter, timecode synchronization, etc.) with one
or more Tracks and Buses, and all the Regions and Plug-Ins they contain.
\subsubsection*{31.2 - Where Are Sessions Stored?}

Sessions are stored in a single folder on the computer’s filesystem. The
first time Ardour is run, it will ask for the default location for this
folder, with the initial choice being the current user’s home folder.

After the first-run dialog, the default location can still be changed at
any time via Edit \textgreater{} Preferences \textgreater{} Misc \textgreater{} Session Management. A
particular (different) location for a session can also be specified when
creating it, in the {\hyperref[\detokenize{index:newopen-session-dialog}]{\emph{New Session dialog}}}.
\subsubsection*{31.3 - New/Open Session Dialog}

The initial Session dialog, displayed at each start of Ardour, consists
of several consecutive pages:
\subsubsection*{Open Session Page}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{session_setup}.png}
\caption{The Session Setup Dialog}\label{\detokenize{index:id521}}\end{figure}

On this page, an existing session can be opened. Any
{\hyperref[\detokenize{index:snapshots}]{\emph{snapshot}}} of a particular session can also be accessed
by clicking on the arrow next to the session name to display all
snapshots, and then selecting one.

If the session is not displayed in the Recent Sessions list, the Other
Sessions button will bring up a file selection dialog to navigate the
file system.

Alternatively, a New Session can be created.
\subsubsection*{New Session page}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{session_new}.png}
\caption{The New Session Dialog}\label{\detokenize{index:id522}}\end{figure}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{template_setup}.png}
\caption{One of the Template Setup Dialogs}\label{\detokenize{index:id523}}\end{figure}

This page allows to type in the name of a session, select a folder to
save it in, and optionally use an existing
{\hyperref[\detokenize{index:session-templates}]{\emph{template}}}.

The different templates, both the “factory” ones and the ones created by
the user, are easily available on the left-side panel. Depending on the
chosen template, a specific Template Settings window may be shown,
allowing the user to fine-tune the details of the template and/or choose
between the different options of the template.

Templates can be huge time savers when working on similar projects, or
on usual projects, as they allow to preset and tweak a lot of the
{\hyperref[\detokenize{index:session-properties-dialog}]{\emph{session properties}}}, (like the
availability of a {\hyperref[\detokenize{index:monitor-section}]{\emph{monitoring section}}}, connection
to a Master Bus, etc.), and handle the creation of
{\hyperref[\detokenize{index:adding-tracks-busses-and-vcas}]{\emph{tracks}}} of any kind.

The Empty Template preset allows to create a session “from scratch”.
Everything a session template does can be done manually —albeit more
tediously— and the resulting sessions will not differ whatsoever.

As of Ardour 5.12, which introduced the new template dialog, the factory
templates are:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

Empty Template
&
Creates an empty session with no
tracks and no monitoring. A
stereo Master Bus is created, and
any track created defaults to
output on this bus.
\\
\hline
Advanced Session
&
Like the Empty Template, but adds
the ability to easily manage the
Master bus (channels, hardware
connection, and track
autoconnection), and the creation
of a monitoring section.
\\
\hline
Recording Session
&
Like the Empty Template, but
allows the fast creation of a
number of tracks, optionally
ready to record.
\\
\hline
Live Band
&
Fast tracks the creation of usual
tracks for a band setup (vocals,
guitars, piano, …), and
optionally adds usual effects on
these tracks.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

Selecting a template will display its description in the right-side
panel, while hovering over a template name will show a tooltip
indicating if it is a factory template, or, if it is a user-created one,
which version of Ardour was used to create it.

Whether or not a template is used, and before the “Template Setup”
dialog, the Audio/MIDI Setup will be shown.
\subsubsection*{Audio/MIDI Setup}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{Audio-MIDI_Setup}.png}
\caption{The Audio/MIDI Setup Dialog}\label{\detokenize{index:id524}}\end{figure}

This window exposes the different audio options to be used by Ardour for
the current work session, for hardware and software and is made of:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

Audio System
&
Depending on the operating
system, Ardour can possibly use
different audio systems, e.g. on
Linux, both ALSA and JACK are
available.
\\
\hline
Driver
&
On Mac OS X this will typically
be CoreAudio. On Linux usually
this will be either FFADO or
ALSA, depending on whether or not
a firewire device is used.
Advanced users on all platforms
may also use NetJack which
provides network audio I/O.
\\
\hline
Device
&
The selector should show all
available interfaces provided by
the driver above and which are
capable of duplex operation.
When using an Intel Mac running
OS X and the builtin audio
interface, its separate input and
output devices must be
{\hyperref[\detokenize{index:using-more-than-one-audio-device}]{\emph{merged}}}
first into a single “aggregate
device” before Ardour will be
able to use it.
\\
\hline
Sample Rate
&
The selector will allow to select
from any sample rate supported by
the device selected above it.
\\
\hline
Buffer Size
&
The size of the buffer used by
the audio interface can be
adjusted to allow for either
lower latency, or lower CPU usage
and higher latency.
\\
\hline
Input/Output Channels
&
Specifies the number of hardware
channels to use. The default is
all available channels.
\\
\hline
Hardware Input/Output Latency
&
Specify the hardware delay in
samples for precise latency
compensation.
\\
\hline
Calibrate
&
This button runs a semi-automated
guided process to obtain precise
hardware latency measurements for
the above option.
\\
\hline
MIDI System
&
Selects the MIDI driver to use.
On Mac OS X, this will be
CoreMIDI. On Linux, it can be
changed between two legacy ALSA
drivers or the (preferred) new
JACK+ALSA implementation.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\subsubsection*{31.4 - Renaming a Session}

Using the Session \textgreater{} Rename menu allows to give the session a new name. A
dialog will appear asking for the new one.

This operation does \sphinxstylestrong{not} make a new session folder—the existing
session folder and relevant contents are renamed. If the session was not
saved before a rename operation, it will be saved automatically and then
renaming will continue.

Ardour’s Session \textgreater{} Save As operation will not make a new copy of the
session folder and its contents. All it does is create a new session
file.
\subsubsection*{31.5 - Session Metadata}
\subsubsection*{Session Metadata}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{edit-session-metadata}.png}
\caption{The session metadata editor}\label{\detokenize{index:id525}}\end{figure}

Sessions can have various items of metadata attached to them, and saved
in the session file. These metadata are filled by the user via Session \textgreater{}
Metadata \textgreater{} Edit Metadata….

These metadata will be exported as tags in the audio and video files
that support it, as long as the right option is chosen at the
{\hyperref[\detokenize{index:export-dialog}]{\emph{export}}} stage. All the video format can retain a
subset of the metadata if the Include Session Metadata is checked in the
{\hyperref[\detokenize{index:workflow-amp-operations}]{\emph{export video}}} window, while only the
Ogg-Vorbis (tagged) and FLAC (tagged) audio format will be exported with
the metadata (as Vorbis comment).

Ardour can also reuse the metadata from another session file in the
current session, with Session \textgreater{} Metadata \textgreater{} Import Metadata…. This menu
brings up a file selector, asking for the source ardour session file to
extract the data from. This can be handy when reusing a lot of
information (Author, Artist Name, etc…) or working on multiple tracks of
the same media.
\subsubsection*{31.6 - Backup and Sharing of Sessions}

An Ardour session is stored in a single folder on the computer’s
filesystem. This makes backup very easy: any tool capable of backing up
a folder can be used to backup a session. The location of a session is
picked when it is created —by default it will be in the default session
location, which can be altered via Edit \textgreater{} Preferences \textgreater{} General \textgreater{}
Session.

The single folder approach also makes sharing a project easy. Simply
copy the session folder (onto a storage device, or across a network) and
another Ardour user (on any platform) will be able to use it.

There is one complication in both cases: a session may reference media
files that are stored outside of the session folder, if the user has
opted not to select Session \textgreater{} Import \textgreater{} Copy to Session during import.
Backing up a session with embedded files will not create a copy of the
session containing those files. To bring those external files to the
session folder, the {\hyperref[\detokenize{index:cleaning-up-sessions}]{\emph{Session \textgreater{} Clean-up \textgreater{} Bring all media into session
folder menu}}} can be used.
\subsubsection*{Using the dedicated Zip/Archive Current Session tool}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{archive-session}.png}
\caption{The Zip/Archive Current Session window}\label{\detokenize{index:id526}}\end{figure}

The Zip/Archive Current Session tool is located in the File \textgreater{} Archive…
menu.

It allows to create a single file containing everything useful in the
session, to share it or back it up, conveniently compressed to a
session-archive which is a zip-file (tar.xz to be specific) containing
all the audio, MIDI, plugin-settings,… and the currently active
session. Ardour can also extract those bundles (Session \textgreater{} Open…).

As opposed to zipping the entire session-folder manually,
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
the session-archive only contains the current session-snapshot and
only files which are used

\item {} 
externally referenced files are included in the archive.

\end{enumerate}

The window shows the following options:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

Archive Name
&
The name of the archive file,
defaulting to the name of the
session followed by the date and
time
\\
\hline
a dropdown extension selector
&
allowing to choose between
different kind or compressed
archive file types
\\
\hline
Target directory/folder
&
defining where in the filesystem
the archive file will be
generated
\\
\hline
Audio Compression
&
a dropdown menu allowing to
compress the audio files
themselves by using an
audio-tailored compression
format, more on that below
\\
\hline
Exclude unused audio sources
&
a checkbox to drop every audio
that is in the session, but not
actually used in the editor
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

The Audio Compression selection accepts any of:
\begin{itemize}
\item {} 
None

\item {} 
FLAC 16bit

\item {} 
FLAC 24bit

\end{itemize}

Encoding the audio sources to FLAC allows for a good size reduction of
the session. It should be noted though that FLAC is a fixed-point
format, meaning that if the audio in the session is in a floating-point
format, this conversion will lose some information on the samples values
that are rounded, though usually, this lost information cannot be
perceived. Choosing “\sphinxstyleemphasis{None}” for Audio Compression does not compress the
audio to FLAC, hence preserving the floating-point data at the cost of a
bigger file size. Notice also that converting to FLAC automatically
normalizes the audio.

Using the Exclude unused audio sources option allows to only keep the
files actually used in the session, which can be useful to leave any
unused take or reference material out of the backup, reducing the
archive’s global file size.
\subsubsection*{32 - Tracks}
\subsubsection*{32.1 - Track Types}

Ardour offers three track types depending on the type of data they
contain, and differentiates between three track modes, depending on
their recording behaviour.
\subsubsection*{Track types}

An Ardour track can be of type audio or MIDI, depending on the data that
the track will primarily record and play back. \sphinxstyleemphasis{However, either type of
track can pass either type of data.} Hence, for example, one might have
a MIDI track that contains an instrument plugin; such a track would
record and play back MIDI data from disk but would produce audio, since
the instrument plugin would turn MIDI data into audio data.

Nevertheless, when adding tracks to a session, its content is typically
known, and Ardour offers three choices:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

Audio
&
An Audio Track is created with a
user-specified number of inputs.
The number of outputs is defined
by the master bus channel count
(for details see {\hyperref[\detokenize{index:channelconfiguration}]{\emph{Channel
Configuration}}}
below). This is the type of track
to use when planning to work with
existing or newly recorded audio.
\\
\hline
MIDI
&
A MIDI track is created with a
single MIDI input, and a single
MIDI output. This is the type of
track to use when planning to
record and play back MIDI. There
are several methods to enable
playback of a MIDI track: add an
instrument plugin to the track,
connect the track to a software
synthesizer, or connect it to
external MIDI hardware.
If an instrument plugin is added,
the MIDI track outputs audio
alongside MIDI data.
\\
\hline
Audio/MIDI
&
There are a few notable plugins
that can usefully accept both
Audio and MIDI data (Reaktor is
one, and various “auto-tune” like
plugins are another). It can be
tricky to configure this type of
track manually, so Ardour allows
to select this type specifically
for use with such plugins. It is
\sphinxstyleemphasis{not} generally the right choice
when working normal MIDI tracks,
and a dialog will warn of this.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\subsubsection*{Track Modes}

Audio tracks in Ardour have a mode which affects how they behave when
recording:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

Normal
&
Tracks in normal mode will record
non-destructively—new data is
written to new files, and when
overdubbing, new regions will be
layered on top of existing ones.
This is the recommended mode for
most workflows.
\\
\hline
Non-Layered
&
Tracks using non-layered mode
will record non-destructively—new
data is written to new files, but
when overdubbing, the existing
regions are trimmed so that there
are no overlaps. This does not
affect the previously recorded
audio data, and trimmed regions
can be expanded again at will.
Non-layered mode can be very
useful for spoken word material,
especially in combination with
{\hyperref[\detokenize{index:pushpull-trimming}]{\emph{push/pull
trimming}}}.
\\
\hline
Tape
&
Tape-mode tracks do
\sphinxstylestrong{destructive} recording: all
data is recorded to a single file
and if a section of existing data
is overdub, the existing data is
destroyed irrevocably—there is no
undo. Fixed crossfades are added
at every punch in and out point.
This mode can be useful for
certain kinds of re-recording
workflows, but is not suggested
for normal use.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{a3_nonlayered_example}.png}
\caption{Normal and non-layered overdubbing comparision}\label{\detokenize{index:id527}}\end{figure}

The screenshot on the right shows the subtle difference between an
overdub in normal mode (upper track) and one in non-layered mode (lower
track). Both tracks were created using identical audio data.

The upper track shows a new region which has been layered on top of the
the existing (longer) region. It can be seen by the region name strips.

The lower track has split the existing region in two, trimmed each new
region to create space for the new overdub, and inserted the overdub
region in between.
\subsubsection*{Channel Configuration}

Ardour tracks can have any number of inputs and any number of outputs,
and the number of either can be changed at any time (subject to
restrictions caused by any plugins in a track). However it is useful to
not have to configure this sort of thing for the most common cases, and
so the {\hyperref[\detokenize{index:adding-tracks-busses-and-vcas}]{\emph{Add Tracks}}} dialog allows to
select “Mono”, “Stereo” and few other typical multichannel presets

The name of the preset describes the number of input channels of the
track or bus.

If Ardour is configured to automatically connect new tracks and busses,
the number of outputs will be determined by the number of inputs of the
master {\hyperref[\detokenize{index:understanding-basic-concepts-and-terminology}]{\emph{bus}}}, to which
the track outputs will be connected.

For example, with a two-channel master bus, a Mono track has one input
and two outputs; a Stereo track has two inputs and two outputs.

If Edit \textgreater{} Preferences \textgreater{} Signal Flow \textgreater{} Track and Bus Connections is set
to manual, then tracks will be left disconnected by default and there
will be as many outputs as there are inputs. It is up to the user to
connect them as desired. This is not a particularly useful way to work
unless something fairly unusual is done with signal routing and
processing. It is almost always preferable to leave Ardour make
connections automatically, even if some changes are manually done later.
\subsubsection*{32.2 - Adding Tracks, Busses and VCAs}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{add-track-or-bus}.png}
\caption{The Add Track/Bus/VCA dialog.}\label{\detokenize{index:id528}}\end{figure}

A track, bus or VCA can be added to a session by either:
\begin{itemize}
\item {} 
Choosing Track \textgreater{} Add Track, Bus or VCA….

\item {} 
Right-clicking in an empty part of the track controls area.

\item {} 
Clicking the Plus (+) button underneath the list of tracks in the
mixer.

\end{itemize}

Any of these actions will open the Add Track/Bus/VCA dialog.

The list of available track templates (both factory and user-created
ones) in the left panel allows to choose the {\hyperref[\detokenize{index:track-types}]{\emph{track(s)
type}}} (e.g. Audio, MIDI, bus, VCA etc.). Some templates
can do even more, like the factory-provided Live Band that automatically
creates a number of usual tracks for a common band setup. See {\hyperref[\detokenize{index:newopen-session-dialog}]{\emph{New
Session}}} for more information about
templates.

The common templates have parameters to tweak:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

Add
&
Selects the number of tracks,
busses or VCAs to create.
\\
\hline
Name
&
Defines the name of the new
track(s). If multiple tracks are
created, or if a track with the
same name already exists, a space
and number will be happened at
the end (e.g.: Audio 1, Audio
2…).
\\
\hline
Configuration
&
This menu allows to choose from a
number of route templates, which
determine the number of input
ports and optionally contain
plugins and other mixer strip
configuration. The most common
choices here are \sphinxstyleemphasis{mono} and
\sphinxstyleemphasis{stereo}.
\\
\hline
Instrument
&
This option is only available for
MIDI tracks and busses and allows
the selection of a default
instrument from the list of
available plugins.
\\
\hline
Group
&
Tracks and busses can be assigned
groups so that a selected range
of operations are applied to all
members of a group at the same
time (selecting record enable, or
editing, for example). This
option assigns the new track/bus
to an existing group, or create a
new group.
\\
\hline
Pin Mode
&
Defines how the number of output
responds to adding a plugin with
a different number of outputs
than the track itself. In \sphinxstyleemphasis{Strict
I/O} mode, plugins cannot alter
the track’s channel count, while
in \sphinxstyleemphasis{Flexible I/O} mode, it will
automatically adapt to the I/O of
its plugins. See {\hyperref[\detokenize{index:trackbus-signal-flow}]{\emph{Signal
flow}}}
to learn more about those
options.
\\
\hline
Record mode
&
This option is only available for
audio tracks and affects how it
behaves when recording. See
{\hyperref[\detokenize{index:track-types}]{\emph{Track Modes}}}
for details.
\\
\hline
Position
&
Defines where in the track list
is the track created. The default
is \sphinxstyleemphasis{Last}, i.e. after all the
tracks and busses, and can also
be \sphinxstyleemphasis{First}, \sphinxstyleemphasis{Before Selection}
(to place it just above the
selected track) or \sphinxstyleemphasis{After
selection}.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

Multiple tracks of different types can be created by using the Add
selected items (and leave dialog open) button, which, used in
conjunction with the Add field, allows for a very efficient and fast way
to create a base track setup.

New tracks appear in both the editor and mixer windows. The editor
window shows the timeline, with any recorded data, and the mixer shows
just the processing elements of the track (its plugins, fader and so
on).
\subsubsection*{Removing Tracks and Busses}

Removing tracks and busses, is done by selecting them, right-clicking
and choosing Remove from the menu. A warning dialog will pop up, as
track removal cannot be undone; this option should be used with care!
\subsubsection*{32.3 - Controlling Track Ordering}

Ardour does not impose any particular ordering of tracks and busses in
either the editor or mixer windows. The default arrangements are as
follows:
\begin{itemize}
\item {} 
In the Editor window, the Master bus will always be on top unless
hidden. Tracks and busses will appear in their initial order, from
top to bottom. The monitor section (if used) is never visible in the
editor window.

\item {} 
In the Mixer window, the tracks and busses will be displayed in their
initial order, from left to right. The Master bus is always on the
far right and occupies its own pane, so that it is always visible no
matter how many other mixer strips are present. If a Monitor section
is used, it shows up at the right edge of the mixer window; it can
also be torn off into a separate window.

\end{itemize}
\subsubsection*{Reordering Tracks}

The track ordering of the Editor and Mixer is synchronized: if a track
is reordered in one window, the ordering in the other window will
follow.
\subsubsection*{Reordering in the Editor Window}

Reordering is done by selecting the tracks to be moved, then using Track
\textgreater{} Move Selected Tracks Up (shortcut: ↑) or Track \textgreater{} Move Selected Tracks
Down (shortcut: ↓).

Alternatively, the {\hyperref[\detokenize{index:the-tracks-and-busses-list}]{\emph{Tracks \& Busses panel of the Editor
Lists}}} can be used, if visible. Here,
tracks and busses can be freely dragged-and-dropped into any desired
order.
\subsubsection*{Reordering in the Mixer Window}

Within the {\hyperref[\detokenize{index:strips-list}]{\emph{Strips List}}} pane at the top left of the
Mixer window, tracks and busses can be freely dragged-and-dropped into
any desired order.
\subsubsection*{“Collecting” Group Members}

Tracks and Busses that are members of a group can be reordered so that
they display contiguously within the Editor and Mixer windows, by
Right-clicking on the group tab and choosing Collect.
\subsubsection*{Ordering of New Tracks}

When {\hyperref[\detokenize{index:adding-tracks-busses-and-vcas}]{\emph{adding new tracks}}}, the Insert:
field allows to determine their placement. New tracks will be placed
\sphinxstyleemphasis{Last} by default, so after the rightmost (in the mixer) or bottom-most
(in the editor) selected track. If no tracks are selected, new tracks
will be added at the end, regardless of the choice.

Because new tracks are automatically selected, they can be quickly
reordered in the editor window via the keyboard shortcuts after adding
them.
\subsubsection*{Track Ordering and Remote Control IDs}

Every track and bus in Ardour is assigned a remote control ID. When a
{\hyperref[\detokenize{index:control-surfaces}]{\emph{control surface}}} or any other remote control is
used to control Ardour, these IDs are used to identify which track(s) or
buss(es) are the intended target of incoming commands.

Remote IDs are assigned to tracks and busses in the order that they
appear in the mixer window from left to right, starting from \#1; manual
assignment of remote IDs is not possible. The master bus and monitor
section can be accessed by name.
\subsubsection*{32.4 - Track Context Menu}

Within the editor window, context-clicking (right click) on either a
region or empty space within a track displays the track context menu.
The context menu provides easy access to many track-level operations.

If a region is clicked, the first item in the menu is the name of the
region. If a {\hyperref[\detokenize{index:layering-display}]{\emph{layered region}}} is clicked, the next
item in the menu is Choose Top. If selected, a dialog appears that
allows to change the vertical order of layers at that point. See
{\hyperref[\detokenize{index:layering-display}]{\emph{Layering Display}}} for more details.

The rest of the track context menu is structured as follows:


\begin{savenotes}\sphinxatlongtablestart\begin{longtable}{|l|l|}
\hline

\endfirsthead

\multicolumn{2}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} -- continued from previous page}}}\\
\hline

\endhead

\hline
\multicolumn{2}{r}{\makebox[0pt][r]{\sphinxtablecontinued{Continued on next page}}}\\
\endfoot

\endlastfoot

Play
&\\
\hline
Play from Edit Point
&
Plays from the location of the
current {\hyperref[\detokenize{index:edit-point-control}]{\emph{Edit
Point}}}.
\\
\hline
Play from Start
&
Plays from the start of the
session
\\
\hline
Play Region
&
Plays the duration of the session
from the start of the earliest
selected region to the end of the
latest selected region
\\
\hline
Select
&\\
\hline
Select All in Track
&
Selects all the regions and
automation points in the current
track
\\
\hline
Select All Objects
&
Selects all the regions and
automation points in the session
\\
\hline
Invert Selection in Track
&
Select the previously unselected
regions, and deselect the
previously selected ones \sphinxstyleemphasis{only}
in the current track
\\
\hline
Invert Selection
&
Select the previously unselected
regions, and deselect the
previously selected ones
\\
\hline
Set Range to Loop Range
&
Creates a range selection on the
selected tracks, based on the
selected loop markers, and
switches to {\hyperref[\detokenize{index:toolbox}]{\emph{Range Mode
tool}}}
\\
\hline
Set Range to Punch Range
&
Same as above, based on the
selected punch markers
\\
\hline
Set Range to Selected Regions
&
Same as above, based on the
selected regions (i.e. from the
start of the earliest region to
the end of the latest one)
\\
\hline
Select All After Edit Point
&
Select all the regions and
automation points that exist
after the Edit Point, even if the
region starts before it. If some
tracks are selected, only selects
on these tracks.
\\
\hline
Select All Before Edit Point
&
Same as above, but before the
Edit point (i.e. to the left of
it)
\\
\hline
Select All After Playhead
&
Same as above, but considering
the Playhead, regardless of the
Edit Point choice
\\
\hline
Select All Before Playhead
&
Same as above, with the Playhead
\\
\hline
Select All Between Playhead and
Edit Point
&
Selects all the regions between
the Playhead and the Edit Point
\\
\hline
Select All Within Playhead and
Edit Point
&
Same as above, but the regions
must be totally included between
the Playhead and Edit Point
\\
\hline
Select Range Between Playhead and
Edit Point
&
Creates a Range between the
Playhead and the Edit Point
\\
\hline
Edit
&\\
\hline
Cut
&
Deletes the current selection,
but puts it in memory ready to be
pasted
\\
\hline
Copy
&
Copies the current selection to
memory
\\
\hline
Paste
&
Pastes the memory at the {\hyperref[\detokenize{index:edit-point-control}]{\emph{Edit
Point}}},
after a Cut or Copy operation
\\
\hline
Align
&
Aligns the sync point of all
selected regions to the Edit
Point
\\
\hline
Align Relative
&
Same as above, but considers
multiple regions as a block and
aligns the whole block, not each
regions
\\
\hline
Insert Selected Region
&
If a region is selected in {\hyperref[\detokenize{index:the-region-list}]{\emph{the
Region
List}}},
inserts it in the track
\\
\hline
Insert Existing Media
&
Inserts an external media file in
the track, same as {\hyperref[\detokenize{index:adding-pre-existing-material}]{\emph{the Session \textgreater{}
Insert Media
menu}}}
\\
\hline
Nudge
&\\
\hline
Nudge Entire Track Later
&
Moves all the region to the right
by the amount shown in the {\hyperref[\detokenize{index:nudge-controls}]{\emph{nudge
timer}}}
\\
\hline
Nudge Track After Edit Point
Later
&
Same as above, but only for
regions that begin after the Edit
Point
\\
\hline
Nudge Entire Track Earlier
&
Same as above, to the left
\\
\hline
Nudge Track After Edit Point
Earlier
&
Same as above, to the left
\\
\hline
(un)Freeze
&
Consolidates all the regions in
the track into one \sphinxstyleemphasis{frozen}
region which can be handled as a
normal, single region. This
operation can be undone at any
time with the same sub-menu.
\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}
\subsubsection*{33 - Controlling Track Appearance}

Ardour offers many options for controlling the appearance of tracks,
including color, height, waveform style and more. These can all be found
in the Edit \textgreater{} Preferences \textgreater{} Editor menu.
\subsubsection*{33.1 - Layering Display}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{track-layer-dialog}.png}
\caption{The Track layering menu}\label{\detokenize{index:id529}}\end{figure}

Ardour allows arbitrary layering of regions—there can any number of
regions at a given position. By default, the regions are overlaid in the
editor window, to save vertical space.

However, this display mode can be confusing for tracks with many
overdubs, because its not obvious in which order the overdubs are
layered. Although there are other methods of moving particular regions
to the top of an overlapping set, and although Ardour also has playlists
to manage {\hyperref[\detokenize{index:playlist-usecases}]{\emph{takes}}} a bit more efficiently than
just continually layering, there are times when being able to clearly
see all regions in a track without any overlaps is reassuring and
useful.

The example below shows a track with a rather drastic overdub situation,
viewed in normal overlaid mode:

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{overlaps_layered}.png}
\caption{Overlapping regions in \sphinxstyleemphasis{overlaid} mode}\label{\detokenize{index:id530}}\end{figure}

This display can be changed by right clicking on the track header,
showing the menu displayed above. There are two choices for layers, and
overlaid is currently selected. Clicking on stacked, the track display
changes to:
.. figure:: /images/layers\_stacked.png
\begin{quote}
\begin{quote}\begin{description}
\item[{alt}] \leavevmode
Overlapping regions in \sphinxstyleemphasis{stacked} mode

\end{description}\end{quote}

Overlapping regions in \sphinxstyleemphasis{stacked} mode
\end{quote}

Regions can still be moved around as usual, and can be dragged so that
they overlay each other again, but when the mouse button is released,
things will flip back to them all being stacked cleanly. The number of
lanes for the track is determined by the maximum number of regions
existing in any one spot throughout the track, so if a track has 10
overdubs stacked up in one spot, it will end up with 10 lanes.
Obviously, using a large track height works much better for this than a
small one.
\subsubsection*{33.2 - Track Color}

New tracks in Ardour are assigned a random color from a pastel color
palette, so they should never end up being particularly bright or
particularly dark.
\subsubsection*{Changing the color of specific tracks}

Changing the color of a track is done by selecting the track(s) and
right clicking on the track header of one of them then from the context
menu, selecting Color and picking a hue in the color dialog. Every
selected track will be re-colored.

If only one track is changed, right clicking on that track’s header will
be enough to select it, saving the extra mouse click.
\subsubsection*{Changing the color of all tracks in a group}

Tracks that belong to a {\hyperref[\detokenize{index:the-track-and-bus-group-list}]{\emph{track/bus
group}}} can share a common color by
enabling the Color option for the group. With this enabled, any color
change will be propagated to all group members.

The group color can also be explicitly changed by context-clicking on
the group tab in the Mixer, selecting Edit Group… and then clicking on
the Color selector in the displayed dialog.
\subsubsection*{33.3 - Track Height}

At some stage of the production, a quick overview over as many tracks as
possible may be required, or a detailed view into just a few, or a
combination of the two. To facilitate this, the height can be configured
individually for each track in the editor window, or globally.
\subsubsection*{Resizing one or a few tracks}

A right click on a track header will display the Height menu, and allow
to choose from a list of standard sizes. All selected tracks will be
redrawn using that height.

Alternatively, moving the pointer to the bottom edge of a track header
will change the cursor to a two-way vertical arrow shape. Left-dragging
dynamically resizes all selected tracks.
\subsubsection*{Resizing all the tracks}

The three rightmost items of the {\hyperref[\detokenize{index:zoom-controls}]{\emph{Zoom Controls}}}, in
the toolbar, allow to quickly resize multiple tracks’ heights at once,
or to display a selected number of tracks in the editor, or all the
selected ones, etc.
\subsubsection*{Fitting to the Editor Window}

Fitting one or many tracks to the Editor window can be done by selecting
the tracks to display and choosing Track \textgreater{} Height \textgreater{} Fit Selection
(Vertical) or using the keyboard shortcut, f. Ardour adjusts the track
heights and view so that the selected tracks completely fill the
vertical space available, unless the tracks cannot be fitted even at the
smallest possible size.

The Visual Undo (default shortcut: Z) can be used to revert this
operation.
\subsubsection*{33.4 - Waveform display}

The display of waveforms (or, more correctly, peak envelopes, since the
actual waveform is only visible at the highest zoom levels) is
configurable via the Edit \textgreater{} Preferences \textgreater{} Appearance \textgreater{} Editor dialog, to
support different use cases and user preferences. The following options
are available:

Show waveforms in regions







By default, Ardour draws waveforms within audio regions. Disable this
option to hide them.

Waveform scale

Linear

This is the traditional linear (1:1) display of the peak envelope, or,
at higher zoom levels, the individual samples.

Logarithmic

Alternatively, a logarithmic display of the peak envelope can be used.
This will give a better idea of program loudness (it is similar to dBs)
and plot soft passages more clearly, which is useful for soft recordings
or small track height.

Waveform shape

Traditional

The zero line appears in the middle of the display and waveforms appear
as positive and negative peaks above \sphinxstyleemphasis{and} below.

Rectified

The zero line appears at the bottom of the display and waveforms appear
as absolute peaks \sphinxstyleemphasis{above} the line only.


\chapter{34 - Importing and Exporting Session Data}
\label{\detokenize{index:importing-and-exporting-session-data}}

\chapter{34.1 - Import Dialog}
\label{\detokenize{index:import-dialog}}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{import-window}.png}
\caption{The import window.}\label{\detokenize{index:id531}}\end{figure}

Many sessions will require the use of existing material, whether it
consists of audio and/or MIDI data. Using existing samples, loops and
riffs from files stored on the system can be the basis for a new
session, or a way to deepen and improve one that is already underway.

Importing audio and MIDI data into the session is done with the Add
Existing Media dialog, accessed by the Session \textgreater{} Import menu.


\section{The Soundfile Information Box}
\label{\detokenize{index:the-soundfile-information-box}}
This box will display information about the currently selected file:
\begin{itemize}
\item {} 
number of channels,

\item {} 
sample rate,

\item {} 
file format,

\item {} 
length,

\item {} 
embedded timestamp (applies to some professional formats such as
Broadcast WAVE), and

\item {} 
{\hyperref[\detokenize{index:searching-for-files-using-tags}]{\emph{tags}}} (attached metadata to help
categorize files in a library).

\end{itemize}

If the sample rate differs from the current session rate, it is
displayed in red, which indicates that the file must be resampled before
importing.

Resampling is controlled by the Conversion quality option described
below.


\section{Auditioner}
\label{\detokenize{index:auditioner}}
Files can be auditioned before importing. The slider under the play and
stop buttons allows to scrub around, a fader on the right side allows to
control the playback volume.

Auditioning MIDI files requires a MIDI instrument to be chosen in the
Instrument dropdown list.


\section{Importing options}
\label{\detokenize{index:importing-options}}
Through the Add files… option, imported files can be inserted in the
session:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

as new tracks
&
automatically creates new tracks
and import the files in it
\\
\hline
to region list
&
adds the files to the {\hyperref[\detokenize{index:the-region-list}]{\emph{region
list}}}, from
where then can be manually
dragged into a track
\\
\hline
as new tape tracks
&
adds the files as {\hyperref[\detokenize{index:track-types}]{\emph{Tape
tracks.}}}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

The Insert at option chooses where in time the file will be imported,
amongst:

the file timestamp (if available, zero by default)

at the {\hyperref[\detokenize{index:edit-point-control}]{\emph{edit point}}}

at the playhead

at the session start.

The Channel Mapping option is only available for multi-channel files
(i.e. all but mono ones). It is either


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

one track/region per file
&
Creates a multi channel track for
each imported file
\\
\hline
one track/region per channel
&
Creates only mono channels, as
many as there are channels in the
imported files
\\
\hline
sequence files
&
If multiple files are imported,
they can be sequenced into a
single track in the order of
selection
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

The Conversion quality drop-down controls the quality of the resampling
process, if the sampling rate of the source file differs from the
session rate.

Finally, and most importantly, the the files can be linked or copied to
the session with the Copy files to session checkbox. Please read
{\hyperref[\detokenize{index:copying-versus-linking}]{\emph{Copying versus Linking}}} for details.


\chapter{34.2 - Supported File Formats}
\label{\detokenize{index:supported-file-formats}}
The list of audio file formats that Ardour can understand is quite long.
It is based on the functionality offered by libsndfile, an excellent and
widely used software library by Australian programmer Erik de Castro
Lopo. As libsndfile’s capabilities expand, so will Ardour’s abilities to
import (and export) new formats. Ardour supports all common audio file
formats, including WAV, AIFF, AIFC, CAF, W64 and BWF, with all typical
sample formats (8-, 16-, 24-, 32-bit integer, floating point, and more).

A full list of libsndfile’s supported formats is available on the
\sphinxhref{http://www.mega-nerd.com/libsndfile/\#Features}{libsndfile website}.

For MIDI import, Ardour will read any Standard MIDI Format (SMF) file.


\chapter{34.3 - Adding Pre-existing Material}
\label{\detokenize{index:adding-pre-existing-material}}
There are several ways to importing an audio or MIDI file into a
session:
\begin{itemize}
\item {} 
Session \textgreater{} Import

\item {} 
Region List context menu: Import To Region List

\item {} 
Track context menu: Import Existing Media

\end{itemize}

These methods are all equivalent: they open the {\hyperref[\detokenize{index:import-dialog}]{\emph{Add Existing
Media}}} dialog.

Finally, files can also easily be imported into a project by dragging
and dropping a file from some other application (e.g. the system’s file
manager). Files can either be dragged onto the Region List, into the
desired track or into an empty space in the editor track display.

The file will be imported and copied into the session, and placed at the
position where the drag ended.


\chapter{34.4 - Copying Versus Linking}
\label{\detokenize{index:copying-versus-linking}}
Copying and linking are two different methods of using existing audio
files on the computer (or network file system) within a session. They
differ in one key aspect:


\section{Copying}
\label{\detokenize{index:copying}}
An existing media file is copied to the session’s audio folder, and if
necessary converted into the session’s native format.

For audio files, the format can be chosen (e.g. WAVE or Broadcast WAVE).
Audio files will also be converted to the session sample rate if
necessary (which can take several minutes for larger files).

MIDI files will already be in SMF format, and are simply copied into the
session’s MIDI folder.


\section{Linking}
\label{\detokenize{index:linking}}
A link to an existing media file somewhere on the disk is used as the
source for a region, but the data is \sphinxstylestrong{not copied or modified} in any
way.

While linking is handy to conserve disk space, it means that the session
is no longer self-contained. If the external file moves, it will become
unavailable, and any changes to it from elsewhere will affect the
session. A backup of the session directory will miss linked files.

The Copy file to session option in the Import dialog window allows to
choose to copy or link files into the session:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

Copy file to session
&
This file will be imported in the
audio/MIDI folder of the session.
\\
\hline
Copy file to session
&
This file won’t be copied.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

There is a global preference Edit \textgreater{} Preferences \textgreater{} General \textgreater{} Session \textgreater{}
Always copy imported files. If it is enabled, linking a file will not be
possible.


\chapter{34.5 - Searching for Files Using Tags}
\label{\detokenize{index:searching-for-files-using-tags}}
A tag is bit of information, or metadata, that is associated with a data
file. Specifically, tags are texts, keywords or terms that have some
relevance to a particular sound file. Ardour can store these tags in a
searchable database so that they can quickly be searched for to retrieve
sounds based on the tags that have been assigned to them.

For example if the term 120bpm has been assigned to a sound, search
later for this tag will make the file appear in the search list. Tags
are independent of the filename or anything else about the file. Tags,
and the file paths that they are associated with, are stored in a file
called sfdb in the Ardour user folder.


\section{Creating and adding tags}
\label{\detokenize{index:creating-and-adding-tags}}
Adding tags to a given file is done by opening the Session \textgreater{} Import
dialog, selecting the file in the browser, and typing new tags into the
tag area in the soundfile information box on the right.

Tags are stored when the input box loses focus, there is no need to
explicitly save them.

To have more than one tag for a file, new tags can either be added on
new lines (meaning the Enter key is pressed between two tags) or they
can be separated from the previous ones by a comma (,), with or without
spaces.


\section{Searching for files by tag}
\label{\detokenize{index:searching-for-files-by-tag}}
Searching for specific tags is done in the Search Tags tab of the same
dialog. Files which have been tagged with the relevant terms will appear
in the results window. Selected files can be auditioned and marked with
additional tags if required.


\chapter{34.6 - Stem Exports}
\label{\detokenize{index:stem-exports}}
Stem exports are covered fully in the {\hyperref[\detokenize{index:mixdown}]{\emph{Export}}} chapter. A
stem export creates one file per track, starting at the beginning of the
session. Each track can then be imported into another DAW.

All data will be lost except the actual audio/MIDI (no plugins, no
automation). This is one of the most common methods of interchange
because it works between all DAWs.


\chapter{35 - File and Session Management and Compatibility}
\label{\detokenize{index:file-and-session-management-and-compatibility}}

\chapter{35.1 - Session Templates}
\label{\detokenize{index:session-templates}}
Session templates are a way to store the setup of a session for future
use. They do not store any \sphinxstyleemphasis{audio} data but can store:
\begin{itemize}
\item {} 
The number of tracks and busses, along with their names

\item {} 
The plugins present on each track or bus (if any)

\item {} 
All I/O connections

\end{itemize}


\section{Creating a Session Template}
\label{\detokenize{index:creating-a-session-template}}
The Session \textgreater{} Save Template shows a dialog asking for the name of the
new template, and a description.


\section{Using a Session Template}
\label{\detokenize{index:using-a-session-template}}
In the {\hyperref[\detokenize{index:newopen-session-dialog}]{\emph{New Session dialog}}}, a panel lists
the different template (factory and user-created).


\section{Managing Templates}
\label{\detokenize{index:managing-templates}}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{manage_templates}.png}
\caption{The Manage Templates window}\label{\detokenize{index:id532}}\end{figure}

Both Session templates and Track Templates can be managed through the
Manage Templates window, which can perform the following actions:
\begin{itemize}
\item {} 
Renaming a template

\item {} 
Removing one

\item {} 
Adding/modifying its description

\item {} 
Exporting the templates (e.g. to be used in another Ardour instance)

\item {} 
Importing templates (from e.g. another Ardour instance).

\end{itemize}

See also {\hyperref[\detokenize{index:adding-tracks-busses-and-vcas}]{\emph{Adding Tracks and Busses}}}
for information on templates for individual tracks or busses.


\chapter{35.2 - Snapshots}
\label{\detokenize{index:snapshots}}
A snapshot is a backup of the current state of a session. It differs
from a simple save by allowing branching. It is a “frozen” version of
the session at a certain point in time.

For example, creating a snapshot before changing the entire arrangement
of a piece, or drastically altering the signal processing provides a
reference to come back to, should that not work out.

This is accomplished by using either of the Session \textgreater{} Snapshot menus. A
small dialog will appear, allowing to enter a name for the snapshot. The
default name is based on the current date and time.

The difference between the two snapshot menus is:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

Snapshot (\& keep working on
current version)…
&
Saves a snapshot of the session,
but keeps the current session
active, i.e. any subsequent
Session \textgreater{} Save will overwrite the
original session, and the
snapshot will remain unchanged.
\\
\hline
Snapshot (\& switch to new
version)…
&
Saves a snapshot of the session,
and uses this snapshot as the
current active session, i.e. any
subsequent Session \textgreater{} Save will
overwrite the snapshot, and the
original session will remain
unchanged.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

Any number of snapshots can be created.

Creating a snapshot does \sphinxstylestrong{not} modify the session, nor does it save
the session. Instead, it saves an alternate version of the session,
within the session folder. The snapshot shares all data present in the
session.


\section{Switching to a Snapshot}
\label{\detokenize{index:switching-to-a-snapshot}}
Switching to an existing snapshot is done by navigating the {\hyperref[\detokenize{index:the-snapshot-list}]{\emph{Snapshot
List}}} and clicking the the name of the desired
snapshot. Ardour will switch to the snapshot, and, if there are unsaved
changes in the current session, offer to save them.


\section{Starting Ardour With a Snapshot}
\label{\detokenize{index:starting-ardour-with-a-snapshot}}
Since a snapshot is just another session file stored within the session
folder, that “version” can be chosen when loading an existing session.
The browser in the “Open Session” dialog will show an expander arrow for
sessions that have more than one session file (i.e. snapshots) present.
Clicking on it shows the list, and then clicking on the name of the
snapshot loads it.


\chapter{35.3 - Cleaning Up Sessions}
\label{\detokenize{index:cleaning-up-sessions}}
Recording and editing any serious session might leave the session with
some unused or misplaced files here and there. Ardour can help deal with
this clutter thanks to the tools located in the Session \textgreater{} Clean-up menu.


\section{Bring all media into session folder}
\label{\detokenize{index:bring-all-media-into-session-folder}}\label{\detokenize{index:id11}}
When {\hyperref[\detokenize{index:adding-pre-existing-material}]{\emph{importing media files}}}, if the
Copy files to session has not been checked, Ardour uses the source file
from its original destination, which can help avoiding file duplication.
Nevertheless, when the session needs to be archived or transferred to
another computer, moving the session folder will not move those
\sphinxstyleemphasis{external} files as they are not in the folder, as seen in {\hyperref[\detokenize{index:backup-and-sharing-of-sessions}]{\emph{Backup and
sharing of sessions}}}.

Using the Bring all media into session folder menu ensures that all
media files used in the session are located inside the session’s folder,
hence avoiding any missing files when copied.


\section{Reset Peak Files}
\label{\detokenize{index:reset-peak-files}}\label{\detokenize{index:id12}}
Ardour represents audio waveforms with peak files, that are graphical
images generated from the sound files. This generation can be time and
CPU consuming, so it uses a cache of the generated images to speed up
the display process. To watch for files modification, Ardour relies on
the file-modification time. If an external file is embedded in the
session and that file changes, but the system-clock is skewed or it is
stored on an external USB disk (VFAT), Ardour can’t know the change
happened, and will still use its deprecated peak files.

Using the Reset Peak Files menu allows to reset this cache, which frees
up disk space, and forces the re-creation of the peak files used in the
session. It can prove useful if some waveforms are not used anymore, or
if a graphical or time glitch happens.


\section{Clean-up Unused Sources…}
\label{\detokenize{index:clean-up-unused-sources}}\label{\detokenize{index:id13}}
Recording usually leaves a lot of unused takes behind, be it in midi or
audio form, that can clutter the Region List, and eat up a lot of hard
drive space. While its generally a good practice to keep as many things
as possible while recording, when transferring or archiving the session,
some clean up can help a lot in reducing the sessions clutter and size.

Selecting Clean-up Unused Sources… will force Ardour to detect those
unused waveforms by looking for unused regions, and (through a prompt)
for unused playlists. The media files will not be destroyed, though. At
this stage, they are just copied in a particular place of the session
path (namely, in the \sphinxcode{\sphinxupquote{dead sounds/}} sub-folder).


\section{Flush Wastebasket}
\label{\detokenize{index:flush-wastebasket}}\label{\detokenize{index:id14}}
Although Ardour is a \sphinxstyleemphasis{non-destructive} audio-editor, it allows for a
very careful destruction of unused media materials. This function is
closely linked to the previous one. When the unused sources have been
cleaned up and quarantined, the Flush Wastebasket menu will allow for
their physical destruction.

As a safeguarding mechanism though, Flushing the wastebasket in
impossible in the same working session as the Cleaning up of unused
sources: the user needs to close the session and reload it before
flushing. It allows to test the playback of the session and ensure both
that Ardour did not commit any mistake (unlikely, but better safe than
sorry), and that the user is absolutely sure of what he does.

All media destroyed this way is not sent to the system’s \sphinxstyleemphasis{trash can} but
permanently deleted. If a file is mistakenly destroyed this way, the
user will have to rely on data recovery techniques to try getting it
back.


\chapter{35.4 - Interchange with other DAWs}
\label{\detokenize{index:interchange-with-other-daws}}
It has never been particularly easy to move sessions or projects from
one DAW to another. There are two interchange standards that have
reasonably widespread support:
\begin{itemize}
\item {} 
OMF (Open Media Framework), also known as OMFI. Developed and
controlled by Avid, never standardized

\item {} 
AAF (Advanced Authoring Format). Developed by a consortium of
media-related corporations.

\end{itemize}

In practice both of these standards have such complex and/or incomplete
specifications that different DAWs support them only partially,
differently, or not at all.


\section{Transferring an Ardour session from / to another DAW}
\label{\detokenize{index:transferring-an-ardour-session-from-to-another-daw}}
To move a session from another DAW to Ardour, or from Ardour to another
DAW, there are two basic choices:
\begin{itemize}
\item {} 
{\hyperref[\detokenize{index:stem-exports}]{\emph{Stem exports}}}

\item {} 
{\hyperref[\detokenize{index:using-aatranslator}]{\emph{Using AATranslator}}}

\end{itemize}


\section{Importing ProTools® files}
\label{\detokenize{index:importing-protools-files}}
Ardour provides a basic import tool for ProTools® sessions, in the
Session \textgreater{} Import PT Session menu.

Though incomplete, this import is intended for ptf and ptx files.
Protools® 5, 8, 9, 10, 11 have been tested with varying degrees of
success. (versions 6 and 7 are not supported).

The elements of the files that are imported are:
\begin{itemize}
\item {} 
Audio regions data \& position

\item {} 
MIDI notes (fused to a unique region).

\end{itemize}


\section{Using AATranslator}
\label{\detokenize{index:using-aatranslator}}
AATranslator is a Windows application that can convert sessions/projects
from many different DAWs into other formats. At the present time
(December 2016), it can read and write Ardour 2.X sessions, and can read
Ardour 3 sessions.

The program runs very well on Linux using
\sphinxhref{http://www.winehq.org/}{Wine} (a Windows environment for Linux).
There are equivalent solutions for running Windows applications on OS X,
but we have no experience with them at this time. Ardour users have
reported great results using AATranslator on Ardour 2.X sessions.

The \sphinxhref{http://www.aatranslator.com.au/}{AATranslator website} has full
details on supported formats and DAWs. The list includes ProTools, Live,
Reaper, OMF, AAF and many more.

AATranslator is closed-source, non-free software (as of this writing,
June 2017, the cost is 59 USD for the “Standard” version, and 199 USD
for the “Enhanced” version).


\chapter{Part V - Playback \& Recording}
\label{\detokenize{index:part-v-playback-recording}}\label{\detokenize{index:recording}}

\chapter{36 - Playing Back Track Material}
\label{\detokenize{index:playing-back-track-material}}

\chapter{36.1 - Controlling Playback}
\label{\detokenize{index:controlling-playback}}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{the-playhead}.png}
\caption{The playhead}\label{\detokenize{index:id533}}\end{figure}

The playhead is a red vertical line that indicates the current position
of playback.


\section{Positioning the Playhead}
\label{\detokenize{index:positioning-the-playhead}}

\subsection{Positioning the playhead at the current pointer position}
\label{\detokenize{index:positioning-the-playhead-at-the-current-pointer-position}}
Pressing P will set the playhead to the current position of the mouse
pointer, if it is within the editor track area.


\subsection{Positioning the playhead on the timeline}
\label{\detokenize{index:positioning-the-playhead-on-the-timeline}}
A Left click anywhere on the {\hyperref[\detokenize{index:ruler}]{\emph{Ruler}}} will move the playhead
to that position.


\subsection{Positioning the playhead with the transport clocks}
\label{\detokenize{index:positioning-the-playhead-with-the-transport-clocks}}
Clicking on either the primary or secondary transport clock and {\hyperref[\detokenize{index:editing-clocks}]{\emph{editing
their value}}} moves the playhead to a specific
position.


\subsection{Positioning the playhead at a marker}
\label{\detokenize{index:positioning-the-playhead-at-a-marker}}
Right clicking on the marker and selecting either Locate to Here or Play
from Here will place the playhead at the marker’s position.

Alternatively, placing the mouse pointer on the marker and pressing P
sets the playhead precisely on the marker location.


\section{Looping the Transport}
\label{\detokenize{index:looping-the-transport}}
When the {\hyperref[\detokenize{index:the-loop-range}]{\emph{loop transport}}} button is pressed, the
playhead will jump the start of the loop range, and continue to the end
of that range before returning to the start and repeating.

While looping, a light green area is displayed in the Ruler over the
tracks to show the loop range.

By default, looping is bound to the l key.


\chapter{36.2 - Using Key Bindings}
\label{\detokenize{index:id15}}
Ardour has many available commands for playback control that can be
bound to keys. Many of them have {\hyperref[\detokenize{index:keyboard-and-mouse-shortcuts}]{\emph{default
bindings}}}, Some of the most used are
found below.

Those keybindings are shown in the corresponding menus. Memorizing at
least the most frequently used can be a great time saver.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

Space
&
switch between playback and stop.
\\
\hline
Home
&
Move playhead to session start marker
\\
\hline
End
&
Move playhead to session end marker
\\
\hline
\(\rightarrow\)
&
Playhead to Next Grid
\\
\hline
←
&
Playhead to Previous Grid
\\
\hline
0
&
Move playhead to start of the timeline
\\
\hline
space
&
Start recording
\\
\hline
space
&
Stop and forget capture
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\chapter{37 - Audio Recording}
\label{\detokenize{index:audio-recording}}

\chapter{37.1 - Monitoring}
\label{\detokenize{index:monitoring}}
When recording, it is important that performers hear themselves, and any
pre-recorded tracks they are performing with.

Audio recorders typically allow monitoring (i.e. listening to) the input
signal of all tracks that are armed for recording, and playing back the
unarmed tracks.


\chapter{37.2 - Latency Considerations}
\label{\detokenize{index:latency-considerations}}
In the days of analog tape recording, the routing of monitor signals was
performed with relays and other analog audio switching devices. Digital
recorders have the same feature, but may impart some
{\hyperref[\detokenize{index:latency-and-latency-compensation}]{\emph{latency}}} (delay) between the time
a noise is made and the time that it will come back from the recorder.

The latency of \sphinxstyleemphasis{any} conversion from analog to digital and back to
analog is about 1.5\textendash{}2 ms. Some musicians claim that even the basic A/D/A
conversion time is objectionable. However even acoustic instruments such
as the piano can have approximately 3 ms of latency, due to the time the
sound takes to travel from the instrument to the musician’s ears.
Latency below 5 ms should be suitable for a professional recording
setup. Because 2 ms are already used in the A/D/A process, extremely low
buffer sizes must be used in the workstation I/O setup to keep the
overall latency below 5ms. Not all {\hyperref[\detokenize{index:the-right-computer-system-for-digital-audio}]{\emph{computer audio
systems}}} are able to
work reliably at such low buffer sizes.

For this reason it is sometimes best to route the monitor signal through
an external mixing console while recording, an approach taken by most if
not all professional recording studios. Many computer I/O devices have a
hardware mixer built in which can route the monitor signal “around” the
computer, avoiding the system latency.

In either case, the monitoring hardware may be digital or analog. And in
the digital case there will still be the A-D-A conversion latency of
1\textendash{}2 ms.


\chapter{37.3 - Monitor Signal Flow}
\label{\detokenize{index:monitor-signal-flow}}
There are three basic ways to approach monitoring:


\section{External Monitoring}
\label{\detokenize{index:external-monitoring}}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{external-monitoring}.png}
\caption{External monitoring}\label{\detokenize{index:id534}}\end{figure}

When using external monitoring, Ardour plays no role in monitoring at
all. Perhaps the recording set-up has an external mixer which can be
used to set up monitor mixes, or perhaps the sound-card being used has a
“listen to the input” feature. This approach yields zero or near-zero
latency. On the other hand it requires external hardware, and the
monitoring settings are less flexible and not saved with the session.


\section{JACK-Based Hardware Monitoring}
\label{\detokenize{index:jack-based-hardware-monitoring}}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{jack-monitoring}.png}
\caption{Hardware Monitoring}\label{\detokenize{index:id535}}\end{figure}

Some sound cards have the ability to mix signals from their inputs to
their outputs with very low or even zero latency, a feature called
hardware monitoring. Furthermore, on some cards this function can be
controlled by JACK. This is a nice arrangement, if the sound card
supports it, as it combines the convenience of having the monitoring
controlled by Ardour with the low latency operation of doing it
externally.


\section{Software Monitoring}
\label{\detokenize{index:software-monitoring}}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{ardour-monitoring}.png}
\caption{Software Monitoring}\label{\detokenize{index:id536}}\end{figure}

With the software monitoring approach, all monitoring is performed by
Ardour—it makes track inputs available at track outputs, governed by
various controls. This approach will almost always have more routing
flexibility than JACK-based monitoring. The disadvantage is that there
will be some latency between the input and the output, which depends for
the most part on the JACK buffer size that is being used.


\chapter{38 - Punch Recording Modes}
\label{\detokenize{index:punch-recording-modes}}

\chapter{38.1 - Working With Markers}
\label{\detokenize{index:working-with-markers}}
It is very useful to be able to tag different locations in a session for
later use when editing and mixing. Ardour supports both locations, which
define specific positions in time, and ranges which define a start and
end position in time.

In addition to the standard location markers, there are three kinds of
special markers:
\begin{itemize}
\item {} 
CD markers are locations that are restricted to legal CD sector
boundaries. They can be used to add track index markers to compact
disc images.

\item {} 
The Loop range defines the start and end points for Looping.

\item {} 
The punch range defines the in and out points for punch recording.

\end{itemize}


\chapter{38.2 - Creating Location Markers}
\label{\detokenize{index:creating-location-markers}}
Location Markers appear in the {\hyperref[\detokenize{index:ruler}]{\emph{Locations Markers ruler}}} at
the top of the timeline. The green begin and end markers, that define
the length of the session, appear automatically, but yellow custom
markers can be created at any position in a session.

There are multiple ways to create custom markers at the current playhead
position:
\begin{itemize}
\item {} 
using the keyboard shortcut (default is Num-↵, the Enter key on the
numeric keypad)

\item {} 
using the Transport \textgreater{} Markers \textgreater{} Add Mark from Playhead menu.

\end{itemize}

Adding a marker at an arbitrary location on the timeline (i.e. not at
the playhead position) can also be done either by:
\begin{itemize}
\item {} 
right clicking in the Location Marker ruler, and selecting New
location marker

\item {} 
using the {\hyperref[\detokenize{index:the-ranges-and-marks-lists}]{\emph{Ranges \& Marks List}}},
clicking New Marker and using the {\hyperref[\detokenize{index:editing-clocks}]{\emph{clock widget}}}
to set its position.

\end{itemize}


\chapter{38.3 - Creating Range Markers}
\label{\detokenize{index:creating-range-markers}}
Range markers are essentially two {\hyperref[\detokenize{index:creating-location-markers}]{\emph{location
markers}}} that appear in the {\hyperref[\detokenize{index:ruler}]{\emph{Range
Markers ruler}}}, and are grouped together to mark the
beginning and end of a section in the timeline.


\section{Creating a Range on the timeline}
\label{\detokenize{index:creating-a-range-on-the-timeline}}
Creating a new range can be done by right clicking on the Range Markers
ruler at the top of the timeline, then selecting New Range. Two markers
with the same name and opposing arrows will appear along the ruler.

It is also possible to create range markers from a selected range or
region in the Editor window, or to using the Ranges \& Marks List in the
Editor list.


\section{Editing a Range}
\label{\detokenize{index:editing-a-range}}
Both markers of a range can be independently moved along the timeline by
clicking and dragging them to the desired location.

They can also be moved together by dragging one marker.

See {\hyperref[\detokenize{index:moving-markers}]{\emph{Moving markers}}} for more information.


\chapter{38.4 - Moving Markers}
\label{\detokenize{index:moving-markers}}

\section{Single marker}
\label{\detokenize{index:single-marker}}
Left-clicking and dragging moves a single marker to a new location on
the timeline.


\section{Multiple markers}
\label{\detokenize{index:multiple-markers}}
It is possible to move multiple markers by the same distance.
Left-clicking each discreet marker, or Left-clicking the first and last
markers of a range of markers selects them, then dragging one to a new
location will move all selected markers together.

The markers are bounded by the zero point on the timeline. In other
words, the first marker in the selection cannot move to the left of zero
on the timeline.


\section{Both ends of a range marker}
\label{\detokenize{index:both-ends-of-a-range-marker}}
By left-dragging either end of the range marker, the other end will move
by the same distance.


\chapter{38.5 - The Loop Range}
\label{\detokenize{index:the-loop-range}}
The loop range is a special range that defines the start and end points
for loop play, which can be enabled in the transport bar.

It can be defined via the timeline or the {\hyperref[\detokenize{index:the-ranges-and-marks-lists}]{\emph{Ranges \& Marks
list}}}.


\chapter{38.6 - Marker Context Menu}
\label{\detokenize{index:marker-context-menu}}
Right-clicking a marker in the timeline opens the marker context menu:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

Locate to Here
&
Move the playhead to this
marker’s position.
\\
\hline
Play from Here
&
start playback from this marker’s
position.
\\
\hline
Move Mark to Playhead
&
Move this marker to the current
playhead position.
\\
\hline
Create Range to Next Marker
&
Create a range marker between
this location and the next one
along on the timeline.
\\
\hline
Hide
&
Hide this marker from the view.
It can be made visible again from
the Window \textgreater{} Locations window or
the {\color{red}\bfseries{}{}`Ranges \& Marks
list \textless{}\#the-ranges-and-marks-lists
\textgreater{}{}`\_\_}.
\\
\hline
Rename
&
Change the name of the marker.
\\
\hline
Lock
&
If this is ticked, it will be
impossible to drag the marker’s
position; useful if you want to
prevent accidental movements.
\\
\hline
Glue to Bars and Beats
&
If this is ticked, the marker
will maintain its position in
bars and beats even if there are
changes in tempo and meter.
\\
\hline
Remove
&
Removes the marker.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

There are also a few options in Transport \textgreater{} Active Mark. These options
apply to the currently selected location marker, and move it to a nearby
region boundary, region sync point, or to the playhead or mouse.


\chapter{38.7 - Punch Range}
\label{\detokenize{index:punch-range}}
The punch range is a special range used to define where recording will
start and/or stop during a punch.

It can be defined on the timeline or in the {\hyperref[\detokenize{index:the-ranges-and-marks-lists}]{\emph{Ranges \&
Marks}}} list.


\chapter{Part VI - Editing}
\label{\detokenize{index:part-vi-editing}}\label{\detokenize{index:editing-and-arranging}}

\chapter{39 - Navigating the Editor}
\label{\detokenize{index:navigating-the-editor}}
Navigating the Editor window is obviously a very frequent operation.
Ardour sticks with a lot of the usual conventions in this regard, to
allow for a quick learning. As those operations are so common, it is
worth taking the time to learn most of the keyboard and mouse shortcuts
in order for these to become fast and natural.

The keyboard shortcuts can, as always, be edited, so the defaults are
shown here.


\section{Scrolling}
\label{\detokenize{index:scrolling}}
Scrolling can be done on-canvas, or with the {\hyperref[\detokenize{index:summary}]{\emph{Summary}}}.


\subsection{On Canvas}
\label{\detokenize{index:on-canvas}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
Action
&\sphinxstyletheadfamily 
Mouse
&\sphinxstyletheadfamily 
Keyboard
\\
\hline
Scrolling up
&
⇑
&
↑
\\
\hline
Scrolling down
&
⇓
&
↓
\\
\hline
Scrolling up one page
&&
⇞
\\
\hline
Scrolling down one page
&&
⇟
\\
\hline
Scrolling left
&
⇑
&\\
\hline
Scrolling right
&
⇓
&\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

Moving the playhead outside the view may scroll the screen accordingly,
so using ← or \(\rightarrow\), while not \sphinxstyleemphasis{scrolling} per se, will result in scrolling
if Transport \textgreater{} Follow playhead is checked. This is also true with the
{\hyperref[\detokenize{index:mini-timeline}]{\emph{Navigation Timeline}}}, and anything that moves the
Playhead.


\subsection{In the Summary}
\label{\detokenize{index:in-the-summary}}
Clicking and dragging in the Summary will scroll the view left and
right. If the screen view is clicked (the white rectangle) and dragged,
the view can also be scrolled vertically.

Additionally, on the left of the Summary, the two \textless{} and \textgreater{} arrows buttons
allow to scroll one screen either left or right, while at the right of
the Summary, the two ∧ and ∨ arrows buttons allow to scroll one screen
either up or down.


\section{Zooming}
\label{\detokenize{index:zooming}}
Zooming (on time) can be done on-canvas (which will always be centered
around the mouse cursor), with the Summary, or with the {\hyperref[\detokenize{index:zoom-controls}]{\emph{Zoom
Controls}}}.


\subsection{On Canvas}
\label{\detokenize{index:on-canvas-1}}\label{\detokenize{index:id16}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

Zooming in
&
⇑
\\
\hline
Zooming out
&
⇓
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsection{In the Summary}
\label{\detokenize{index:in-the-summary-1}}\label{\detokenize{index:id17}}
Resizing the screen view in the Summary (the white rectangle) changes
the zoom accordingly.


\subsection{With the Zoom Controls}
\label{\detokenize{index:with-the-zoom-controls}}
With the Zoom Focus set, the − and + buttons will zoom out or in around
this focus. The {[} {]} button zooms to the whole session as defined by the
start and end markers.

Theses controls are bound to the keyboard − and = respectively by
default.


\section{Height of the tracks}
\label{\detokenize{index:height-of-the-tracks}}
Changing the height of the tracks results in more or less tracks on
screen. This can be done on canvas, with the Summary or with the Zoom
Controls.


\subsection{On canvas}
\label{\detokenize{index:on-canvas-2}}\label{\detokenize{index:id18}}
Using ⇓ or ⇑ while hovering over a track reduces or enhances its height,
i.e. zooms on the hovered track, regardless of the selection.

The F key resizes the tracks so that only the selected one(s) are
displayed. If some unselected tracks are in-between those selected
tracks, their {\hyperref[\detokenize{index:the-tracks-and-busses-list}]{\emph{visibility}}} will be
toggled off.


\subsection{In the Summary}
\label{\detokenize{index:in-the-summary-2}}\label{\detokenize{index:id19}}
Resizing the screen view in the Summary (the white rectangle) changes
the number of tracks displayed (hence their heights) accordingly. It
behaves more like a zoom as the relative height of the tracks are kept.


\subsection{With the Zoom Controls}
\label{\detokenize{index:with-the-zoom-controls-1}}\label{\detokenize{index:id20}}
The three rightmost buttons of the Zoom Control bar, while not zoom
buttons, act upon the height of the tracks:
\begin{itemize}
\item {} 
The first selector directly selects how many tracks are currently on
screen.

\item {} 
The second one reduces the height of the selected track(s). If none
are selected, all the tracks are affected, while maintaining (as long
as it is possible) their relative heights.

\item {} 
The third one enlarges the tracks, and is the counterpart of the
previous one.

\end{itemize}


\chapter{40 - Editing Basics}
\label{\detokenize{index:editing-basics}}

\chapter{40.1 - Working With Regions}
\label{\detokenize{index:working-with-regions}}

\section{Working With Regions}
\label{\detokenize{index:working-with-regions-1}}\label{\detokenize{index:id21}}
Regions are the basic elements of editing and composing in Ardour. In
most cases, a region represents a single contiguous section of one or
more media files. Regions are defined by a fixed set of attributes:
\begin{itemize}
\item {} 
the audio or MIDI source file(s) they represent,

\item {} 
an offset (the “start point”) in the audio or MIDI file(s), and

\item {} 
a length.

\end{itemize}

When placed into a playlist, they gain additional attributes:
\begin{itemize}
\item {} 
a position along the timeline, and

\item {} 
a layer.

\end{itemize}

There are other attributes as well, but they do not \sphinxstyleemphasis{define} the region.
Things to know about regions:


\subsection{Regions Are Cheap}
\label{\detokenize{index:regions-are-cheap}}
By themselves, regions consume very little in terms of computer’s
resources. Each region requires a small amount of memory, and represents
a rather small amount of CPU work if placed into an active track. So,
multiplying regions creation whenever needed should not be much of an
issue CPU wise.


\subsection{Regions Are Not Files}
\label{\detokenize{index:regions-are-not-files}}
Although a region can represent an entire audio file, they are never
equivalent to an audio file. Most regions represent just parts of an
audio file(s) on disk, and removing a region from a track has nothing to
do with removing the audio file(s) from the disk (the Destroy operation,
one of Ardour’s few destructive operations, can affect this). Changing
the length of a region has no effect on the audio file(s) on disk.
Splitting and copying regions does not alter the audio file in any way,
nor does it create new audio files (only recording, and the Export,
Bounce and Reverse operations create new audio files).


\chapter{40.2 - Region Naming}
\label{\detokenize{index:region-naming}}
Region names are initially derived from either:
\begin{itemize}
\item {} 
the name of the track for which they were recorded, or

\item {} 
the name of the embedded/imported file they represent.

\end{itemize}


\section{Whole File Region Names}
\label{\detokenize{index:whole-file-region-names}}
These are not audio files, but regions that represent the full extent of
an audio file. Every time a new recording is done, or a new file is
imported to the session, a new region is created that represents the
entire audio file. This region will have the name of the
track/playlist/original file, followed by a “-“, then a number plus a
dot and then a number.

For recorded regions, the number will increase each time a new recording
is made. So, for example, if there is a track called Didgeridoo, the
first recorded whole file region for that playlist will be called
Didgeridoo-1. The next one will be Didgeridoo-2 and so on.

For imported regions, the region name will be based on the original file
name, but with any final suffix (e.g. “.wav” or “.aiff”) removed.

Normally, whole file regions are not inserted into tracks or playlists,
but regions derived from them are. The whole-file versions live in the
{\hyperref[\detokenize{index:the-region-list}]{\emph{Editor’s region list}}} where they act as an
organizing mechanism for regions that are derived from them.


\section{Normal Region Names}
\label{\detokenize{index:normal-region-names}}
When a region is inserted into a track and playlist, its initial name
will end in a version number, such as .1. For a recorded region, if the
whole file region was Hang drum-1, then the region in the track will
appear with the name Hang drum-1.1. For an imported region, if the whole
file region was Bach:Invention3, then the region in the track will
appear with the name Bach:Invention3.1.


\section{Copied Region Names}
\label{\detokenize{index:copied-region-names}}
Duplicating or splitting a region creates new region(s) that are based
on the same original files. Hence, they share the same base name (in the
example above, Hang drum-1), but their version number will be
incremented each time. Duplicating Hang drum-1.4 by left dragging it
will create a new region called Hang drum-1.5. Splitting Hang drum-1.5
by hitting the S key will remove the Hang drum-1.5 region and create two
shorter regions named Hang drum-1.6 and Hang drum-1.7.


\section{Renaming Regions}
\label{\detokenize{index:renaming-regions}}
Regions can be renamed at any time using the region context menu : right
click \textgreater{} \sphinxstyleemphasis{name\_of\_the\_region} \textgreater{} Rename… . The new name does not need to
have a version number in it (in fact, it probably should not). Ardour
will add a version number in the future if needed (e.g. if the region is
copied or sliced).


\chapter{40.3 - Corresponding Regions Selection}
\label{\detokenize{index:corresponding-regions-selection}}
{\hyperref[\detokenize{index:the-track-and-bus-group-list}]{\emph{Track Groups}}} have a property titled
Select which, if enabled, cause Ardour to propagate a region selection
in one track of a group to the corresponding regions of the other tracks
in that group.

This can be particularly useful when an instrument has been recorded
using multiple microphones (e.g. a drum kit): by enabling the Select
property for the group, selecting a region in one of the tracks, Ardour
will select the corresponding region in every other track of the group,
which in turn means that a subsequent edit operation will affect all the
tracks together.


\section{How Ardour Decides Which Regions are “Corresponding”}
\label{\detokenize{index:how-ardour-decides-which-regions-are-corresponding}}
Regions in different tracks are considered to be corresponding for the
purposes of sharing selection if they satisfy \sphinxstyleemphasis{all} the following
criteria:
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
each region starts at the same offset within its source file,

\item {} 
each region is located at the same position on the timeline, and

\item {} 
each region has the same length.

\end{enumerate}


\section{Overlap Correspondence}
\label{\detokenize{index:overlap-correspondence}}
Sometimes, the rules outlined above are too strict to get Ardour to
consider regions as corresponding. Regions may have been trimmed to
slightly different lengths, or positioned slightly differently, and this
will cause Ardour to not select regions in other grouped tracks.

In this case, changing Edit \textgreater{} Preferences \textgreater{} Editor \textgreater{} Regions in active
edit groups are edited together: to whenever they overlap in time will
allow regions in different tracks to be considered equivalent for the
purposes of selection if they overlap. This is much more flexible and
will cover almost all of the cases that the fixed rules above might make
cumbersome.


\chapter{40.4 - Region Context Menu}
\label{\detokenize{index:region-context-menu}}
In the editor window, right clicking (context clicking) on a region
displays a menu with track and region operations. The menu begins with
the name of the region, or Selected Regions if multiple regions are
selected. Selecting it will display {\hyperref[\detokenize{index:the-region-menu}]{\emph{the Region
menu}}} for operations on this(these) region(s).

Some items may not be in the exact same order as in the main menu.

If there is more than one region layered at the point clicked, the menu
will also contain a Choose Top item. This dialog allows to select which
region should be on the top layer. See {\hyperref[\detokenize{index:layering-display}]{\emph{Adjusting Region
Layering}}} for more details.

Below these items is the rest of the {\hyperref[\detokenize{index:track-context-menu}]{\emph{Track Context
Menu}}}, which provides access to track-level
operations.


\chapter{40.5 - Common Region Edit Operations}
\label{\detokenize{index:common-region-edit-operations}}
This section covers a set of region editing operations that are likely
to be used often while working on a session. Depending on work habits
(and experience of other DAWs), some of these operations will be
critical while others are used only rarely.

All of these operations can be carried out from the keyboard (see
{\hyperref[\detokenize{index:default-keyboard-bindings}]{\emph{Default Keyboard Shortcuts}}} for a list).
Equivalent operations can be performed with the mouse in most cases.

Some of these operations make use of {\hyperref[\detokenize{index:edit-point-control}]{\emph{the edit
point/range}}} and {\hyperref[\detokenize{index:which-regions-are-affected}]{\emph{affect specific
regions}}}.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

Spot (Align)
&
Move selected regions to the edit
point.
\\
\hline
Split
&
Split selected regions at the
edit point.
\\
\hline
Trim Start
&
Adjust the start of selected
regions to the edit point (or as
close as possible).
\\
\hline
Trim End
&
Adjust the end of selected
regions to the edit point (or as
close as possible).
\\
\hline
Duplicate
&
Make a copy of each selected
region and position it
immediately after the original.
\\
\hline
Crop
&
Truncate selected regions to the
edit range.
\\
\hline
Separate
&
Split selected regions at both
ends of the edit range.
\\
\hline
Set Fade In
&
Adjust selected audio regions’
fade in to end at the edit point.
\\
\hline
Set Fade Out
&
Adjust selected audio regions’
fade out to end at the edit
point.
\\
\hline
Toggle Fade In
&
Turn selected audio regions’ fade
in on or off.
\\
\hline
Toggle Fade Out
&
Turn selected audio regions’ fade
out on or off.
\\
\hline
Play Region
&
Play session from the start of
the earliest selected region.
\\
\hline
Zoom To Region
&
Zoom horizontally so that the
selected regions span the editor
track view.
\\
\hline
Set Sync Point
&
Set the sync point of all
selected regions to the edit
point.
\\
\hline
Insert
&
Inserts the currently selected
regions in the Region List at the
edit point.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\chapter{40.6 - Copy Regions}
\label{\detokenize{index:copy-regions}}

\section{Copy a Single Region}
\label{\detokenize{index:copy-a-single-region}}
Copying a region is done using the {\hyperref[\detokenize{index:toolbox}]{\emph{Grab mouse mode}}}, by
moving the mouse pointer into the region and left-dragging. Ardour
creates a new region and follows the mouse pointer as it moves. See
{\hyperref[\detokenize{index:move-regions-with-the-mouse}]{\emph{Move Regions}}} for more details on
moving the copied region.


\section{Copy Multiple Regions}
\label{\detokenize{index:copy-multiple-regions}}
Copying multiple regions requires them to be selected before copying.
Then left-dragging one of the selected regions will copy the regions as
they move. The copied regions will keep their positions relative to each
other.


\section{Fixed-Time Copying}
\label{\detokenize{index:fixed-time-copying}}
Copying region(s) to other track(s) while keeping the copies at the same
exact position on the timeline as the originals is done by simply using
a Middle-drag instead.


\chapter{40.7 - Move Regions With the Mouse}
\label{\detokenize{index:move-regions-with-the-mouse}}
Moving or copying a region is done using the {\hyperref[\detokenize{index:toolbox}]{\emph{Grab mouse
mode}}}, or the Smart mode with the pointer in the lower half
of the region to begin a move or {\hyperref[\detokenize{index:copy-regions}]{\emph{copy}}} operation.

With the pointer in the region, using a Left-drag will make the region
follow the pointer as it is moved around. By default, the region can
move freely along the timeline.

To move a region from one track to another, the move must be started as
described above, but the pointer should end in the desired track. The
region will follow the pointer.

if some other kinds of tracks are visible, the region will remain where
it is as the pointer moves across them, and will then jump to the new
track. This serves as a visual reminder that an audio region cannot be
dragged into an automation track or a bus, for example.


\section{Move Multiple Regions}
\label{\detokenize{index:move-multiple-regions}}
In order to move multiple regions, they should be selected before
moving. Then Left-dragging one of the selected regions will move all the
regions, keeping their positions relative to each other.


\section{Fixed-Time Motion}
\label{\detokenize{index:fixed-time-motion}}
Moving region(s) to other track(s) while keeping its at the same exact
position on the timeline is done by simply using a Middle-drag instead.


\chapter{40.8 - Align (Spot) Regions}
\label{\detokenize{index:align-spot-regions}}
Aligning regions (sometimes called “spotting”) means moving one or more
regions based on a defined location, which in Ardour is always the {\hyperref[\detokenize{index:edit-point-control}]{\emph{edit
point}}}. An alignment operation moves the
region(s) so that some part of the region is positioned at the edit
point. Available alignment commands include:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

Align Region starts a
&
Selected region(s) are moved so
that their start is located at
the current edit point
\\
\hline
Align Region ends a
&
Selected region(s) are moved so
that the end is located at the
current edit point
\\
\hline
Align Region sync points a
&
Selected region(s) are moved so
that their sync point is located
at the current edit point
\\
\hline
Align Region starts relative a
&
Selected region(s) are moved so
that the start of the earliest
region is located at the current
edit point, and all others
maintain their relative position
relative to that region
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\chapter{41 - Edit Mode and Tools}
\label{\detokenize{index:edit-mode-and-tools}}

\chapter{41.1 - Editing Clocks}
\label{\detokenize{index:editing-clocks}}

\section{Clock Modes}
\label{\detokenize{index:clock-modes}}
Every clock in Ardour has four different, selectable clock modes. Each
mode displays time using different units. The clock mode can be changed
by Right-clicking on the clock and selecting the desired mode from the
menu. Some clocks are entirely independent of any other clock’s mode;
others are linked so that changing one changes all clocks in that group.
The different modes are:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

Timecode
&
Time is shown as SMPTE timecode
in Hours:Minutes:Seconds:Frames,
measured from the timecode zero
point on the timeline (which may
not correspond to the session
start and/or absolute zero on the
timeline, depending on
configurable timecode offsets).
The frames value is dictated by
either the session FPS setting,
or, if slaved to an external
timecode master, the master’s
setting. In the transport clocks,
the FPS value is shown below the
time display, along with an
indication of the current
timecode source (INT means that
Ardour is its own timecode
source).
\\
\hline
BBT
&
Time is shown as
Bars:Beats:Ticks, indicating
musical time measured from the
start of the session. The
transport clocks show the current
tempo in bpm and meter below the
time display.
\\
\hline
Minutes:Seconds
&
Time is shown as
Hours:Minutes:Seconds.Millisecond
s,
measured from the absolute start
of the timeline (ignoring the
session start and any timecode
offsets).
\\
\hline
Samples
&
Time is shown as a sample count
from the absolute start of the
timeline (ignoring the session
start and any timecode offsets).
The number of samples per second
is given by the current sample
rate, and in the transport
clocks, this rate is shown below
the time display along with any
pullup/pulldown adjustment.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\section{Changing clock values with the keyboard}
\label{\detokenize{index:changing-clock-values-with-the-keyboard}}
New values for the clock can be typed in after clicking on the relevant
clock. Clicking on the clock will show a thin vertical cursor bar just
to the right of the next character to be overwritten. Time should be
typed in the same order as the current clock mode—if the clock is in
Timecode mode, it should be hours, minutes, seconds, frames. So, to
change to a time of 12:15:20:15 one would type 12152015. Each number
typed will appear in a different color, from right to left, overwriting
the existing value. Mid-edit, after typing 3222 the clock might look
like this:

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{clockedit}.png}
\caption{A clock being edited in Ardour}\label{\detokenize{index:id537}}\end{figure}

Finishing the edit is done by pressing ↵ or Tab. The ESC key allows to
exit an edit without changing the clock. If an entry is mis-typed so
that the new value would be illegal (for example, resulting in more than
30 frames when Timecode is set to 30 frames per second), the clock will
reset at the end of the edit, and move the cursor back to the start to
allow for another try.


\section{Avoiding the mouse entirely}
\label{\detokenize{index:avoiding-the-mouse-entirely}}
There is a shortcut available to edit the transport clocks entirely
without the mouse. It can be found in Window \textgreater{} Key Bindings \textgreater{} Transport
\textgreater{} Focus On Clock. If bound to a key (÷ on the numerical keypad is the
default), then pressing that key is equivalent to clicking on the
primary (left) transport clock, and editing can begin immediately.


\section{Entering Partial Times}
\label{\detokenize{index:entering-partial-times}}
One detail of the editing design that is not immediately obvious is that
it is possible to enter part of a full time value.

As an example, supposing that the clock is in BBT mode, displaying
024\textbar{}03\textbar{}0029, altering the value to the first beat of the current bar can
be done by clicking on the clock and typing 010000. Similarly, if it is
in Minutes:Seconds mode, displaying 02:03:04.456, getting to exactly 2
hours can be achieved by clicking on the clock and typing 0000000 to
reset the minutes, seconds and milliseconds fields.


\section{Entering Delta Times}
\label{\detokenize{index:entering-delta-times}}
Values can also be typed into the clock that are intended as a relative
change, rather than a new absolute value, by ending the edit by pressing
+ or - (the ones on any keypad will also work). The plus key will add
the entered value to the current value of the clock, minus will subtract
it. For example, if the clock is in Samples mode and displays 2917839,
moving it back 2000 samples is done by typing 2000 and -, rather than
ending with Enter or Tab.


\section{Changing clock values with the mouse}
\label{\detokenize{index:changing-clock-values-with-the-mouse}}

\subsection{Using a scroll wheel}
\label{\detokenize{index:using-a-scroll-wheel}}
With the mouse pointer over the clock, moving the scroll wheel changes
the clock values. Moving the scroll wheel up (⇑) increases the value
shown on the clock, moving it down (⇓) decreases it. The step size is
equal to the unit of the field hovered over (seconds, hours, etc.).


\subsection{Dragging the mouse}
\label{\detokenize{index:dragging-the-mouse}}
With the mouse pointer over the clock, pressing the left mouse button
and dragging also affects the clocks: dragging upwards increases the
value shown on the clock, dragging downwards decreases it, again with a
step size equal to the unit of the field where the drag began on.


\chapter{41.2 - Which Regions Are Affected?}
\label{\detokenize{index:which-regions-are-affected}}
This section explains the rules used to decide which regions are
affected by editing operations. They don’t really have to be
understood—hopefully things will Just Work—but it may be useful
eventually.

Editing operations in Ardour either operate on a single point in time
(Split being the obvious example) or on two points (which can also be
considered to be a range of sorts), Separate is a good example of this.

Most operations will operate on the currently selected region(s), but if
no regions are selected, the region that the mouse is in will be used
instead. Single-point operations will generally pick a set of regions to
use based on the following rules:
\begin{itemize}
\item {} 
If the {\hyperref[\detokenize{index:edit-point-control}]{\emph{Edit Point}}} is mouse, then
\begin{itemize}
\item {} 
if the mouse is over a selected region, or no region, use all
selected regions, or

\item {} 
if the mouse is over an unselected region, use just that region.

\end{itemize}

\item {} 
For all other Edit Points
\begin{itemize}
\item {} 
use the selected regions \sphinxstyleemphasis{and} those that are both under the edit
position \sphinxstyleemphasis{and} on a selected track, or on a track which is in the
same active edit-enabled route group as a selected region.

\end{itemize}

\end{itemize}

The rationale here for the two different rules is that the mouse Edit
Point is special in that its position indicates both a time and a track;
the other edit points (Playhead,Marker) indicate a time only.


\chapter{42 - Making Selections}
\label{\detokenize{index:making-selections}}\label{\detokenize{index:select-regions}}
Many editing operations in Ardour require to first select one or more
regions to change them in some way. A single region, or multiple regions
can be selected, including regions in different tracks. When a region is
selected, it will appear in a darker color than unselected regions.

If a track is a member of a group that is active and has the Select
property enabled, then Ardour will attempt to match whatever selections
is made in one track across every other track of the group. See
{\hyperref[\detokenize{index:corresponding-regions-selection}]{\emph{Corresponding Regions Selection}}}
for more information on precisely how selections will be propagated to
other tracks.


\section{Track Selection}
\label{\detokenize{index:track-selection}}
Tracks are selected by clicking on the Track header at the left of the
Editor window. Multiple tracks can be selected with Left clicks, or a
range of consecutive tracks with Left.


\section{Region Selection}
\label{\detokenize{index:region-selection}}
Using the {\hyperref[\detokenize{index:toolbox}]{\emph{Grab Mode tool}}}, left clicking on a region
selects it. If {\hyperref[\detokenize{index:toolbox}]{\emph{Smart mode}}} is enabled, the lower half of
the region must be clicked.


\section{Deselecting a Region}
\label{\detokenize{index:deselecting-a-region}}
Still using the {\hyperref[\detokenize{index:toolbox}]{\emph{Grab Mode tool}}}, Left-clicking the region
deselects it. If {\hyperref[\detokenize{index:toolbox}]{\emph{Smart mode}}} is enabled, the lower half of
the region must be clicked.

Note that a left click simply toggles the selected status of an object,
so it can be used to select unselected regions too.


\section{Selecting Multiple Regions in a Track}
\label{\detokenize{index:selecting-multiple-regions-in-a-track}}
This can be achieved in different ways:
\begin{itemize}
\item {} 
Left-clicking each region.

\item {} 
Dragging a rubberband box from an empty point in a track before the
first region to select to a point within or after the last region to
select. Using left-drag allows doing it multiple times.

\item {} 
If the regions are all adjacent to one another, clicking the first
region to select, then Left-clicking the last one.

\end{itemize}


\section{Selecting All Regions in a Track}
\label{\detokenize{index:selecting-all-regions-in-a-track}}
The Select \textgreater{} Select All In Track option in the context menu (Right click
on the track) selects all the regions in the track at once.

See the {\hyperref[\detokenize{index:track-context-menu}]{\emph{Track Context Menu}}} for more
information on other per-track selection operations that are available.


\section{Selecting Multiple Regions Across Different Tracks}
\label{\detokenize{index:selecting-multiple-regions-across-different-tracks}}
This can be achieved by a left-click or Left-click on the regions to
select.


\section{Selecting a Region From the Region List}
\label{\detokenize{index:selecting-a-region-from-the-region-list}}
Clicking the name of the region in the {\hyperref[\detokenize{index:the-region-list}]{\emph{Region
List}}}. selects it. This will do nothing for
whole-file regions, since they do not exist anywhere in a playlist or
track.


\chapter{43 - Editing Regions and Selections}
\label{\detokenize{index:editing-regions-and-selections}}

\chapter{43.1 - Trimming Regions}
\label{\detokenize{index:trimming-regions}}
Changing the length of a region is a very common editing operation,
often known as trimming. There are several ways to accomplish this with
Ardour, and some very useful specialized trimming operations.


\section{Drag-Trimming With the Mouse}
\label{\detokenize{index:drag-trimming-with-the-mouse}}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{trimming-region-before}.png}
\caption{Trimming region - before and after}\label{\detokenize{index:id538}}\end{figure}

In Grab mode, moving the pointer near the beginning or end of the region
changes the cursor to indicate that trimming is possible, and the edge
of the region can then be Left-dragged in both directions.

Trimming will obey {\hyperref[\detokenize{index:grid-controls}]{\emph{Snap settings}}}.


\section{Other Trimming operations}
\label{\detokenize{index:other-trimming-operations}}
There are several commands for region trimming. Some use the {\hyperref[\detokenize{index:edit-point-control}]{\emph{edit
point}}} to determine where to trim to. Some are
not bound to any keys by default (but could be via the {\hyperref[\detokenize{index:default-keyboard-bindings}]{\emph{Keybindings
Editor}}}).

These command are both in the Region \textgreater{} Trim main menu (with a region
selected) or in the context menu of a region, right click on a region \textgreater{}
\sphinxstyleemphasis{Name\_Of\_The\_Region} \textgreater{} Trim


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

Trim Start at Edit Point (j)
&
Trim selected region(s) start to
edit point.
\\
\hline
Trim End at Edit Point (k)
&
Trim selected region(s) end to
edit point.
\\
\hline
Trim to Loop/Punch
&
Trim selected region(s) beginning
and end to the loop/punch
boundaries (if it exists).
\\
\hline
Trim to Previous (j)
&
Trim the start of selected
region(s) to the end of the
previous region. If the region is
too short, it is extended to its
maximum to the left.
\\
\hline
Trim to Next (k)
&
Trim the end of selected
region(s) to the start of the
following region. If the region
is too short, it is extended to
its maximum to the right.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\chapter{43.2 - Push/Pull Trimming}
\label{\detokenize{index:push-pull-trimming}}
Normally, when trimming regions by dragging with the mouse, it affects
only the selected regions. Their lengths are directly affected by the
trim operation, but nothing else is. Sometimes though, when trimming a
region that directly adjoins another, the desired result is to move the
boundary between the regions and not to make these regions overlap. This
requires trimming both regions on either side of the junction, in
opposite directions. Push/Pull trim, activated by pressing key before
starting the drag, will do just that.

The following pictures show the difference in the results of a normal
trim and a push/pull trim:

In the initial situation, before trimming, two adjacent regions are
present, the rightmost-one being selected.

The simple trim, obtained by dragging the selected region’s starting
position earlier, overlaps the earlier region. A crossfade has been
manually created between them, so their sound will fade from the
leftmost region to the rightmost one.

If the same trim is done, but by Left-dragging to turn it into a
push-pull trim instead, there is no overlap, and the end of the earlier
region has been moved along with the start of the later region, so that
they still directly adjoin each other. In effect, it is like doing a
simple trim to reduce the leftmost region, then doing a simple trim to
extend the rightmost one to fill the gap.


\chapter{43.3 - Stretching}
\label{\detokenize{index:stretching}}
The Stretch Mode tool can be switched to by selecting it in the
{\hyperref[\detokenize{index:toolbox}]{\emph{Toolbox}}}, or simply by hitting the T key.

It allows to extend or reduce the duration of a region, optionally
maintaining its pitch. This is one of the few operations in Ardour that
affect the underlying audio data from a region, even if the original
audio is kept safely—no data is lost in the process.

This operation is usually used to fit an audio sequence with a different
rhythm into a session, but can be used in a wide area of cases, due to
its ability to maintain or alter the pitch.

The Stretch Mode tool is very similar in use to doing a trim in grab
mode: the boundary (start or end) is left-clicked and dragged to its
wanted position. Notice a timer appearing, showing the new duration of
the region using the same {\hyperref[\detokenize{index:editing-clocks}]{\emph{clock mode}}} as in the
{\hyperref[\detokenize{index:transport-clocks}]{\emph{primary transport clock}}}.

Stretching is a complex operation (phase vocoding), involving
resampling, frequency analysis and synthesis. The parameters used to
transform the audio data are user tweakable, and exposed to the user as
the left mouse button is released:

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{time-stretch-audio}.png}
\caption{The Time Stretch Audio window}\label{\detokenize{index:id539}}\end{figure}

The Time Stretch Audio window is made of:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

Duration
&
The target duration of the
region, expressed using the
primary transport clock’s mode
\\
\hline
Percent
&
The target duration of the
region, expressed as a percentage
of the region’s original length.
Can be either higher than 100\%
(to expand the region) or lower
(to shrink it)
\\
\hline
Contents
&
The type of audio the region is
made of. Ardour will fine-tune
its algorithm based on this
content, see below
\\
\hline
Minimize time distortion
&
Tries to reduce the smearing of
the audio created by the phase
vocoding process
\\
\hline
a Progress bar
&
showing the operation in
progress.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

The \sphinxstyleemphasis{Contents} should be selected to best fit the actual content of the
region, amongst:

Content

Disable phase resynchronisation at transients

Band-limit phase resync to extreme frequencies

Disable phase locking to peak frequencies

Use longer processing window (actual size may vary)

Use shorter processing window

Mushy

X

X

X

Smooth

X

X

Balanced multitimbral mixture

X

Unpitched percussion with stable notes

X

Crisp monophonic instrumental (\sphinxstyleemphasis{default})

Unpitched solo percussion

X

X

Resample without preserving pitch

\sphinxstyleemphasis{see below}

While the table above details \sphinxstyleemphasis{how} the different kinds of audio
material alter the fine-tuning of the DSP, from an user point of view,
the operation often consists in trying different settings and listening
to the result.

The best way to start experimenting is to consider the material itself:
\begin{itemize}
\item {} 
If the material doesn’t need its pitch to be preserved, the best
choice is \sphinxstyleemphasis{Resample without preserving pitch}

\item {} 
For drum-type material, the best choice is (depending on the
transients crispness, stretching factor…) one of the two
\sphinxstyleemphasis{percussion} types

\item {} 
For melodic mono-tonal material (bass, winds,…), the best (and
default) choice is \sphinxstyleemphasis{Crisp monophonic instrumental}

\item {} 
For multi-tonal material (chords,…), either one of the three first
choice, or the default \sphinxstyleemphasis{Crisp}.

\end{itemize}


\chapter{43.4 - Separate Under}
\label{\detokenize{index:separate-under}}

\section{Separate Under}
\label{\detokenize{index:separate-under-1}}\label{\detokenize{index:id22}}
When one region is over another, and the lower region has to be cut so
that it directly adjoins both ends of the overlapping one, with no
overlaps, the Separate Under tool can be a very efficient time-saver.
With the upper region selected, the Edit \textgreater{} Separate \textgreater{} Separate Under
menu will split the lower region so that it no longer overlaps the upper
region at all.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{before-separate-under}.png}
\caption{Region arrangement before and after ‘Separate Under’}\label{\detokenize{index:id540}}\end{figure}

If the upper region covers only one end of the lower region, then this
operation is equivalent to {\hyperref[\detokenize{index:trimming-regions}]{\emph{Trim to Next or Trim to
Previous}}}, depending on which end is covered.


\section{Separate Using Range}
\label{\detokenize{index:separate-using-range}}
A loop or punch range can also be used to slice a region. By using the
Edit \textgreater{} Separate \textgreater{} Separate Using Loop/Punch Range, any selected regions
that are covered by the range at both ends of the range, or just one if
the range only covers part of the region. This makes it easy to generate
regions that correspond precisely to a range.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{before-separate-loop}.png}
\caption{Region arrangement before and after ‘Separate Using Loop Range’}\label{\detokenize{index:id541}}\end{figure}


\chapter{43.5 - Strip Silence from Audio Regions}
\label{\detokenize{index:strip-silence-from-audio-regions}}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{strip-silence-window}.png}
\caption{The Strip Silence window}\label{\detokenize{index:id542}}\end{figure}

The Strip Silence tool allows to remove the parts of one or multiple
regions that are below a user-defined silence threshold. It does \sphinxstyleemphasis{not}
destroy the underlying audio, but trims the regions according to the
silence threshold parameter. The edit applies to all selected regions,
allowing batch processing.

The window, accessible either through the Region \textgreater{} Edit \textgreater{} Strip Silence
menu or right click on a region \textgreater{} \sphinxstyleemphasis{Name\_Of\_The\_Region} \textgreater{} Edit \textgreater{} Strip
Silenceis made of:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

Threshold
&
The audio level under which the
audio is considered silent (in
dBFS)
\\
\hline
Minimum length
&
A minimum number of samples for
Ardour to create a split. Under
this number, the region won’t be
sliced
\\
\hline
Fade length
&
Ardour adds fades, both in and
out, to the trimmed regions, to
the created region (so the sliced
regions are longer by both the in
and out fades duration, expressed
in samples)
\\
\hline
A progress bar
&
showing the time Ardour takes to
compute the trimming based on the
current parameters
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

Changing any parameter in the window is reflected in the main editor:
the silent segments are highlighted and the number and durations of the
shortest segments is displayed, helping fine-tune the parameters.

The minimum length for silence can be useful when editing very
percussive material and just needing to automatically trim the ends of a
region.


\chapter{43.6 - Insert/Remove Time}
\label{\detokenize{index:insert-remove-time}}\label{\detokenize{index:id23}}

\section{Insert Time}
\label{\detokenize{index:insert-time}}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{insert-time}.png}
\caption{The Insert Time window}\label{\detokenize{index:id543}}\end{figure}

The Insert Time window allows to insert blank space in the timeline, on
the selected track(s). It is accessed through the Track \textgreater{} Insert Time
menu.

The Insert Time window not only allows to set the time inserted, but
also some fine tuning options:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

Insert Time starting at:
&
Sets the point in the session
where the time will be added. By
default, it is the playhead’s
position
\\
\hline
Time to insert:
&
Duration of the blank space
inserted
\\
\hline
Intersected regions should:
&
A choice as to what happens to
regions that exists at the Insert
Time set above. See below.
\\
\hline
Apply to all the track’s
playlists
&
As a track can have multiple
{\hyperref[\detokenize{index:understanding-playlists}]{\emph{playlists}}},
the insertion can happen either
only on the active playlist or on
all the playlists of this track
\\
\hline
Move glued-to-musical-time
regions (MIDI regions)
&
Defines if MIDI regions in
selected tracks are affected by
the operation
\\
\hline
Move markers
&
As a
{\hyperref[\detokenize{index:working-with-markers}]{\emph{marker}}}
\_
can be locked or glued to
bars/beats, this option and the
two subjacent ones allow to shift
the time position of those
markers
\\
\hline
Move tempo and meter changes
&
The {\hyperref[\detokenize{index:tempo-and-meter}]{\emph{tempo and
meter}}}
markers, that can be used to
change the tempo along the
session, can also be shifted in
the process. Though, moving the
tempo markers while e.g. keeping
the MIDI regions unaffected can
create oddities.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

Both the two time fields have a useful context menu, that allows to
copy/paste the time and change the display among one of the {\hyperref[\detokenize{index:editing-clocks}]{\emph{clock
modes}}}. The Insert Time field also has two options
to Set from Playhead (to get the insertion time from the playhead, which
is what happens by default) and Locate to This Time which moves the
playhead to the time field value, useful if the field has been manually
edited to better visualize the insertion point.

The “Intersected regions should” dropdown allows to select what happens
to regions that cross the insertion position:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

stay in position \sphinxstyleemphasis{(default)}
&
The crossed regions are not
affected by the time insertion.
Only regions after the insertion
point are moved.
\\
\hline
move
&
The crossed regions are shifted
in time.
\\
\hline
be split
&
The crossed regions are split,
and the section after the time
insertion point is shifted in
time.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

This last mode allows a \sphinxstyleemphasis{brute force} insertion, creating a blank space
in all the selected tracks, and replacing multiple operations.

Note: One interesting option is, if a range selection (created with in
{\hyperref[\detokenize{index:toolbox}]{\emph{Range Mode}}}) exists, it is used as the default parameters
in the window, instead of the playhead, for both the start time and
duration.


\section{Remove Time}
\label{\detokenize{index:remove-time}}
The Remove Time window, accessed through the Track \textgreater{} Remove Time menu,
is very similar to the previous, and its options are very similar. Only
the \sphinxstyleemphasis{“Intersected regions should”} option is not present.

The range selection note above can be especially useful in this context.


\chapter{43.7 - Region Properties}
\label{\detokenize{index:region-properties}}

\section{Region properties}
\label{\detokenize{index:region-properties-1}}\label{\detokenize{index:id25}}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{region-properties}.png}
\caption{The Region Properties window}\label{\detokenize{index:id544}}\end{figure}

The Region properties window brings information about the selected
regions, and allows to fine tune its sequencing. It is accessed through
the Region \textgreater{} Properties… menu, or by right clicking the region,
\sphinxstyleemphasis{Name\_of\_the\_Region} \textgreater{} Properties….

This window also allows to manually set the different values.

Field

Meaning

Editable

Name:

The {\hyperref[\detokenize{index:region-naming}]{\emph{name of the region}}} in the editor

X

Audition

This button allows to listen to the region and only the region, dry
(with no effects, regardless of the processors applied to the track).
For MIDI, the default MIDI synth, set in the
{\hyperref[\detokenize{index:preferences}]{\emph{Preferences}}}, is used to audition the region.

Position:

Position in time of the left-hand side of the region

X

End:

Position in time of the right-hand side of the region

X

Length:

Duration of the region (=End−Position)

X

Sync point (relative to region):

Position in time of the {\hyperref[\detokenize{index:grid-controls}]{\emph{Sync Point}}}, relative to the
beginning of the region. No manual sync point means the sync point is
the beginning of the region (=Position), so will show as “0” in time and
\sphinxcode{\sphinxupquote{001\textbar{}01\textbar{}0000}} in Bars:Beats notation.

X

Sync point (absolute):

Position in time of the {\hyperref[\detokenize{index:grid-controls}]{\emph{Sync Point}}}, relative to the
beginning of the session. No manual sync point means the sync point is
the beginning of the region, and will be equal to the Position.

X

File start:

Position in time of the beginning of the region relative to the source
file start. If the region has not been trimmed on the left, then the
regions start is the file start and this value is 0.

Source:

Name of the source audio/MIDI file the region is extracted from. A
region can be a part of or a whole audio/MIDI file, and multiple regions
can be based on the same source file.

X

Region gain:

\sphinxstyleemphasis{(Audio files only)} Manual gain, in dB, applied constantly to the whole
region, regardless of the global track’s gain, automation, etc…

X

Peak amplitude:

\sphinxstyleemphasis{(Audio files only)} Maximum level the signal reaches inside the region.
Expressed in dBFS (Full Scale), where 0 is the numeric maximum a signal
can reach.

All the fields marked as “editable” in the table above allow the user to
manually enter a value in the field, to manually set this value.

Right-clicking on a field allow to switch between the different {\hyperref[\detokenize{index:editing-clocks}]{\emph{clock
modes}}}.

The context menu that pops up also allows the relevant fields (Position,
End, and both Sync points) to be set from the playhead location, which
can be used to e.g. trim a region to the playhead or place a sync point
exactly on a beat.


\chapter{44 - Fades and Crossfades}
\label{\detokenize{index:fades-and-crossfades}}\label{\detokenize{index:create-region-fades-and-crossfades}}
Every Region has a fade-in and fade-out. By default, the region fade is
very short, and serves to de-click the transitions at the start and end
of the region. By adjusting the regions fade length, a more gradual
transition can be accomplished.


\section{Region Fades}
\label{\detokenize{index:region-fades}}
Region fades are possible at the beginning and end of all audio regions.
In object mode, a grip appears at the top left and top right of an audio
region when the cursor hovers over it. Placing the cursor over the top
of the grip displays the region fade cursor tip. Clicking and dragging
the grip left or right in the timeline adjusts the length of the fade.


\section{Crossfades}
\label{\detokenize{index:crossfades}}
Crossfades refer to the behavior of two audio regions transitioning
smoothly (mixing) from one to another on the same track. Historically,
this was done by splicing two pieces of analog tape together, and this
concept was carried forward into digital editing. Each track is a
sequence of sound files (regions). If two regions are butted against
each other, there needs to be a method to splice them smoothly together.
The crossfade allows one region to fade smoothly out, while the next
region fades smoothly in, like two pieces of tape that have been cut at
an angle, and overlapped.

But Ardour uses a more refined “layered” editing model, and therefore it
is possible for multiple regions to be stacked on a single location with
arbitrary overlaps between different layers. For this reason, crossfades
must be implemented differently. It can’t be assumed that a crossfade is
an entity that exists between two regions; instead each region must have
its own associated crossfades at each end, and the topmost region must
always crossfade down to the underlying region(s), if any.

Ardour solves this problem by putting a crossfade at the beginning and
end of every region. The fades of the bottom-most region are first
rendered, and then each region is rendered on top of the one below it,
with fades at the end of each region providing a crossfade to the
region(s) beneath it.

It is important to understand that region fades \sphinxstyleemphasis{are} crossfades. When
one region has another region or multiple regions beneath its fade area,
then what will be heard is the topmost region fade-out mirrored as a
fade-in on the underlying region(s). The grip for the topmost region
will allow changing the length and type of the crossfade into the
underlying region(s). In this way complicated series of crossfades can
be created, and then another region layered atop the others, and faded
into a complicated series.

If a region doesn’t have any region(s) under it, then the region is
crossfaded to silence; for convenience this is called a “fade” rather
than a crossfade.


\section{Fade Shapes}
\label{\detokenize{index:fade-shapes}}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{crossfade_menu}.png}
\caption{The fade shape context menu.}\label{\detokenize{index:id545}}\end{figure}

To activate/deactivate or change the shape of a region’s fadein or
fade-out, the cursor has to be hovered over the region fade grip until
the cursor tip indicates region fade editing, then right clicked to
bring up a context menu. In the context menu is a list of options for
the region fade. Activate/Deactivate enables and disables the region
fade.

Because each fade is also a crossfade, it has an inverse fade shape for
the audio beneath the fade. It is important to know how the shapes
differ, and which are most suitable for various editing tasks.

The different types of fades are:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

Linear
&
A simple linear coefficient
decrease, and its mathematical
inverse. A Linear fade starts
attenuating quickly, and then
cuts off even more abruptly at
lower levels. When used as a
crossfade, the signals are each
-6dB attenuated at the midpoint.
This is the correct crossfade to
use with highly-correlated
signals for a smooth transition.
\\
\hline
Constant Power
&
The constant power curve starts
fading slowly and then cuts off
abruptly. When used as a
crossfade between 2 audio
regions, the signals are
symmetrically attenuated, and
they each reach -3dB at the
midpoint. This is the correct
crossfade to use when splicing
audio in the general
(uncorrelated) case.
\\
\hline
Symmetric
&
The Symmetric fade starts slowly,
then attenuates significantly
before transitioning to a slower
fade-out near the end of the
fade. When used as a crossfade,
the Symmetric curve is not
mathematically correct like the
Constant Power or Linear curves,
but it provides a slower fade-out
at low volumes. This is sometimes
useful when editing 2 entire
music works together so that the
transition is more gradual.
\\
\hline
Slow
&
The Slow curve is a modified
linear decibel fade. The initial
curve starts more gradually so
that it has a less abrupt
transition near unity. After
that, it sounds like a perfectly
smooth fader or knob moved to
silence. This shape is excellent
as a general-purpose fade-out.
When used as a crossfade, the
inverse fade curve maintains
constant power but is therefore
non-symmetric; so its use is
limited to those cases where the
user finds it appropriate.
\\
\hline
Fast
&
The Fast curve is a linear
decibel fade; It sounds like a
perfectly smooth fader or knob
moved to silence. This shape is
excellent as a general-purpose
fade-in. When used as a
crossfade, the inverse fade curve
maintains constant power but is
therefore non-symmetric; so its
use is limited to those cases
where the user finds it
appropriate.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

Although these fade shapes serve specific purposes, any of the shapes is
usable in any situation, so the final decision is mostly an artistic
choice.

These fade curves are developed to provide a range of common uses, and
are developed with the least possible amount of changes in the “slope”
of the line. This provides artefact-free crossfades. Some DAWs provide
complicated fade editors with parametric “spline” controls of the fade
curves. While it might be interesting to develop a fade curve with a
faster cutoff, the mathematical difference between this and simply
shortening the fade is vanishingly small; and the amount of effort to
shorten the fade is much easier than messing with a crossfade editor
dialog.


\chapter{45 - Gain Envelopes}
\label{\detokenize{index:gain-envelopes}}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{gain-envelope1}.png}
\caption{A gain envelope (in green).}\label{\detokenize{index:id546}}\end{figure}

In Ardour, every region has a gain envelope, which is normally hidden.
Clicking on the Draw tool will cause all the gain envelopes on all
regions to show themselves; these will appear as green lines with square
dots (control points) at the beginning and end of each region. The
vertical axis represents gain, with the top of the region representing
+6dB and the bottom representing approximately -170dB. By default, the
line starts and ends at 0dB; the control points can be moved up and down
to change the amount of gain at that point.

Gain follows the line between control points continuously during
playback, and adjusts the gain for that region accordingly. It is
completely automatic, unlike channel {\hyperref[\detokenize{index:automation}]{\emph{automation}}}.


\section{Manipulating Gain Envelopes}
\label{\detokenize{index:manipulating-gain-envelopes}}
The default gain curve, by itself, is not very useful; in order to have
more control over the shape of the gain envelope it is necessary to add
extra control points. Clicking anywhere in the region where there are no
existing control points adds a control point to the envelope; it will
appear \sphinxstyleemphasis{on the line} at the X-axis of the mouse’s current position in
the region.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{gain-envelope2}.png}
\caption{A more complex gain envelope.}\label{\detokenize{index:id547}}\end{figure}

Once added, a control point can be Left clicked and dragged to the
desired location. Hovering over a control point will show its current
level in dB. Left clicking a control point and pressing Delete, or Right
clicking a point deletes it.


\chapter{46 - Playlists}
\label{\detokenize{index:id26}}

\chapter{46.1 - Understanding Playlists}
\label{\detokenize{index:understanding-playlists}}
A playlist is a list of regions ordered in time. It defines which parts
of which source files should be played and when. Playlists are a fairly
advanced topic, and can be safely ignored for many types of audio
production. However, the use of playlists allows the audio engineer more
flexibility for tasks like multiple takes of a single instrument,
alternate edits of a given recording, parallel effects such as reverb or
compression, and other tasks.

Each audio track in Ardour is really just a mechanism for taking a
playlist and generating the audio stream that it represents. As a
result, editing a track really means modifying its playlist in some way.
Since a playlist is a list of regions, most of the modifications involve
manipulating regions: their position, length and so forth. This is
covered in the chapter {\hyperref[\detokenize{index:working-with-regions}]{\emph{Working With Regions}}}.

This page covers some of the things that can be done with playlists as
objects in their own right.


\section{Tracks are not Playlists}
\label{\detokenize{index:tracks-are-not-playlists}}
It is important to understand that a track \sphinxstyleemphasis{is not} a playlist. A track
\sphinxstyleemphasis{has} a playlist. A track is a mechanism for generating the audio stream
represented by the playlist and passing it through a signal processing
pathway. At any point in time, a track has a single playlist associated
with it. When the track is used to record, that playlist will have one
or more new regions added to it. When the track is used for playback,
the contents of the playlist will be heard. The playlist associated with
a track can be changed at (almost) any time, and tracks can even share
playlists.

Some other DAWs use the term “virtual track” to define a track that
isn’t actually playing or doing anything, but can be mapped/assigned to
a real track. This concept is functionally identical to Ardour’s
playlists. We just like to be little more clear about what is actually
happening rather than mixing old and new terminology (“virtual” and
“track”), which might be confusing.


\section{Playlists are Cheap}
\label{\detokenize{index:playlists-are-cheap}}
One thing to bear in mind is that playlists are cheap. They do not cost
anything in terms of CPU consumption, and they have very minimal efforts
on memory use. So generating new playlists whenever needed is
recommended. They are not equivalent to tracks, which require extra CPU
time and significant memory space, or audio files, which use disk space,
or plugins that require extra CPU time. If a playlist is not in use, it
occupies a small amount of memory, and nothing more.


\chapter{46.2 - Playlist Operations}
\label{\detokenize{index:playlist-operations}}
In the {\hyperref[\detokenize{index:audio-track-controls}]{\emph{track header}}} (editor window, left
pane) is a button labelled p (for “Playlist”). A click on this button
displays the following menu:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

(Local Playlists)
&
Shows all of the playlists
associated with this track, and
indicates the currently selected
playlist
\\
\hline
Rename…
&
Displays a dialog to rename the
current playlist
\\
\hline
New…
&
Creates a new empty playlist, and
the track switches to the new
playlist
\\
\hline
New Copy…
&
Creates a new playlist that is a
copy of the current playlist; the
track switches to the new
playlist
\\
\hline
Clear Current
&
Removes all regions from the
current playlist
\\
\hline
Select From All…
&
Displays a playlist browser to
manually choose which playlist
this track should use. (from this
track or another one)
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\section{Renaming Playlists}
\label{\detokenize{index:renaming-playlists}}
Playlists are created by default with the name of the active playlist,
plus a version number, and the first playlist is named after the track
with which it is associated. So, the first playlist for a track called
“Cowbell” will be called “Cowbell.1”, the next one “Cowbell.2”, etc.
This name can be changed at any time, to anything: Ardour does not
require playlist names to be unique, although it will make the user’s
life easier if they are. Suggested examples of user-assigned names for a
playlist might include Lead Guitar, 2nd take, vocals (quiet), and
downbeat cuica. These might be different from the associated track
names, which for these examples might be Lead Guitar, Vocals and Cuica.
The playlist name provides more information because it is about a
specific version of the material that may (or may not) end up in the
final version of the track.

Using the fact that playlist names are based on the active one with an
incremented version number, one can rename a playlist “Cowbell take.1”
so that the next playlist created is automatically named “Cowbell
take.2” etc. This allows for a quick way to label different takes.


\section{Sharing Playlists}
\label{\detokenize{index:sharing-playlists}}
It is entirely possible to share playlists between tracks. The only
slightly unusual thing that should be noted when sharing is that edits
to the playlist made in one track will magically appear in the other. It
is an obvious consequence of sharing. One application of this attribute
is parallel processing, described in {\hyperref[\detokenize{index:playlist-usecases}]{\emph{Playlist Use
Cases}}}.

To avoid this kind of behaviour, and nevertheless use the same (or
substantially the same) playlist on two tracks, the desired playlist
must be chosen in the second track, and then the New Copy… button
clicked. This generates an independent copy of it for that track, which
can then be edited without affecting the original.


\chapter{46.3 - Playlist Usecases}
\label{\detokenize{index:playlist-usecases}}

\section{Using Playlists for Parallel Processing}
\label{\detokenize{index:using-playlists-for-parallel-processing}}
One of the uses of playlists is to apply multiple effects to the same
audio stream. For example, applying two different non-linear effects
such as distortion or compression to the same audio source (linear
effects can be just applied one after the other in the same track) can
be done by creating a new track, applying the original track’s playlist,
and then applying effects to both tracks independently.

The same result could be achieved by feeding the track to multiple
busses which then contain the processing, but this increases the overall
latency, complicates routing and uses more space in the Mixer window.


\section{Using Playlists for “Takes”}
\label{\detokenize{index:using-playlists-for-takes}}
Using Playlists for takes is a good solution when one needs the ability
to edit individual takes, and select between them.

Each time a new take is started, a new playlist should be created with p
\textgreater{} New. Thus, later, any previous or later takes can be selected as
desired.

Creating a composite edit from multiple takes, can be achieved either:
\begin{itemize}
\item {} 
by creating a new track to assemble the final version, and “cherry
picking” from the playlists in the original track by copying regions
over as required

\item {} 
by recording each successive take on top of the others in “layers”
and then editing them using the layer tools.

\end{itemize}


\section{Using Playlists for Multi-Language Productions}
\label{\detokenize{index:using-playlists-for-multi-language-productions}}
The same approach as for takes is useful when recording or editing
content in multiple versions, such as dubbed movie dialog in several
languages: having all versions on the same track allows to apply the
same processing, making it easy to switch language before exporting the
session.


\chapter{47 - Rhythm Ferret}
\label{\detokenize{index:rhythm-ferret}}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{rhythm-ferret}.png}
\caption{The Rhythm Ferret window}\label{\detokenize{index:id548}}\end{figure}

The Rhythm Ferret is a dedicated tool to speed up the usually labor
intensive task of slicing and adjusting a sound region to match a
specific time grid. It is especially useful for drum tracks, either to
match a different tempo, or to adjust a slightly out of tempo
performance.

It is not limited to this use though, as it supports both percussive and
note type detection, and can be used on melodic material too.


\section{Accessing the Rhythm Ferret}
\label{\detokenize{index:accessing-the-rhythm-ferret}}
The Rhythm Ferret window can be accessed by right clicking any audio
region, then \sphinxstyleemphasis{Name\_Of\_The\_Region} \textgreater{} Edit \textgreater{} Rhythm Ferret.

Once the window is open, selecting any region will make it the focus of
the Rhythm Ferret’s detection, hence allowing to process multiple
regions sequentially without reopening the window each time.

The window itself is made of:
\begin{itemize}
\item {} 
a “mode” selection

\item {} 
some parameters for this mode

\item {} 
an operation selection, that for now only allows to Split regions.

\end{itemize}


\section{The “Mode” selection}
\label{\detokenize{index:the-mode-selection}}
As the Rhythm Ferret is able to detect both percussive hits and melodic
notes, it is important to choose the best suited mode for the considered
material, so that Ardour can perform the detection with the greatest
accuracy :
\begin{itemize}
\item {} 
Percussive Onset will detect the start of each hit based on the
sudden change in energy (= volume) of the waveform

\item {} 
Note Onset will detect the start of each note based on the changes in
the frequency domain.

\end{itemize}


\section{The Percussive Onset mode}
\label{\detokenize{index:the-percussive-onset-mode}}
In this mode, only two parameters are active:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

Sensitivity (\%)
&
The proportion of the samples
that must exceed the energy rise
threshold in order for an onset
to be detected (at frames in
which the detection function
peaks). This roughly corresponds
to how “noisy” a percussive sound
must be in order to be detected.
\\
\hline
Cut Pos Threshold (dB)
&
The rise in energy amongst a
group of samples that is required
for that to be counted toward the
detection function’s count. This
roughly corresponds to how “loud”
a percussive sound must be in
order to be detected.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

As those parameters are very material-related, there is no recipe for a
perfect match, and a good peak detection is a matter of adjusting those
two parameters by trial and error, and trying using the Analyze button
after each try.

Vertical grey markers will appear on the selected region, showing where
Ardour detects onsets as per the parameters. This markers can be
manually adjusted, see below.


\section{The Note Onset Mode}
\label{\detokenize{index:the-note-onset-mode}}
In the Note Onset mode, more parameters are active:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

Detection function
&
The method used to detect note
changes. More on this below.
\\
\hline
Trigger gap (postproc) (ms)
&
Set the minimum inter-onset
interval, in milliseconds, i.e.
the shortest interval between two
consecutive onsets.
\\
\hline
Peak threshold
&
Set the threshold value for the
onset peak picking. Lower
threshold values imply more
onsets detected. Increasing this
threshold should reduce the
number of incorrect detections.
\\
\hline
Silence threshold (dB)
&
Set the silence threshold, in dB,
under which the onset will not be
detected. A value of -20.0 would
eliminate most onsets but the
loudest ones. A value of -90.0
would select all onsets.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

The Detection function, used in Note Onset mode to choose the
mathematical strategy used to detect the note changes, is
user-selectable:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

Energy based
&
This function calculates the
local energy of the input
spectral frame
\\
\hline
Spectral Difference
&
Spectral difference onset
detection function based on
Jonathan Foote and Shingo
Uchihashi’s “The beat spectrum: a
new approach to rhythm analysis”
(2001)
\\
\hline
High-Frequency Content
&
This method computes the High
Frequency Content (HFC) of the
input spectral frame. The
resulting function is efficient
at detecting percussive onsets.
Based on Paul Masri’s “Computer
modeling of Sound for
Transformation and Synthesis of
Musical Signal” (1996)
\\
\hline
Complex Domain
&
This function uses information
both in frequency and in phase to
determine changes in the spectral
content that might correspond to
musical onsets. It is best suited
for complex signals such as
polyphonic recordings.
\\
\hline
Phase Deviation
&
This function uses information
both energy and in phase to
determine musical onsets.
\\
\hline
Kullback-Liebler
&
Kulback-Liebler onset detection
function based on Stephen
Hainsworth and Malcom Macleod’s
“Onset detection in music audio
signals” (2003)
\\
\hline
Modified Kullback-Liebler
&
Modified Kulback-Liebler onset
detection function based on Paul
Brossier’s “Automatic annotation
of musical audio for interactive
systems” (2006)
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

Ardour defaults to Complex Domain, which usually gives good result for
harmonic material.


\section{Manual adjustment}
\label{\detokenize{index:manual-adjustment}}
Using the Rhythm Ferret consists usually in finding the right parameters
to split the audio, by adjusting them and clicking the Analyze button.
Each time an analysis is run, Ardour erases the previous results, and
creates grey markers on the region according to the parameters. Those
markers can be manually dragged with the LEFT mouse button to adjust
their positions.

Once the markers are suitably placed, the second button in the down hand
side of the Rhythm Ferret window allows to Apply the operation. At the
moment of writing, only the Split Region is available, which will split
the region at the markers.

Those regions can then be manually aligned, or have their sync points
set to the closest grid (as per the {\hyperref[\detokenize{index:grid-controls}]{\emph{Grid settings}}}
in effect), by selecting all the regions, and using the right click then
Selected Regions \textgreater{} Position \textgreater{} Snap position to grid.


\chapter{Part VII - MIDI}
\label{\detokenize{index:part-vii-midi}}\label{\detokenize{index:id27}}

\chapter{48 - MIDI Editing}
\label{\detokenize{index:midi-editing}}\label{\detokenize{index:edit-midi}}
Ardour’s handling of MIDI editing differs from most other DAWs and MIDI
sequencers.


\section{Key features of Ardour MIDI handling}
\label{\detokenize{index:key-features-of-ardour-midi-handling}}\begin{itemize}
\item {} 
All editing is done in-place, in-window. There is no separate piano
roll window or pane. Edit notes right where they appear.

\item {} 
MIDI, just like audio, exists in regions. MIDI regions behave like
audio regions: they can be moved, trimmed, copied (cloned), or
deleted. Ardour allows either editing MIDI (or audio) regions, or
MIDI region content (the notes), but never both at the same time. The
e key (by default) toggles between region level and note level
editing

\item {} 
Editing note information in Ardour occurs in only a single region.
There is no way currently to edit in note data for multiple regions
at the same time, so for example notes cannot be selected in several
regions and then all deleted, nor can they be copied-and-pasted from
one region to another. Region(s), though, can be copy-pasted just as
with audio.

\item {} 
All MIDI I/O is done via JACK for sample accurate timing and maximal
efficiency when communicating with external software synthesizers.

\item {} 
Every MIDI track has its own JACK MIDI port for input; it may have an
arbitrary combination of audio and MIDI outputs, depending on the
signal processing in the track; the full flexibility of JACK
connectivity is present for MIDI just as it is for audio.

\item {} 
Full automation for MIDI tracks, integrated with the handling of all
MIDI CC data for each track.

\item {} 
Controllers (CC data) can be set to discrete or continuous modes (the
latter will interpolate between control points and send additional
data).

\item {} 
There is a Normal and a Percussive mode for note data editing.

\item {} 
The scroomer is a combination scroll/zoom tool for altering the zoom
level and range of visible MIDI data.

\end{itemize}


\section{Notable Differences}
\label{\detokenize{index:notable-differences}}\begin{itemize}
\item {} 
Fader (volume) control currently operates on transmitted MIDI data,
not by sending CC \#7.

\item {} 
All note/data editing is per-region. There are no cross-region
operations at this time.

\item {} 
By default, copying a MIDI region creates a deep link—both regions
share the same data source, and edits to the contents of one will
affect the other. Breaking this link is done by selecting MIDI \textgreater{}
Unlink from other copies from the region context menu, after which
the selected region(s) will have their own copies of \sphinxstyleemphasis{only} the data
that they visually display on screen. The region will no longer be
trimmable back to its original length after an Unlink operation, and
the operation cannot be undone.

\end{itemize}


\chapter{49 - Creating MIDI Tracks}
\label{\detokenize{index:creating-midi-tracks}}\label{\detokenize{index:create-midi-tracks}}
Creating new MIDI track(s) can be done using the Session \textgreater{} Add Track/Bus
menu. In the {\hyperref[\detokenize{index:adding-tracks-busses-and-vcas}]{\emph{Add Track/Bus dialog}}},
MIDI Tracks must be picked from the combo selector at the upper left.

A track template can be used, by selecting it in the \sphinxstyleemphasis{Configuration}
drop down menu.

One singularity of the MIDI track creation in the ability to select
right at creation time the instrument that will be used in the track.
The instrument in this context is any plugin that will generate audio in
response to receiving MIDI.


\chapter{50 - Creating MIDI Regions}
\label{\detokenize{index:creating-midi-regions}}\label{\detokenize{index:create-midi-regions}}
Although recording MIDI is a common way to create new MIDI regions, it
is often desirable to do so as part of editing/arranging.

Create a new MIDI region is as simple as entering draw mode (press “d”
or click on the pencil tool) and then Left-clicking in a MIDI track. A
region will be created that is one bar long. Alternatively, use the left
button to drag-create a new region of the desired length.

Once the region exists, to trim it to a different length, switch back to
grabber/object/select mode (press “g” or click on the grabber tool). It
can then be {\hyperref[\detokenize{index:trimming-regions}]{\emph{trimmed}}} to any length desired.

Once a region has been created, {\hyperref[\detokenize{index:add-new-notes}]{\emph{some notes}}} should
be added to it.


\chapter{51 - Adding New Notes}
\label{\detokenize{index:adding-new-notes}}\label{\detokenize{index:add-new-notes}}

\section{Adding new notes}
\label{\detokenize{index:id28}}
In general, most MIDI editing will probably be done with the mouse in
object mode. This allows to select notes, copy, move or delete them and
alter their properties (see below). But at some point, \sphinxstyleemphasis{adding} notes to
a MIDI region using the mouse will mean dragging with the mouse. Since
this would normally be a selection operation if the mouse is in object
mode, there needs to be some way to tell Ardour that the user is trying
to draw new notes within a MIDI region. Ardour provides two ways do
this. One is to leave the mouse in object mode and Left-drag. The other,
useful to enter a lot of notes for a while, is to switch the mouse into
Draw Notes mode, which will now interpret any drags and clicks as
requests to add a new note. For obvious reasons, Draw Notes mode can not
be used while using region-level editing.

So, to summarize:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|*{2}{\X{1}{2}|}}
\hline

Selecting, moving, copying,
trimming, deleting \sphinxstyleemphasis{regions}
&
Note Level Editing disabled,
using object, range or other
mouse modes
\\
\hline
Selecting, moving, copying
trimming, deleting \sphinxstyleemphasis{notes}
&
Note Level Editing enabled, and
using mouse object mode
\\
\hline
Adding new notes
&
enabling “Note Level Editing” and
then either
\begin{itemize}
\item {} 
using mouse object mode and
Left-drag, or

\item {} 
using mouse draw mode.

\end{itemize}
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}

Note that there is also {\hyperref[\detokenize{index:step-entry}]{\emph{a step entry editor}}} allowing
to enter notes from a virtual keyboard and lots more besides.


\chapter{52 - Changing Note Properties}
\label{\detokenize{index:changing-note-properties}}\label{\detokenize{index:change-note-properties}}
All the details about a selected note can be viewed by context-clicking
on it. The dialog that pops up will also allow to modify all the
properties of the selected note(s). Individual properties can also be
modified more efficiently using the techniques described below.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

Moving notes
&
Right arrow and Left arrow move
the selected note(s) early and
later in time.
\\
\hline
Changing pitch values
&
↑ increases the pitch of the
selected notes.
↓ reduces the pitch of the
selected notes.
If any of the selected notes are
already at the maximum or minimum
value, no changes will be made to
any of the notes, to preserve
relative pitches. This can be
overrode with . The default shift
distance is one semitone. alters
this to one octave.
\\
\hline
Changing velocity values
&
↑ increases the velocity of the
selected notes.
↓ reduces the velocity of the
selected notes.
If any of the selected notes are
already at the maximum or minimum
value, no changes will be made to
any of the notes, to preserve
relative velocities. This can be
overrode with . Also, pressing v
pops up a dialog that will allow
to set the absolute velocity
value of each selected note.
Finally, the scroll wheel ⇑ ⇓
will also adjust notes in the
same way as the arrow keys (note
that like the arrow keys it only
affects selected notes, not the
note the pointer is over).
\\
\hline
Changing channel
&
Pressing c brings up a dialog
that allows to see and alter the
MIDI channel of the selected
notes. If the selected notes use
different channels, they will all
be forced to the newly selected
channel.
\\
\hline
Changing start/end/duration
&
, (comma) will alter the start
time of the note.
. (period) will alter the end
time of the note. Both keys will
by default make the note longer
(either by moving the start
earlier or the end later). For
the opposite effect, ,/. can be
used. The note will be altered by
the current grid setting. To
change the start/end positions by
1/128th of a beat, the modifier
must be added to these shortcuts.
\\
\hline
Quantization
&
q will quantize the selected
notes using the current quantize
settings. If the quantize
settings have not been set for
this session yet, the quantize
dialog will appear. q will
display the quantize dialog to
allow to reset the quantize
settings, and then quantizes the
selected notes. The default
quantize settings are: quantize
note starts to the current grid
setting, no swing, no threshold,
full strength.
\\
\hline
Step Entry, Quantize etc.
&
Refer to the {\hyperref[\detokenize{index:step-entry}]{\emph{Step
Entry}}},
{\hyperref[\detokenize{index:quantize-midi}]{\emph{Quantizing
MIDI}}}, etc.
specific pages.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\chapter{53 - Handling Overlapping Notes}
\label{\detokenize{index:handling-overlapping-notes}}
Every MIDI note consists of two messages, a NoteOn and a NoteOff. Each
one has a note number and a channel (also a velocity, but that isn’t
relevant here). The MIDI standard stresses that it is invalid to send a
second NoteOn for the same note number on the same channel before a
NoteOff for the first NoteOn. It is more or less impossible to do this
with a physical MIDI controller such as a keyboard, but remarkably easy
to trigger when editing in a DAW—simply overlapping two instances of the
same note will do it.

Ardour offers many options for how to deal with instances where two
instances of the same note overlap. Which one to use is a per-session
property and can be modified from Session \textgreater{} Properties \textgreater{} Misc \textgreater{} MIDI
Options.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

never allow them
&
Edits that would create note
overlaps are not allowed
\\
\hline
don’t do anything in particular
&
Ardour leaves overlapping notes
alone—the behaviour of a MIDI
receiver (plugin or hardware) is
undefined
\\
\hline
replace any overlapped existing
note
&
When one note is moved to overlap
another, remove the one that
wasn’t being moved
\\
\hline
shorten the overlapped existing
note
&
When one note is moved to overlap
another, shorten the one that
wasn’t moved so that there is no
overlap
\\
\hline
shorten the overlapping new note
&
When one note is moved to overlap
another, shorten the one that was
moved so that there is no overlap
\\
\hline
replace both overlapping notes
with a single note
&
When one note is moved to overlap
another, merge them both to form
one (longer) note
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

Changing the option in use will not retroactively make changes—it will
only affect new note overlaps created while the option remains chosen.

Ardour does not check for note overlaps across tracks or even across
regions. Dealing with the consequences is up to the user.


\chapter{54 - Note Cut, Copy and Paste}
\label{\detokenize{index:note-cut-copy-and-paste}}
While in {\hyperref[\detokenize{index:add-new-notes}]{\emph{note edit}}} mode, selected notes can be cut
and paste as in most software, that is:
\begin{itemize}
\item {} 
cut: x

\item {} 
copy: c

\item {} 
delete: Delete

\item {} 
paste: v.

\end{itemize}

These operations use the same keyboard shortcuts as most editing
software does, and as Ardour uses for regions. Obviously, the paste
operation only works if a cut or copy operation has happened beforehand.


\chapter{55 - Note Selection}
\label{\detokenize{index:note-selection}}

\section{Selecting/Navigating note-by-note}
\label{\detokenize{index:selecting-navigating-note-by-note}}
Tab selects the next note. Tab selects the previous note. Tab or Tab
adds the next/previous note to the selection.


\section{Selecting notes with the mouse}
\label{\detokenize{index:selecting-notes-with-the-mouse}}
While in mouse object mode, any note can be clicked to select it. Once a
note has been selected, Left-clicking on another selects all notes
between them. Adding or removing a note to/from the selection is done by
Left clicking it. Clicking and dragging outside of a note rubberband
selects a series of notes.

Three different selection operations are possible while in mouse range
mode:
\begin{itemize}
\item {} 
Vertical drags within the MIDI region will select all notes within
the spanned note range.

\item {} 
Clicks on the piano header of the track (if visible—the track must be
tall enough to display it) will select all occurrences of that note.

\item {} 
Drags on the piano header of the track will select all notes within
the spanned note range.

\end{itemize}


\section{Listening to Selected Notes}
\label{\detokenize{index:listening-to-selected-notes}}
If Edit \textgreater{} Preferences \textgreater{} MIDI \textgreater{} Sound MIDI notes as they are selected is
enabled, Ardour will send a pair of NoteOn/NoteOff messages through the
track, which will typically allow to hear each note as it is selected.


\chapter{56 - Quantizing MIDI}
\label{\detokenize{index:quantizing-midi}}\label{\detokenize{index:quantize-midi}}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{quantize}.png}
\caption{The Quantize dialog}\label{\detokenize{index:id549}}\end{figure}

Quantizing a MIDI region, usually one recorded from a MIDI instrument,
consists in perfectly aligning the notes with the grid by shifting the
notes positions to the closest grid line. The result is a perfectly
timed MIDI region, allowing to correct rhythmically poor performance.

This dialog is accessed via the Region \textgreater{} MIDI \textgreater{} Quantize… while having
a MIDI region selected, or by right clicking a MIDI region,
\sphinxstyleemphasis{Name\_Of\_The\_Region} \textgreater{} MIDI \textgreater{} Quantize… or with the default 5 shortcut
and includes:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

Snap note start
&
If checked, the start of the
notes will be aligned to the grid
as defined in the following
combo-box (see below)
\\
\hline
Snap note end
&
If checked, the end of the notes
will be aligned to the grid as
defined in the following
combo-box (see below)
\\
\hline
Threshold (ticks)
&
Defines how close from a grid
point a note must be in order to
be quantized. Notes farther than
this number of
{\hyperref[\detokenize{index:timecode-generators-and-slaves}]{\emph{ticks}}}
will not be affected.
\\
\hline
Strength
&
Defines how close to its new
position the note must be moved,
as a percentage of the nominal
distance (allowing for a
non-perfect quantization, i.e.
just making the performance
rhythmically better without
giving it a machine-generated
feel)
\\
\hline
Swing
&
Applies a \sphinxstyleemphasis{swing} to the midi
notes, i.e. delays every 2nd note
by this amount, to e.g. simulate
a groovy drummer
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

The grid selection combo boxes allow a choice between the current \sphinxstyleemphasis{main
grid}, or many beat subdivisions.

Both note start and note end can be selected at once, resulting in a
2-pass quantization: the note starts are aligned to the grid (with or
without the swing and Strength parameters), then their ends are aligned.

The swing is a value between 0 and 130, and is relative to the
user-selected grid type: every note which is considered a second note
(i.e. close enough to an odd grid line as per the threshold value) will
be delayed by this number of ticks.


\chapter{57 - Step Entry}
\label{\detokenize{index:step-entry}}
Editing MIDI can be a tedious task. Ardour allows using a connected MIDI
device like a music keyboard or pad controller, or use the mouse. A
third option, providing fine-grain control, precision and speed of entry
comes from using a custom note entry dialog.

The step entry dialog is accessed via a right click context menu on the
rec-enable button, because step entry is related to \sphinxstyleemphasis{recording} MIDI
data. Step editing and recording MIDI via the track’s MIDI port cannot
happen simultaneously.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{a3_step_entry}.png}
\caption{Ardour’s Step Entry dialog}\label{\detokenize{index:id550}}\end{figure}

The dialog (quite closely modelled on Logic’s) contains:
\begin{itemize}
\item {} 
Chord entry switch (successive notes are stacked in a chord until it
is released)

\item {} 
Note length selectors

\item {} 
Triplet toggle

\item {} 
Normal, single, double and triple dotted note selectors

\item {} 
Sustain button

\item {} 
Buttons to:
\begin{itemize}
\item {} 
Insert a rest of the current selected note duration

\item {} 
Insert a rest of the current grid step size

\item {} 
Move back to the last inserted note

\item {} 
Move forward to the next beat, or bar

\item {} 
Move forward to the edit point

\end{itemize}

\item {} 
Dynamics controls from pianississimo to fortississimo

\item {} 
Channel selector

\item {} 
Explicit numerical velocity selector, for more precise control than
the dynamics selectors offer

\item {} 
Octave selector

\item {} 
Buttons to add bank or program change events

\item {} 
a full 10 octave virtual keyboard

\end{itemize}

More or less all actions in the step entry dialog can be driven directly
from the keyboard, so that moving back and forth from the keyboard to
the mouse is not necessary even for complex data insertion.

The default key bindings for this (configured in
\sphinxcode{\sphinxupquote{step\_editing.bindings}}) are:


\begin{savenotes}\sphinxatlongtablestart\begin{longtable}{|l|l|}
\hline

\endfirsthead

\multicolumn{2}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} -- continued from previous page}}}\\
\hline

\endhead

\hline
\multicolumn{2}{r}{\makebox[0pt][r]{\sphinxtablecontinued{Continued on next page}}}\\
\endfoot

\endlastfoot

grave
&
octave 0
\\
\hline
1 to 9
&
octave 1 to 9
\\
\hline
0
&
octave 10
\\
\hline
F1
&
note length whole
\\
\hline
F2
&
note length half
\\
\hline
F3
&
note length third
\\
\hline
F4 to F8
&
note length quarter to sixtyfourth
\\
\hline
a
&
insert C
\\
\hline
w
&
insert C ♯
\\
\hline
s
&
insert D
\\
\hline
e
&
insert D ♯
\\
\hline
d
&
insert E
\\
\hline
f
&
insert F
\\
\hline
t
&
insert F ♯
\\
\hline
g
&
insert G
\\
\hline
y
&
insert G ♯
\\
\hline
h
&
insert A
\\
\hline
u
&
insert A ♯
\\
\hline
j
&
insert B
\\
\hline
Tab
&
insert rest
\\
\hline
Primary Tab
&
insert snap rest
\\
\hline
BackSpace
&
back
\\
\hline
z
&
note velocity 𝆏𝆏𝆏
\\
\hline
x
&
note velocity 𝆏𝆏
\\
\hline
c
&
note velocity 𝆏
\\
\hline
v
&
note velocity 𝆐𝆏
\\
\hline
b
&
note velocity 𝆐𝆑
\\
\hline
n
&
note velocity 𝆑
\\
\hline
m
&
note velocity 𝆑𝆑
\\
\hline
comma
&
note velocity 𝆑𝆑𝆑
\\
\hline
Up
&
next note velocity
\\
\hline
Down
&
prev note velocity
\\
\hline
Primary Up
&
next note length
\\
\hline
Primary Down
&
prev note length
\\
\hline
apostrophe
&
toggle triplet
\\
\hline
period
&
toggle dotted
\\
\hline
Primary period
&
no dotted
\\
\hline
bar
&
toggle chord
\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}


\chapter{58 - Patch Change}
\label{\detokenize{index:patch-change}}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{patch_change}.png}
\caption{A patch change in a MIDI region}\label{\detokenize{index:id551}}\end{figure}

A patch change is Ardour’s description for a combination of MIDI program
change and bank select messages, that (typically) instruct a synthesizer
or sampler to select a different sound to use on a particular channel.

Patch changes are shown within MIDI regions as small rectangles or
flags, with a vertical line showing where in the region (hence “when”)
this patch change happens.


\section{Inserting Patch Changes}
\label{\detokenize{index:inserting-patch-changes}}
To insert a patch change, the {\hyperref[\detokenize{index:edit-point-control}]{\emph{edit point}}}
should be located where the patch change should be (within an existing
MIDI region). When right clicking, and from the MIDI region’s context
menu, selecting MIDI \textgreater{} Insert Patch Change, a dialog appears allowing to
set the bank and program values.


\section{Modifying Patch Changes}
\label{\detokenize{index:modifying-patch-changes}}
Context-clicking on a patch change will bring up the same dialog that
was used to create it, allowing to modify the program and/or bank
numbers.

The mouse wheel can also be used: ⇑/⇓ on the patch change will alter the
program number, ⇑/⇓ will modify the bank number.


\section{Moving Patch Changes}
\label{\detokenize{index:moving-patch-changes}}
Just Left-dragging the patch change moves it around.


\section{Removing Patch Changes}
\label{\detokenize{index:removing-patch-changes}}
Pressing Del with the mouse pointer into the rectangular area, or using
the delete mouse button operation will remove the patch change (the
operation can be undone).


\section{Names for Patch Numbers: MIDNAM files}
\label{\detokenize{index:names-for-patch-numbers-midnam-files}}
MIDNAM files assign human-redable names to the “coordinates” (MSB, LSB,
pc) of instruments and controls of MIDI-devices. A number of MIDNAM
files come already pre-bundled with Ardour. Should this not be the case
for your device, you can add your own (see below).


\subsection{Selecting a device}
\label{\detokenize{index:selecting-a-device}}
For the proper names to show up in the “Patch Selector”-dialog, you have
to assign a device to your current track. To do so, hover the lower
border of the tracks header (the mouse-cursor will change to a
“resize-cursor”) and expand it. You’ll see dropdown menus. Select your
device in the menu.


\subsection{Adding a custom MIDNAM-file}
\label{\detokenize{index:adding-a-custom-midnam-file}}
MIDNAM-files are XML-Files. You can edit them using your favorite
text-editor. When doing so, please ensure to change the “Model” of the
device, as Ardour will only load each model once (i.e. it will skip
files, if there are clashes).

After you have done modifications to a file, it is a good idea to
validate it. This can be done using the tool \sphinxstyleemphasis{xmllint} as shown below:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} xmllint \PYGZhy{}\PYGZhy{}valid \PYGZhy{}\PYGZhy{}noout myfile.midnam
\PYGZdl{} wget http://www.midi.org/dtds/MIDINameDocument10.dtd
\PYGZdl{} xmllint \PYGZhy{}\PYGZhy{}dtdvalid MIDINameDocument10.dtd myfile.midnam
\end{sphinxVerbatim}

Once you are satisfied with your file, you have to put it at a location
where Ardour picks it up. The best place would be the (hidden) directory
{\hyperref[\detokenize{index:files-and-directories-ardour-knows-about}]{\emph{Ardour configuration
directory}}} subdirectory
patchfiles. in your home-folder. Should the sub-directory \sphinxstyleemphasis{patchfiles}
not exist yet, just create it. The path and file-names are
case-sensitive. The file should end with “\sphinxstyleemphasis{.midnam}”.

After restarting Ardour, hit the small Log-button in the upper right
corner of the main window. It should say something like (this is Linux,
Macos or Windows will be different):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{n}{INFO}\PYG{p}{]}\PYG{p}{:} \PYG{n}{Loading} \PYG{l+m+mi}{3} \PYG{n}{MIDI} \PYG{n}{patches} \PYG{k+kn}{from} \PYG{o}{/}\PYG{n}{home}\PYG{o}{/}\PYG{n}{username}\PYG{o}{/}\PYG{o}{.}\PYG{n}{config}\PYG{o}{/}\PYG{n}{ardour5}\PYG{o}{/}\PYG{n}{patchfiles}
\end{sphinxVerbatim}

The added device should now show up in the dropdown mentioned in the
previous paragraph.

Should the MIDNAM-file be useful for the general public, it would be
nice to share it: Fork the Ardour-project on
\sphinxhref{https://github.com/Ardour/ardour}{gitHub} by hitting the
“Fork”-Button. Go to the patchfiles-directory (and read the README).

You can upload the file using the Web-Interface. Be sure to select
“\sphinxstyleemphasis{Create a new branch for this commit and start a pull request}”.


\chapter{59 - Independent and Dependent MIDI Region Copies}
\label{\detokenize{index:independent-and-dependent-midi-region-copies}}
When copying a MIDI region, Ardour has to decide whether to make the
copy refer to the same data as the original or not. If it does refer to
the same data, then editing either the copy or the original will affect
the both of them. If it refers to an independent copy of the data then
each one can be edited without affecting the other.


\section{Changing dependent/independent copying for the entire session}
\label{\detokenize{index:changing-dependent-independent-copying-for-the-entire-session}}
Session \textgreater{} Properties \textgreater{} Misc \textgreater{} MIDI region copies are independent can be
used to control the default behaviour when making a copy of a MIDI
region.

When enabled, every new copy of a MIDI region results in a copy being
made of the MIDI data used by the region, and the new copy of the region
will refer to that data.

When disabled, every new copy of a MIDI region will refer to the same
MIDI data, and thus editing any copy will change the contents of all of
them.

Changing the status of this option has no effect on the existing
dependent/independent status of existing region copies.


\section{Making an existing copy of a MIDI region independent}
\label{\detokenize{index:making-an-existing-copy-of-a-midi-region-independent}}
Right clicking on the MIDI region to be independent then selecting MIDI
\textgreater{} Unlink From Other Copies makes it independent: the copy is now using
its own version of the data, and edits to the copy will affect only the
copy. Other copies will continue to share data.

Note that the copied data only covers the extent of the region when the
copy is made. If the region was already trimmed and then a copy is made,
an independent copy will have no access to data that is earlier or later
than the bounds of the region it was copied from. Put differently,
making an independent copy of a trimmed MIDI region only retains the
visible part of it.


\chapter{60 - Transposing MIDI}
\label{\detokenize{index:transposing-midi}}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{transpose_midi}.png}
\caption{The Transpose dialog}\label{\detokenize{index:id552}}\end{figure}

A whole region, or multiple regions, can be transposed at once, with the
help of the Transpose MIDI dialog, accessed by right clicking a region \textgreater{}
\sphinxstyleemphasis{name\_of\_the\_midi\_region} \textgreater{} MIDI \textgreater{} Transpose… .

This very simple dialog allows to choose either a number of semitones to
add or subtract to all the notes inside the region(s), and/or for more
significant changes, octaves (12 semitones).


\chapter{61 - Automating MIDI-Pitch bending and aftertouch}
\label{\detokenize{index:automating-midi-pitch-bending-and-aftertouch}}\label{\detokenize{index:id29}}
Adding pitch bending or aftertouch can add a lot of subtlety to an
otherwise plain sounding midi region and help humanize it.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{MIDI_pitch_bending}.png}
\caption{Automation: pitch bending}\label{\detokenize{index:id553}}\end{figure}

Pitch bending and aftertouch both work the same way, through automation,
by right clicking the MIDI track’s header \textgreater{} Automation \textgreater{} Bender (or
Pressure) \textgreater{} the channel to bend.

Using the Draw tool, as for all the automation, allows to create a
gradual change from one drawn point to another. A line in the center
produces no change to the pitch, while a line above the center will bend
the pitch to a higher note (up to 4 semitones) and a line going under
the middle will bend the pitch to a lower note.

The values can be anything between 0 (-4 semitones) to 16383 (+4
semitones). No automation or a value of 8192 means no pitch shifting.

Aftertouch works very similarly, though the values are between 0 and
127. It should be noted that aftertouch differs from velocity, as
aftertouch allows to slightly change the timbre or create a vibrato,
while the velocity sets the power with which the note is played (e.g. on
a keyboard, the key is hit).


\chapter{62 - Transforming MIDI-Mathematical operations}
\label{\detokenize{index:transforming-midi-mathematical-operations}}\label{\detokenize{index:id30}}
Considering the numerical nature of MIDI events, it can be tempting to
apply mathematical transformations to our MIDI regions by using
mathematical operations. Ardour makes it very easy and powerful with the
Transform tool.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{MIDI_transform}.png}
\caption{MIDI transformation}\label{\detokenize{index:id554}}\end{figure}

To access the Transform tool, right click the MIDI region \textgreater{}
\sphinxstyleemphasis{name\_of\_the\_region} \textgreater{} MIDI \textgreater{} Transform…

First, select the property you want to modify in the ‘Set’ field, then
change the target value using the 2 following fields. If you want to add
more operands, click the “+” sign to create new lines. You can remove a
superfluous line using the “-” sign on the right of the newly created
line.

In the picture above, the Transform tool has been used to add a bit of
humanisation, by slightly changing the velocity of each note of the
region, by a random number between -19 and +19 from its original
velocity. So three operations are applied:
\begin{itemize}
\item {} 
Set velocity to this note’s velocity

\item {} \begin{itemize}
\item {} 
a random number from 1 to 20

\end{itemize}

\item {} \begin{itemize}
\item {} 
a random number from 1 to 20

\end{itemize}

\end{itemize}

Each note will trigger a calculation of its own, so its velocity will be
increased by a random number between 1 and 20, then decreased by a
random number between 1 and 20.

The properties that can be computed are:
\begin{itemize}
\item {} 
note number (e.g. C2 is note number 24, C\#2 is 25 and {\hyperref[\detokenize{index:midi-notes-ref}]{\emph{so
on}}})

\item {} 
velocity (the global intensity of the note, between 0 and 127)

\item {} 
start time (in beats)

\item {} 
length (in beats)

\item {} 
channel

\end{itemize}

and the calculation may be based on the following properties:
\begin{itemize}
\item {} 
this note’s

\item {} 
the previous note’s

\item {} 
this note’s index (number of the note, i.e. the first one is 0, the
second is 1, etc.)

\item {} 
exactly (for a constant value, between 1 and 127)

\item {} 
a random number from \sphinxstyleemphasis{lower} to \sphinxstyleemphasis{higher} (\sphinxstyleemphasis{lower} and \sphinxstyleemphasis{higher} being
constant values between 1 and 127)

\item {} 
equal steps from \sphinxstyleemphasis{lower} to \sphinxstyleemphasis{higher} (\sphinxstyleemphasis{lower} and \sphinxstyleemphasis{higher} being
constant values between 1 and 127)

\end{itemize}

The mathematical operators can be:
\begin{itemize}
\item {} \begin{itemize}
\item {} 
(addition)

\end{itemize}

\item {} \begin{itemize}
\item {} 
(subtraction)

\end{itemize}

\item {} 
* (multiplication)

\item {} 
/ (euclidian division)

\item {} 
mod (remainder of the euclidian division).

\end{itemize}

All these operations can be very handy, as long as there is a
mathematical way to achieve the targeted goal. Beware though of odd
“border cases”: division by zero (which does nothing), using the note’s
index and forgetting it starts at 0 and not 1, etc.

Very interesting results can nevertheless be created, like humanizing
(randomizing the velocity, start time and duration of all the notes),
creating arpeggios, automating tedious tasks, transposing, etc.


\chapter{63 - MIDI List Editor}
\label{\detokenize{index:midi-list-editor}}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{midi-list-editor}.png}
\caption{The MIDI List Editor window}\label{\detokenize{index:id555}}\end{figure}

The List Editor is a way to look at the MIDI data of a region, not
graphically as they are displayed in the Editor, but in a tabular form.
This way of seeing the MIDI data allows for a quicker “debugging” of a
MIDI region, and for a fast \sphinxstyleemphasis{non-graphical} (i.e. no mouse involved)
editing. This list has a vertical flow, i.e. the first events (in time)
are on the top of the window, and the latest are at its bottom.

It is accessed by selecting the Region \textgreater{} MIDI \textgreater{} List Editor… menu while
having one MIDI region selected, or by Right clicking the MIDI region
and choosing \sphinxstyleemphasis{Name\_Of\_The\_Region} \textgreater{} MIDI \textgreater{} List Editor…

The window displays the following MIDI data:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

Start
&
the timestamp of the start of the
note
\\
\hline
Channel
&
the MIDI channel of the event
\\
\hline
Num
&
The {\hyperref[\detokenize{index:midi-notes-ref}]{\emph{MIDI
number}}} of
the note
\\
\hline
Name
&
The MIDI name of the note, made
of its English name and octave
(e.g. “C4”)
\\
\hline
Vel
&
the velocity of the note (i.e.
its intensity, between 0 and 127)
\\
\hline
Length
&
duration of the note, either
expressed as a number (in ticks,
related to the tempo) or as a
text (fraction of a beat, also
related to the tempo)
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

At the top of the window is a Sound Selected MIDI Notes, which is a
toggle button allowing to listen to a note as it is selected.

Each value can be manually modified, by Left clicking it. The Name field
is related to the Number one, and cannot be edited. To change a note,
its number must be changed, which will be reflected in the Name field.


\chapter{64 - MIDI Tracer}
\label{\detokenize{index:midi-tracer}}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{midi-tracer}.png}
\caption{The MIDI Tracer window}\label{\detokenize{index:id556}}\end{figure}

The MIDI Tracer is similar to the {\hyperref[\detokenize{index:midi-list-editor}]{\emph{MIDI List
Editor}}}, in the way that it displays MIDI
information as a tabular text view, and has a vertical flow, i.e. the
events follow a top to bottom time order.

Its use is different though, as it is \sphinxstyleemphasis{not} bound to a specific region
or track: the MIDI that is monitored is any global input or output
Ardour presents to the system. It is hence a very useful option to
monitor a MIDI port, be it an external controller/device or the
in/output of any track.

It is accessed by selecting the Window \textgreater{} MIDI Tracer menu.

The window is made of:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

Port
&
a list of all the MIDI ports
Ardour presents to the system.
They are both internal and
external and are the same ports
Ardour presents to JACK, if
enabled.
\\
\hline
the events list
&
where all the events for this
port are listed, see below
\\
\hline
Line history
&
how many lines should be kept in
the events list
\\
\hline
Delta times
&
if checked, shows the times as
the duration since the last
event, instead of the {\hyperref[\detokenize{index:on-clock-and-time}]{\emph{absolute
time}}}
\\
\hline
Decimal
&
if checked, shows the MIDI data
as decimal values instead of the
original hexadecimal values
\\
\hline
Enabled
&
if checked, the events are
displayed in the events list,
otherwise stops the logging
\\
\hline
Auto-Scroll
&
if checked, the events list
scrolls as new events are logged,
allowing to keep the newest
events on screen
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

The events list displays the events as columns:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

time of the event
&
either absolute or relative,
based on the Delta times checkbox
\\
\hline
MIDI status (event type)
&
what midi events happened (e.g.
Note On, Note Off, Pitch Bend, …)
\\
\hline
MIDI channel
&
in which MIDI channel did the
event happen
\\
\hline
MIDI data bytes (event
parameters)
&
parameters of the event, e.g. for
a Note On: what note was it, and
which was the note’s velocity
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

Note: The MIDI Tracer can lists all kind of MIDI events, “audio” ones,
but also {\hyperref[\detokenize{index:midi-scene-automation}]{\emph{scene automation}}} or
{\hyperref[\detokenize{index:timecode-generators-and-slaves}]{\emph{timecodes}}} ones.


\chapter{65 - MIDI Recording}
\label{\detokenize{index:midi-recording}}

\chapter{66 - MIDI Scene Automation}
\label{\detokenize{index:midi-scene-automation}}
Ardour is capable of being used to both record and deliver MIDI “scene”
automation. These are MIDI messages typically used to switch presets or
“scenes” on a variety of external equipment (or software), including
lighting and other audio/video tools. A common use case is to
automatically change presets between songs or to change lighting
conditions based on a specific position on the timeline.

Each change from one scene to another is represented by a marker in the
“Marker” bar.

Technically, scene changes are delivered as a combination of bank and
program change MIDI messages. MIDI allows for 16384 banks, each with 128
programs.


\section{Recording Scene Changes}
\label{\detokenize{index:recording-scene-changes}}
Ardour has a dedicated MIDI port named “Scene In”. Recording scene
changes can be done by connecting this port to whatever source(s) of
MIDI scene (bank/program change) messages should be recorded.

Whenever the global record enable button is engaged and Ardour’s
transport is rolling, a new marker will be created for each scene change
message received via the “Scene In” port.

If two different scene changes are received within a certain time
period, only the later one will be recorded as a new marker. The default
threshold for this is 1 millisecond.

If a scene change message is received while the playhead is close to an
existing marker with an associated scene change, the recording process
will alter the scene change in the existing marker rather than adding a
new one. The default threshold for this “proximity” test is 1
millisecond.


\section{Manually Creating Scene Changes}
\label{\detokenize{index:manually-creating-scene-changes}}
This feature is not currently implemented.


\section{Playing back Scene Changes}
\label{\detokenize{index:playing-back-scene-changes}}
Ardour has a dedicated MIDI port named “Scene Out”. Playing back scene
changes can be done by connecting this port to whatever target(s) of
MIDI scene (bank/program change) messages should be sent to.

When the global record enable button is \sphinxstyleemphasis{not} enabled, the relevant
message(s) will be sent via the “Scene Out” port as the playhead rolls
past each marker with a scene change associated with it.


\section{Editing Scene Changes}
\label{\detokenize{index:editing-scene-changes}}
This feature is not currently implemented.


\section{Disabling Scene Changes}
\label{\detokenize{index:disabling-scene-changes}}
This feature is not currently implemented.


\chapter{Part VIII - Arranging}
\label{\detokenize{index:part-viii-arranging}}\label{\detokenize{index:arranging}}

\chapter{67 - Time, Tempo and Meter}
\label{\detokenize{index:time-tempo-and-meter}}

\chapter{67.1 - Tempo and Meter}
\label{\detokenize{index:tempo-and-meter}}
Tempo and meter belong together. Without both, there is no way to know
where a beat lies in time.

Tempo provides a musical pulse, which is divided into beats and bars by
a meter. When tempo is changed or an audio-locked meter is moved, all
objects on the timeline that are glued to bars and beats (locations,
regions) will move in sympathy.

When performing meter or tempo operations, it is advisable to use the
BBT ruler (available by right-clicking an existing marker or ruler
name), and ensure that the constraint modifier is set (in
Preferences-\textgreater{}User Interaction) so that no other modifiers share its key
combination. The constraint modifier is the “Constrain drags using: ”
setting under the “When Beginning a Drag” heading. One viable setting is
.


\section{Tempo}
\label{\detokenize{index:tempo}}
Tempo can be adjusted in several ways:
\begin{itemize}
\item {} 
by double clicking on a tempo marker. This opens the tempo dialog
which allows entering the tempo directly into an entry box.

\item {} 
by using the constraint modifier (which is set in Preferences-\textgreater{}User
Interaction) to drag the beat/bars in the BBT ruler or the
tempo/meter lines. This is the preferred way to match the tempo to
previously recorded material.

\item {} 
by holding down the constraint modifier while dragging a tempo
vertically. This is used for more complex tempo solving, as it allows
changing of the position and tempo of a tempo marker in the same
drag; it is, however, a useful way to adjust the first tempo for a
quick result.

\end{itemize}

A tempo may be locked to audio or musical time. This can be changed by
right-clicking on a tempo. If a tempo is locked to music, an entry will
be available to lock it to audio. Similarly an audio-locked tempo may be
locked to music by right-clicking it and selecting the “Lock to Music”
entry.

Audio locked tempo marks stay in their frame position as their
neighbour’s positions are altered. Their pulse (musical) position will
change as their neighbours move. Music locked tempo marks move their
frame position as their neighbours are moved, but keep their pulse
position (they will move as the music is moved).

A tempo may be constant or ramped:
\begin{itemize}
\item {} 
A constant tempo will keep the session tempo constant until the next
tempo section, at which time it will jump instantly to the next
tempo. These are mostly useful abrupt changes, and is the way in
which traditional DAWs deal with tempo changes (abrupt jumps in
tempo).

\item {} 
A ramped tempo increases its tempo over time so that when the next
tempo section has arrived, the session tempo is the same as the
second one. This is useful for matching the session tempo to music
which has been recorded without a metronome. Ramps may also be used
as a compositional tool, but more on this later. Note that a ramp
requires two points—a start and an end tempo. The first tempo in a
new session is ramped, but appears to be constant as it has no tempo
to ramp to. It is only when a new tempo is added and one of them is
adjusted that a ramp will be heard. The same applies to the last
tempo in the session—it will always appear to be constant until a new
last tempo is added and changed.

\end{itemize}

To add a new tempo, use the primary modifier and click on the tempo line
at the desired position. The new tempo will be the same as the tempo at
the position of the mouse click (it will not change the shape of the
ramp).

To copy a tempo, hold down the primary modifier and drag the tempo to be
copied.


\section{Meter}
\label{\detokenize{index:meter}}
Meter positions beats using the musical pulse of a tempo, and groups
them into bars using its number of divisions per bar.

The first meter in a new session may be moved freely. It has an
associated tempo which cannot be dragged by itself (although all others
can). It can be moved freely and is locked to audio.

New meters are locked to music. They may only occur on a bar line if
music locked.

An audio locked meter provides a way to cope with musical passages which
have no meter (rubato, pause), or to allow a film composer to insert a
break in music which cannot be counted in beats.

If a meter is audio-locked, its bar number is fixed from the point at
which it left the main score. That bar number cannot be changed, nor can
tempo motion allow the previous bar to overlap. If another bar is
needed, lock the meter to music again (right click-\textgreater{}”Lock to Music”),
drag the meter to the desired bar and re-lock to audio. The new bar can
be freely dragged again.
\begin{itemize}
\item {} 
To change a meter, double click it. A dialog will appear.

\item {} 
To copy a meter, hold down and drag it.

\end{itemize}


\chapter{67.2 - Techniques for Working with Tempo and Meter}
\label{\detokenize{index:techniques-for-working-with-tempo-and-meter}}

\section{Matching a recorded tempo with a tempo ramp}
\label{\detokenize{index:matching-a-recorded-tempo-with-a-tempo-ramp}}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{tempo-ramp_1}.png}
\caption{Initial state.}\label{\detokenize{index:id557}}\end{figure}

As a general approach, the best way to control tempo ramps is to use
them in pairs.

One typical use of tempo ramps is to match the click to a drum
performance recorded in ‘free time’, like in the (admittedly bad) 4/4
example on the left.


\subsection{Step 1 : First meter}
\label{\detokenize{index:step-1-first-meter}}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{tempo-ramp_2}.png}
\caption{Placing the first meter}\label{\detokenize{index:id558}}\end{figure}

The first thing needed is determining where the first beat is in the
recording and left dragging the first meter to that position.


\subsection{Step 2 : Locating the \sphinxstyleemphasis{n}th bar}
\label{\detokenize{index:step-2-locating-the-nth-bar}}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{tempo-ramp_3}.png}
\caption{Locating a known beat}\label{\detokenize{index:id559}}\end{figure}

Now the first click will be in time with the first beat. By listening to
the recorded drums, the position of bar \sphinxstyleemphasis{n} (here, 9th beat, 3rd bar) is
visually located (the playhead may be moved to this location to “pin”
it).


\subsection{Step 3 : Aligning the ruler with the tempo}
\label{\detokenize{index:step-3-aligning-the-ruler-with-the-tempo}}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{tempo-ramp_4}.png}
\caption{Matching the tempi}\label{\detokenize{index:id560}}\end{figure}

Holding the constraint modifier ( by default), the third bar marker in
the BBT ruler is dragged at the position of the third bar in the
recording (where the playhead is located). This drag can be done either
in the Meter or in the Tempo rulers. The tempo (on the first and only
tempo marker) reflects the new value based on this change.

The click now matches the first 8 beats, but after that it can wander
off, which will be reflected in the tempo lines thet won’t quite match
the drum hits.


\subsection{Step 4 : Placing a new tempo marker}
\label{\detokenize{index:step-4-placing-a-new-tempo-marker}}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{tempo-ramp_5}.png}
\caption{Creating a tempo marker}\label{\detokenize{index:id561}}\end{figure}

A new tempo marker is placed on the last position where the click
matches the recorded audio, by -clicking the Tempo ruler. This will
“anchor” the value of the tempo at that position.


\subsection{Step 5 : Placing another tempo marker at the \sphinxstyleemphasis{n}th beat}
\label{\detokenize{index:step-5-placing-another-tempo-marker-at-the-nth-beat}}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{tempo-ramp_6}.png}
\caption{Placing another marker}\label{\detokenize{index:id562}}\end{figure}

Another tempo marker is placed \sphinxstyleemphasis{n} beats after the previous marker
(here, 4 beats, 1 bar).


\subsection{Step 6 : Changing the tempo to a new value}
\label{\detokenize{index:step-6-changing-the-tempo-to-a-new-value}}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{tempo-ramp_7}.png}
\caption{Adjusting the tempo}\label{\detokenize{index:id563}}\end{figure}

Now, -dragging any beat \sphinxstylestrong{after} the second new tempo marker will allow
to align the drum audio and tempo after the second marker.


\subsection{Step 7 : Ramping the tempo change}
\label{\detokenize{index:step-7-ramping-the-tempo-change}}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{tempo-ramp_8}.png}
\caption{Ramping the change}\label{\detokenize{index:id564}}\end{figure}

Although it may be unnecessary in some cases where the tempo changes
abruptly, most of the time, the tempo change is progressive in time,
like an instrumentist drifting in tempo. In those cases, the tempo
change should be progressive too, and Ardour allows that by ramping the
tempo change.

right clicking the first tempo marker, a menu appears, allowing to Ramp
to Next. This will make the tempo between the two markers linearly
change from the first marker’s value to the second’s.

Again, some time later the click will probably drift again, so the same
technique has to be repeated: adding two new tempos and dragging the BBT
ruler \sphinxstylestrong{after} the newest tempo so that the beats align with the audio
again.

In a general sense, adding tempo markers in pairs allows to ‘pin’ the
tempo at the marker’s location while moving further to the right.


\section{Other use cases}
\label{\detokenize{index:other-use-cases}}
Audio locked meters can be useful when composing, as they allow a
continuous piece of music to be worked on in isolated segments,
preventing the listening fatigue of a fixed form. Reassembly is left as
an excercise for the reader.

Tempo ramps can also be used in a video context, e.g. for an
accelerando, by snapping to TC frames and dragging the ruler so that a
bar ends up on a significant video frame.


\chapter{Part IX - Mixing}
\label{\detokenize{index:part-ix-mixing}}\label{\detokenize{index:mixing}}

\chapter{68 - Basic Mixing}
\label{\detokenize{index:basic-mixing}}

\chapter{68.1 - Metering in Ardour}
\label{\detokenize{index:metering-in-ardour}}

\section{Introduction}
\label{\detokenize{index:introduction}}
An engineer reading and using audio level meters compares to a musician
reading or writing sheet-music. Just like there are virtuoso musicians
who can’t read a single note, there are great sound-engineers who just
go by their ears and produce great mixes and masters without ever
looking at a single meter.

Yet, in order to work in or with the broadcast industry, it is usually
unavoidable to use meters.

Audio level meters are very powerful tools that are useful in every part
of the entire production chain:
\begin{itemize}
\item {} 
When tracking, meters are used to ensure that the input signal does
not overload and maintains reasonable headroom.

\item {} 
Meters offer a quick visual indication of an activity when working
with a large number of tracks.

\item {} 
During mixing, meters provide an rough estimate of the loudness of
each track.

\item {} 
At the mastering stage, meters are used to check compliance with
upstream level and loudness standards and to optimize the loudness
range for a given medium.

\end{itemize}


\section{Meter Types}
\label{\detokenize{index:meter-types}}
A general treatise on metering is beyond the scope of this manual. It is
a complex subject with a history… For background information and further
reading we recommend:
\begin{itemize}
\item {} 
\sphinxhref{http://www.digido.com/how-to-make-better-recordings-part-2.html}{How To Make Better Recordings in the 21st Century—An Integrated
Approach to Metering, Monitoring, and Leveling
Practices}
by Bob Katz. Has a good historic overview of meters and motivates the
K-meter

\item {} 
\sphinxhref{https://en.wikipedia.org/wiki/Peak\_programme\_meter\#Table\_of\_characteristics}{Wikipedia: Peak programme
meter}—overview
of meter types.

\item {} 
“Audio Metering: Measurements, Standards and Practice: Measurements,
Standards and Practice”, by Eddy Brixen. ISBN: 0240814673

\item {} 
“Art of Digital Audio”, by John Watkinson. ISBN: 0240515870

\end{itemize}

There are different metering standards, most of which are available in
Ardour. In short:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|*{2}{\X{1}{2}|}}
\hline

Digital peak-meter
&
A Digital Peak Meter displays the
absolute maximum signal of the
raw audio PCM signal (for a given
time). It is commonly used when
tracking to make sure the
recorded audio never clips. To
that end, DPMs are always
calibrated to 0 dBFS, or the
maximum level that can be
represented digitally in a given
system. This value has no musical
reason whatsoever and depends
only on the properties of the
signal chain or target medium.
There are conventions for
fall-off-time and peak-hold, but
no exact specifications.
Various conventions for DPM
fall-off times and dBFS line-up
level can be chosen in Edit \textgreater{}
Preferences \textgreater{} Metering.
\\
\hline
RMS meters
&
An RMS-type meter is an averaging
meter that looks at the energy in
the signal. It provides a general
indication of loudness as
perceived by humans. Ardour
features three RMS meters, all of
which offer additional peak
indication.
\begin{itemize}
\item {} 
K20: A meter according to the
K-system introduced by Bob
Katz, scale aligned to
-20 dBFS, rise/fall times and
color schema according to
spec.

\item {} 
K14: Same as K20 with scale
aligned to -14 dBFS.

\item {} 
K12: Same as K20 with scale
aligned to -12 dBFS (since
3.5.143).

\item {} 
Peak + RMS: standard RMS,
customizable via Edit \textgreater{}
Preferences \textgreater{} Metering

\end{itemize}
\\
\hline
IEC PPMs
&
IEC-type PPMs are a mix between
DPMs and RMS meters, created
mainly for the purpose of
interoperability. Many national
and institutional varieties exist
(EBU, BBC, DIN).
These loudness and metering
standards provide a common point
of reference which is used by
broadcasters in particular so
that the interchange of material
is uniform across their sphere of
influence, regardless of the
equipment used to play it back.

For home recording, there is no
real need for this level of
interoperability, and these
meters are only strictly required
when working in or with the
broadcast industry. However,
IEC-type meters have certain
characteristics (rise-time,
ballistics) that make them useful
outside the context of broadcast.

Their specification is very
exact, and consequently, there
are no customizable parameters.
\\
\hline
VU meters
&
VU meters are the dinosaurs
(1939) amongst the meters. They
react very slowly, averaging out
peaks. Their specification is
very strict (300ms rise-time,
1\textendash{}1.5\% overshoot, flat frequency
response). Ardour’s VU meter
adheres to that spec, but for
visual consistency it is
displayed as a bar-graph rather
than needle-style (more below).
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}


\section{Ardour Specifics}
\label{\detokenize{index:ardour-specifics}}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{mixer-meter-context-menu}.png}
\caption{Mixer strip meter context menu}\label{\detokenize{index:id565}}\end{figure}

Meters are available in various places in Ardour:
\begin{itemize}
\item {} 
The mixer window features fixed height meters for each channel strip.

\item {} 
There are small (narrow) meters on each track-header in the editor
window.

\item {} 
There are variable height meters in the meterbridge window.

\item {} 
Optionally, a fixed-size master meter can be displayed in the main
toolbar.

\item {} 
Various other locations (file import, sends) have level-meters.

\end{itemize}

They all share the same configuration and color-theme which is available
in preferences and the theme-manager. Settings for the Peak and RMS+Peak
meters as well as VU meter standards are found in Edit \textgreater{} Preferences \textgreater{}
Metering.

The type of meter and the metering point (the place in the signal chain
where the meter taps the signal) are configurable in the context menu of
each meter. Depending on the Edit \textgreater{} Preferences \textgreater{} Mixer settings, the
metering point is also accessible via a button in each Mixer strip.

Regardless of meter type and standard the meter display will highlight
red if the signal on the given channel exceeds the configured peak
threshold.

\begin{DUlineblock}{0em}
\item[] Left clicking on the peak-indicator button resets the peak-hold
indicator of a single channel.
\item[] Left clicking resets a whole group, and
\item[] Left clicking resets all meters.
\end{DUlineblock}


\section{Overview of meter types}
\label{\detokenize{index:overview-of-meter-types}}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{meter-types-18}.png}
\caption{Bar-graph meters in Ardour}\label{\detokenize{index:id566}}\end{figure}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{needle-meters-18}.png}
\caption{Needle-style meters as external LV2 plugins}\label{\detokenize{index:id567}}\end{figure}

The figure on the left shows all available meter-types in Ardour when
fed with a -18 dBFS 1 kHz sine wave.

Due to layout concerns and consistent look and feel all meters available
in Ardour itself are bar-graph type meters. Corresponding needle-style
meters—which take up more visual screen space—are available as LV2
plugins (see image on the right):
\sphinxhref{https://github.com/x42/meters.lv2/}{meters.lv2}.


\chapter{68.2 - Signal Routing}
\label{\detokenize{index:signal-routing}}
Ardour does most of its internal signal routing via JACK: all track and
bus inputs and outputs are JACK ports, as are sends and inserts, which
means they can be tapped into by other JACK clients. Only the signal
flow inside a track or bus (i.e. from {\hyperref[\detokenize{index:processor-box}]{\emph{processor to
processor}}}) is handled internally.

By default, Ardour will automatically create the following connections:
\begin{itemize}
\item {} 
Track inputs are optionally auto-connected to hardware inputs, in
round robin order, depending on the setting chosen in the {\hyperref[\detokenize{index:newopen-session-dialog}]{\emph{Session \textgreater{}
New Session dialog}}}.

\item {} 
Bus inputs are left disconnected.

\item {} 
The number of track and bus outputs are equal to the number of inputs
of the master bus.

\item {} 
Track and bus outputs are always auto-connected to the master bus
inputs.

\item {} 
Master bus outputs are connected to hardware outputs.

\end{itemize}

This configuration is sufficient to do basic tracking and playback of
many sessions without any adjustment by the user. Changing these
connections is generally not necessary and often leads to problems.

However, for many workflows during mixing, more complicated signal
routing is required. Ardour offers many possibilities for connecting
things to fit any particular workflow.


\chapter{68.3 - Aux Sends}
\label{\detokenize{index:aux-sends}}
Auxiliary sends are simple {\hyperref[\detokenize{index:processor-box}]{\emph{processors}}} in a bus or
track channel strip. They tap the signal at a specific point in the
signal flow (pre-fader, post-fader, before or after EQs and other
plugins, etc.) and send a copy of that signal to a bus, without
affecting the normal signal flow downwards to the channel fader.

Aux sends from several tracks are collectively sent to a bus in Ardour,
to create a monitor mix for a musician, or to feed an effect unit. A bus
used in this way is considered an auxiliary bus or Aux bus even though
it is the same as any other bus. The output of such a bus might be
routed to separate hardware outputs (in the case of headphone or monitor
wedge mixes), or returned to the main mix (in the case of an effect).

Aux sends are not JACK ports, {\hyperref[\detokenize{index:external-sends}]{\emph{External Sends}}}
should be used to send audio to Jack ports. External Sends can send the
tapped signal somewhere else directly, which is not usually possible on
hardware mixers.

It may be useful to {\hyperref[\detokenize{index:comparing-aux-sends-and-subgroups}]{\emph{compare and
contrast}}} the use of aux sends
with {\hyperref[\detokenize{index:subgrouping}]{\emph{subgrouping}}}.


\section{Adding a new aux bus}
\label{\detokenize{index:adding-a-new-aux-bus}}
New busses can be created using the Session \textgreater{} Add Track, Bus or VCA…
menu, and selecting Audio Busses in the Template/Type selector on the
left of the Add Track/Bus/VCA dialog.


\section{Adding a send to an aux bus}
\label{\detokenize{index:adding-a-send-to-an-aux-bus}}
Context-clicking on the processor box for the track to send to the bus,
and choosing New Aux Send … shows a submenu, listing the busses.
Choosing one bus will add a send (which will be visible in the processor
box). Note that if the only existing bus is the Master Bus, the menu
will be grayed out.


\subsection{Pre-fader and Post-fader Aux Sends}
\label{\detokenize{index:pre-fader-and-post-fader-aux-sends}}
Depending on whether the context-click happened above or below the fader
in the processor box, the new aux send can be placed before or after the
fader in the channel strip.
\begin{itemize}
\item {} 
Post-fader aux sends are typically used when using an aux for shared
signal processing (FX), so that the amount of effect is always
proportional to the main mix fader.

\item {} 
Pre-fader sends ensure that the level sent to the bus is controlled
\sphinxstyleemphasis{only} by the send, not the main fader—this is typical when
constructing headphone and monitor wedge mixes.

\end{itemize}

The color of the processor will reflect this pre/post position (red for
Pre, green for Post). Dragging and dropping the send inside the
processor box before or after the Fader processor changes the type of
fader accordingly.


\section{Adding a new aux bus and sending a Track Group to it}
\label{\detokenize{index:adding-a-new-aux-bus-and-sending-a-track-group-to-it}}
All members of a group can be sent to a new aux bus at once with a
single click. After creating the {\hyperref[\detokenize{index:track-and-bus-groups}]{\emph{track group}}}
(and adding tracks to it), context-clicking on the group tab allows to
choose either Add New Aux Bus (pre-fader) or Add New Aux Bus
(post-fader). A new aux bus will be created, and a new aux send added to
every member of the track group that connects to this aux bus.


\section{Altering Send Levels}
\label{\detokenize{index:altering-send-levels}}
The amount of the signal received by a send that it delivers to the bus
it connects to can be altered in two ways:


\subsection{Using the Send Fader}
\label{\detokenize{index:using-the-send-fader}}
Every send processor has a small horizontal fader that can be adjusted
in the usual way. It is not very big and so this can be a little
unsatisfactory if a very fine control over the send level is required.


\subsection{Map Aux Sends To Main Faders}
\label{\detokenize{index:map-aux-sends-to-main-faders}}
In Mixer mode, pressing the button marked Aux on a aux bus will alter
the channel strip for every track or bus that feeds the aux bus. Many
aspects of the strip will become insensitive and/or change their visual
appearance. More importantly, the main fader of the affected channel
strips will now control the send level and \sphinxstylestrong{not} the track gain. This
gives a larger, more configurable control to alter the level. Clicking
the Aux button of the aux bus again reverts the channel strips to their
normal use.


\section{Disabling Sends}
\label{\detokenize{index:disabling-sends}}
Clicking on the small LED in the send display in the processor box of
the channel strip will enable/disable the send. When disabled, only
silence will be delivered to the aux bus by this track. When enabled,
the signal arriving at the send will be delivered to the aux bus.


\section{Send Panning}
\label{\detokenize{index:send-panning}}
Send panners can be configured to either be independent of the main
panner, or to follow it. The latter could be useful for Reverb effects,
or for in-ear monitor mixes delivered in stereo.


\chapter{68.4 - Comparing Aux Sends and Subgroups}
\label{\detokenize{index:comparing-aux-sends-and-subgroups}}
Auxes and Subgroups share a common concept—they both provide a way for
one or more tracks (or busses) to send their signal to a single bus so
that common signal processing can be applied to the mix of their
signals.

Aux sends leave the existing signal routing to the main mix in place,
and are typically used to create a separate mix to send to (for example)
monitors or headphones (for performer monitor mixes):

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=300\sphinxpxdimen]{{aux_routing}.png}
\caption{Aux signal routing}\label{\detokenize{index:id568}}\end{figure}

Subgroups usually remove the original signal routing to the main mix and
replace it with a new one that delivers the output of the subgroup bus
to the main mix instead.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=300\sphinxpxdimen]{{subgroup_routes}.png}
\caption{Sub group signal routing}\label{\detokenize{index:id569}}\end{figure}


\chapter{68.5 - External Sends}
\label{\detokenize{index:external-sends}}
Like a normal aux send, an external send taps the signal at a specific
point within a channel strip, but delivers it to an external application
or piece of hardware rather than an Ardour bus. By itself, an external
send has no effect whatsoever on the audio signals within Ardour—it is a
one-way signal routing that leaves all existing signal processing just
as it was.

Most people will not have much use for this, but it can be useful to
experiment with external applications or hardware signal processing
applications.


\section{Adding an External Send}
\label{\detokenize{index:adding-an-external-send}}
Context-clicking on the {\hyperref[\detokenize{index:processor-box}]{\emph{processor box}}} in a channel
strip (at the desired location, pre or post fader) and choosing Add new
External Send will show a dialog containing the standard Ardour
{\hyperref[\detokenize{index:patchbay}]{\emph{patchbay}}} to allow to connect the send to the desired
destination.


\section{Removing an External Send}
\label{\detokenize{index:removing-an-external-send}}
An external send can be removed in several ways:
\begin{itemize}
\item {} 
Right-clicking the send in the processor box and choosing either Cut
or Delete.

\item {} 
Selecting the send (with a single left click) and pressing the Del
key.

\end{itemize}


\section{Altering Send Levels}
\label{\detokenize{index:altering-send-levels-1}}\label{\detokenize{index:id31}}
Just below the send in the processor box is a small fader that can be
used like all other faders in Ardour to control the gain applied to the
signal delivered by the send. Dragging it alters the level, Shift-click
restores to unity (0dB) gain.


\section{Disabling Sends}
\label{\detokenize{index:disabling-sends-1}}\label{\detokenize{index:id32}}
Clicking the small LED in the send display within the processor box
turns it on and off. When turned off, silence will be delivered to the
send. When turned on, the signal within the channel strip will be
delivered.


\section{Editing Send Routing}
\label{\detokenize{index:editing-send-routing}}
Double-clicking on the send in the processor box will re-display the
patchbay dialog that gives full control over the routing of the send.


\chapter{68.6 - Inserts}
\label{\detokenize{index:inserts}}
\begin{DUlineblock}{0em}
\item[] Inserts are signal tap points that can be placed anywhere inside a
channel strip. Unlike Auxes, they will interrupt the signal flow,
feeding the signal from before the insert point to its Insert send(s),
and connecting the remainder of the channel strip to the Insert
return(s), both of which are JACK ports which are visible to other
JACK applications.
\item[] Inserts are the JACK equivalents of normalized switching jacks on an
analog console.
\end{DUlineblock}

An insert allows to either use a special external DSP JACK application
that is not available as a plugin, or to splice an external analog piece
of gear into a channel strip, such as a vintage compressor, tube
equalizer, etc. In the latter case, the inserts would first be connected
to a pair of hardware ports, which are in turn connected to the outboard
gear.

Disabling (bypassing) an insert is done by clicking on its LED in the
processor box.

When an insert is created, the signal will be interrupted until the
relevant connections to the insert ports are made!

Inserts will incur an additional JACK period of latency, which can be
measured and compensated for during mixing, but not during tracking!


\chapter{68.7 - Subgrouping}
\label{\detokenize{index:subgrouping}}
Subgrouping (sometimes known as “Grouping” or “Audio Grouping”) is a way
to collect related signals together to apply some common treatment,
before sending them on to the main mix. One standard application is to
group several tracks belonging to the same instrument or section (such
as a drum kit or horn section), to be able to adjust their volume with a
single fader, after their inner balance has been set using the track
faders.

Ardour also provides {\hyperref[\detokenize{index:control-masters-mixer-strips}]{\emph{VCAs}}} that is a
very flexible way to adjust the volume of a group of tracks/busses when
no additionnal processing is needed.

Create a subgroup from an existing Track/Bus group is done by
right-clicking on the relevant {\hyperref[\detokenize{index:the-track-and-bus-group-list}]{\emph{group
tab}}}, and choosing Add new subgroup
bus. A new bus will be created and every member of the track group will
have its outputs disconnected from other destinations and then connected
to the new bus inputs. The bus outputs will feed the master bus unless
manual connections have been selected in the session preferences. The
bus will be named after the track group name.

Alternatively, a group can be created manually, by first adding a new
bus, then, for each track to be fed in the subgroup bus, disconnecting
its outputs from the master and connecting it to the inputs of the
subgroup bus instead. This can be done in the global audio patchbay or
on a track by track basis via the output button of each track’s channel
strip.

Remove a subgroup (bus) is done by right -clicking on the track group
tab, and selecting Remove subgroup bus. Simply deleting the bus itself
will \sphinxstylestrong{not} restore signal routing to the way it was before the
addition of the subgroup bus—tracks that had been subgrouped will be
left with their main outputs disconnected.


\chapter{68.8 - Patchbay}
\label{\detokenize{index:patchbay}}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{connection-manager}.png}
\caption{An example patchbay}\label{\detokenize{index:id570}}\end{figure}

The patchbay is the main way to make connections to, from and within
Ardour’s mixer.

Notable exceptions are internal aux sends and connections to the monitor
bus (when using one): these cannot be controlled from a patchbay, and
are basically not under manual control at all.

The patchbay presents two groups of ports; one set of sources (which
produce data), and one of destinations (which consume data). Depending
on the relative number of each, the sources will be placed on the left
or the top of the dialogue, and the destinations on the right or the
bottom. Thus, in general, signal flow is from top or left to right or
bottom.

Both sources and destinations are divided up into groups, with each
group being given a tab:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

Hardware
&
These are ports which are
connected to a physical piece of
hardware (a sound card or MIDI
interface).
\\
\hline
Ardour Busses
&
All ports belonging to busses.
\\
\hline
Ardour Tracks
&
All ports belonging to tracks.
\\
\hline
Ardour Misc
&
These are other ports that do not
fit into the previous two
categories; for example, the
ports on which the metronome
click is output, and MIDI ports
for things like control surfaces
and timecode.
\\
\hline
Other
&
If there are other JACK clients
running, their ports will be
found here. If there are no such
ports, the tab will not exist (on
one or both axes of the grid).
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

The main part of the patchbay is a matrix grid. Within this grid, green
dots represent connections, and any of the squares can be clicked on to
make or break connections. Clicking and dragging draws a line of
connections, which is sometimes useful for making many connections at
once.

In the example patchbay shown above we can note various things. We are
using the Ardour Tracks sources tab, so we see the output ports of the
three tracks in our session: Fred, Jim and Foo. Our destinations are
from the Ardour Busses tab, so we have the inputs of a session bus,
Sheila, and the inputs of the master bus. Fred and Jim have stereo
outputs, so have L and R connections. Foo is a MIDI track, so it only
has one connection, and its squares in the grid are coloured light grey
to indicate that no connection can be made between Foo (a MIDI output)
and our busses (which are all audio-input).

The green dots in the example show that both Fred and Jim are connected
to the master bus, left to left and right to right.


\section{Variants on the Patchbay}
\label{\detokenize{index:variants-on-the-patchbay}}
Slightly different versions of the patchbay are available from different
places in Ardour. A global view of all JACK audio connections is
available, in Window \textgreater{} Audio Connections, or by pressing P. A
corresponding MIDI Connection Manager can be opened using P.

There is also a patchbay available when connecting individual tracks;
clicking on the input or output buttons of a mixer strip will open a
connection manager which has the corresponding track input or output as
the only destination or source, with all other ports available for
connection to it.


\section{Other patchbay features}
\label{\detokenize{index:other-patchbay-features}}
right-clicking on a port name in the connection manager opens a context
menu which provides a few handy options:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

Add audio port
and
Add MIDI port
&
These options add audio or MIDI
ports to the clicked source, if
this is possible. In this way,
for example, tracks and busses
can be extended to have more
inputs or outputs.
\\
\hline
Remove \sphinxstyleemphasis{port\_name}
&
Removes the given port, if
possible. Right-clicking a port
will do the same.
\\
\hline
Disconnect all from \sphinxstyleemphasis{port\_name}
&
Disconnects everything from the
given port.
\\
\hline
Rescan
&
Ardour will try to keep abreast
of any changes to the JACK ports
on the system, and reflect them
in any connection managers which
are open. If for some reason this
fails, this can be used to
re-scan the list of ports and
update the manager.
\\
\hline
Show individual ports
&
If a session has lots of
multi-channel tracks or busses,
it may be an unnecessary detail
that left has to be connected to
left and right to right every
time a connection is made. This
obviously gets worse with higher
channel counts (such as for 5.1
or Ambisonics). To make life
easier with such sessions, Show
individual ports can be unticked.
After that, the channels of
tracks and busses will be hidden,
and any green dots added in the
connection manager will
automatically connect each
channel of the source to the
corresponding channel of the
destination (left to left, right
to right and so on). In this
mode, a half-circle in the
connection grid indicates that
some (but not all) of the
source’s ports are connected to
the destination.
\\
\hline
Flip
&
This will flip the visible ports
on the vertical axis with those
on the horizontal. If, for
example, the top of the
connection manager is showing
Ardour Busses and the right is
showing Hardware, flip will swap
the view to the opposite.
Flipping can also be done by
pressing f. Note that if there
are no matching tabs on both
axes, flipping will be
impossible.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\chapter{68.9 - Track/Bus Signal Flow}
\label{\detokenize{index:track-bus-signal-flow}}

\section{Overview}
\label{\detokenize{index:overview}}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{track_signal_routing}.png}
\caption{Typical signal routing in a channel strip.}\label{\detokenize{index:id571}}\end{figure}

In each individual Track or Bus the signal flow is top to bottom, as
shown in the diagram on the right.

Trim, Fader and Panner are provided by Ardour. The Processor Box can
hold third party plugins or host-provided redirects (insert, aux-send,
etc.).

An important aspect is that the signal flow is multi-channel and not
fixed throughout the track. For example, a track can have a mono input,
a mono to stereo plugin (e.g. reverb) flowing into a surround panner
with 6 outputs.

The design of Ardour is that the width of the signal flow is defined by
the passage through plugins in the processor box, followed by panning.
The number of inputs to the panner is defined by the number of outputs
of the last plugin in the chain. The number of panner outputs is equal
to the track’s outputs ports, which can be added and removed
dynamically. This schema is called \sphinxstyleemphasis{Flexible I/O}. It is very powerful
and a distinctive feature of Ardour.

The golden rule of processor signal flow: The number of outputs of one
link of the process chain defines the number of inputs of the next,
until the panner.

Due to this rule there is one very common case that is hard to achieve:
keeping a mono track mono. With \sphinxstyleemphasis{Flexible I/O}, if a stereo plugin is
added on a mono track, the signal flow after that plugin becomes stereo.


\section{Strict I/O}
\label{\detokenize{index:strict-i-o}}
Strict I/O enforces a simple rule: plugins have the same number of
inputs as they have outputs. By induction the track will have as many
output ports as there are input ports.

Adding a plugin will not modify the signal flow. The number of plugin
outputs is forced to the number of inputs present at the point of
insertion. If a plugin pin is missing, it is ignored. If a plugin pin is
not connected, it is fed with silence. Non-connected plugin outputs are
ignored.

Strict I/O enforces the number of output ports. The number of inputs to
the panner (outputs of last plugin) defines the number of track outputs
(after panner). Required ports are automatically added, excess ports are
removed. The user cannot manually add or remove output ports.

Strict I/O is set when creating the track and can later be enabled or
disabled dynamically in the context menu of every mixer strip.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{strict_io_routing}.png}
\caption{Flexible vs. Strict I/O.}\label{\detokenize{index:id572}}\end{figure}

There are two exceptions to the above rule:
\begin{itemize}
\item {} 
Midi Synths. When adding a synth at a point where there is a Midi
port only, the synthesizer plugin will add audio output ports, which
trickle down the processor chain to all follow up plugins as inputs
and in turn force their outputs to match

\item {} 
Side chain inputs are not affected by Strict I/O

\end{itemize}


\section{Customizing the Signal Flow: The Pin Connection window}
\label{\detokenize{index:customizing-the-signal-flow-the-pin-connection-window}}
The signal flow though the mixer can be customized at every processor
node via Pin Configuration in the context menu of every processor. User
customization overrides all automatic (Flexible and Strict I/O mode)
inferred output port settings.

The Pin Connection window is made of three vertical sections:
\begin{itemize}
\item {} 
an I/O config column

\item {} 
an interactive diagram

\item {} 
a sidechain column

\end{itemize}

By default, the I/O config is set to \sphinxstyleemphasis{Automatic}, i.e. the Manual Config
LED light is turned off. In this mode, the diagram will display the
standard input/outputs for this plugin, i.e. the number of ports (inputs
\& outputs) is equal to the number of pins on the plugin, and a
one-to-one connection is automatically created.

Adding new instances of the plugin allows to apply this plugin to more
inputs or outputs. E.g., a mono effect can be applied to each channel of
a \sphinxstyleemphasis{n}-channels track by adding as many instances of the plugins as there
are input channels (i.e. ports). This happens automatically when adding,
e.g., a mono effect to a stereo track:
\begin{itemize}
\item {} 
Ardour creates two instances of the plugin

\item {} 
the plugin gets a (2x1) label in the processor box

\item {} 
its two input ports are each connected to one pin of an instance

\item {} 
each mono output pin of the plugin is connected to one output port

\end{itemize}

Output channels can also, in Manual Config mode, be added or removed,
whether they are audio or MIDI.

Using the Pin Connection overrides the I/O config setting (Flexible vs.
Strict). A processor \sphinxstyleemphasis{can}, even in Strict I/O mode, have a different
number of outputs than inputs. Non-customized plugins downstream will
follow suit depending on the selected route mode. e.g. adding an
additional output to a plugin on a track set to Strict I/O will trickle
down the process chain to the output and result in the addition of an
output port. This is useful for example in case of a mono to stereo
reverb.

The window allows connection of the I/O ports to the plugin pins and
other I/O ports, provided they are compatible (MIDI vs. audio), just by
dragging and dropping the end connectors on top of one another. A dotted
connector’s line is a “\sphinxstyleemphasis{thru}” line that directly connects an input to
an output without connecting to a pin on the plugin—hence without any
audio modification. These “thru” connections are latency compensated,
with respect to those being affected by the plugin, in order to avoid
phasing issues.

An example of using “thru” connections, shown below, is separate
left/right channel equalization using two mono plugins on a stereo
track:

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{left_right_eq}.png}
\caption{An example of using two mono plugins on a stereo track.}\label{\detokenize{index:id573}}\end{figure}

The only way to add inputs to a processor is via
{\hyperref[\detokenize{index:sidechaining}]{\emph{Sidechaining}}} from another signal. This is done by
“tapping” the signal from another track or bus at any point.

Adding a sidechain signal in Ardour is as simple as enabling the Side
Chain button in the Pin Configuration window, and choosing an Audio or
MIDI sidechain in the Add Sidechain Input lower right hand section. A
new drop-down menu appears, which displays a list of the tracks/busses
available to be sidechained, or, for a more complex setup (e.g.
sidechaining from hardware directly), the {\hyperref[\detokenize{index:patchbay}]{\emph{Routing Grid}}}
(also accessible with a Right-click on the drop-down menu).

The sidechain ports can then be connected, as other inputs, to a pin of
the plugin, or an output port as a “thru”.


\chapter{68.10 - Sidechaining}
\label{\detokenize{index:sidechaining}}
Dynamic Processors—such as compressors—in general use the the original
input signal for analysis and operate on the same signal. Side-chaining
uses the signal level of \sphinxstyleemphasis{another input} to control the compression
level of the original signal.

Effect Processors which have a side-chain input (sometimes also called
\sphinxstyleemphasis{key input}) have an additional input pin to receive a signal from an
external input. In Ardour that extra input can be connected in the
plugin’s Pin Configuration dialog: the signal from one track can be
tapped off and used as an input to a plugin on a different track. This
dialog is accessed via the plugin’s context-menu \textgreater{} Pin Connections….

In case a plugin has a dedicated sidechain input, Ardour automatically
creates a port for the input. This is a normal I/O port which can be fed
by any external signal. The Pin Configuration dialog is not limited to
processors with a dedicated sidechain input, it also allows to manually
create (or remove) a sidechain input port and provides for flexible
connection of the signal to plugin pins.

The operational flow in the Ardour GUI starts at the processor which is
to receive the signal: a sidechain source is selected, and Ardour
creates a dedicated send-processor in the source processor box, the
level of which can be adjusted either in the Pin Configuration window or
directly on the source’s send.


\section{A simple example: Sidechain compression}
\label{\detokenize{index:a-simple-example-sidechain-compression}}
One example is the use of a bass drum track to trigger the compression
on a bass track. The sidechain compressor (a-Compressor) will be placed
on the bass track, and will need to receive the signal from the bass
drum track as a way to trigger the compression.

Here, on the bass track, an \sphinxstyleemphasis{a-Compressor} has been added, and the Drum
track has been set as the sidechain source. The mixer reflects this by
showing an \sphinxstyleemphasis{SC}-send processor in the drum track, very similar to a
{\hyperref[\detokenize{index:aux-sends}]{\emph{send}}}. The bass track also shows an arrow as one of the
a-compressor input.

As a result, in the editor, each peak in the kick drum track triggers
the compression on the bass track and the resulting track shows the
compression kicking in on each kick drum peak, hence reducing the gain.
The compression is applied to the bass, but only based on the level of
the drum track.

This is commonly used for \sphinxstyleemphasis{ducking} effect, when e.g. a radio speaker’s
voice triggers the compression on the audio playing.


\section{MIDI Sidechaining}
\label{\detokenize{index:midi-sidechaining}}
Ardour allows the sidechain sources to be either audio or MIDI
tracks/busses. This is particularly useful when a MIDI signal is used to
control an audio effect, like a vocoder or an auto-tuner, like
\sphinxhref{https://github.com/x42/fat1.lv2}{fat1}, the LV2 port of Fons
Adriaensen’s \sphinxhref{http://kokkinizita.linuxaudio.org/linuxaudio/zita-at1-doc/quickguide.html}{Zita
AT1}
by Robin Gareus:

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{pin-connection-autotune}.png}
\caption{MIDI sidechaining example: fat1.lv2.}\label{\detokenize{index:id574}}\end{figure}

Here, the MIDI track is inputted to the plugin’s MIDI IN pin through a
sidechain, indicating to the plugin what note the source audio should be
corrected to.

Notice that in the example above, the output of the “Vocals” track is
connected to the input of the “Corrected” track. We could have chosen to
insert the “Vocals” track content as an audio sidechain too, totally
disconnecting the input from the plugin, and connecting the plugin’s
input pin to the audio sidechain port.


\section{Pre-processing the sidechained signal}
\label{\detokenize{index:pre-processing-the-sidechained-signal}}
Sometimes, the effects of a sidechain signal on a plugin can be enhanced
by pre-processing the signal.

In the first example above, if the entire drum part is on one track,
then compressing with this signal as a sidechain will result in every
peak triggering the compression, be they bass drum kicks or snare,
cymbals, etc.

In this case, adding an EQ to the drum track with a low pass filter
would filter out the peaks created by the high pitched instruments of
the drum kit, and allow for a better triggering, though to avoid
damaging the original drum track, a send to an intermediary track would
be better suited to place the EQ on. This track won’t be connected to
the Master, as its content is of no musical interest except for its use
as a trigger, allowing for some extreme EQ.


\chapter{68.11 - Muting and Soloing}
\label{\detokenize{index:muting-and-soloing}}
Each track and bus has two buttons which have important implications for
signal flow: mute and solo. The behaviour of these buttons is
configurable in Ardour, to suit different studio set-ups.


\section{Without a monitor bus}
\label{\detokenize{index:without-a-monitor-bus}}
When using Ardour without a monitor bus, there is only one way in which
mute and solo will work:
\begin{itemize}
\item {} 
Mute on a track or bus will mute that track on the master bus, so
that it will not be heard.

\item {} 
Solo on a track or bus will solo that track or bus and mute all
others. Soloing a bus will also solo any tracks or busses which feed
that bus.

\end{itemize}


\section{With a monitor bus}
\label{\detokenize{index:with-a-monitor-bus}}
For setups with a monitor bus, more options are available, mostly
governed by the setting of the Solo controls are Listen controls option
in Edit \textgreater{} Preferences \textgreater{} Mixer.

With Solo controls are Listen controls unticked, behaviour is almost
exactly the same as the situation without a monitor bus. Mute and solo
behave the same, and the monitor bus is fed from the master bus, so it
sees the same thing.

With Solo controls are Listen controls ticked, the master and monitor
busses behave differently. In this mode, solo controls are more properly
called listen controls, and Ardour’s solo buttons will change their
legend from S to either A or P to reflect this.

Now, without any mute or listen, the monitor bus remains fed by the
master bus. Also:
\begin{itemize}
\item {} 
Mute will mute the track or bus, so that it will not be heard
anywhere (neither on the master nor monitor busses), much as before.

\item {} 
Listen will disconnect the monitor bus from the master bus, so that
the monitor bus now only receives things that are “listened to”.
Listen will not perform any muting, and hence the master bus will not
be affected by a listened track or bus.

\end{itemize}

When solo controls are listen controls, the listening point can be set
to either After-Fade Listen (AFL) or Pre-Fade Listen (PFL). The precise
point to get the signal from can further be configured using the PFL
signals come from and AFL signals come from options.

The solo-mute arrangement with a monitor bus is shown below:

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{solo-mute}.png}
\caption{Mute/solo signal flow}\label{\detokenize{index:id575}}\end{figure}

Here we have a number of tracks or busses (in orange). Each one has an
output which feeds the master bus. In addition, each has PFL and AFL
outputs; we have a choice of which to use. PFL/AFL from each track or
bus are mixed. Then, whenever anything is set to AFL/PFL, the monitor
out becomes just those AFL/PFL feeds; the rest of the time, the monitor
out is fed from the master bus.

In this scheme Solo has no effect other than to mute other non-soloed
tracks; with solo (rather than listen), the monitor out is fed from the
master bus.


\section{Other solo options}
\label{\detokenize{index:other-solo-options}}
Edit \textgreater{} Preferences \textgreater{} Mixer has some more solo options:


\subsection{Solo-in-place mute cut}
\label{\detokenize{index:solo-in-place-mute-cut}}
When using solo-in-place (SiP), in other words when soloed tracks are
being listened to on the master bus, this fader specifies the gain that
will be applied to other tracks in order to mute them. Setting this
level to -\(\infty\) dB will mean that other tracks will not be heard at all;
setting to some higher value less than 0dB means that other non-soloed
tracks will be heard, just reduced in volume compared to the soloed
tracks. Using a value larger than -\(\infty\) dB is sometimes called
“Solo-In-Front” by other DAWs, because the listener has the sense that
soloed material is “in front” of other material. In Ardour, this is not
a distinct mode, but instead the mute cut control offers any level of
“in-front-ness” that is desired.


\subsection{Exclusive solo}
\label{\detokenize{index:exclusive-solo}}
If this is enabled, only one track or bus will ever be soloed at once;
soloing track B while track A is currently soloed will un-solo track A
before soloing track B.


\subsection{Show solo muting}
\label{\detokenize{index:show-solo-muting}}
If this is enabled, the mute button of tracks and busses will be drawn
outlined to indicate that the track or bus is muted because something
else is soloed. This is enabled by default, and it is recommended to
leave it that way unless extremely comfortable with Ardour’s mute/solo
behaviour.


\subsection{Soloing overrides muting}
\label{\detokenize{index:soloing-overrides-muting}}
If this is enabled, a track or bus that is both soloed and muted will
behave as if it is soloed.


\subsection{Mute affects…}
\label{\detokenize{index:mute-affects}}
These options dictate whether muting the track will affect various
routes out of the track; through the sends, through the control outputs
(to the monitor bus) and to the main outputs.


\chapter{68.12 - Panning}
\label{\detokenize{index:panning}}
Panning is the process of distributing one or more signals across a
series of outputs so that the listener will have the experience of them
coming from a particular point or area of the overall listening field.

It is used to create a sense of space and/or a sense of motion in an
audio mix. Different signals can be spread out across the space, and
moved over time.


\section{Types of Panners}
\label{\detokenize{index:types-of-panners}}
The way a panner works depends a great deal on how many signals it is
going to process and how many outputs it will send them to. The simplest
case is distributing a single signal to 2 outputs, which is the common
case when using a “mono” track and a stereo speaker setup.

But panning in Ardour could theoretically involve distributing any
number of signals to any number of outputs. In reality, Ardour does not
have specific panners for each different situation. Currently, it has
dedicated panners for the following situations:
\begin{itemize}
\item {} 
1 signal distributed to 2 outputs (the {\hyperref[\detokenize{index:mono-panner}]{\emph{mono
panner}}})

\item {} 
2 signals distributed to 2 outputs (the {\hyperref[\detokenize{index:stereo-panner}]{\emph{stereo
panner}}})

\item {} 
N signals distributed to M outputs (the {\hyperref[\detokenize{index:vbap-panner}]{\emph{VBAP
panner}}})

\end{itemize}

Even for each of these cases, there are many different ways to implement
panning. Ardour currently offers just one solution to each of these
situations, but in the future will offer more.

In addition to the panners, Ardour has a balance control for subtle
corrections to existing stereo images.


\chapter{68.13 - Mono Panner}
\label{\detokenize{index:mono-panner}}
The default mono panner distributes 1 input to 2 outputs. Its behaviour
is controlled by a single parameter, the position. By default, the
panner is centered.


\section{Mono Panner User Interface}
\label{\detokenize{index:mono-panner-user-interface}}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{mono-panner}.png}
\caption{The mono panner}\label{\detokenize{index:id576}}\end{figure}

The mono panner looks quite similar to the {\hyperref[\detokenize{index:stereo-panner}]{\emph{stereo
panner}}} interface. The difference is that the L/R
labels in the lower half of the mono panner do not move because there is
no “width” to control.

On the adjacent picture, the panner is centered, as shown by the central
position of the slider, called position indicator.


\section{Using the mouse}
\label{\detokenize{index:using-the-mouse-1}}\label{\detokenize{index:id33}}
To change the position smoothly, press the right button and drag
anywhere within the panner. \sphinxstyleemphasis{Note: grabbing the position indicator is
not needed in order to drag.}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

Reset to defaults
&
Click right
\\
\hline
Change to a “hard left”
&
Double click right in the left
side of the panner
\\
\hline
Change to a “hard right”
&
Double click right in the right
side of the panner
\\
\hline
Set the position to center
&
Double Click right in the middle
of the panner
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\section{Keyboard bindings}
\label{\detokenize{index:keyboard-bindings}}
When the pointer is within a mono panner user interface, the following
keybindings are available to operate on that panner:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

← / ←
&
move position 1° / 5° to the left
\\
\hline
\(\rightarrow\) / \(\rightarrow\)
&
move position 1° / 5° to the right
\\
\hline
0
&
reset position to center
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\section{Using the scroll wheel/touch scroll}
\label{\detokenize{index:using-the-scroll-wheel-touch-scroll}}
When the pointer is within a mono panner user interface, the scroll
wheel may be used as follows:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

⇑ or ⇐
&
move position to the left by 1°
\\
\hline
⇑ or ⇐
&
move position to the left by 5°
\\
\hline
⇓ or ⇒
&
move position to the right by 1°
\\
\hline
⇓ or ⇒
&
move position to the right by 5°
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\chapter{68.14 - Balance Control}
\label{\detokenize{index:balance-control}}
For stereo tracks, it is possible to switch between the default stereo
panner and a traditional balance control by right-clicking on the panner
widget.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{stereo-balance}.png}
\caption{Stereo Balance control}\label{\detokenize{index:id577}}\end{figure}

When the balance is centered, the incoming signals will be unaffected.
Moving it to one side will linearly attenuate the signal of the opposite
side.

While the balance control is considerably less flexible than the stereo
panner, it works with arbitrary content without danger of introducing
comb filter artefacts.


\chapter{68.15 - Stereo Panner}
\label{\detokenize{index:stereo-panner}}
The default stereo panner distributes two inputs to two outputs. Its
behaviour is controlled by two parameters, width and position. By
default, the panner is centered at full width.

The stereo panner assumes that the signals to distribute are either
uncorrelated (i.e. totally independent), or that they contain a stereo
image which is mono-compatible, such as a co-incident microphone
recording, or a sound stage that has been created with pan
pots.{\hyperref[\detokenize{index:caveat}]{\emph{*}}}

With the default values it is not possible to alter the position, since
the width is already spread entirely across both outputs. To alter the
position, the width must first be reduced.


\section{Stereo Panner User Interface}
\label{\detokenize{index:stereo-panner-user-interface}}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{stereo-panner}.png}
\caption{The Stereo Panner}\label{\detokenize{index:id578}}\end{figure}

The panner user interface consists of three elements, divided between
the top and bottom half. Clicking and/or dragging in the top half
controls position; clicking and/or dragging in the bottom half controls
width (see below for details).

In the top half is the position indicator, which shows where the center
of the stereo image is relative to the left and right edges. When this
is the middle of the panner, the stereo image is centered between the
left and right outputs. When it all the way to the left, the stereo
image collapses to just the left speaker.

In the bottom half are two signal indicators, one marked L and the other
R. The distance between these two shows the width of the stereo image.
If the width is reduced to zero, there will only be a single signal
indicator marked M (for mono), whose color will change to indicate this
special state.

It is possible to invert the outputs (see below) so that whatever would
have gone to the right channel goes to the left and vice versa. When
this happens, the entire movable part of the panner changes color to
indicate clearly that this is the case.


\subsection{Position vs. L/R}
\label{\detokenize{index:position-vs-l-r}}
Although the implementation of the panner uses the “position” parameter,
when the user interface displays it numerically, it shows a pair of
numbers that will be familiar to most audio engineers.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
Position
&\sphinxstyletheadfamily 
L/R
&\sphinxstyletheadfamily 
English
\\
\hline
0
&
L=50\% R=50\%
&
signal image is
midway between left
and right speakers
\\
\hline
-1
&
L=100\% R=0\%
&
signal image is
entirely at the left
speaker
\\
\hline
1
&
L=0\% R=100\%
&
signal image is
entirely at the right
speaker
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

One way to remember this sort of convention is that the middle of the
USA is not Kansas, but “Los Angeles: 50\% New York: 50\%”.


\subsection{Examples In Use}
\label{\detokenize{index:examples-in-use}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
Appearance
&\sphinxstyletheadfamily 
Settings
\\
\hline
\sphinxincludegraphics{{stereo-panner}.png}
&
Width=100\%, L=50 R=50
\\
\hline
\sphinxincludegraphics{{stereo-panner-zero}.png}
&
Width=0\%, L=50 R=50
\\
\hline
\sphinxincludegraphics{{stereo-panner-inverted}.png}
&
Width=-100\%, Position = 0 (center)
\\
\hline
\sphinxincludegraphics{{stereo-panner-right}.png}
&
Width=36\%, L=44 R=56
\\
\hline
\sphinxincludegraphics{{stereo-panner-hard-right}.png}
&
Width=0\%, L=0 R=100
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsubsection{Using the mouse}
\label{\detokenize{index:using-the-mouse-2}}\label{\detokenize{index:id34}}
Mouse operations in the upper half of the panner adjust the position
parameter, constrained by the current width setting.

Mouse operations in the lower half of the panner adjust the width
parameter, constrained by the current position setting.

The position can be changed smoothly, by pressing the right button and
dragging within the top half of the panner, then releasing. The position
will be limited by the current width setting. \sphinxstyleemphasis{Note: it is not necessary
to grab the position indicator in order to drag.}

The width can also be changed smoothly, by pressing the right button and
dragging within the lower half of the panner, then releasing. The width
will be limited by the current position setting. \sphinxstyleemphasis{Note: it is not
necessary to grab the L/R indicators in order to drag.}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

Reset to defaults
&
Click right
\\
\hline
Change to hard left
&
Double click right in the upper
left half of the panner
\\
\hline
Change to a hard right
&
Double click right in the upper
right half of the panner
\\
\hline
Move position as far left as
possible, given width
&
Double click right in the upper
left half of the panner
\\
\hline
Move position as far right as
possible, given width
&
Double click right in the upper
right half of the panner
\\
\hline
Set the position to center
&
Click right in the upper middle
of the panner
\\
\hline
Reset to maximum possible width
&
Double click right on the lower
left side
\\
\hline
Invert (flip channel assignments)
&
Double click right on the lower
right side
\\
\hline
Set width to 0°
&
Double click right in the lower
middle
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsubsection{Keyboard bindings}
\label{\detokenize{index:keyboard-bindings-1}}\label{\detokenize{index:id35}}
When the pointer is within a stereo panner user interface, the following
keybindings are available to operate on that panner:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

↑ / ↑
&
increase width by 1° / 5°
\\
\hline
↓ / ↓
&
decrease width by 1° / 5°
\\
\hline
← / ←
&
move position 1° / 5° to the left
\\
\hline
\(\rightarrow\) / \(\rightarrow\)
&
move position 1° / 5° to the right
\\
\hline
0
&
reset position to center
\\
\hline
↑
&
reset width to full (100\%)
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsubsection{Using the scroll wheel/touch scroll}
\label{\detokenize{index:using-the-scroll-wheeltouch-scroll-1}}\label{\detokenize{index:id36}}
When the pointer is within a stereo panner user interface, the scroll
wheel may be used as follows:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

⇐ / ⇐
&
increase width by 1° / 5°
\\
\hline
⇒ / ⇒
&
decrease width by 1° / 5°
\\
\hline
⇑ / ⇑
&
move position 1° / 5° to the left
\\
\hline
⇓ / ⇓
&
move position 1° / 5°to the right
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\section{Stereo panning caveats}
\label{\detokenize{index:stereo-panning-caveats}}
\begin{DUlineblock}{0em}
\item[] The stereo panner will introduce unwanted side effects on material
that includes a time difference between the channels, such as A/B,
ORTF or NOS microphone recordings, or delay-panned mixes.
\item[] When the width is reduced, two highly correlated signals with a delay
are effectively summed, which will cause comb filtering.
\end{DUlineblock}

Let’s take a closer look at what happens when a source is recorded at
45° to the right side with an ORTF stereo microphone array and then the
width manipulated.

For testing, we apply a pink noise signal to both inputs of an Ardour
stereo bus with the stereo panner, and feed the bus output to a
two-channel analyser. Since pink noise contains equal energy per octave,
the expected readout is a straight line, which would indicate that our
signal chain does not color the sound:

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{stereo-panner-with-ORTF-fullwidth}.png}
\caption{Stereo panner with ORTF full width}\label{\detokenize{index:id579}}\end{figure}

An ORTF is simulated using Robin Gareus’ stereo balance control LV2 to
set the level difference and time delay. The Trim/Gain can be
ignored—its purpose is just to align the test signal with the 0dB line
of the analyser.

An ORTF microphone pair consists of two cardioids spaced 17 cm apart,
with an opening angle of 110°. For a far source at 45° to the right, the
time difference between the capsules is 350 \(\mu\)s or approximately 15
samples at 44.1 kHz. The level difference due to the directivity of the
microphones is about 7.5 dB (indicated by the distance between the blue
and red lines in the analyser).

Now for the interesting part: if the width of the signal is reduced to
50\%, the time-delayed signals will be combined in the panner. What
happens to the frequency response of the left and right outputs is shown
in the following picture:

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{stereo-panner-with-ORTF-halfwidth}.png}
\caption{Stereo panner with ORTF half width}\label{\detokenize{index:id580}}\end{figure}

It can be argued that all spaced microphone recordings will undergo comb
filtering later, when the two channels recombine in the air between the
speakers. Perceptually however, there is a huge difference: our hearing
system is very good at eliminating comb filters in the real world, where
their component signals are spatially separated. But once they are
combined inside a signal chain, this spatial separation is lost and the
brain will no longer be able to sort out the timbral mess.

Depending on the material and on how much the width needs to be
manipulated, some degree of comb filtering may be acceptable. Then
again, it may not. It is advised to listen carefully for artefacts when
manipulating unknown stereo signals—many orchestra sample libraries for
example do contain time-delay components.


\chapter{68.16 - VBAP Panner}
\label{\detokenize{index:vbap-panner}}
\begin{DUlineblock}{0em}
\item[] Ardour’s VBAP panner is currently in development, and its semantics
may change in the near future, possibly affecting mixes using it. It
is advised not to rely on it for important production work while the
dust settles.
\item[] The Panner only works in fixed static mode, it does not support
automation playback.
\end{DUlineblock}

VBAP is a versatile and straightforward method to pan a source around
over an arbitrary number of speakers on a horizontal polygon or a 3D
surface, even if the speaker layout is highly irregular.


\section{Basic concepts}
\label{\detokenize{index:basic-concepts}}
VBAP was developed by Ville Pulkki at Aalto University, Helsinki, in
1997. It works by distributing the signal to the speakers nearest to the
desired direction with appropriate weightings, aiming to create a
maximally sharp phantom source by using as few speakers as possible:
\begin{itemize}
\item {} 
one speaker, if the desired direction coincides with a speaker
location,

\item {} 
two speakers, if the desired direction is on the line between two
speakers,

\item {} 
and three speakers in the general 3D case.

\end{itemize}

Thus, if the panner is moved onto a speaker, only this speaker will get
any signal. This is handy when precise 1:1 routing is needed.

The drawback of VBAP is that a moving source will constantly change its
apparent sharpness, as it transitions between the three states mentioned
above.

An horizontal VBAP panner has one parameter, the azimuth angle. A
full-sphere panner offers an additional elevation angle control.

More elaborate implementations of VBAP also include a spread parameter,
which will distribute the signal over a greater number of speakers in
order to maintain constant (but no longer maximal) sharpness, regardless
of position. Ardour’s VBAP panner does not currently include this
feature.


\section{Speaker layout}
\label{\detokenize{index:speaker-layout}}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{VBAP-panner-5}.png}
\caption{The VBAP panner with 5 outputs}\label{\detokenize{index:id581}}\end{figure}

Each VBAP panner is specific to its speaker layout—the panner has to
“know” about the precise location of all the speakers. A complete VBAP
implementation must therefore include the possibility to define this
layout.

Ardour currently uses a simplified approach: if a track or bus has more
than two output channels (which implies stereo), it assumes that there
are N speakers distributed in a regular N-gon. That means that for
irregular layouts such as 5.1 or 7.1, the direction dialed in will
differ a bit from the actual auditory result, but any desired
spatialisation can still be achieved.


\subsection{Experimental 3D VBAP}
\label{\detokenize{index:experimental-3d-vbap}}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{VBAP-panner-10}.png}
\caption{The VBAP panner with 10 outputs, in experimental 3D mode}\label{\detokenize{index:id582}}\end{figure}

For tracks with 10 outputs, Ardour will currently assume a 3-dimensional
speaker layout corresponding to Auro-3D 10.1, which is a horizontal 5.1
system, four elevated speakers above L, R, Ls, and Rs, and an additional
“voice-of-god” speaker at the zenith.


\section{N:M panning}
\label{\detokenize{index:n-m-panning}}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{VBAP-panner-4in5}.png}
\caption{The VBAP panner in 4 in, 5 out mode}\label{\detokenize{index:id583}}\end{figure}

For tracks and busses with more than one input, Ardour will (for now)
assume that the inputs are distributed symmetrically along the latitude
around the panner direction. The width parameter controls the opening
angle of the distribution sector.


\chapter{69 - Plugin and Hardware Inserts}
\label{\detokenize{index:plugin-and-hardware-inserts}}

\chapter{69.1 - Working With Plugins}
\label{\detokenize{index:working-with-plugins}}
Plugins are bits of software that get loaded by Ardour in order to:
\begin{itemize}
\item {} 
Create various audio or MIDI effects

\item {} 
Generate audio by functioning as “software instruments”

\end{itemize}

They are usually written by 3rd parties, though {\hyperref[\detokenize{index:plugins-bundled-with-ardour}]{\emph{a few come as part of a
standard Ardour install}}}. The sources
for plugins are many and varied; see {\hyperref[\detokenize{index:getting-more-plugins}]{\emph{here}}}
for some information on how to get them.

Ardour supports a variety of different plugin standards:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

LADSPA
&
An early, simple, lightweight
plugin API, audio effects only,
plugins have no editors/GUI of
their own (Ardour provides one,
however).
\\
\hline
LV2
&
An extensible, full-featured
plugin API, audio and MIDI,
plugins can provide their own
GUIs but may use the one Ardour
provides instead.
\\
\hline
AU
&
OS X only, full featured, audio
and MIDI, plugins can provide
their own GUI
\\
\hline
VST
&
Plugins using Steinberg’s VST
plugin standard. Varies by
platform:
+————\textendash{}+————\textendash{}+
\textbar{} on Linux     \textbar{} (native)     \textbar{}
\textbar{}              \textbar{} Linux VST    \textbar{}
\textbar{}              \textbar{} plugins      \textbar{}
\textbar{}              \textbar{} fully        \textbar{}
\textbar{}              \textbar{} supported    \textbar{}
\textbar{}              \textbar{} (VST2.4)     \textbar{}
+————\textendash{}+————\textendash{}+
\textbar{} on Windows   \textbar{} (native)     \textbar{}
\textbar{}              \textbar{} Windows VST  \textbar{}
\textbar{}              \textbar{} plugins      \textbar{}
\textbar{}              \textbar{} fully        \textbar{}
\textbar{}              \textbar{} supported    \textbar{}
\textbar{}              \textbar{} (VST2.4)     \textbar{}
+————\textendash{}+————\textendash{}+
\textbar{} on OS X      \textbar{} (native)     \textbar{}
\textbar{}              \textbar{} macOS VST    \textbar{}
\textbar{}              \textbar{} plugins      \textbar{}
\textbar{}              \textbar{} fully        \textbar{}
\textbar{}              \textbar{} supported    \textbar{}
\textbar{}              \textbar{} (VST2.4)     \textbar{}
\textbar{}              \textbar{} since Ardour \textbar{}
\textbar{}              \textbar{} 5.5          \textbar{}
+————\textendash{}+————\textendash{}+
\\
\hline
Windows VST Plugins on Linux
&
VST plugins for Windows, but
being used on Linux. \sphinxstyleemphasis{Not
supported by normal builds of
Ardour.}{\hyperref[\detokenize{index:using-windows-vst-plugins-on-linux}]{\emph{Read
more…}}}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\section{Adding/Removing/Copying Plugins}
\label{\detokenize{index:adding-removing-copying-plugins}}
Within Ardour, plugins are just another type of Processor and so the
techniques for adding/removing/copying/moving processors apply to
plugins as well. These techniques are covered on the {\hyperref[\detokenize{index:processor-box}]{\emph{Processor
Box}}} page.


\chapter{69.2 - Processor Box}
\label{\detokenize{index:id37}}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{processor-box}.png}
\caption{Processor Box.}\label{\detokenize{index:id584}}\end{figure}

In Ardour terminology, a processor is anything which treats the signal
in some way and gets plugged into a mixer strip. Ardour provides several
builtin processors such as the fader or panners. Processors can also be
plugins used for effects or as instruments, as well as sends or inserts
which affect {\hyperref[\detokenize{index:signal-routing}]{\emph{signal routing}}}.

The arrangement of processors is arbitrary, and there is no limit to how
many there can be. The Processor Box will automagically add a scrollbar
to itself if there are more processors in it than can be shown in the
given space.

The main box in the top half of a mixer strip shows the processor box.
Processors are shown as colored rectangles, with a small LED beside them
that lights up when the processor is enabled. The color of the processor
depends on its location in the sequence; processors that are pre-fader
are colored in red, and post-fader processors are colored green (in the
default theme).

The processor box will always contain a blue Fader processor. This
indicates where in the processor chain the main channel fader is
located; this is the fader shown in the lower half of the strip. It can
be enabled and disabled like any other processor.


\section{Adding Processors}
\label{\detokenize{index:adding-processors}}
Processors can be added to the chain by Right-clicking in the processor
list, This does three things:
\begin{itemize}
\item {} 
A gap is opened up to indicate the location of the click. The gap
shows where any new processors will be inserted.

\item {} 
The processor under the click is selected.

\item {} 
An options menu is presented.

\end{itemize}

From the menu, new processors can be inserted.

Processors can also be dragged and dropped from the {\hyperref[\detokenize{index:favorite-plugins-window}]{\emph{Favorite Plugins
window}}} to an appropriate spot in the
Processor Box.

The Favorite Plugins window can be populated via the {\hyperref[\detokenize{index:plugin-manager}]{\emph{Plugin
Manager}}}, or by dragging and dropping an existing
processor from the processor box to the Favorite Plugins window.


\section{To Reorder (Move) Processors}
\label{\detokenize{index:to-reorder-move-processors}}
Processors can be re-ordered using drag and drop. Dragging a processor
allows it to be moved around within the chain, or copied to another
processor list on another track or bus.


\section{To Enable/Disable a Processor}
\label{\detokenize{index:to-enable-disable-a-processor}}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{processor}.png}
\caption{A typical processor.}\label{\detokenize{index:id585}}\end{figure}

To the left of the name of each processor is a small LED symbol; if this
is lit-up, the processor is active. Clicking on it will deactivate the
processor and effectively bypass it.

Some processors have their own bypass controls that are independent of
the one that Ardour provides; this can make it appear that the plugin is
non-responsive when its independent bypass control is active.


\section{Selecting Processors}
\label{\detokenize{index:selecting-processors}}
A processor in the processor box can be selected with a Left-click on
it; it will be highlighted in red. Other processors can be selected at
the same time by Left-clicking on them while holding down the key, and
ranges can be selected by Left-clicking on them while holding down the
key.


\section{Removing Processors}
\label{\detokenize{index:removing-processors}}
Context-click on the processor to be removed, and select Delete; or
Right-click on it; or Left-click on it and press the Delete key. If
multiple processors are selected, they will all be deleted at the same
time.


\chapter{69.3 - Plugin Manager}
\label{\detokenize{index:plugin-manager}}
The Plugin Manager serves two purposes. Primarily it is used to control
the display status of plugins. It can also be used to find and insert
plugins into the {\hyperref[\detokenize{index:processor-box}]{\emph{Processor Box}}}. It is displayed
either by a double-click in the Processor Box or by choosing New Plugin
\textgreater{} Plugin Manager… from the Processor Box context menu.

Displayed for each plugin is the status (normal, favorite, hidden),
name, type, category, creator (author), and the number of audio and MIDI
connections. The plugins can be sorted by clicking on a column header.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{plugin-manager}.png}
\caption{The Plugin Manager window.}\label{\detokenize{index:id586}}\end{figure}


\section{Plugin Display Status}
\label{\detokenize{index:plugin-display-status}}
Click on a Fav(orite) or Hide radio button to change a plugin’s display
status. Clicking on an already selected radio button will cancel it,
returning the plugin to the normal display status. Plugins marked as a
favorite show up in the Processor Box context menu under New Plugin \textgreater{}
Favorites. Setting the hide radio button on a plugin will keep the
plugin from showing in the Processor Box context menus New Plugin \textgreater{} By
Creator or New Plugin \textgreater{} By Category.


\section{Filtering Listed Plugins}
\label{\detokenize{index:filtering-listed-plugins}}
The bottom left part of the Plugin Manager is used to filter the listed
plugins. Typing into the text-box will filter the plugins based on the
filter mode selected by drop-down box. Clicking Clear empties the
text-box.


\section{Inserting Plugins in the Processor Box}
\label{\detokenize{index:inserting-plugins-in-the-processor-box}}
The right part of the plugin manager shows plugins that have been
selected for insertion into the Processor Box. A plugin can be added by
either double clicking the plugin entry in the top left part, or, if
already selected in top left part, by clicking Add.

Plugins can be removed from the right part with a double click, or, if
already selected, by clicking Remove.


\chapter{69.4 - Managing Plugin Presets}
\label{\detokenize{index:managing-plugin-presets}}
All plugin control widgets, whether they are created by Ardour or by the
plugin, have a common set of controls at the top of the window. These
include 4 controls for managing plugin presets.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{plugins_preset_bar}.png}
\caption{The plugin presets toolbar.}\label{\detokenize{index:id587}}\end{figure}


\section{What Is a Plugin Preset?}
\label{\detokenize{index:what-is-a-plugin-preset}}
A preset for a plugin is simply a saved set of values for all of a
plugin’s parameters. If you load a preset, you are restoring all the
parameters of that plugin to the values stored in the preset. This is an
easy, fast way to manage your preferred settings for particular plugins.


\section{The Preset Selector}
\label{\detokenize{index:the-preset-selector}}
The preset selector (1) is a regular selector that can be clicked to
display a list of all known presets for this plugin. This will include
presets that have been created by the user, and for some plugin formats,
presets that come with the plugin itself.


\section{Loading a New Preset}
\label{\detokenize{index:loading-a-new-preset}}
Clicking on the preset selector pops up a menu showing the names of all
available presets. Clicking on the name of a preset loads it, and
various controls in the plugin editor change to reflect the new value of
some or all parameters.


\section{Creating a Preset}
\label{\detokenize{index:creating-a-preset}}
Saving the current plugin settings as a new preset is done by clicking
on the Add button (2) at the top of the window. A dialog will appear
asking for a name for the preset.


\section{Saving a Preset}
\label{\detokenize{index:saving-a-preset}}
To modify the settings in an existing preset, the preset selector must
be used to load the preset, then, when the settings have been adjusted,
the Save button (3) clicked. The new values will be stored, overwriting
the previous version of this preset.


\section{Deleting a preset}
\label{\detokenize{index:deleting-a-preset}}
Deleting an existing preset is achieved by loading the preset first,
then clicking the Delete button (4). The preset will be removed, and the
preset selector turns blank, showing that no preset is currently loaded
(although the settings will stay as they were).


\chapter{69.5 - Working with Ardour-built Plugin Editors}
\label{\detokenize{index:working-with-ardour-built-plugin-editors}}
The plugin editor can be shown by double-clicking on the plugin within
the {\hyperref[\detokenize{index:processor-box}]{\emph{processor box}}}. A new window will appear showing
the editor/GUI for the plugin.


\section{Generic Plugin Editor}
\label{\detokenize{index:generic-plugin-editor}}
If a plugin does not have its own GUI, Ardour will construct a generic
plugin editor from a small set of common control elements. Ardour will
do this even for plugins that have their own, if Edit \textgreater{} Preferences \textgreater{}
GUI \textgreater{} Use Plugins’ own interface instead of Ardour’s is disabled.

The generic UI can be temporarily switched to by right clicking on a
processor and selecting Edit with generic controls. This is necessary in
order to access the {\hyperref[\detokenize{index:automation}]{\emph{plugin automation controls}}}.

In the generic UI, any controller can be reset to its default state by
Left-clicking on it.


\section{Analysis Graph}
\label{\detokenize{index:analysis-graph}}
At the bottom of the generic plugin editor, clicking the arrow displays
the Analysis Graph.

This graph displays:
\begin{itemize}
\item {} 
the transfer function in white,

\item {} 
the phase response in red (optional),

\item {} 
the post effect spectrum in green.

\end{itemize}

The transfer function plots the output amplitude of the plugin
(considered as a “black box”) against its input amplitude, along the
audio spectrum.

The phase response, that can be switched on or off using the Show phase
checkbox, plots the phase of the plugins output against its input phase,
along the audio spectrum. The scale is shown in yellow on the right.

The green spectrum plots the output signal spectrum, after the plugin
(for tracks that have a signal on).

The dB scale selector in the bottom left allows to change the vertical
scale of the graphs.


\section{MIDI instruments specificities}
\label{\detokenize{index:midi-instruments-specificities}}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{instrument_plugins-keyboard}.png}
\caption{The MIDI keyboard in instruments plugins}\label{\detokenize{index:id588}}\end{figure}

The generic UI provides, for all MIDI instruments plugins, a keyboard,
that can be used either with the mouse, or by using a QWERTY keyboard as
a piano. Both the channel and the velocity can be set above the
keyboard.


\chapter{69.6 - Plugins Bundled With Ardour}
\label{\detokenize{index:plugins-bundled-with-ardour}}
Ardour does not come with any built-in signal processors of its own
(other than volume faders) but does ship, since v5.0, with the small
group of plugins listed below. These plugins are listed as authored by
“Ardour Team”, which are LV2 plugins, and are named with “a-” as the
start of the name (like a-EQ) or are listed as authored by “Ardour LUA
Task Force” in which case they are example (but still useful) LUA
scripts. These plugins use Ardour’s generic GUI, and they work on all
supported platforms so that projects started on one platform will sound
the same on another platform—if they use just these plugins.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

a-Amplifier
&
A versatile \(\pm\)20dB multi-channel
amplifier
\\
\hline
a-Compressor
&
A side-chain enabled compressor
with the usual controls. Comes in
stereo and mono versions
\\
\hline
a-Delay
&
A basic single-tap delay line,
with tempo sync
\\
\hline
a-EQ
&
A nice sounding 4-band parametric
EQ with shelves
\\
\hline
a-Fluid Synth
&
Wraps the Fluidsynth SoundFont2
synthesis engine as a new sample
player
\\
\hline
a-High/Low Pass Filter
&
Independent high and low pass
filters with steepness up to 48dB
per octave
\\
\hline
a-Inline Scope
&
A mixer strip inline waveform
display
\\
\hline
a-Inline Spectrogram
&
A mixer strip inline spectrum
display
\\
\hline
a-MIDI Monitor
&
A mixer strip inline display to
show recent MIDI events
\\
\hline
a-Reverb
&
A reverb that finds a balance
between sounding good, using a
lot of CPU and having too many
controls
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\chapter{69.7 - Getting More Plugins}
\label{\detokenize{index:getting-more-plugins}}
The following list shows a few plugin packages. In some cases, a package
contains just one or two plugins; in other cases, dozens.

This list does not aim at being exhaustive.


\section{Plugins by Standard:}
\label{\detokenize{index:plugins-by-standard}}

\subsection{LV2}
\label{\detokenize{index:lv2}}\label{\detokenize{index:id38}}\begin{itemize}
\item {} 
SWH \sphinxurl{http://plugin.org.uk/lv2/} {[}GNU GPLv3{]}

\item {} 
ll-plugins \sphinxurl{http://ll-plugins.nongnu.org/} {[}GNU GPLv3{]}

\item {} 
ZynAddSubFX \sphinxurl{http://zynaddsubfx.sourceforge.net/} {[}GNU GPLv2+{]}

\item {} 
OvertoneDSP \sphinxurl{https://www.overtonedsp.co.uk/} {[}Proprietary{]}

\item {} 
Invada Studio \sphinxurl{https://launchpad.net/invada-studio/} {[}GNU GPLv2{]}

\item {} 
Pianoteq \sphinxurl{https://www.pianoteq.com/} {[}Proprietary{]}

\end{itemize}


\subsection{LADSPA}
\label{\detokenize{index:ladspa}}\label{\detokenize{index:id39}}\begin{itemize}
\item {} 
Kokkini Zita \sphinxurl{http://kokkinizita.linuxaudio.org/linuxaudio/} {[}GNU
GPL/GNU GPLv3{]}

\item {} 
Blepvco
\sphinxhref{http://smbolton.com/linux.html}{http://www.smbolton.com/linux.html}
{[}GNU GPLv2+{]}

\item {} 
Blop \sphinxurl{http://blop.sourceforge.net/} {[}GNU GPLv2{]}

\item {} 
CAPS \sphinxurl{http://quitte.de/dsp/caps.html} {[}GNU GPLv3{]}

\item {} 
CMT \sphinxurl{http://www.ladspa.org/cmt/overview.html} {[}GNU GPLv2{]}

\item {} 
FOO \sphinxurl{https://github.com/sampov2/foo-plugins} {[}GNU GPLv2{]}

\item {} 
NJL \sphinxurl{https://github.com/tialaramex/njl-plugins} {[}GNU GPLv2{]}

\item {} 
Omins \sphinxurl{http://www.nongnu.org/om-synth/omins.html} {[}GNU GPLv3{]}

\item {} 
SWH \sphinxurl{http://plugin.org.uk/} {[}GNU GPLv3{]}

\item {} 
TAP \sphinxurl{http://tap-plugins.sourceforge.net/} {[}GNU GPLv2{]}

\item {} 
VCF
\sphinxhref{http://users.suse.com/~mana/ladspa.html}{http://www.suse.de/\textasciitilde{}mana/ladspa.html}
{[}GNU LGPL{]}

\item {} 
VLevel
\sphinxhref{http://vlevel.sourceforge.net/about/}{http://vlevel.sourceforge.net/}
{[}GNU GPLv2{]}

\item {} 
Vocoder \sphinxurl{http://www.sirlab.de/linux/download\_vocoder.html} {[}GNU GPLv2+{]}

\item {} 
WASP \sphinxurl{http://linux01.gwdg.de/~nlissne/wasp/index.html} {[}GNU GPLv3{]}

\item {} 
Nova
\sphinxurl{http://chuck.stanford.edu/planetccrma/mirror/fedora/linux/planetccrma/10/i386/repoview/ladspa-nova-plugins.html}
{[}GNU GPLv2+{]}

\item {} 
Socal’s LEET Plugins \sphinxurl{http://code.google.com/p/leetplugins/} {[}GNU
GPLv2{]}

\end{itemize}


\subsection{Linux VST (LXVST)}
\label{\detokenize{index:linux-vst-lxvst}}\label{\detokenize{index:linuxvst}}\begin{itemize}
\item {} 
Loomer \sphinxurl{http://www.loomer.co.uk/} {[}Proprietary{]}

\item {} 
Distrho \sphinxurl{http://distrho.sourceforge.net/ports.php} {[}GNU GPLv3{]}

\item {} 
Argotlunar \sphinxurl{http://argotlunar.info/} {[}GNU GPLv2{]}

\item {} 
U-he \sphinxurl{https://u-he.com/} {[}Proprietary{]}

\end{itemize}


\section{How to install plugins?}
\label{\detokenize{index:how-to-install-plugins}}

\subsection{Linux}
\label{\detokenize{index:linux-1}}\label{\detokenize{index:id40}}
Installation will vary a little depending on how the plugins have been
obtained. If a particular plugin package appears in the local
repository, installing it using is done by using the normal software
package management tool for the system. Most Linux distributions that
are good for audio work will have most of the LADSPA and LV2 plugins
mentioned above available in ready-to-use form.

Finding them will typically require \sphinxstyleemphasis{searching} the distribution’s
repository to find the name of the package. The tools for doing this
vary from distribution to distribution. A good place to start searching
is with the name of the package (e.g. “caps” or “cmt”). There are no
fixed rules about what different Linux distributions call their packages
for a given set of plugins.

If the package isn’t available, then the plugins can be built from
source (plugins are generally fairly easy to compile and
well-documented).

LADSPA plugins are shared library files. They need to be installed in
either /usr/lib/ladspa, /usr/local/lib/ladspa or in a directory
mentioned in the local LADSPA\_PATH environment variable.

LV2 plugins are folders/directories. They need to be installed in either
/usr/lib/lv2, /usr/local/lib/lv2 or a directory mentioned in the local
LV2\_PATH environment variable.

Linux VST (LXVST) plugins are distributed as shared library files. They
are typically installed in /usr/lib/lxvst, /usr/local/lib/lxvst or a
directory mentioned in the local LXVST\_PATH environment variable.


\subsection{OS X}
\label{\detokenize{index:os-x-1}}\label{\detokenize{index:id41}}
Except for the particularly technical computer user, building and
installing plugins in the LV2 (or LADSPA) format is probably not
something worth planning on.

Most of the plugins likely to be used on OS X will be in Apple’s
AudioUnit format. These have their own installation process that tends
to just work.


\chapter{69.8 - Using Windows VST Plugins on Linux}
\label{\detokenize{index:using-windows-vst-plugins-on-linux}}
Thanks to the combined work of Torben Hohn, Kjetil Mattheusen, Paul
Davis and a few other developers, it is possible to use Windows VST
plugins (that is, plugins in VST format built and distributed for the
Windows platforms) on Ardour running on Linux.

However, doing so has three \sphinxstyleemphasis{substantial} downsides:
\begin{itemize}
\item {} 
It requires a special build of Ardour that is fundamentally very
different from normal builds

\item {} 
Support depends on \sphinxhref{http://winehq.org/}{Wine}, a Windows
“emulator”

\item {} 
As usual with plugins, a crashing plugin will take Ardour down with
it—and crashes in Windows VST plugins are more likely when used in
this way

\end{itemize}

The dependence on Wine makes it almost impossible for the Ardour project
to support this feature. Wine’s functionality generally improves over
time, but any given release of Wine may behave worse with some or all
Windows VST plugins. It may even just crash Ardour completely.

Step back and think about what “using Windows VSTs” really means: taking
bits of software written with only one idea in mind—running on the
Windows platform—and then trying to use them on an entirely different
platform. It is a bit of a miracle (thanks largely to the incredible
work done by the Wine project) that it works at all. But is this the
basis of a stable, reliable DAW for a non-Windows platform? Getting
Ardour on Linux to pretend that its really a Windows application running
on Windows?

It is understandable that there are many outstanding plugins available
as Windows VSTs and, that in many cases, no equivalent is available for
Linux. If a workflow is so dependent on those plugins, Ardour should be
used on Windows (or potentially used with an actual Windows VST host
running inside of Wine). If the effort can be made, a better environment
can be obtained by using a normal build of Ardour and exploring the
world of plugins built to run on Linux natively. This covers LADSPA, LV2
and Linux VST formats, and even some outstanding proprietary plugins
such as those from \sphinxhref{http://www.loomer.co.uk/}{Loomer}.


\section{A Plea To Plugin Manufacturers}
\label{\detokenize{index:a-plea-to-plugin-manufacturers}}
Please consider porting your plugins so that users can enjoy them on
Linux too. Several other commercial plugin developers have already done
this. You can choose between using “Linux VST” (which is what Loomer and
others have done)—you will find toolkits like JUCE that help to make
this fairly easy—or using LV2 format which is ultimately more flexible
but probably requires more work. We have users—thousands of users—on
Linux who would like to use your plugins.


\chapter{70 - Automation}
\label{\detokenize{index:automation}}
Automation is the ability to dynamically control various aspects of a
track’s innate attributes and the attributes of any processors attached
to it. In Ardour, automation can be used to make dynamic changes to a
track’s:
\begin{itemize}
\item {} 
Volume

\item {} 
Panning

\item {} 
Trim

\item {} 
Muting

\item {} 
Any attached processor’s parameters

\end{itemize}

Any combination of these can be enabled on a single track; as such, it
offers a lot of power and flexibility over how a track will ultimately
sound when played back.


\chapter{70.1 - Automation Nomenclature}
\label{\detokenize{index:automation-nomenclature}}
Track automation occurs in one or more lanes. Each lane has a control
that allows setting the amount or position of a certain parameter
associated with the lane. Parameters are things that can be controlled
on a track’s automation lane, such as volume, panning, muting, trim,
etc. Automation curves consist of lines connected by control points,
that live within the confines of a lane; these tell Ardour how to change
a given parameter over time. Automation modes govern how a given
automation lane will behave during playback.


\chapter{70.2 - Automation Modes}
\label{\detokenize{index:automation-modes}}
In order to understand how automation in Ardour works, it is necessary
to understand the four modes of automation. They are: Manual, Play,
Write, and Touch.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{automation-modes1}.png}
\caption{The automation mode menu.}\label{\detokenize{index:id589}}\end{figure}

Manual mode is basically analogous to a processor’s bypass switch.
Whenever an automation lane is in this mode, it is inactive and any
level that is manually set for controlling the lane’s parameter will
persist during playback like normal.

In Ardour, every track and processor parameter is initially set to
Manual mode.

Play mode tells Ardour to use the automation curve in the automation
lane to control the level of the parameter controlled by the lane
\sphinxstyleemphasis{during playback}. The control that normally sets the parameter will be
\sphinxstyleemphasis{unresponsive to manual input} and will move automatically in accord
with the lane’s automation curve during playback.

Write mode allows continuous, dynamic setting of a control during
playback; all such settings are written to the lane the control is in.
This defines the lane’s automation curve in the interval being played,
and overwrites any existing automation curve in the lane being
manipulated.

Touch mode is similar to Write mode, except it only overwrites sections
of a lane’s automation curve when the control is changed in some way.
This allows for changing only the parts of an automation curve that are
desired to be changed, while leaving the rest unchanged.


\chapter{70.3 - Automation Lanes}
\label{\detokenize{index:automation-lanes}}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{automation-lane1}.png}
\caption{A typical automation lane.}\label{\detokenize{index:id590}}\end{figure}

An automation lane is similar to a track in that it holds data that can
be played back; however, unlike a track, it is not an independent
entity—it is always attached to the track that it controls. Automation
lanes also contain zero to one automation curves. Each lane controls one
and only one parameter of the track it is attached to.

Every track will have at least five automation lanes associated with it:
trim, fader, mute, and pan (which consists of two lanes: L/R and Width);
it can possibly have many more if there are any processors associated
with it. All these lanes are automatically attached to the track but
hidden, and initially they are all empty (have no automation curves in
them).

Automation lanes typically have the following controls:
\begin{itemize}
\item {} 
A hide button (square button with an “X” inside)

\item {} 
A horizontal fader

\item {} 
An automation mode selector

\end{itemize}

The hide button, as the name implies, hides the automation lane. The
horizontal fader controls the level of the parameter that the lane
controls; manipulating this while in Write or Touch mode during playback
will make changes to the lane’s automation curve. The automation mode
selector selects which mode the lane is in (Manual, Play, Write, or
Touch).

The hide button will only hide the lane; it does not remove it from the
track. The automation lane never really goes away—the closest one can
get to that is to clear the automation curve and hide the lane.


\chapter{70.4 - Automation Curves}
\label{\detokenize{index:automation-curves}}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{automation-curve1}.png}
\caption{A typical automation curve.}\label{\detokenize{index:id591}}\end{figure}

An automation curve is a series of lines connected by control points
that defines a continuous line. As the curve is traversed from left to
right, the line defines the level of the parameter controlled by the
automation lane.

The curve by itself does nothing; it will \sphinxstyleemphasis{only} control playback if the
lane it is in is in Play mode.


\chapter{70.5 - Controlling a Track with Automation}
\label{\detokenize{index:controlling-a-track-with-automation}}\label{\detokenize{index:track-automation}}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{automation-menu1}.png}
\caption{The automation menu.}\label{\detokenize{index:id592}}\end{figure}

To automate a parameter on a given track, click on the track’s A button
and select a parameter to control from the menu that appears. Once a
parameter has been selected, an automation lane for that parameter will
appear beneath the track. The lane thus shown will be empty; from here
an automation curve must be defined.

If the height of the automation lane is too small to see all of its
controls, the height can be increased by Left clicking on the bottom
border of the lane and dragging it.

There are three ways to define an automation curve:
\begin{itemize}
\item {} 
Record it using Write mode

\item {} 
Record it using Touch mode

\item {} 
Draw it using the mouse

\end{itemize}


\section{Recording an Automation Curve Using Write Mode}
\label{\detokenize{index:recording-an-automation-curve-using-write-mode}}
To create an automation curve using Write mode, first set the lane’s
mode selector to Write, then set the playhead to the position where the
automation curve should start, then set the transport to play. While the
playhead is moving, Ardour will continuously record any changes made
with the lane’s fader. Even if no changes are made to the fader, they
will overwrite anything that existed in the lane where the playhead is
moving. When the desired automation curve has been recorded, stop the
transport.

After the transport is stopped, the lane’s mode selector will
automatically switch to Touch mode—it is generally a bad idea to leave
an automation lane in Write mode, as it is a destructive operation that
makes it easy to inadvertently overwrite existing automation curves.


\section{Recording an Automation Curve Using Touch Mode}
\label{\detokenize{index:recording-an-automation-curve-using-touch-mode}}
Creating an automation curve using Touch mode is similar to the method
employed in creating one using Write mode; the only difference is that
changes are written to the automation curve \sphinxstyleemphasis{only} when the lane’s fader
is moved—at all other times, whatever was in the automation curve will
remain as it was.

Touch mode is useful when only small parts of the automation curve need
touching up versus Write mode, which is usually used to create the
automation curve in the first place.


\section{Drawing an Automation Curve Using the Mouse}
\label{\detokenize{index:drawing-an-automation-curve-using-the-mouse}}
In Draw mode, control points can be entered in the automation lane by
Left-clicking in the lane at a point where there is no existing control
point.

Once added, a control point can be Left-clicked and dragged to a desired
location. Hovering over a control point will show its current level in
dB. To remove a control point, Left-click it and press Delete, or
Right-click on it.


\section{Controlling the Track}
\label{\detokenize{index:controlling-the-track}}
Once an automation curve has been defined through any of the methods
outlined above, the track won’t do anything with it until the lane that
the curve was defined in is set to Play mode. Then, during playback, as
the playhead moves through the automation curve, the lane’s control will
move in accord with the curve.

The lane’s fader will \sphinxstyleemphasis{not} be responsive to manual input while it is in
Play mode.


\chapter{71 - Mixdown}
\label{\detokenize{index:mixdown}}

\chapter{71.1 - Export Dialog}
\label{\detokenize{index:export-dialog}}
When the work in Ardour is finished, one or multiple sound file(s) need
to be created, be it to be printed to a medium such as a CD or DVD,
uploaded to a streaming site or sent to another person or software for
further work. This can be done either using Session \textgreater{} Export \textgreater{} Export to
Audio file(s)…, or Session \textgreater{} Export \textgreater{} Stem Export….

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{export-dialog-file-format}.png}
\caption{The Export window}\label{\detokenize{index:id593}}\end{figure}


\section{File Format}
\label{\detokenize{index:file-format}}
This tab contains controls for the format of the exported audio file(s).
More than one format can be enabled here, in which case each will be
exported in turn. Ardour is supplied with a list of export formats,
including:
\begin{itemize}
\item {} 
BWAV 32float

\item {} 
CD (Red Book)

\item {} 
DVD-A

\item {} 
FLAC 24 bit

\item {} 
FLAC 24 bit (tagged)

\item {} 
Ogg/Vorbis

\item {} 
Ogg/Vorbis (tagged)

\item {} 
Ring Tone

\end{itemize}

These formats can be edited, or new ones created, with the {\hyperref[\detokenize{index:export-format-profiles}]{\emph{“Edit Export
Format Profile”}}} dialog, which appears when
clicking the Edit or New buttons to the right of the drop-down list of
formats.

Presets can also be created, consisting of one or more formats. Ardour
provides some ready-made presets, too:
\begin{itemize}
\item {} 
CD + DVD-A

\item {} 
CD + FLAC

\item {} 
CD + FLAC (tagged)

\item {} 
CD + Ogg/Vorbis + FLAC (tagged)

\item {} 
CD + Ogg/Vorbis

\item {} 
CD + Ogg/Vorbis (tagged)

\item {} 
CD only

\item {} 
DVD-A only

\item {} 
FLAC

\item {} 
FLAC (tagged)

\item {} 
Ogg/Vorbis + FLAC

\item {} 
Ogg/Vorbis + FLAC (tagged)

\item {} 
Ogg/Vorbis

\item {} 
Ogg/Vorbis (tagged)

\end{itemize}


\section{The location}
\label{\detokenize{index:the-location}}
Aside from providing a way to tell Ardour \sphinxstyleemphasis{where} to put the created
file(s), the location part of the window allows to name the exported
files with a lot of choice regarding the naming convention, hence
blending into the user’s workflow, and providing a clean way to keep the
export folders from being cluttered with poorly named files.

The name of the file(s) can optionally be made of:
\begin{itemize}
\item {} 
The session or snapshot’s name

\item {} 
A custom label (i.e., any text)

\item {} 
A revision number

\item {} 
The name of the timespan (see below)

\item {} 
A date (in multiple formats)

\item {} 
A time (also in multiple format).

\end{itemize}

As in the screenshot above, when writing a file could erase a present
file with the same name, Ardour shows a yellow warning line in the
bottom of the window, and a button to list all the files that would be
erased and replaced.


\section{Analyze exported audio}
\label{\detokenize{index:analyze-exported-audio}}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{export-report-analysis}.png}
\caption{The Export Report/Analysis window}\label{\detokenize{index:id594}}\end{figure}

Checking Analyze Exported Audio shows the Export Report/Analysis window.
This provides a lot of useful information about the exported file:
\begin{itemize}
\item {} 
the file name and location

\item {} 
its format

\item {} 
its channel count

\item {} 
its sample rate

\item {} 
its duration and timecode.

\end{itemize}

It also allows to Play the file, and the Open Folder button gives a
quick access to the place where it has been created.

The most prominent feature though, are the two generated views of the
audio file in time (waveform) and frequency (sonograph) domain, and the
loudness analysis, giving:
\begin{itemize}
\item {} 
the Peak value

\item {} 
the True Peak value (to take inter sample peaks into account)

\item {} 
the Normalization Gain (if it has been applied)

\item {} 
the Integrated Loudness

\item {} 
the loudness range

\item {} 
a graph of the multiplicity of the peaks at the different loudness
levels.

\end{itemize}


\section{Time Span}
\label{\detokenize{index:time-span}}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{export-dialog-timespan}.png}
\caption{The Time Span tab}\label{\detokenize{index:id595}}\end{figure}

This tab allows to select the range (or ranges) of the timeline to
export. By default, “session” is enabled—this will export the whole
session from the start marker to the end marker. Any loop or range
present in the session can be chosen, or a combination thereof.

The realtime checkboxes allow to export audio as it is played, and not
freewheeling to render the file as fast as Ardour can. This can prevent
odd behaviours from some plugins (reverbs, etc…). This can be chosen
globally (with the Realtime Export checkbox at the top) or individually
on a per time span basis, with the RT checkbox next to each time span.


\section{Channels}
\label{\detokenize{index:channels}}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{export-dialog-channels}.png}
\caption{The Channels tab}\label{\detokenize{index:id596}}\end{figure}

This tab decides which outputs (tracks or busses) should be sent to the
exported file. By default, only the Master Bus is sent.


\section{Stem Export}
\label{\detokenize{index:stem-export}}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{export-dialog-stem-export}.png}
\caption{Stem export}\label{\detokenize{index:id597}}\end{figure}

Stem exporting allows to transfer files between different systems and
softwares by exporting each track individually, including silence, to
keep them in sync.

If ‘Stem Export’ is chosen, the ‘Channels’ tab appears slightly
differently: in this case each chosen channel (track or bus) is exported
to its own file, instead of all channels being mixed together into a
single file.

The exported tracks or busses can, by checking Apply track/bus
processing, be exported with the effects/processors applied, so that the
destination system does not need those effects plugins.


\chapter{71.2 - Export Format Profiles}
\label{\detokenize{index:export-format-profiles}}

\section{Export Format Profiles}
\label{\detokenize{index:export-format-profiles-1}}\label{\detokenize{index:id42}}
An Export Format Profile specifies the file format in which Ardour will
export audio files, and also other audio file export options.

Export Format Profiles are edited via the Edit Export Format Profile
dialog.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{edit-export-format-profile}.png}
\caption{The ‘Edit Export Format Profile’ dialog}\label{\detokenize{index:id598}}\end{figure}


\subsection{Normalize}
\label{\detokenize{index:normalize}}
If enabled, levels of exported files will be normalized to the level
chosen here. The normalization can be either:
\begin{itemize}
\item {} 
Peak, which adjusts the gain to bring the highest signal peak to the
chosen level (in dBFS),

\item {} 
Loudness, which adjusts the gain to bring the average amplitude to
the chosen level (in LUFS), without exceeding the chosen true-peak
value (in dBTP). EBU R128 is only available for mono or stereo sounds
while true-peak works for any channel layout.

\end{itemize}


\subsection{Trim silence at start/end}
\label{\detokenize{index:trim-silence-at-start-end}}
These checkboxes allow to remove any part Ardour considers silent (0dB),
at the beginning or/and end of each exported track.


\subsection{Add silence at start/end}
\label{\detokenize{index:add-silence-at-start-end}}
These checkboxes allow to add silence at the beginning or/and end of
each exported track. The duration of the added silence can be manually
fixed in the adjacent ‘timer’ input fields.


\subsection{Compatibility/Quality/File format/Sample rate}
\label{\detokenize{index:compatibility-quality-file-format-sample-rate}}

\subsubsection{Compatibility}
\label{\detokenize{index:compatibility}}
Selecting an item in the ‘Compatibility’ emphasizes the settings in the
other columns that are compatible with the selected standard, by turning
incompatible options red. When an incompatible quality/format/sample
rate is selected, the compatibility column checkbox disappears.


\subsubsection{Quality}
\label{\detokenize{index:quality}}
The appropriate item in the ‘Quality’ column will be highlighted when a
file format is chosen. At the moment, selecting a Quality setting does
not show the compatible File formats.


\subsubsection{File format}
\label{\detokenize{index:file-format-1}}\label{\detokenize{index:id43}}
This column contains a list of Ardour’s supported export file types.
Selecting one updates the options underneath it.


\subsubsection{Sample rate}
\label{\detokenize{index:sample-rate}}
A specific sample rate can be chosen for the exported files, or the
current session’s sample rate (by choosing ‘Session rate’), without
sample rate conversion.


\subsubsection{Sample rate conversion quality}
\label{\detokenize{index:sample-rate-conversion-quality}}
In case the chosen sample rate does not match the current session’s
sample rate, the sample rate conversion quality can be chosen here.
Better quality options are slower.


\subsection{Format Options}
\label{\detokenize{index:format-options}}
Options relevant to the chosen file format will appear just under the
Compatibility/Quality/File format/Sample rate table.


\subsubsection{Tag with session’s metadata}
\label{\detokenize{index:tag-with-session-s-metadata}}
If the exported file format supports metadata (e.g. FLAC, Ogg Vorbis),
use data entered in the {\hyperref[\detokenize{index:metadata}]{\emph{Session Metadata}}} window to tag
the exported files.


\subsubsection{Sample Format and Dithering}
\label{\detokenize{index:sample-format-and-dithering}}
The Sample Format is the bit depth of exported files, i.e. the numbers
of values a sample can have. Increasing the sample format results in a
better defined audio file at the cost of increasing the file size.

If the exported files bit depth is less than Ardour’s native bit depth
(32 bits floating point by default), the dithering algorithm, that
chooses how to compute the conversion can be chosen in the Dithering
column.


\subsection{Options}
\label{\detokenize{index:options}}
These options are presented whatever the chosen format is:


\subsubsection{Create CUE/TOC/chapter mark file}
\label{\detokenize{index:create-cue-toc-chapter-mark-file}}
As well as exporting an audio file, Ardour can create a file (in CUE,
TOC or MP4ch format respectively) containing CD track information, as
defined in the {\hyperref[\detokenize{index:the-ranges-and-marks-lists}]{\emph{Ranges \& Marks List}}}.
Those files can then be used to either burn a CD or DVD, or to create
“chapters” inside a compatible mp4 video container.


\subsection{Label}
\label{\detokenize{index:label}}
The Label field allows to choose the name which will be shown for this
format in the drop-down list of export formats in the ‘File Formats’ tab
of the {\hyperref[\detokenize{index:export-dialog}]{\emph{Export dialog}}}.


\subsection{Command to run post-export}
\label{\detokenize{index:command-to-run-post-export}}
If this is not blank, it is considered as a command to be run after the
export of each file. Either the command must exist in \$PATH, or an
absolute path to an executable file can be specified here.

Certain sequences are allowed here to stand for the exported file name
and various parameters. Currently these are:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

\sphinxcode{\sphinxupquote{\%f}}
&
Full path and filename of the
exported audio file
\\
\hline
\sphinxcode{\sphinxupquote{\%d}}
&
Directory containing the exported
audio file (including trailing
directory separator)
\\
\hline
\sphinxcode{\sphinxupquote{\%b}}
&
Basename of the exported audio
file (without extension)
\\
\hline
\sphinxcode{\sphinxupquote{\%s}}
&
Path to the current session file
\\
\hline
\sphinxcode{\sphinxupquote{\%n}}
&
Name of the current session file
\\
\hline
\sphinxcode{\sphinxupquote{\%\%}}
&
A literal percent sign
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

Any part of the command-line enclosed in double-quotes (“) will be used
as-is.

For example, exporting an mp3 file can be done by inserting
\sphinxcode{\sphinxupquote{lame -b320 \%f}} which will convert the exported audio file (‘\%f’) to a
320 kbs mp3 using the lame encoder (provided lame is installed first on
the system).


\chapter{Part X - Video}
\label{\detokenize{index:part-x-video}}\label{\detokenize{index:id44}}

\chapter{72 - Video Timeline and Monitoring}
\label{\detokenize{index:video-timeline-and-monitoring}}
Ardour offers a video timeline and video monitoring for convenient audio
mixing and editing to video, in order to produce film soundtracks and
music videos, or perform TV post-production tasks.

The video capabilities are:
\begin{itemize}
\item {} 
Import a single video and optionally extract the soundtrack from it.

\item {} 
Provide a video monitor window, or full-screen display, of the
imported video in sync with any of the available Ardour timecode
sources.

\item {} 
Display a frame-by-frame (thumbnail) timeline of the video.

\item {} 
Allow for a configurable timecode offset.

\item {} 
\sphinxstyleemphasis{Lock} audio regions to the video.

\item {} 
Move audio regions with the video at video-frame granularity.

\item {} 
Export the video, trim start and end, add blank frames and/or
multiplex it with the soundtrack of the current session.

\end{itemize}

The setup of the video subsystem is modular and can be configured in
different ways, including:
\begin{itemize}
\item {} 
One machine for all video decoding, video monitoring and audio
editing tasks

\item {} 
Two machines, one for video monitoring, one for Ardour

\item {} 
Three machines, separate video server (for timeline decoding and file
archive), dedicated video monitor, and Ardour

\end{itemize}

Ardour does \sphinxstyleemphasis{not}:
\begin{itemize}
\item {} 
allow for more than one video to be loaded at a time.

\item {} 
provide video editing capabilities

\end{itemize}


\chapter{73 - Video Timeline Setup}
\label{\detokenize{index:video-timeline-setup}}
No configuration is required if everything is to meant be run on a
single machine, and the version of Ardour comes from
\sphinxurl{http://www.ardour.org}. Everything is pre-configured and included with
the download/install.


\section{Single Machine}
\label{\detokenize{index:single-machine}}
If Ardour is compiled from source, or installed from a 3rd party
repository, three additional tools will need to be installed manually,
which are used by Ardour to provide video features:
\begin{itemize}
\item {} 
xjadeo (the video monitor application):
\sphinxhref{http://xjadeo.sourceforge.net/}{http://xjadeo.sf.net}

\item {} 
harvid (a video decoder used for the thumbnail timeline):
\sphinxhref{http://x42.github.io/harvid/}{http://x42.github.com/harvid/}

\item {} 
ffmpeg, ffprobe (used to import/export video, extract soundtracks and
query video information): \sphinxurl{http://ffmpeg.org}

\end{itemize}

Ardour requires xjadeo ≥ version 0.6.4, harvid ≥ version 0.7.0 and
ffmpeg (known to work versions: 1.2, 2.8.2)

The Ardour development team is in control of the first two applications.
ffmpeg however can be a bit of a problem. To avoid conflicts with
distribution packages, Ardour looks for \sphinxcode{\sphinxupquote{ffmpeg\_harvid}} and
\sphinxcode{\sphinxupquote{ffprobe\_harvid}}.

All four applications need to be found in \sphinxcode{\sphinxupquote{\$PATH}} (e.g. \sphinxcode{\sphinxupquote{\$HOME/bin}}
or \sphinxcode{\sphinxupquote{/usr/local/bin}}). For convenience the binary releases of harvid
include ffmpeg\_harvid and ffprobe\_harvid, but if the distribution
provides suitable ffmpeg commands, symbolic links can be created to the
distribution-provided binaries:

sudo ln -s /usr/bin/ffmpeg /usr/bin/ffmpeg\_harvid sudo ln -s
/usr/bin/ffprobe /usr/bin/ffprobe\_harvid

Binary releases are available from ardour.org as well as an installer
script:
\sphinxhref{https://github.com/Ardour/ardour/blob/master/tools/videotimeline/install\_video\_tools.sh}{install\_video\_tools.sh}.

The easiest way to install the video-utilities is by running the
following line in a terminal:

sh -c “\$(curl -s -L \sphinxurl{http://git.io/tVUCkw})”


\section{Studio Setup}
\label{\detokenize{index:studio-setup}}
As Setting up a proper A/V post-production studio can be a complicated
task, it is advised to read the info in the previous section to get
familiar with the tools involved first. As much as the Ardour team
streamlines and simplifies the \sphinxstyleemphasis{single machine} setup, the studio setup
is focused on modularity.
\begin{itemize}
\item {} 
TODO:

\item {} 
Synchronization ardour \(\rightarrow\) video-display-box should be accomplished by
external means. Jack-transport(netjack), MTC, LTC (OSC and/or
ssh-pipe work but introduce additional latency + jitter)

\item {} 
Ardour launches \sphinxcode{\sphinxupquote{XJREMOTE}} (environment variable, default
‘xjremote’ which comes with xjadeo).

\item {} 
Either use a custom shell script that ssh’es into the remote box and
launches/controls xjadeo there, selects the sync-source and passes
though communication between ardour ⇔ xjadeo via ssh (xjadeo is
launched stopped with the session).

\item {} 
…or override xjremote’s behavior—instead of IPC with a local running
xjadeo-process, using OSC for example. Xjadeo would run permanently
and Ardour will just tell it to load files and set offsets via OSC.
See
\sphinxhref{http://xjadeo.git.sourceforge.net/git/gitweb.cgi?p=xjadeo/xjadeo;a=blob\_plain;f=contrib/xjremote-osc}{xjremote-osc}
example script.

\item {} 
If the video server runs remotely, Ardour needs to be configured in
Ardour \textgreater{} Preference \textgreater{} Video (hostname of the video-server).

\item {} 
Ideally the machines have a common shared folder (NFS or similar).
Ardour’s import (audio-extract) and export (mux) functionality
depends on having access to the video file. Also Ardour’s
video-import transcodes the file into a suitable proxy-format that
allows reliable seeking to any frame…

\end{itemize}


\chapter{74 - Transcoding, Formats \& Codecs}
\label{\detokenize{index:transcoding-formats-codecs}}\label{\detokenize{index:transcoding-formats-amp-codecs}}
This chapter provides a short primer on video files, formats and codecs
\textendash{} because it is often cause for confusion:

A video file is a container. It usually contains one video track, one or
more audio tracks, and possibly subtitle tracks, chapters… The way these
tracks are stored in the file is defined by the file format. Common
formats are avi, mov, ogg, mkv, mpeg, mpeg-ts, mp4, flv, or vob.

Each of the tracks by itself is encoded using a Codec. Common video
codecs are h264, mpeg2, mpeg4, theora, mjpeg, wmv3. Common audio codecs
are mp2, mp3, dts, aac, wav/pcm.

Not all codecs can be packed into a given format. For example the mpeg
format is limited to mpeg2, mpeg4 and mp3 codecs (not entirely true).
DVDs do have stringent limitations as well. The opposite would be .avi:
pretty much every audio/video codec combination can be contained in an
avi file-format.

To make things worse, naming conventions for video codecs and formats
are often identical (especially MPEG ones) which leads to confusion. All
in all it is a very wide and deep field. Suffice there are different
uses for different codecs and formats.


\section{Ardour specific issues}
\label{\detokenize{index:ardour-specific-issues}}
Ardour supports a wide variety of video file formats codecs. More
specifically, Ardour itself actually does not support any video at all
but delegates handling of video files to
\sphinxhref{http://ffmpeg.org/}{ffmpeg}, which supports over 350 different video
codecs and more than 250 file formats.

When importing a video into Ardour, it will be transcoded (changed from
one format and codec to another) to avi/mjpeg for internal use (this
allows reliable seeking to frames at low CPU cost—the file size will
increase, but hard disks are large and fast).

The export dialog includes presets for common format and codec
combinations (such as DVD, web-video,..). If in doubt, one of the
presets should be used.

As a last note: every time a video is transcoded, the quality can only
get worse. Hence for the final mastering/muxing process, one should
always go back and use the original source of the video.


\chapter{75 - Workflow \& Operations}
\label{\detokenize{index:workflow-operations}}\label{\detokenize{index:workflow-amp-operations}}

\section{Overview of Operations}
\label{\detokenize{index:overview-of-operations}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

Session \textgreater{} Open Video…
&
Add/replace a video to/on the
timeline
\\
\hline
Window \textgreater{} Video Monitor
&
Open/close external video monitor
window
\\
\hline
View \textgreater{} Video Monitor \textgreater{} …
&
Various settings of the video
monitor
\\
\hline
Session \textgreater{} Export \textgreater{} Export to
Video File…
&
Export session and multiplex with
video-file
\\
\hline
Left-drag the video in the
timeline
&
Re-align video and move ‘locked’
audio-regions along
\\
\hline
Context-menu on the
video-timeline: Lock
&
Prevent accidental drags
\\
\hline
Audio region context menu:
\sphinxstyleemphasis{Name\_Of\_The\_Region} \textgreater{} Position \textgreater{}
Lock to video
&
Mark audio region(s) to be moved
along with the video.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\section{Adding a video}
\label{\detokenize{index:adding-a-video}}
Adding a video is a two-step process: selecting a video file, and
choosing import mode and optionally selecting an audio track to extract.
Only one video can be present in the session, so opening a video when
one is already opened results in replacing the video.


\subsection{Launching the video server (optionnal)}
\label{\detokenize{index:launching-the-video-server-optionnal}}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{launch_video_server}.png}
\caption{The Launch Video Server dialog}\label{\detokenize{index:id599}}\end{figure}

Importing a video makes Ardour start the video server automatically. If
the Show video Server Startup Dialog option in the Video section of the
{\hyperref[\detokenize{index:preferences}]{\emph{preferences}}} is checked, the Launch Video Server
window is shown, allowing more complex operations, e.g. connecting to a
remote video server instead of a local one.


\subsection{Selecting a file}
\label{\detokenize{index:selecting-a-file}}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{set_video_track}.png}
\caption{The video open dialog}\label{\detokenize{index:id600}}\end{figure}

This step is rather straight-forward. The panel on the right side allows
to seek through the video and displays basic file information. It is
also useful to check if the video format/codec is supported.

The lower part of the window shows some options:
\begin{itemize}
\item {} 
Open Video Monitor Window to automatically show the video monitor
(Harvid). This can also be done later by using the Window \textgreater{} Video
Monitor menu which is binded to V by default.

\item {} 
Adjust Session Framerate to Match Video Framerate which can also be
set later with the {\hyperref[\detokenize{index:session-properties-dialog}]{\emph{Session
Properties}}}. Having the session and
video framerate at the same value allows their sync not to drift off.

\end{itemize}


\subsection{Import options}
\label{\detokenize{index:import-options}}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{transcode-import_video_file}.png}
\caption{The Transcode/Import Video dialog}\label{\detokenize{index:id601}}\end{figure}

This step analyzes the video file in more detail and offers import
options:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

Import/Transcode Video to Session
&
This is the default. The video
will be imported in a suitable
video format/codec for the
timeline and video monitor and
saved inside the session folder.
A location other than the session
folder can also be chosen
(external disk, or network
storage of the video server on a
different machine) by using the
Output File: field.
\\
\hline
Reference from Current Location
(Previously Transcoded Files
Only)
&
Only useful for opening files
that were previously encoded (are
already in a good format/codec
for Ardour). Should be used with
care.
\\
\hline
Do not Import Video (Audio Import
Only)
&
Useful for extracting audio only.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

By default the video is imported using the original width/height. If it
is a large video (e.g. full-HD), it makes sense to scale it down to
decrease the CPU load and disk I/O required to decode and play the file.

A small, low-quality representation of the image is usually sufficient
for editing soundtracks. The default bitrate in kbit/sec is set to use
0.7 bits per pixel (in comparison, the average DVD medium uses
5000 kbit/s; at PAL resolution this is about 0.5 bits per pixel, but the
DVD is using the mpeg2—a denser compression algorithm than the mjpeg
codec used by Ardour).

The Extract Audio: offers options regarding the Audio part of the
stream, allowing to either not extract audio, or to choose which audio
stream to add to the session.

When extracting any audio, if it includes {\hyperref[\detokenize{index:timecode-generators-and-slaves}]{\emph{LTC
timecodes}}}, those can be extracted
and used to sync the video by checking the option below.


\section{Working with A/V}
\label{\detokenize{index:working-with-a-v}}
Working with A/V in Ardour is similar to working in a pure audio setup,
except for the presence of a video timeline in the {\hyperref[\detokenize{index:ruler}]{\emph{ruler}}}
zone, and a Xjadeo video window, showing a preview of the result.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{video_timeline}.png}
\caption{The Video Timeline}\label{\detokenize{index:id602}}\end{figure}

The Xjadeo window supports some user interactions, such as showing some
OSD information or changing the zoom level. Xjadeo’s documentation is
available on its
\sphinxhref{http://xjadeo.sourceforge.net/xjadeo.html\#heading8}{website}.


\section{Exporting Video}
\label{\detokenize{index:exporting-video}}\label{\detokenize{index:export}}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{export_video_file}.png}
\caption{The Video Export Dialog}\label{\detokenize{index:id603}}\end{figure}

The video export will take audio from the current Ardour session and
multiplex it with a video file. The soundtrack of the video is taken
from an audio export of Ardour’s master bus.

An arbitrary video file can be chosen. For high quality exports, the
original file (before it was imported into the timeline) should be used.
This is the default behaviour if that file can be found. If not, Ardour
will fall back to the imported proxy-video which is currently in use on
the timeline. Any existing audio tracks on this video file are stripped.

The range selection allows to cut or extend the video. If the session is
longer than the video duration, black frames are prefixed or appended to
the video. (Note: this process may fail with non-standard pixel aspect
ratios). If Ardour’s session range is shorter, the video will be cut
accordingly.

Audio sample-rate and normalization are options for Ardour’s audio
exporter. The remaining settings are options that are directly passed on
to ffmpeg.

The file format is determined by the extension chosen for it (.avi,
.mov, .flv, .ogv, .webm,…). Note: not all combinations of format, codec,
and settings produce files which are according to specifications. For
example, flv files require sample rates of 22.1 kHz or 44.1 kHz, mpeg
containers can not be used with ac3 audio-codec, etc. If in doubt, one
of the built-in presets should be used.

Ardour video export is not recommended for mastering! While ffmpeg
(which is used by Ardour) can produce high-quality files, this export
lacks the possibility to tweak many settings. We recommend using
\sphinxhref{http://www.biggmatt.com/winff/}{winff},
\sphinxhref{http://www.rastersoft.com/programas/devede.html}{devede} or
\sphinxhref{http://dvdauthor.sourceforge.net/}{dvdauthor} to mux and master.
Nevertheless this video-export comes in handy to do quick snapshots,
intermediates, dailies or online videos.


\chapter{Part XI - Control Surfaces}
\label{\detokenize{index:part-xi-control-surfaces}}\label{\detokenize{index:id45}}

\chapter{76 - Controlling Ardour with OSC}
\label{\detokenize{index:controlling-ardour-with-osc}}
OSC lets synthesizers and other devices communicate with Ardour. OSC
devices can send commands relating to playback (such as play or stop),
performance (such as volume, play, stop, and almost any other function
(such as Edit, or Undo).


\chapter{76.1 - OSC: Controlling Ardour with OSC}
\label{\detokenize{index:osc-controlling-ardour-with-osc}}\label{\detokenize{index:osc58-controlling-ardour-with-osc}}
OSC lets synthesizers and other devices communicate with Ardour. OSC
devices can send commands relating to playback (such as play or stop),
performance (such as volume, play, stop, and almost any other function
(such as Edit, or Undo).

\sphinxstyleemphasis{Note:} OSC control has changed dramatically since Ardour 4.7. The Path
structure has been completely redone, Banking has been introduced, The
controller is now able to tell Ardour what kind of feedback it can work
with (including bank size) and two new math styles have been added to
gain controls. If you are using an Ardour version of 4.7 or less, please
read {\hyperref[\detokenize{index:osc-control-for-ardour-4.7-and-prior}]{\emph{Osc control in Ardour 4.7 and
prior.}}}

Ardour is probably one of the most OSC-controllable audio applications
around, but as with all OSC-controllable apps, you can’t do much without
knowing what messages can be sent. This document describes the various
categories of messages that Ardour understands. It is subject to change,
particularly the “Actions” part below, since this relates to the GTK GUI
for Ardour rather than the backend.


\section{Connecting to Ardour via OSC}
\label{\detokenize{index:connecting-to-ardour-via-osc}}
OSC support is not enabled by default, but can be turned on via Edit \textgreater{}
Preferences \textgreater{} Control Surfaces. Once enabled, Ardour will listen on port
\sphinxcode{\sphinxupquote{3819}} by default. This port number can be changed by editing
\sphinxcode{\sphinxupquote{\$ARDOUR\_CONFIG}} and adding this line within the \sphinxcode{\sphinxupquote{\textless{}Config\textgreater{}}} section:

\textless{}Option name=”osc-port” value=”\sphinxstyleemphasis{Your choice here}”/\textgreater{}

Ardour sends any feedback to the port and address that sent any feedback
request. The port does not have to match Ardour’s port. In fact it is
better not to. This means that Ardour can deal with more than one
controller at a time. The two controllers can bank independently and
even use different math for faders. This could be used to allow talent
to adjust their own monitor mix using a tablet or phone that can run an
OSC controller. For a full explanation of how Ardour’s feedback works
please read {\hyperref[\detokenize{index:osc58-feedback}]{\emph{OSC feedback In Ardour.}}}


\section{Control Surface Set Up}
\label{\detokenize{index:control-surface-set-up}}
Control surface set up allows the controller to tell Ardour about its
capabilities. The surface can tell Ardour how many control strips it has
for banking, if it is capable of setting its faders or buttons to values
set by Ardour’s GUI or automation, What kind of math the faders use and
more.

Any time the \sphinxstyleemphasis{/set\_surface} command is sent, the current bank is
recalculated and if feedback is turned on, the values of each strip’s
controls are sent (or refreshed) as well. This will also refresh the
Master feedback setup.

Surface Port Setting is available in the OSC GUI.

As of Ardour 5.1, There is now a GUI setup in response to those using
tablets with applications such as touchOSC or AndrOSC who need to be
able to set a port for Ardour to send to. It can also change the default
setting for set\_surface. For more information about Ardour’s OSC
configuration GUI please read {\hyperref[\detokenize{index:osc58-using-the-setup-dialog}]{\emph{Ardour’s Setup
Dialog.}}}

If /set\_surface is not sent, the default values are used:
\begin{itemize}
\item {} 
\sphinxstyleemphasis{Bank Size}: 0— No banking (or infinite bank size).

\item {} 
\sphinxstyleemphasis{Strip Types}: 0— All strip types except hidden and special.

\item {} 
\sphinxstyleemphasis{Feedback}: 0— All off.

\item {} 
\sphinxstyleemphasis{Fader Mode}: 0— gain in dB (not relevant with feedback off)

\item {} 
\sphinxstyleemphasis{Send Page Size}: 0— No Send Paging.

\item {} 
\sphinxstyleemphasis{Plugin Page Size}: 0— No Plugin Paging.

\end{itemize}

These values give the same behaviour as prior versions of Ardour. (or
the closest possible)


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

/set\_surface \sphinxstyleemphasis{bank\_size}
\sphinxstyleemphasis{strip\_types} \sphinxstyleemphasis{feedback}
\sphinxstyleemphasis{fadermode} \sphinxstyleemphasis{send\_page\_size}
\sphinxstyleemphasis{plugin\_page\_size}
&
See below for an explanation of
each parameter.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

The /set\_surface message may have all values except the last in-line.
For example: \sphinxcode{\sphinxupquote{/set\_surface/8/31/8403/0/8 i 16}} would be valid. Do be
careful of switches which send a 0 on release, it may be necessary to
set the value as the release value rather than the press value.

The /set\_surface message may have less than the full set of parameters.
those left out will remain as they were before the /set\_surface message
was sent. All parameters included must be valid. For example, setting
send page size would require also setting bank\_size, strip\_types,
feedback and gain mode. using only two parameters will set bank\_size and
strip\_types. Sending /set\_surface with no parameters will result in
Ardour returning a /set\_surface message with the current settings.
Surfaces using /set\_surface iiii b st fb gm as was the case in versions
of Ardour older than 5.10 will continue to work.


\subsection{bank\_size}
\label{\detokenize{index:bank-size}}
Bank Size is the number of channel strips the controller supports
without banking. Setting this to 0 turns banking off by setting the bank
size to infinite.

Bank size can also be set with \sphinxstyleemphasis{/set\_surface/bank\_size size.}


\subsection{strip\_types}
\label{\detokenize{index:strip-types}}
strip\_types is an integer made up of bits. The easy way to deal with
this is to think of strip\_types items being worth a number and then
adding all those numbers together for a value to send. Strip Types will
determine what kind of strips will be included in bank. This would
include: Audio, MIDI, busses, VCAs, Master, Monitor and hidden or
selected strips.

Aside from setting the track types for the main mix assignments, using
/set\_surface/strip\_types with more than one surface button will allow
switching between modes for example: inputs only, busses only, selected
only, hidden only, by having the buttons send values of: 3, 12, 256,
512. A full mix button might have a value 31.

While Master and Monitor are listed as possibilities, most surfaces will
not use them. Using /master and /monitor makes more sense. However, in
the case where there are no master or monitor fader strips on the
surface, it may be necessary to include them in the banked strips.

Please see: {\hyperref[\detokenize{index:osc58-feedback-and-strip-types-values}]{\emph{Calculating Feedback and Strip-types
Values.}}}

Strip types can also be set with \sphinxstyleemphasis{/set\_surface/strip\_types types.}


\subsection{feedback}
\label{\detokenize{index:feedback}}
Feedback is an integer made up of bits. The easy way to deal with this
is to think of feedback items being worth a number and then adding all
those numbers together for a value to send.

Please see: {\hyperref[\detokenize{index:osc58-feedback-and-strip-types-values}]{\emph{Calculating Feedback and Strip-types
Values.}}}

Feedback can also be set with \sphinxstyleemphasis{/set\_surface/feedback feedback.}


\subsection{gainmode}
\label{\detokenize{index:gainmode}}
Gainmode is a an int that acts as a bool:
\begin{itemize}
\item {} 
\sphinxstyleemphasis{0 (or false)} dB value as a float from -193 to +6. Sent as
/strip/gain SSID value. (-193 or below are the same as -inf)

\item {} 
\sphinxstyleemphasis{1 (or true)} A positional fader based on the same math as Ardour’s
GUI. An Float from 0 to 1. Sent as /strip/fader SSID value

\end{itemize}

Gainmode applies only to feedback values. The controller can choose
which gain math to use by choosing to use the /\sphinxstyleemphasis{/gain or /}/fader path
to send to Ardour. This makes sure a controller that doesn’t set up
Ardour’s OSC can still use either math. The gainmode for feedback also
determines the path Ardour uses for feedback so that the feedback
messages match the control messages.

Gain mode can also be set with \sphinxstyleemphasis{/set\_surface/gainmode gainmode.}


\subsection{send\_page\_size}
\label{\detokenize{index:send-page-size}}
Send\_page\_size is an int for the number of send channels that can be
controlled at one time. Each channel has a name, level and enable
control. (added in Ardour 5.10)

Send page size can also be set with \sphinxstyleemphasis{/set\_surface/send\_page\_size
send\_page\_size.}


\subsection{plugin\_page\_size}
\label{\detokenize{index:plugin-page-size}}
plugin\_page\_size is an int for the number of plugin controls that can be
controlled at one time. Each control has a name and level. As each
plugin is different (as is each parameter), the surface should expect to
control the plugin parameters with a variable control (pot or slider)
with a float value from 0 to 1 (even on/off switches). (added in Ardour
5.10)

Plugin page size can also be set with \sphinxstyleemphasis{/set\_surface/plugin\_page\_size
plugin\_page\_size.}


\section{Querying Ardour for information}
\label{\detokenize{index:querying-ardour-for-information}}
The control Surface may wish to control the type a frequency of updates
it receives. It can do this with querying commands. See: {\hyperref[\detokenize{index:osc58-querying-ardour}]{\emph{Querying
Ardour with OSC.}}}


\section{List of OSC messages}
\label{\detokenize{index:list-of-osc-messages}}
Parameter types show how the value will be used. However, they may be
sent as a different type if needed, see: {\hyperref[\detokenize{index:osc58-parameter-types}]{\emph{Parameter Types in
OSC.}}}


\subsection{Master or Global messages}
\label{\detokenize{index:master-or-global-messages}}

\subsubsection{Transport Control}
\label{\detokenize{index:transport-control}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

/transport\_stop
&
Stops a rolling transport
\\
\hline
/transport\_play
&
Puts transport in play mode
\\
\hline
/toggle\_roll
&
Toggles between play and stop
\\
\hline
/stop\_forget
&
Stop transport and delete/forget
last take
\\
\hline
/set\_transport\_speed \sphinxstyleemphasis{speed}
&
where \sphinxstyleemphasis{speed} is a float ranging
from -8.0f to 8.0f
\\
\hline
/ffwd
&
Adds 1.5 times to transport speed
to maximum +8 times normal speed
\\
\hline
/rewind
&
Adds -1.5 times to transport
speed to maximum -8 times normal
speed
\\
\hline
/goto\_start
&
Move playhead to start of session
\\
\hline
/goto\_end
&
Move playhead to end of session
\\
\hline
/jump\_bars \sphinxstyleemphasis{bars}
&
Where \sphinxstyleemphasis{bars} is a float (+/-) of
the number of bars to jump
\\
\hline
/jump\_seconds \sphinxstyleemphasis{seconds}
&
Where \sphinxstyleemphasis{seconds} is a float (+/-)
of the number of seconds to jump
\\
\hline
/toggle\_click
&
Toggle metronome click on and off
\\
\hline
/add\_marker
&
(adds marker to the current
transport position)
\\
\hline
/remove\_marker
&
Removes marker at the current
transport position (if there is
one)
\\
\hline
/next\_marker
&
Move playhead to next marker
\\
\hline
/prev\_marker
&
Move playhead to previous marker
\\
\hline
/locate \sphinxstyleemphasis{spos} \sphinxstyleemphasis{roll}
&
where \sphinxstyleemphasis{spos} is the target
position in samples and \sphinxstyleemphasis{roll} is
a bool/integer defining whether
you want transport to be kept
rolling or not
\\
\hline
/loop\_toggle
&
Toggle loop mode on and off
\\
\hline
/loop\_location \sphinxstyleemphasis{start} \sphinxstyleemphasis{end}
&
\sphinxstyleemphasis{start} is the beginning of a
loop and \sphinxstyleemphasis{end} is the end of a
loop both are integer frame
positions.
\\
\hline
/midi\_panic
&
Ardour will send an all notes off
to all midi tracks
\\
\hline
/cancel\_all\_solos
&
Cancel All Solos/PFLs/AFLs
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

New for Ardour 5.9.

/scrub \sphinxstyleemphasis{delta}

Where \sphinxstyleemphasis{delta} is a float indicating forward or reverse movement. See
{\hyperref[\detokenize{index:osc58-jog-modes}]{\emph{OSC Scrub Modes}}}

/jog \sphinxstyleemphasis{delta}

Where \sphinxstyleemphasis{delta} is a float indicating forward or reverse movement

/jog/mode \sphinxstyleemphasis{mode}

Where \sphinxstyleemphasis{mode} is an int from 0 to 7 indicating what the \sphinxstyleemphasis{/jog} command
controls. See {\hyperref[\detokenize{index:osc58-jog-modes}]{\emph{OSC Jog Modes}}}


\subsubsection{Recording control}
\label{\detokenize{index:recording-control}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

/toggle\_punch\_in
&\\
\hline
/toggle\_punch\_out
&\\
\hline
/rec\_enable\_toggle
&
Toggles master record enable
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsubsection{Transport Information}
\label{\detokenize{index:transport-information}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

/transport\_frame
&
Ardour sends /transport\_frame \sphinxstyleemphasis{current\_frame}
\\
\hline
/transport\_speed
&
Ardour sends /transport\_speed \sphinxstyleemphasis{speed}
\\
\hline
/record\_enabled
&
Ardour sends /record\_enabled \sphinxstyleemphasis{recordenable\_status}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsubsection{Editing-related}
\label{\detokenize{index:editing-related}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

/undo
&\\
\hline
/redo
&\\
\hline
/save\_state
&
(this is the regular Session \textgreater{} Save operation)
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsubsection{Master and Monitor strip control}
\label{\detokenize{index:master-and-monitor-strip-control}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

/master/gain \sphinxstyleemphasis{dB}
&
dB is a float indicating the
desired gain in dB
\\
\hline
/master/fader \sphinxstyleemphasis{position}
&
position is a float between 0 and
1 setting the desired position of
the fader
\\
\hline
/master/db\_delta \sphinxstyleemphasis{delta}
&
where \sphinxstyleemphasis{delta} is a float that
will increase or decrease the
gain of master by the amount of
the delta. (Ardour 5.11+)
\\
\hline
/master/trimdB \sphinxstyleemphasis{dB}
&
dB is a float from -20 to +20
representing the desired trim
gain in dB
\\
\hline
/master/pan\_stereo\_position
\sphinxstyleemphasis{position}
&
position is a float from 0 to 1
representing the desired pan
position
\\
\hline
/master/mute \sphinxstyleemphasis{key}
&
key is an optional float 1
representing a master bus select
\\
\hline
/master/select \sphinxstyleemphasis{state}
&
state is an int of o or 1
representing the desired mute
state
\\
\hline
/monitor/gain \sphinxstyleemphasis{dB}
&
dB is a float indicating the
desired gain in dB
\\
\hline
/monitor/fader \sphinxstyleemphasis{position}
&
position is a float between 0 and
1 setting the desired position of
the fader
\\
\hline
/monitor/db\_delta \sphinxstyleemphasis{delta}
&
where \sphinxstyleemphasis{delta} is a float that
will increase or decrease the
gain of monitor by the amount of
the delta. (Ardour 5.11+)
\\
\hline
/monitor/mute \sphinxstyleemphasis{state}
&
state is an int of 0 or 1 where 1
is muted
\\
\hline
/monitor/dim \sphinxstyleemphasis{state}
&
state is an int of 0 or 1 where 1
is dimmed
\\
\hline
/monitor/mono \sphinxstyleemphasis{state}
&
state is an int of 0 or 1 where 1
is mono mode
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsection{Track specific operations}
\label{\detokenize{index:track-specific-operations}}
For each of the following, \sphinxstyleemphasis{ssid} is the Surface Strip ID for the track

SSID has a different meaning than RID in Ardour version 4.7 and before.
Effectively, banking is always being used and the SSID is generated on
the fly. The SSID is the position of the strip within bank as an int 1
to bank size. There are no gaps as there have been in the past.
Depending on the value of strip\_types sent to Ardour, Master and
Monitor, may be included in the list of SSIDs or not as set in
\sphinxstyleemphasis{/set\_surface}.

Some Surfaces (many Android applets) are not able to deal with more than
one parameter in a command. However, the two parameter commands below
can also be sent as /strip/command/ssid param. In this case the param
should be a float even if an int is required below.


\begin{savenotes}\sphinxatlongtablestart\begin{longtable}{|l|l|}
\hline

\endfirsthead

\multicolumn{2}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} -- continued from previous page}}}\\
\hline

\endhead

\hline
\multicolumn{2}{r}{\makebox[0pt][r]{\sphinxtablecontinued{Continued on next page}}}\\
\endfoot

\endlastfoot

/bank\_up
&
Change bank to the next higher
bank.
\\
\hline
/bank\_up \sphinxstyleemphasis{delta}
&
Where \sphinxstyleemphasis{delta} is a float of 1 to
bank up and -1 is bank down for
use with an encoder (Ardour
5.11+)
\\
\hline
/bank\_down
&
Change bank to the next lower
bank.
\\
\hline
/use\_group \sphinxstyleemphasis{state}
&
Where \sphinxstyleemphasis{state} is a float of 1 to
use group or 0 to not use group.
{\hyperref[\detokenize{index:osc58-feedback-and-strip-types-values}]{\emph{more info on
use\_group}}}
\\
\hline
/strip/mute \sphinxstyleemphasis{ssid} \sphinxstyleemphasis{mute\_st}
&
where \sphinxstyleemphasis{mute\_st} is a bool/int
representing the desired mute
state of the track
\\
\hline
/strip/solo \sphinxstyleemphasis{ssid} \sphinxstyleemphasis{solo\_st}
&
where \sphinxstyleemphasis{solo\_st} is a bool/int
representing the desired solo
state of the track
\\
\hline
/strip/solo\_iso \sphinxstyleemphasis{ssid} \sphinxstyleemphasis{state}
&
where \sphinxstyleemphasis{state} is a bool/int
representing the desired solo
isolate state of the track
\\
\hline
/strip/solo\_safe \sphinxstyleemphasis{ssid} \sphinxstyleemphasis{state}
&
where \sphinxstyleemphasis{state} is a bool/int
representing the desired solo
safe/lock state of the track
\\
\hline
/strip/monitor\_input \sphinxstyleemphasis{ssid}
\sphinxstyleemphasis{monitor\_st}
&
where \sphinxstyleemphasis{monitor\_st} is a bool/int
where 1 is forced input
monitoring.
\\
\hline
/strip/monitor\_disk \sphinxstyleemphasis{ssid}
\sphinxstyleemphasis{monitor\_st}
&
where \sphinxstyleemphasis{monitor\_st} is a bool/int
where 1 is forced disk
monitoring. When input and disk
are both off, Auto monitoring is
enabled.
\\
\hline
/strip/recenable \sphinxstyleemphasis{ssid} \sphinxstyleemphasis{rec\_st}
&
where \sphinxstyleemphasis{rec\_st} is a bool/int
representing the desired rec
state of the track
\\
\hline
/strip/record\_safe \sphinxstyleemphasis{ssid}
\sphinxstyleemphasis{rec\_st}
&
where \sphinxstyleemphasis{rec\_st} is a bool/int
representing the desired record
safe state of the track
\\
\hline
/strip/polarity \sphinxstyleemphasis{ssid} \sphinxstyleemphasis{invert}
&
where \sphinxstyleemphasis{invert} is a bool/int
representing the desired polarity
of the track
\\
\hline
/strip/gain \sphinxstyleemphasis{ssid} \sphinxstyleemphasis{gain}
&
where \sphinxstyleemphasis{gain} is a float ranging
from -193 to 6 representing the
desired gain of the track in dB.
\\
\hline
/strip/fader \sphinxstyleemphasis{ssid} \sphinxstyleemphasis{position}
&
where \sphinxstyleemphasis{position} is a float
ranging from 0 to 1 representing
the fader control position.
\\
\hline
/strip/db\_delta \sphinxstyleemphasis{ssid} \sphinxstyleemphasis{delta}
&
where \sphinxstyleemphasis{delta} is a float that
will increase or decrease the
gain of a track by the amount of
the delta. (Ardour 5.11+)
\\
\hline
/strip/\sphinxstyleemphasis{/automation *ssid} \sphinxstyleemphasis{mode}
&
where \sphinxstyleemphasis{mode} is an int ranging
from 0 to 3 representing the
desired automation mode for the
control. {\hyperref[\detokenize{index:osc58-automation}]{\emph{See OSC
Automation.}}}
\_
\\
\hline
/strip/\sphinxstyleemphasis{/touch *ssid} \sphinxstyleemphasis{state}
&
where \sphinxstyleemphasis{state} is an int of 1 for
touched and 0 for released. {\hyperref[\detokenize{index:osc58-automation}]{\emph{See
OSC
Automation.}}}
\_
\\
\hline
/strip/trimdB \sphinxstyleemphasis{ssid} \sphinxstyleemphasis{trim\_db}
&
where \sphinxstyleemphasis{trim\_db} is a float
ranging from -20 to 20
representing the desired trim of
the track in dB.
\\
\hline
/strip/pan\_stereo\_position \sphinxstyleemphasis{ssid}
\sphinxstyleemphasis{position}
&
where \sphinxstyleemphasis{position} is a float
ranging from 0 to 1 representing
the desired pan position of the
track
\\
\hline
/strip/pan\_stereo\_width \sphinxstyleemphasis{ssid}
\sphinxstyleemphasis{width}
&
where \sphinxstyleemphasis{width} is a float ranging
from 0 to 1 representing the
desired pan width of the track
\\
\hline
/strip/send/gain \sphinxstyleemphasis{ssid} \sphinxstyleemphasis{sendid}
\sphinxstyleemphasis{send\_gain}
&
where \sphinxstyleemphasis{sendid} = nth\_send,
\sphinxstyleemphasis{send\_gain} is a float ranging
from -193 to +6 representing the
desired gain in dB for the send
\\
\hline
/strip/send/fader \sphinxstyleemphasis{ssid} \sphinxstyleemphasis{sendid}
\sphinxstyleemphasis{send\_gain}
&
where \sphinxstyleemphasis{sendid} = nth\_send,
\sphinxstyleemphasis{send\_gain} is a float ranging
from 0 to 1 representing the
desired position for the send as
a fader
\\
\hline
/strip/send/enable \sphinxstyleemphasis{ssid}
\sphinxstyleemphasis{sendid} \sphinxstyleemphasis{state}
&
where \sphinxstyleemphasis{sendid} = nth\_send,
\sphinxstyleemphasis{state} is 1 for enabled and 0
for disabled
\\
\hline
/strip/list
&
see: {\hyperref[\detokenize{index:osc58-querying-ardour}]{\emph{Querying Ardour with
OSC.}}}
\\
\hline
/strip/sends \sphinxstyleemphasis{ssid}
&
see: {\hyperref[\detokenize{index:osc58-querying-ardour}]{\emph{Querying Ardour with
OSC.}}}
\\
\hline
/strip/receives \sphinxstyleemphasis{ssid}
&
see: {\hyperref[\detokenize{index:osc58-querying-ardour}]{\emph{Querying Ardour with
OSC.}}}
\\
\hline
/strip/plugin/list \sphinxstyleemphasis{ssid}
&
see: {\hyperref[\detokenize{index:osc58-querying-ardour}]{\emph{Querying Ardour with
OSC.}}}
\\
\hline
/strip/plugin/descriptor \sphinxstyleemphasis{ssid}
&
see: {\hyperref[\detokenize{index:osc58-querying-ardour}]{\emph{Querying Ardour with
OSC.}}}
\\
\hline
/strip/plugin/reset \sphinxstyleemphasis{ssid} \sphinxstyleemphasis{piid}
&
where \sphinxstyleemphasis{piid} = nth Plugin, will
reset all values to the plugin’s
original values
\\
\hline
/strip/plugin/activate \sphinxstyleemphasis{ssid}
\sphinxstyleemphasis{piid}
&
where \sphinxstyleemphasis{piid} = nth Plugin, will
set the plugin’s state to active
\\
\hline
/strip/plugin/deactivate \sphinxstyleemphasis{ssid}
\sphinxstyleemphasis{piid}
&
where \sphinxstyleemphasis{piid} = nth Plugin, will
set the plugin’s state to
inactive
\\
\hline
/strip/plugin/parameter \sphinxstyleemphasis{ssid}
\sphinxstyleemphasis{piid} \sphinxstyleemphasis{param} \sphinxstyleemphasis{value}
&
where \sphinxstyleemphasis{piid} = nth Plugin,
\sphinxstyleemphasis{param} = nth param, \sphinxstyleemphasis{value} is a
float ranging from 0 to 1
representing the desired
parameter value
\\
\hline
/strip/name \sphinxstyleemphasis{ssid} \sphinxstyleemphasis{name}
&
where \sphinxstyleemphasis{name} is a string for the
desired name of the track
\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}


\subsection{Selected Strip Operations}
\label{\detokenize{index:selected-strip-operations}}
New for Ardour 5, A whole set of operations that work on the selected or
expanded strip.

Selected strip operations are complex enough for their own page. Please
read: {\hyperref[\detokenize{index:osc58-selection-and-expansion-considerations}]{\emph{Selection Considerations in
OSC.}}} This is most
important if more than one OSC surface is being used with Ardour.

There are two kinds of selection in OSC. GUI selection and local
expansion. By default expansion follows selection.
\begin{itemize}
\item {} 
GUI selection: Use \sphinxstyleemphasis{/strip/select} to set. Selecting a strip in the
GUI will set OSC surface select and the surface will set GUI
selection as well.

\item {} 
Local expansion: Use \sphinxstyleemphasis{/strip/expand} to expand a strip without
changing overall selection. When /strip/expand is set to 0 or false,
the select channel will go back to using the strip selected by the
GUI. While expand is turned on, selecting a strip on the GUI does not
select the OSC strip. Sending a /strip/select message will override
the expand as if it had been set to false. Good for more than one OSC
controller at a time.

\end{itemize}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

/strip/select \sphinxstyleemphasis{ssid} \sphinxstyleemphasis{y/n}
&
Where \sphinxstyleemphasis{y/n} = 1 for select. Sets
both GUI select and strip to
expanded mode. (0 is ignored)
\\
\hline
/strip/expand \sphinxstyleemphasis{ssid} \sphinxstyleemphasis{y/n}
&
Where \sphinxstyleemphasis{y/n} = 1 for expanded
mode. Sets only local strip to
Expanded. Setting to 0 resets the
expansion to follow selection.
\\
\hline
/select/expand \sphinxstyleemphasis{y/n}
&
Where \sphinxstyleemphasis{y/n} = 1 for expanded
mode, 0 for Select mode.
\\
\hline
/select/recenable \sphinxstyleemphasis{y/n}
&
Where \sphinxstyleemphasis{y/n} is 1 for enabled and
0 for disabled
\\
\hline
/select/record\_safe \sphinxstyleemphasis{y/n}
&
Where \sphinxstyleemphasis{y/n} is 1 for safe and 0
for unlocked
\\
\hline
/select/mute \sphinxstyleemphasis{y/n}
&
Where \sphinxstyleemphasis{y/n} is 1 for enabled and
0 for disabled
\\
\hline
/select/solo \sphinxstyleemphasis{y/n}
&
Where \sphinxstyleemphasis{y/n} is 1 for enabled and
0 for disabled
\\
\hline
/select/solo\_iso \sphinxstyleemphasis{state}
&
where \sphinxstyleemphasis{state} is a bool/int
representing the desired solo
isolate state of the track
\\
\hline
/select/solo\_safe \sphinxstyleemphasis{state}
&
where \sphinxstyleemphasis{state} is a bool/int
representing the desired solo
safe/lock state of the track
\\
\hline
/select/monitor\_input \sphinxstyleemphasis{y/n}
&
Where \sphinxstyleemphasis{y/n} is 1 for monitor from
input and 0 for auto
\\
\hline
/select/monitor\_disk \sphinxstyleemphasis{y/n}
&
Where \sphinxstyleemphasis{y/n} is 1 for monitor from
disk and 0 for auto
\\
\hline
/select/polarity \sphinxstyleemphasis{invert}
&
where \sphinxstyleemphasis{invert} is a bool/int
representing the desired polarity
of the track
\\
\hline
/select/gain \sphinxstyleemphasis{gain}
&
Where \sphinxstyleemphasis{gain} is a float ranging
from -193 to 6 representing the
desired gain of the track in dB.
\\
\hline
/select/fader \sphinxstyleemphasis{position}
&
Where \sphinxstyleemphasis{position} is an float
ranging from 0 to 1 representing
the fader control position.
\\
\hline
/select/db\_delta \sphinxstyleemphasis{delta}
&
where \sphinxstyleemphasis{delta} is a float that
will increase or decrease the
gain of the selected track by the
amount of the delta. (Ardour
5.11+)
\\
\hline
/select/\sphinxstyleemphasis{/automation *mode}
&
where \sphinxstyleemphasis{mode} is an int ranging
from 0 to 3 representing the
desired automation mode for the
control. {\hyperref[\detokenize{index:osc58-automation}]{\emph{See OSC
Automation.}}}
\_
\\
\hline
/select/\sphinxstyleemphasis{/touch *state}
&
where \sphinxstyleemphasis{state} is an int of 1 for
touched and 0 for released. {\hyperref[\detokenize{index:osc58-automation}]{\emph{See
OSC
Automation.}}}
\_
\\
\hline
/select/trimdB \sphinxstyleemphasis{trim\_db}
&
where \sphinxstyleemphasis{trim\_db} is a float
ranging from -20 to 20
representing the desired trim of
the track in dB.
\\
\hline
/select/pan\_stereo\_position
\sphinxstyleemphasis{position}
&
where \sphinxstyleemphasis{position} is a float
ranging from 0 to 1 representing
the desired pan position of the
track
\\
\hline
/select/pan\_stereo\_width \sphinxstyleemphasis{width}
&
where \sphinxstyleemphasis{width} is a float ranging
from 0 to 1 representing the
desired pan width of the track
\\
\hline
/select/pan\_elevation\_position
\sphinxstyleemphasis{position}
&
where \sphinxstyleemphasis{position} is a float
ranging from 0 to 1 representing
the desired pan elevation of the
track
\\
\hline
/select/pan\_frontback\_position
\sphinxstyleemphasis{position}
&
where \sphinxstyleemphasis{position} is a float
ranging from 0 to 1 representing
the desired front to back
position of the track
\\
\hline
/select/pan\_lfe\_control \sphinxstyleemphasis{value}
&
where \sphinxstyleemphasis{value} is a float ranging
from 0 to 1 representing the
desired LFE control value for the
track
\\
\hline
/select/send\_gain”, \sphinxstyleemphasis{sendid}
\sphinxstyleemphasis{send\_gain}
&
where \sphinxstyleemphasis{sendid} = nth\_send,
\sphinxstyleemphasis{send\_gain} is a float ranging
from -193 to +6 representing the
desired gain in dB for the send
\\
\hline
/select/send\_fader”, \sphinxstyleemphasis{sendid}
\sphinxstyleemphasis{send\_gain}
&
where \sphinxstyleemphasis{sendid} = nth\_send,
\sphinxstyleemphasis{send\_gain} is a float ranging
from 0 to 1 representing the
desired position for the send as
a fader
\\
\hline
/select/send\_enable”, \sphinxstyleemphasis{sendid}
\sphinxstyleemphasis{state}
&
where \sphinxstyleemphasis{sendid} = nth\_send,
\sphinxstyleemphasis{state} is 1 for enabled and 0
for disabled
\\
\hline
/select/send\_page”, \sphinxstyleemphasis{delta}
&
where \sphinxstyleemphasis{delta} is an int or float
selecting another send as a delta
from the current send.
\\
\hline
/select/plugin\_page”, \sphinxstyleemphasis{delta}
&
where \sphinxstyleemphasis{delta} is an int or float
selecting another plugin
parameter as a delta from the
current parameter.
\\
\hline
/select/plugin/parameter”,
\sphinxstyleemphasis{plugin} \sphinxstyleemphasis{parameter} \sphinxstyleemphasis{value}
&
where \sphinxstyleemphasis{plugin} = nth plugin,
\sphinxstyleemphasis{parameter} = nth parameter and
\sphinxstyleemphasis{value} is a float from 0 to 1
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\sphinxcode{\sphinxupquote{/select/send\_page}} and \sphinxcode{\sphinxupquote{/select/plugin\_page}} may be used with a
page up and page down switch by using a switch with a value of \sphinxcode{\sphinxupquote{1}} for
page up and a switch with a value of \sphinxcode{\sphinxupquote{-1}} for page down. An encoder
can be used as well. (these commands were added in Ardour version 5.10)


\subsection{Menu actions}
\label{\detokenize{index:menu-actions}}
Every single menu item in Ardour’s GUI is accessible via OSC. There is a
single common syntax to trigger the action as if it was selected with
the mouse (or keyboard):

/access\_action \sphinxstyleemphasis{action\_name}

As of Ardour 5.9, \sphinxstyleemphasis{access\_action} can be inlined for control surfaces
that are unable to send string parameters. The \sphinxstyleemphasis{action\_name} is composed
of a group and an action in the form of \sphinxstyleemphasis{Group/action} which fits very
well as an OSC path extension:

/access\_action/\sphinxstyleemphasis{Group/action} \sphinxstyleemphasis{key\_pressed}

The key\_pressed is optional, but if present is a float 1 or 0 where the
command is ignored if key\_pressed is 0.

Some of the Menu Actions duplicate other OSC commands. In all cases it
is better to use the OSC commands rather than the Menu Actions if
possible as the OSC commands are more direct.

The {\hyperref[\detokenize{index:list-of-menu-actions}]{\emph{list of actions}}} shows all available
values of \sphinxstyleemphasis{action-name} for Ardour.


\chapter{76.2 - OSC: Using the Setup Dialog}
\label{\detokenize{index:osc-using-the-setup-dialog}}\label{\detokenize{index:osc58-using-the-setup-dialog}}
Starting with Ardour 5.1 OSC has a graphic setup dialog. This dialog can
be accessed from Preferences-\textgreater{}Control Surfaces. Select OSC and click on
the Show Protocol Settings.

The Ardour OSC dialog has three tabs. The main tab, the Strip Types tab
and the Feedback tab.

Many OSC devices get their IP from a DHCP making it difficult to set an
IP in Ardour’s OSC settings. Therefore, most of the settings are
\sphinxstyleemphasis{default} settings. Values are set and the next OSC surface to send an
OSC message to Ardour will use those settings. An OSC surface that has
previously sent a message to Ardour will retain the settings it already
had. Any change to a setting will reset all device settings. A
\sphinxstyleemphasis{/refresh} message will set that device to any new settings. The use of
\sphinxstyleemphasis{/set\_surface} will override all settings except \sphinxstyleemphasis{Port Mode}. \sphinxstyleemphasis{Port
Mode} affects all connected surfaces and so all surfaces must use either
the set manual port or send OSC messages from the same port they expect
to receive feedback on.


\section{Dialog settings}
\label{\detokenize{index:dialog-settings}}

\subsection{OSC setup tab}
\label{\detokenize{index:osc-setup-tab}}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{osc-dialog}.png}
\caption{The OSC configuration dialog}\label{\detokenize{index:id604}}\end{figure}


\subsubsection{Connection:}
\label{\detokenize{index:connection}}
This field is informational only. It shows where Ardour will receive OSC
messages. The system Name and the Port are the most important parts.
Normally, Ardour will use 3819 as its server port. However, if some
other server is already using this port, Ardour will try to use the next
port up and will keep trying up to 10 ports up.


\subsubsection{Port Mode:}
\label{\detokenize{index:port-mode}}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{osc-portmode}.png}
\caption{Port Mode Dropdown}\label{\detokenize{index:id605}}\end{figure}

This drop down allows the choice of Auto or Manual outbound port
setting. The Auto port mode, will send OSC messages back to the port
messages from that surface are received from. This setting allows two
surfaces on the same IP to operate independently. However, there are a
number of OSC control surfaces that do not monitor the same port they
send from and in fact may change ports they send from as well. Manual
allows the outgoing port, the port the surface will receive on, to be
manually set. In Manual port mode only one control surface per IP can
work. Most phone or tablet OSC controllers like touchOSC or Control need
Manual port mode. More than one controller can be used so long as each
has it’s own IP.


\subsubsection{Manual Port:}
\label{\detokenize{index:manual-port}}
This is an Entry box for setting the outgoing port when in Manual port
mode.


\subsubsection{Bank Size:}
\label{\detokenize{index:id49}}
This sets the default bank size for the next surface to send a
\sphinxstyleemphasis{/set\_surface/*} OSC message. Bank size 0 (the default) sets no banking
and allows controlling all strips included in strip\_types at once. The
entry area will be bright blue for a port that is not valid (ports below
1024 or 3819).


\subsubsection{Send Page Size:}
\label{\detokenize{index:id50}}
This allows setting the size of pages for sends. In the case there are
more sends than controls. A size of 0 is the same as no paging and all
sends are directly controllable.


\subsubsection{Plugin Page Size:}
\label{\detokenize{index:id51}}
This allows setting the size of pages for plugin controls. Some plugins
have hundreds of controls and so it may be necessary to page the plugin
controls to a limited number of physical controls. A size of 0 is the
same as no paging and all plugin controls are directly controllable.


\subsubsection{Gain Mode:}
\label{\detokenize{index:gain-mode}}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{osc-gainmode}.png}
\caption{Gain Mode Dropdown}\label{\detokenize{index:id606}}\end{figure}

Sets the faders (and sends faders) feedback math to position where a
value between 0 and 1 represents the fader position of the same fader in
the mixer GUI or dB where the feedback from fader movement will be
returned as a dB value. When the Gain Mode is set to position, the
/{\color{red}\bfseries{}*}/name feedback for the channel will show dB values in text while the
fader is being adjusted and then return the name text.


\subsubsection{Debug:}
\label{\detokenize{index:debug}}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{osc-debug}.png}
\caption{Debug Mode Dropdown}\label{\detokenize{index:id607}}\end{figure}

For debugging purposes this allows logging either all OSC messages
Ardour receives or invalid messages received or none.


\subsubsection{Preset:}
\label{\detokenize{index:preset}}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{osc-preset}.png}
\caption{Preset Loader}\label{\detokenize{index:id608}}\end{figure}

Ardour now allows the use of preset settings. The default settings used
are the settings from the last session or the factory defaults the first
time OSC is enabled. As soon as any of these settings are changed, the
Preset will change to “User” and the new settings will be save to the
osc directory in the {\hyperref[\detokenize{index:files-and-directories-ardour-knows-about}]{\emph{Ardour configuration
directory}}} as
\sphinxstyleemphasis{user.preset}. This preset file can be renamed for future use. It is
suggested to also change the name value inside to avoid confusion in the
preset listing. Ardour will ship with some of it’s own presets that go
with some popular OSC control and map combinations.


\subsubsection{Clear OSC Devices}
\label{\detokenize{index:clear-osc-devices}}
This button has been removed after Ardour 5.10. Instead this action is
triggered by any change in the settings.

This button clears operating device profiles so that Ardour will reset
all devices settings to use the new defaults from changed settings. a
device may still override these new settings with the /set\_surface set
of commands. The reason for setting defaults settings is that some OSC
controllers are not able to send more than one parameter at a time and
so having correct defaults allows one “Connect” button rather than 4.


\subsection{Default Strip Types tab}
\label{\detokenize{index:default-strip-types-tab}}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{osc-strip-types}.png}
\caption{The Default Strip Types tab}\label{\detokenize{index:id609}}\end{figure}

This allows selecting which of Ardour’s mixer strips will be available
for control. The Factory default is all strips except master, monitor
and hidden strips. If it is desired to only see input tracks the others
can be deselected. It is also possible to change these settings from the
control surface. A set of buttons could select showing only inputs or
only busses. If a group is selected in the GUI then showing only
selected strips will show only that group. Showing hidden tracks is
handy for cases where a groups of tracks that grouped to a bus or
controlled by a VCA are hidden, but one of those tracks needs a tweak.


\subsection{Default Feedback tab}
\label{\detokenize{index:default-feedback-tab}}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{osc-feedbackdefault}.png}
\caption{The Default Feedback tab}\label{\detokenize{index:id610}}\end{figure}

This allows setting up which controls provide feedback. The Factory
default is none. If the controller is unable to receive feedback, this
should be left blank. In the case of metering, Metering as a LED strip
only works if Metering as a Float is disabled.


\chapter{76.3 - OSC: Querying Ardour}
\label{\detokenize{index:osc-querying-ardour}}\label{\detokenize{index:osc58-querying-ardour}}
In order to make a custom controller that knows what strips Ardour has,
the controller needs to be able to query Ardour for that information.
These set of commands are for smarter control surfaces That have the
logic to figure out what to do with the information. These are not of
value for mapped controllers like touchOSC and friends. The controller
will need to send these queries to Ardour as often as it needs this
information. It may well make sense to use regular feedback for things
that need to be updated often such as position or metering. Here are the
commands used to query Ardour: (added in Ardour 5.5)


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

/strip/list
&
Ask for a list of strips
\\
\hline
/strip/sends \sphinxstyleemphasis{ssid}
&
Asks for a list of sends on the
strip \sphinxstyleemphasis{ssid}
\\
\hline
/strip/receives \sphinxstyleemphasis{ssid}
&
Asks for a list of tracks that
have sends to the strip \sphinxstyleemphasis{ssid}
points to
\\
\hline
/strip/plugin/list \sphinxstyleemphasis{ssid}
&
Asks for a list of plug-ins for
strip \sphinxstyleemphasis{ssid.}
\\
\hline
/strip/plugin/descriptor \sphinxstyleemphasis{ssid}
\sphinxstyleemphasis{piid}
&
Asks for a list of descriptors
for plug-in \sphinxstyleemphasis{piid} on strip
\sphinxstyleemphasis{ssid}
\\
\hline
/set\_surface
&
Ask for the current surface
setting. Reply is in the same
form as setting the surface would
be.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\section{A list of strips}
\label{\detokenize{index:a-list-of-strips}}
\sphinxcode{\sphinxupquote{/strip/list}} asks Ardour for a list of strips that the current
session has. Ardour replies with a message for each strip with the
following information:

Strip type - One of:
\begin{itemize}
\item {} 
AT - Audio Track

\item {} 
MT - MIDI Track

\item {} 
B - Audio Bus

\item {} 
MB - MIDI bus

\item {} 
AX - Aux bus

\item {} 
V - VCA

\end{itemize}

Strip name

Number of inputs

Number of outputs

Muted

Soloed

Ssid (strip number)

Record enabled

After all the strip messages have been sent, one final message is sent
with:
\begin{itemize}
\item {} 
The text \sphinxcode{\sphinxupquote{end\_route\_list}}

\item {} 
The session frame rate

\item {} 
The last frame number of the session

\item {} 
Monitor section present

\end{itemize}

The \sphinxcode{\sphinxupquote{/set\_surface}} should be set before this is called. That way The
right set of strips will be sent in return (though the default is good
for most uses) and feedback will start correctly.

If the surface is using \sphinxcode{\sphinxupquote{/strip/list}}, the surface needs to know if
the strips have changed. This would be true if a strip gets moved,
created or deleted. When this happens Ardour sends \sphinxcode{\sphinxupquote{/strip/list}} to
the surfaces that have previously requested a \sphinxcode{\sphinxupquote{/strip/list}}. This lets
the surface know that its list of strips is no longer valid.

A bus will not have a record enable and so a bus message will have one
less parameter than a track. It is the controllers responsibility to
deal with this.


\section{A list of sends}
\label{\detokenize{index:a-list-of-sends}}
\sphinxcode{\sphinxupquote{/strip/sends ssid}} asks Ardour for a list of sends for strip number
ssid. The reply is sent back to the controller as one message with the
following information:

Ssid that information is for

Each send’s information:
\begin{itemize}
\item {} 
The send’s target bus ssid

\item {} 
The send’s target bus name

\item {} 
The send id for this strip

\item {} 
The send gain as a fader position

\item {} 
The Send’s enable state

\end{itemize}

The controller can tell how many sends there are from the number of
parameters as each send has 5 parameters and there is one extra for
ssid.


\section{A list if tracks that send audio to a bus}
\label{\detokenize{index:a-list-if-tracks-that-send-audio-to-a-bus}}
\sphinxcode{\sphinxupquote{/strip/receives ssid}} will return a list of tracks that have sends to
the bus at the ssid. The reply will contain the following information
for each track connected to this bus:
\begin{itemize}
\item {} 
The ssid of the track sending

\item {} 
The name of the sending track

\item {} 
The id of the send at that track

\item {} 
It’s gain in fader position

\item {} 
The send’s enable state

\end{itemize}


\section{A list of plug-ins for strip}
\label{\detokenize{index:a-list-of-plug-ins-for-strip}}
\sphinxcode{\sphinxupquote{/strip/plugin/list ssid}} will return a list of plug-ins that strip
ssid has. The reply will contain the following information:

Ssid that information is for

Each plugin’s information:
\begin{itemize}
\item {} 
The plug-in’s id

\item {} 
The plug-in’s name

\end{itemize}


\section{A list of a plug-in’s parameters}
\label{\detokenize{index:a-list-of-a-plug-in-s-parameters}}
\sphinxcode{\sphinxupquote{/strip/plugin/descriptor ssid piid}} will return the plug-in
parameters for ppid plug-in on the ssid strip. The reply will be sent as
a number of messages, one for each parameter. Each message will contain
the following information:

Ssid of the strip the plug-in is in

The plug-in id for the plug-in

The plug-in parameter id for the plug-in

The plug-in parameter’s name

Information about that parameter:
\begin{itemize}
\item {} 
A bitset of flags (see below)

\item {} 
Data type

\item {} 
Minimum value

\item {} 
Maximum value

\item {} 
The number of scale points

\item {} 
zero or more scale points of one value and one string each

\item {} 
The current parameter value

\end{itemize}

After all the parameters have been sent this way, one final message”
\sphinxcode{\sphinxupquote{/strip/plugin/descriptor\_end}} is sent with these parameters:
\begin{itemize}
\item {} 
Ssid of the strip the plugin is in

\item {} 
The plug-in id for the plug-in

\end{itemize}

The flag bitset above has been defined as (from lsb):
\begin{itemize}
\item {} 
0—enumeration

\item {} 
1—integer step

\item {} 
2—logarithmic

\item {} 
5—sample rate dependent

\item {} 
6—toggled

\item {} 
7—controllable

\item {} 
8—hidden

\end{itemize}

Bits 3 and 4 are not used, they were max unbound and min unbound in
previous versions and always zero.

While this seems complex, it is really not that bad. Minimum, maximum
and value will in most cases give you all you need. For simpler access
to plug-ins, the /select/plugin/ set of commands will handle most needs.


\chapter{76.4 - OSC: Feedback}
\label{\detokenize{index:osc-feedback}}\label{\detokenize{index:osc58-feedback}}
Feedback from the Ardour to the the control surface is very useful for a
number of things. Motor faders need to know where the the track they
have been attached to is at before they were assigned otherwise the DAW
fader will jump to where the controller fader is. Likewise, the buttons
on each strip need to know what their value is so they can light their
LED correctly. Transport controls should let you know if they are active
too. This is what feedback is all about.

Ardour does feedback by sending the same path back that is used to
control the same function. As such any controls that have feedback have
a parameter that is the value of the control or its state (on or off).
In the case of OSC paths listed on the main OSC page as having no
parameter, if they have feedback, they will also work with a 1 for
button press and 0 for button release. This is because many OSC
controllers will only use exactly the same path for feedback as for
control. For example:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

/transport\_stop
&\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

can be used also in the form:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

/transport\_stop \sphinxstyleemphasis{press}
&
where \sphinxstyleemphasis{press} is an int/bool
indicating if the button is
pressed or not.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

The feedback does not have the same meaning as the control message.
Where the button release sent to Ardour will be ignored and has no
meaning. Both states have meaning in feedback to the controller. The
feedback will be:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

/transport\_stop \sphinxstyleemphasis{state}
&
where \sphinxstyleemphasis{state} is an int/bool
indicating if the transport is
stopped or not.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

With feedback turned on, OSC control commands that try to change a
control that does not exist will get feedback that resets that control
to off. For example, sending a /strip/recenable to a buss will not work
and Ardour will try to turn the controller LED off in that case. Also
note that Pan operation may be limited by pan width in some cases. That
is with pan width at 100\% (or -100\%) there is no pan position movement
available.

It may come as a surprise, but feedback often generates more network
traffic than control itself does. Some things are more obvious like head
position or meters. But even a simple button push like transport start
sends not only a signal to turn on the play LED, but also one to turn
off the stop LED, the Rewind LED, the Fast Forward LED and the Loop LED.
That is still minor, think instead of a surface refresh such as happens
when the surface is first connected and then most of that happens every
time the fader strips are banked. This is why feedback is enabled in
sections so that as little feedback as is actually needed is sent. This
is also a consideration if the surface is connected via wifi.


\section{List of OSC feedback messages}
\label{\detokenize{index:list-of-osc-feedback-messages}}

\subsection{Feedback only}
\label{\detokenize{index:feedback-only}}
These messages are feedback only. They are sent as status from Ardour
and some of them may be enabled separately from other feedback. See:
{\hyperref[\detokenize{index:osc58-feedback-and-strip-types-values}]{\emph{Calculating Feedback and Strip-types
Values.}}}

See strip section below for info about ssid and wrapping it into the
path. Also /master and /monitor support what the /strip does.

In the case where Gainmode is set to position, the track name will show
the dB value while values are changing.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

/strip/name \sphinxstyleemphasis{ssid} \sphinxstyleemphasis{track\_name}
&
where \sphinxstyleemphasis{track\_name} is a string
representing the name of the
track
\\
\hline
/strip/\sphinxstyleemphasis{/automation\_name *ssid}
\sphinxstyleemphasis{name}
&
where \sphinxstyleemphasis{name} is a string
representing the current
automation mode for the control.
{\hyperref[\detokenize{index:osc58-automation}]{\emph{See OSC
Automation.}}}
\_
\\
\hline
/session\_name \sphinxstyleemphasis{session\_name}
&
where \sphinxstyleemphasis{session\_name} is a string
representing the name of the
session
\\
\hline
/strip/meter \sphinxstyleemphasis{ssid} \sphinxstyleemphasis{meter}
&
where \sphinxstyleemphasis{meter} is a value
representing the current audio
level. (the exact math used is
determined by the feedback bits
set)
\\
\hline
/strip/signal \sphinxstyleemphasis{ssid} \sphinxstyleemphasis{signal}
&
where \sphinxstyleemphasis{signal} is a float
indicating the instantaneous
audio level is -40dB or higher.
\\
\hline
/position/smpte \sphinxstyleemphasis{time}
&
where \sphinxstyleemphasis{time} is a string with the
current play head time. Seconds
as per smpte.
\\
\hline
/position/bbt \sphinxstyleemphasis{beat}
&
where \sphinxstyleemphasis{beat} is a string with the
current play head bar/beat.
\\
\hline
/position/time \sphinxstyleemphasis{time}
&
where \sphinxstyleemphasis{time} is a string with the
current play head time. Seconds
are in milliseconds
\\
\hline
/position/samples \sphinxstyleemphasis{samples}
&
where \sphinxstyleemphasis{samples} is a string with
the current play head position in
samples.
\\
\hline
/heartbeat \sphinxstyleemphasis{LED}
&
where \sphinxstyleemphasis{LED} is a float that
cycles 1/0 at 1 second intervals.
\\
\hline
/record\_tally \sphinxstyleemphasis{state}
&
Some record enable is true or
“ready to record”. For a
“Recording” sign at studio door.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsection{Transport Control}
\label{\detokenize{index:transport-control-1}}\label{\detokenize{index:id55}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

/transport\_stop \sphinxstyleemphasis{state}
&
\sphinxstyleemphasis{state} is true when transport is
stopped
\\
\hline
/transport\_play \sphinxstyleemphasis{state}
&
\sphinxstyleemphasis{state} is true when transport
speed is 1.0
\\
\hline
/ffwd \sphinxstyleemphasis{state}
&
\sphinxstyleemphasis{state} is true when transport is
moving forward but not at speed
1.0
\\
\hline
/rewind \sphinxstyleemphasis{state}
&
\sphinxstyleemphasis{state} is true when transport
speed is less than 0.0
\\
\hline
/loop\_toggle \sphinxstyleemphasis{state}
&
\sphinxstyleemphasis{state} is true when loop mode is
true
\\
\hline
/cancel\_all\_solos \sphinxstyleemphasis{state}
&
Where \sphinxstyleemphasis{state} true indicates
there are active solos that can
be canceled.
\\
\hline
/jog/mode/name \sphinxstyleemphasis{name}
&
Where \sphinxstyleemphasis{name} is a string
indicating the name of the
current jog mode.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsection{Recording control}
\label{\detokenize{index:recording-control-1}}\label{\detokenize{index:id56}}
/rec\_enable\_toggle \sphinxstyleemphasis{state}

Master record enabled.


\subsection{Master and monitor strips}
\label{\detokenize{index:master-and-monitor-strips}}
Master and monitor strips are similar to track strips but do not use the
SSID. Rather they use their name as part of the path:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

/master/gain \sphinxstyleemphasis{dB}
&
where \sphinxstyleemphasis{dB} is a float ranging
from -193 to +6 representing the
actual gain of master in dB
\\
\hline
/master/fader \sphinxstyleemphasis{position}
&
where \sphinxstyleemphasis{position} is an int
ranging from 0 to 1023
representing the fader control
position
\\
\hline
/master/trimdB \sphinxstyleemphasis{dB}
&
where \sphinxstyleemphasis{dB} is a float ranging
from -20 to +20 representing the
actual trim for master in dB
\\
\hline
/master/pan\_stereo\_position
\sphinxstyleemphasis{position}
&
where \sphinxstyleemphasis{position} is a float
ranging from 0 to 1 representing
the actual pan position for
master
\\
\hline
/master/mute \sphinxstyleemphasis{state}
&
where \sphinxstyleemphasis{state} is a bool/int
representing the actual mute
state of the Master strip
\\
\hline
/monitor/gain \sphinxstyleemphasis{dB}
&
where \sphinxstyleemphasis{dB} is a float ranging
from -193 to 6 representing the
actual gain of monitor in dB
\\
\hline
/monitor/fader \sphinxstyleemphasis{position}
&
where \sphinxstyleemphasis{position} is an int
ranging from 0 to 1023
representing the fader control
position
\\
\hline
/monitor/mute \sphinxstyleemphasis{state}
&
where \sphinxstyleemphasis{state} is a bool/int
representing the actual mute
state of the Monitor strip
\\
\hline
/monitor/dim \sphinxstyleemphasis{state}
&
where \sphinxstyleemphasis{state} is a bool/int
representing the actual dim state
of the Monitor strip
\\
\hline
/monitor/mono \sphinxstyleemphasis{state}
&
where \sphinxstyleemphasis{state} is a bool/int
representing the actual mono
state of the Monitor strip
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsection{Track specific operations}
\label{\detokenize{index:track-specific-operations-1}}\label{\detokenize{index:id57}}
For each of the following, \sphinxstyleemphasis{ssid} is the surface strip ID for the track

Some Surfaces (many Android applets) are not able to deal with more than
one parameter in a command. However, the two parameter commands below
can also be sent as /strip/command/ssid param. Feedback can be set to
match this with the /set\_surface/feedback \sphinxstyleemphasis{state} command. See
{\hyperref[\detokenize{index:osc58-feedback-and-strip-types-values}]{\emph{Calculating Feedback and Strip-types
Values.}}}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

/bank\_up \sphinxstyleemphasis{LED}
&
where \sphinxstyleemphasis{LED} is a bool that
indicates another bank\_up
operation is possible.
\\
\hline
/bank\_down \sphinxstyleemphasis{LED}
&
where \sphinxstyleemphasis{LED} is a bool that
indicates another bank\_down
operation is possible.
\\
\hline
/strip/name \sphinxstyleemphasis{ssid} \sphinxstyleemphasis{track\_name}
&
where \sphinxstyleemphasis{track\_name} is a string
representing the name of the
track (note there is no
corresponding command to set the
track name)
\\
\hline
/strip/mute \sphinxstyleemphasis{ssid} \sphinxstyleemphasis{mute\_st}
&
where \sphinxstyleemphasis{mute\_st} is a bool/int
representing the actual mute
state of the track
\\
\hline
/strip/solo \sphinxstyleemphasis{ssid} \sphinxstyleemphasis{solo\_st}
&
where \sphinxstyleemphasis{solo\_st} is a bool/int
representing the actual solo
state of the track
\\
\hline
/strip/monitor\_input \sphinxstyleemphasis{ssid}
\sphinxstyleemphasis{monitor\_st}
&
where \sphinxstyleemphasis{monitor\_st} is a bool/int.
True/1 meaning the track is force
to monitor input
\\
\hline
/strip/monitor\_disk \sphinxstyleemphasis{ssid}
\sphinxstyleemphasis{monitor\_st}
&
where \sphinxstyleemphasis{monitor\_st} is a bool/int.
True/1 meaning the track is force
to monitor disk, where both disk
and input are false/0, auto
monitoring is used.
\\
\hline
/strip/recenable \sphinxstyleemphasis{ssid} \sphinxstyleemphasis{rec\_st}
&
where \sphinxstyleemphasis{rec\_st} is a bool/int
representing the actual rec state
of the track
\\
\hline
/strip/record\_safe \sphinxstyleemphasis{ssid}
\sphinxstyleemphasis{rec\_st}
&
where \sphinxstyleemphasis{rec\_st} is a bool/int
representing the actual record
safe state of the track
\\
\hline
/strip/gain \sphinxstyleemphasis{ssid} \sphinxstyleemphasis{gain}
&
where \sphinxstyleemphasis{gain} is a float ranging
from -193 to 6 representing the
actual gain of the track in dB.
\\
\hline
/strip/fader \sphinxstyleemphasis{ssid} \sphinxstyleemphasis{position}
&
where \sphinxstyleemphasis{position} is an float
ranging from 0 to 1 representing
the actual fader position of the
track.
\\
\hline
/strip/\sphinxstyleemphasis{/automation *ssid} \sphinxstyleemphasis{mode}
&
where \sphinxstyleemphasis{mode} is an int ranging
from 0 to 3 representing the
actual automation mode for the
control. {\hyperref[\detokenize{index:osc58-automation}]{\emph{See OSC
Automation.}}}
\_
\\
\hline
/strip/trimdB \sphinxstyleemphasis{ssid} \sphinxstyleemphasis{trim\_db}
&
where \sphinxstyleemphasis{trim\_db} is a float
ranging from -20 to 20
representing the actual trim of
the track in dB.
\\
\hline
/strip/pan\_stereo\_position \sphinxstyleemphasis{ssid}
\sphinxstyleemphasis{position}
&
where \sphinxstyleemphasis{position} is a float
ranging from 0 to 1 representing
the actual pan position of the
track
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsection{Selected Operations}
\label{\detokenize{index:selected-operations}}
Selection feedback is the same as for strips, only the path changes from
\sphinxstyleemphasis{/strip} to \sphinxstyleemphasis{/select} and there is no \sphinxstyleemphasis{ssid}. there are some extra
feedback and commands that will be listed here.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

/select/n\_inputs \sphinxstyleemphasis{number}
&
where \sphinxstyleemphasis{number} number of inputs
for this strip
\\
\hline
/select/n\_outputs \sphinxstyleemphasis{number}
&
where \sphinxstyleemphasis{number} number of outputs
for this strip
\\
\hline
/select/comment \sphinxstyleemphasis{text}
&
where \sphinxstyleemphasis{text} is the strip comment
\\
\hline
/select/solo\_iso \sphinxstyleemphasis{state}
&
where \sphinxstyleemphasis{state} is a bool/int
representing the Actual solo
isolate state of the track
\\
\hline
/select/solo\_safe \sphinxstyleemphasis{state}
&
where \sphinxstyleemphasis{state} is a bool/int
representing the actual solo
safe/lock state of the track
\\
\hline
/select/polarity \sphinxstyleemphasis{invert}
&
where \sphinxstyleemphasis{invert} is a bool/int
representing the actual polarity
of the track
\\
\hline
/select/pan\_stereo\_width \sphinxstyleemphasis{width}
&
where \sphinxstyleemphasis{width} is a float ranging
from 0 to 1 representing the
actual pan width of the track
\\
\hline
/select/send\_gain”, \sphinxstyleemphasis{sendid}
\sphinxstyleemphasis{send\_gain}
&
where \sphinxstyleemphasis{sendid} = nth\_send,
\sphinxstyleemphasis{send\_gain}is a float ranging
from -193 to +6 representing the
actual gain in dB for the send
\\
\hline
/select/send\_fader”, \sphinxstyleemphasis{sendid}
\sphinxstyleemphasis{send\_gain}
&
where \sphinxstyleemphasis{sendid} = nth\_send,
\sphinxstyleemphasis{send\_gain}is a float ranging
from 0 to 1 representing the
actual position for the send as a
fader
\\
\hline
/select/send\_name \sphinxstyleemphasis{sendid}
\sphinxstyleemphasis{send\_name}
&
where \sphinxstyleemphasis{send\_name} is a string
representing the name of the buss
this send goes to.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsection{Menu actions}
\label{\detokenize{index:menu-actions-1}}\label{\detokenize{index:id59}}
Every single menu item in Ardour’s GUI is accessible via OSC. However,
there is no provision for returning the state of anything set this way.
This is not a bad thing as most menu items either do not have an on/off
state or that state is quite visible. Bindings that affect other
parameters that OSC does track will show on those OSC controls. Examples
of this might be track record enable for tracks 1 to 32, play or stop.


\chapter{76.5 - OSC: Feedback and Strip-types Values}
\label{\detokenize{index:osc-feedback-and-strip-types-values}}\label{\detokenize{index:osc58-feedback-and-strip-types-values}}
\sphinxstyleemphasis{/set\_surface} has two values the user needs to calculate before use. In
general these will not be calculated at run time, but beforehand. There
may be more than one button with different values to turn various kinds
of feedback on or off or to determine which kinds of strips are
currently viewed/controlled.

Both \sphinxstyleemphasis{feedback} and \sphinxstyleemphasis{strip-types} use bitsets to keep track what they
are doing. Any number in a computer is made out of bits that are on or
off, but we represent them as normal base 10 numbers. Any one bit turned
on will add a unique value to the number as a whole. So for each kind of
feedback or strip type to be used, that number should be added to the
total.


\section{strip\_types}
\label{\detokenize{index:strip-types-1}}\label{\detokenize{index:id60}}
strip\_types is an integer made up of bits. The easy way to deal with
this is to think of strip\_types items being worth a number and then
adding all those numbers together for a value to send. Strip Types will
determine What kind of strips will be included in bank. This would
include: Audio, MIDI, busses, VCAs, Master, Monitor and hidden or
selected strips.
\begin{itemize}
\item {} 
1: AudioTracks.

\item {} 
2: MidiTracks.

\item {} 
4: AudioBusses.

\item {} 
8: MidiBusses.

\item {} 
16: VCAs.

\item {} 
32: Master.

\item {} 
64: Monitor.

\item {} 
128: Audio Aux.

\item {} 
256: Selected.

\item {} 
512: Hidden.

\item {} 
1024: Use Group.

\end{itemize}

Selected and Hidden bits are normally not needed as Ardour defaults to
showing Selected strips and not showing Hidden strips. The purpose of
these two flags is to allow showing only Selected strips or only Hidden
strips. Using Hidden with other flags will allow Hidden strips to show
inline with other strips.

Use Group on will tell ardour that any control on a strip that is part
of a group will affect all strips within that group. Default is off or
the control should only affect the strip the control is applied to. The
\sphinxcode{\sphinxupquote{/use\_group f state}} command can be used to temporarily change this on
the fly.

Some handy numbers to use might be: 15 (all tracks and busses - 1 + 2 +
4 + 8), 31 (add VCAs to that - 15 + 16). Master or Monitor strips are
generally not useful on a surface that has dedicated controls for these
strips as there are /master* and /monitor* commands already. However,
on a surface with just a bank of fader strips, adding master or monitor
would allow access to them within the banks. Selected would be useful
for working on a group or a set of user selected strips. Hidden shows
strips the GUI has hidden.

Audio Aux? say what? I am sure most people will have noticed that they
can find no \sphinxstyleemphasis{Aux} strips in the Ardour mixer. There are none. There are
busses that can be used a number of ways. From analog days, in OSC, a
bus is something that gets used as a sub mix before ending up going to
Master. An auxiliary bus is used like a separate mixer and its output
goes outside the program or computer to be used as: a monitor mix, a
back up recording, or what have you. In OSC where controller strips may
be limited, it may be useful not to use up a strip for an aux that is
not really a part of the mix. It is also useful to get a list of only
aux busses if the control surface is a phone used to provide talent
monitor mix control on stage. Each performer would be able to mix their
own monitor. The user is free to enable both busses and auxes if they
would prefer.


\section{feedback}
\label{\detokenize{index:id61}}
Feedback is an integer made up of bits. The easy way to deal with this
is to think of feedback items being worth a number and then adding all
those numbers together for a value to send.
\begin{itemize}
\item {} 
1: Button status for strips.

\item {} 
2: Variable control values for strips.

\item {} 
4: Send SSID as path extension.

\item {} 
8: heartbeat to surface.

\item {} 
16: Enable master section feedback.

\item {} 
32: Send Bar and Beat.

\item {} 
64: Send timecode.

\item {} 
128: Send meter as dB (-193 to +6) or 0 to 1 depending on gainmode

\item {} 
256: Send meter a 16 bit value where each bit is a level and all bits
of lower level are on. For use in a LED strip. This will not work if
the above option is turned on.

\item {} 
512: Send signal present, true if level is higher than -40dB

\item {} 
1024: Send position in samples

\item {} 
2048: Send position in time, hours, minutes, seconds and milliseconds

\item {} 
8192: Turn on select channel feedback

\item {} 
16384: Use OSC 1.0 /reply instead of \#reply

\end{itemize}

So using a value of 19 (1 + 2 + 16) would turn on feedback for strip and
master controls, but leave meters, timecode and bar/beat feedback off.


\chapter{76.6 - OSC: Jog Modes}
\label{\detokenize{index:osc-jog-modes}}\label{\detokenize{index:osc58-jog-modes}}
The \sphinxcode{\sphinxupquote{/jog}} command will have a different affect depending on which jog
mode is selected. The jog system has two commands and gives feedback of
the mode chosen.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

/jog \sphinxstyleemphasis{delta}
&
Where \sphinxstyleemphasis{delta} is a float
indicating the amount and
direction.
\\
\hline
/jog/mode \sphinxstyleemphasis{mode}
&
Where \sphinxstyleemphasis{mode} is an int from 0 to
7 indicating the mode
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

Feedback is as below


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

/jog/mode/name \sphinxstyleemphasis{name}
&
Where \sphinxstyleemphasis{name} is a string
indicating the name of the
current jog mode.
\\
\hline
/jog/mode \sphinxstyleemphasis{mode}
&
Where \sphinxstyleemphasis{mode} is an int from 0 to
7 indicating the current jog
mode.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\section{Jog Modes}
\label{\detokenize{index:jog-modes}}\begin{itemize}
\item {} 
0 Jog, each tick moves the Playhead forward or backward .2 seconds.

\item {} 
1 Nudge, Moves the Playhead forward or backward by the amount of the
nudge clock.

\item {} 
2 Scrub, see {\hyperref[\detokenize{index:scrub}]{\emph{Scrub mode}}}.

\item {} 
3 Shuttle, each tick raises or lowers the transport speed by 12.5\%.

\item {} 
4 Marker, Moves the Playhead to the previous or next Marker.

\item {} 
5 Scroll, each tick scrolls the edit window by one, forward or back.

\item {} 
6 Track, moves the current bank left or right by one strip.

\item {} 
7 Bank, Moves the current bank left or right by one bank.

\end{itemize}

The jog mode may be set using a slider with 0 to 7 limits, a group of
switches or radio buttons. What works in any situation will depend on
the controller.


\section{Scrub}
\label{\detokenize{index:scrub}}
Scrub deserves special mention. In an ideal world, scrub would be jog
with sound. However, Ardour does not have that functionality yet. So
scrub starts the transport rolling at either 50\% or 100\% depending on
how fast the jog wheel is turned. The position of the last tick is
always saved and if no more ticks are received, the transport is located
there when stopped at time out. If the jog wheel gives a value of 0 when
released the transport stops at the location the value 0 is sent.


\chapter{76.7 - OSC: Automation}
\label{\detokenize{index:osc-automation}}\label{\detokenize{index:osc58-automation}}
Ardour has automation modes for many of its controls. As of version 5.9,
OSC can control what automation mode a fader uses. ({\hyperref[\detokenize{index:automation}]{\emph{See
Automation.}}})

The form of the automation mode command is:

\sphinxcode{\sphinxupquote{/strip/{[}control{]}/automation ii ssid mode}}
\begin{itemize}
\item {} 
/strip may also be /select in which case the only parameter is the
mode.

\item {} 
{[}control{]} as of Ardour version 5.9 control can be:
\begin{itemize}
\item {} 
gain

\item {} 
fader

\end{itemize}

This list will expand.

\item {} 
ssid can be a parameter as shown or inline (automation/{[}ssid{]}).
/select has no ssid.

\item {} 
mode can be one of:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{0}} Manual mode

\item {} 
\sphinxcode{\sphinxupquote{1}} Play mode

\item {} 
\sphinxcode{\sphinxupquote{2}} Write mode

\item {} 
\sphinxcode{\sphinxupquote{3}} Touch mode

\end{itemize}

The mode value may be sent as a float allowing a “pot” or “slider”
with a range of 0 to 3 to be used to control mode.

\end{itemize}

The next version of Ardour will add
\sphinxcode{\sphinxupquote{/strip/{[}control{]}/automation\_name is ssid mode\_name}} as feedback. A
surface may choose to use only the first character of the string (M, P,
W or T) instead of the whole string (this is in git now).

The touch mode needs more input so there is a Touch command as well
(added post 5.9). It is almost identical to the automation command:

\sphinxcode{\sphinxupquote{/strip/{[}control{]}/touch ii ssid touch}}

The only difference is the last parameter is 1 for touched and 0 for
touch released. All of the rest of the explanation above applies.


\chapter{76.8 - OSC: Personal Monitoring Control}
\label{\detokenize{index:osc-personal-monitoring-control}}\label{\detokenize{index:osc58-personal-monitoring-control}}
Personal monitoring can allow a performer with a smart phone to set
their personal monitor mix for a floor wedge or in-ear monitoring. In
Ardour 5.6 OSC commands to allow this were added.


\section{Setup}
\label{\detokenize{index:setup}}
Some setup needs to be done in the GUI mixer window before this can
work.
\begin{itemize}
\item {} 
Create a bus for each performer who will have personal monitoring. A
good practice is to name the bus with the performers name.

\item {} 
Connect the output of that bus to one of the audio interface’s
playback ports that is not otherwise used. OSC will now include this
bus in its list of aux busses as it no longer has its output
connected to the Master bus.

\item {} 
Add an aux send to each channel the performer needs to hear in their
personal mix. Many performers only need three or four sources to be
mixed. If the performer needs to hear a a set of inputs that are
combined into a bus, adding the aux send to that bus may make more
sense than adding ten drum channels for example.

\item {} 
If the performer wishes to hear effects in their monitor, an extra
send from the send bus, placing the performers aux send after the
effect or a plugin can be added in line in the aux bus itself.

\end{itemize}

This gives stage or studio monitoring for the performer.


\section{The OSC commands and feedback for personal monitoring}
\label{\detokenize{index:the-osc-commands-and-feedback-for-personal-monitoring}}
All of the personal monitoring commands and feedback start with a
\sphinxstyleemphasis{/cue}. It is expected that a surface used as a personal monitor control
will use only \sphinxstyleemphasis{/cue} commands.

Most phone OSC applets (TouchOSC, Control) require manual port to be
set. There are certainly more controls than needed. Using send enables
for example, may lead to wasted time discovering why a send has no
sound. A good easy to use controller that fits on most phones while
still being controllable even with big fingers might look like:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\begin{sphinxfigure-in-table}
\centering

\noindent\sphinxincludegraphics{{octosc}.jpg}
\end{sphinxfigure-in-table}\relax
&\begin{sphinxfigure-in-table}
\centering

\noindent\sphinxincludegraphics{{oscctrl}.jpg}
\end{sphinxfigure-in-table}\relax
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

Ardour is not limited to talking to one personal monitor controller at a
time, but is able to deal with many simultaneously, each controlling its
own Aux bus.

The send controls and feedback all have the send id (1 to n) in line as
part of the OSC path. So the path for the second send would be
\sphinxstyleemphasis{/cue/send/fader/2} to set the level. It is considered that most
surfaces used for this will only be able to handle one parameter.


\subsection{Commands}
\label{\detokenize{index:commands}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

/cue/connect
&
Returns a list of aux busses and
connects to the first.
\\
\hline
/cue/aux \sphinxstyleemphasis{aux-number}
&
where \sphinxstyleemphasis{aux-number} is an integer
or float which is the aux bus
number this surface will use.
\\
\hline
/cue/next\_aux
&
Sets the the aux bus to one bus
higher.
\\
\hline
/cue/previous\_aux
&
Sets the aux to one bus lower.
This can also be used as a
“connect” button to save space in
a phone layout.
\\
\hline
/cue/fader \sphinxstyleemphasis{position}
&
where \sphinxstyleemphasis{position} is a float for
the position of the fader between
0.0 and 1.0.
\\
\hline
/cue/mute \sphinxstyleemphasis{state}
&
where \sphinxstyleemphasis{state} is a float of 0.0
for mute off and 1.0 for the Aux
bus mute on.
\\
\hline
/cue/send/fader/\sphinxstyleemphasis{id} \sphinxstyleemphasis{position}
&
where \sphinxstyleemphasis{position} is a float for
the position of the fader between
0.0 and 1.0.
\\
\hline
/cue/send/enable/\sphinxstyleemphasis{id} \sphinxstyleemphasis{state}
&
where \sphinxstyleemphasis{state} is a float of 0.0
for disable and 1.0 for enable.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsection{Feedback}
\label{\detokenize{index:feedback-1}}\label{\detokenize{index:id62}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

/cue/name \sphinxstyleemphasis{name}
&
where \sphinxstyleemphasis{name} is a string that is
the name of the currently
selected aux bus.
\\
\hline
/cue/name/\sphinxstyleemphasis{id} \sphinxstyleemphasis{name}
&
where \sphinxstyleemphasis{name} is a string that is
the name of the aux bus that \sphinxstyleemphasis{id}
belongs to.
\\
\hline
/cue/fader \sphinxstyleemphasis{position}
&
where \sphinxstyleemphasis{position} is a float from
0.0 to 1.0 that shows the fader
position for the selected aux
bus.
\\
\hline
/cue/mute \sphinxstyleemphasis{state}
&
where \sphinxstyleemphasis{state} is a float of 0.0
or 1.0 that shows the state of
the mute for the selected aux
bus.
\\
\hline
/cue/signal \sphinxstyleemphasis{activity}
&
where \sphinxstyleemphasis{activity} is a float of
0.0 or 1.0 that shows audio
activity for the selected aux
bus.
\\
\hline
/cue/send/name/\sphinxstyleemphasis{id} \sphinxstyleemphasis{name}
&
where \sphinxstyleemphasis{name} is a string that is
the name of the channel that send
\sphinxstyleemphasis{id} belongs to.
\\
\hline
/cue/send/fader/\sphinxstyleemphasis{id} \sphinxstyleemphasis{position}
&
where \sphinxstyleemphasis{position} is a float from
0.0 to 1.0 that is the position
for the fader for the send that
\sphinxstyleemphasis{id} belongs to.
\\
\hline
/cue/send/enable/\sphinxstyleemphasis{id} \sphinxstyleemphasis{state}
&
where \sphinxstyleemphasis{state} is a float of 0.0
or 1.0 that is the state of the
enable for the send that \sphinxstyleemphasis{id}
belongs to.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

While a fader is being adjusted, the corresponding \sphinxstyleemphasis{/}/name* text will
give the level in db.


\chapter{76.9 - OSC: Parameter Types}
\label{\detokenize{index:osc-parameter-types}}\label{\detokenize{index:osc58-parameter-types}}
An OSC message is laid out in this form:

/path/of/command type parameter

The type is there to indicate what the parameter is. This gives the idea
that parameter types are quite strict and if the command requires an
Integer \sphinxstyleemphasis{“i”} then the controller had better send it. However, the
checking of the parameter type is left to the receiving software.

What this means in practical terms is that the surface can get away with
sending the wrong type of parameter. There are some places where that
just doesn’t make sense. For example, a parameter that is specified as a
Float with a range of 0 to 1, could be sent as an Integer, but would
only have full scale and minimum value with nothing in between. This is
not much use for a fader, though OK for a button.

There are a number of OSC controllers based on iOS and Android tablets
that only send or receive parameters as floats or text. These
controllers should have no problem sending bool or int values as floats.
Ardour will interpret the values as required.


\chapter{76.10 - OSC: Selection and Expansion Considerations}
\label{\detokenize{index:osc-selection-and-expansion-considerations}}\label{\detokenize{index:osc58-selection-and-expansion-considerations}}
Ardour does not send every possible feedback value for each channel. It
does send expanded information on the selected channel. There are also
extra commands for the selected strip. All the feedback and select
commands have their own path \sphinxstyleemphasis{/select}. This means that for the selected
channel the surface does not have to keep track of the strip ID. The
/select strip will follow the “current mixer strip” in the GUI editor
window.

There are two major uses for this:
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
Single strip control surfaces. Using \sphinxstyleemphasis{/access\_action
Editor/select-next-route} or \sphinxstyleemphasis{/access\_action
Editor/select-prev-route} to step through the mixer strips.

\item {} 
Using a “Super strip” section of knobs to control parts of the strip
that are changed less often such as polarity, sends or plugin
parameters.

\end{enumerate}

Selection in Ardour’s OSC implementation are complicated by the
possibility of using more than one OSC controller at the same time. User
“A” may select strip 4 and use a selected controller to make changes to
that strip. User “B” may subsequently select strip 7 to make changes on.
This leaves user “A” making changes to strip 7 which they did not
choose.

For this reason Ardour offers local expansion aside from the GUI
selection. Local expansion only affects the one OSC controller. GUI
selection is global and affects all controllers using GUI selection as
well as the GUI.

Both select and expansion use the /select set of commands.

In general, in a one user situation where that one user may use either
the OSC surface or the GUI, using GUI based selection makes the most
sense. This is the default because this is the more common use.

When there is more than one operator, then expansion only is the mode of
choice. It may make sense for one of the surfaces to use GUI selection
where the operator is also using the GUI for some things. However, the
set up should be carefully analyzed for the possibility of selection
confusions. Expansion should be considered the \sphinxstyleemphasis{safe} option.

It is always OK to use expansion on the surface even in a one user
scenario. This allows the user to use GUI and surface selection for
different uses.

It is also possible to use both if desired. /strip/select will ways set
the GUI select, but /strip/expand will set the select feedback and
commands locally without changing the GUI select. Another /strip/expand
or a /strip/select will override that expand command and releasing the
/strip/expand or /select/expand (setting it to 0 or false) will set the
/select set of commands and feedback back to whichever strip the GUI has
selected at that time. This could be used to switch between the GUI
select and the local expand to compare two strips settings.


\chapter{76.11 - OSC control for Ardour 4.7 and Prior}
\label{\detokenize{index:osc-control-for-ardour-4-7-and-prior}}
This page is what was available before version 5.* was added. It has
not been updated to make sure all 4.7 functionality is accurately
represented. This page will vanish soon.

OSC lets synthesizers and other devices communicate with Ardour. OSC
devices can send commands relating to playback (such as play or stop),
performance (such as volume, play, stop, and almost any other function
(such as Edit, or Undo).

Ardour is probably one of the most OSC-controllable audio applications
around, but as with all OSC-controllable apps, you can’t do much without
knowing what messages can be sent. This document describes the various
categories of messages that Ardour understands. It is subject to change,
particularly the “Actions” part below, since this relates to the GTK GUI
for Ardour rather than the backend.


\section{Connecting to Ardour via OSC}
\label{\detokenize{index:connecting-to-ardour-via-osc-1}}\label{\detokenize{index:id63}}
OSC support is not enabled by default, but can be turned on via Edit \textgreater{}
Preferences \textgreater{} Control Surfaces. Once enabled, Ardour will listen on port
\sphinxcode{\sphinxupquote{3819}} by default. This port number can be changed by editing
\sphinxcode{\sphinxupquote{\$ARDOUR\_CONFIG}} and adding this line within the \sphinxcode{\sphinxupquote{\textless{}Config\textgreater{}}} section:

\textless{}Option name=”osc-port” value=”\sphinxstyleemphasis{Your choice here}”/\textgreater{}


\section{List of OSC messages}
\label{\detokenize{index:list-of-osc-messages-1}}\label{\detokenize{index:id64}}

\subsection{Transport Control}
\label{\detokenize{index:transport-control-2}}\label{\detokenize{index:id65}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

/ardour/transport\_stop
&\\
\hline
/ardour/transport\_play
&\\
\hline
/ardour/set\_transport\_speed \sphinxstyleemphasis{s}
&
where \sphinxstyleemphasis{s} is a float ranging from
-8.0f to 8.0f
\\
\hline
/ardour/ffwd
&\\
\hline
/ardour/rewind
&\\
\hline
/ardour/goto\_start
&\\
\hline
/ardour/goto\_end
&\\
\hline
/ardour/add\_marker
&
(adds marker to the current
transport position)
\\
\hline
/ardour/next\_marker
&\\
\hline
/ardour/prev\_marker
&\\
\hline
/ardour/locate \sphinxstyleemphasis{spos} \sphinxstyleemphasis{roll}
&
where \sphinxstyleemphasis{spos} is the target
position in samples and \sphinxstyleemphasis{roll} is
a bool/integer defining whether
you want transport to be kept
rolling or not
\\
\hline
/ardour/loop\_toggle
&\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsection{Editing-related}
\label{\detokenize{index:editing-related-1}}\label{\detokenize{index:id66}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

/ardour/undo
&\\
\hline
/ardour/redo
&\\
\hline
/ardour/save\_state
&
(this is the regular Session \textgreater{} Save operation)
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsection{Recording control}
\label{\detokenize{index:recording-control-2}}\label{\detokenize{index:id67}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

/ardour/toggle\_punch\_in
&\\
\hline
/ardour/toggle\_punch\_out
&\\
\hline
/ardour/rec\_enable\_toggle
&\\
\hline
/ardour/toggle\_all\_rec\_enables
&
(toggles all tracks’ recording state)
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsection{Track specific operations}
\label{\detokenize{index:track-specific-operations-2}}\label{\detokenize{index:id68}}
For each of the following, \sphinxstyleemphasis{rid} is the remote ID or the track


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

/ardour/routes/mute \sphinxstyleemphasis{rid}
\sphinxstyleemphasis{mute\_st}
&
where \sphinxstyleemphasis{mute\_st} is a bool/int
representing the desired mute
state of the track
\\
\hline
/ardour/routes/solo \sphinxstyleemphasis{rid}
\sphinxstyleemphasis{solo\_st}
&
where \sphinxstyleemphasis{solo\_st} is a bool/int
representing the desired solo
state of the track
\\
\hline
/ardour/routes/recenable \sphinxstyleemphasis{rid}
\sphinxstyleemphasis{rec\_st}
&
where \sphinxstyleemphasis{rec\_st} is a bool/int
representing the desired rec
state of the track
\\
\hline
/ardour/routes/gainabs \sphinxstyleemphasis{rid}
\sphinxstyleemphasis{gain\_abs}
&
where \sphinxstyleemphasis{gain\_abs} is a float
ranging from 0 to 2 (0 being
-infinite, 1 being 0dB and 2
being +6dB).
\\
\hline
/ardour/routes/gaindB \sphinxstyleemphasis{rid}
\sphinxstyleemphasis{gain\_db}
&
where \sphinxstyleemphasis{gain\_db} is a float
ranging from -400 to 6
representing the desired gain of
the track in dB.
\\
\hline
/ardour/routes/trimabs \sphinxstyleemphasis{rid}
\sphinxstyleemphasis{trim\_abs}
&
where \sphinxstyleemphasis{trim\_abs} is a float
ranging from 0.1 to 10 (-20dB to
+20dB). (since 4.1)
\\
\hline
/ardour/routes/trimdB \sphinxstyleemphasis{rid}
\sphinxstyleemphasis{trim\_db}
&
where \sphinxstyleemphasis{trim\_db} is a float
ranging from -20 to 20
representing the desired trim of
the track in dB. (since 4.1)
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsection{Menu actions}
\label{\detokenize{index:menu-actions-2}}\label{\detokenize{index:id69}}
Every single menu item in Ardour’s GUI is accessible via OSC. There is a
single common syntax to trigger the action as if it was selected with
the mouse (or keyboard):

/ardour/access\_action \sphinxstyleemphasis{action\_name}

The list below shows all available values of \sphinxstyleemphasis{action-name} as of
mid-February 2014 for Ardour 3.5. You can get the current list at any
time by running Ardour with the -b flag.


\begin{savenotes}\sphinxatlongtablestart\begin{longtable}{|l|l|}
\hline

\endfirsthead

\multicolumn{2}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} -- continued from previous page}}}\\
\hline

\endhead

\hline
\multicolumn{2}{r}{\makebox[0pt][r]{\sphinxtablecontinued{Continued on next page}}}\\
\endfoot

\endlastfoot

\sphinxstylestrong{Action Name}
&
\sphinxstylestrong{Menu Name}
\\
\hline
Common/Chat
&
Chat
\\
\hline
Common/KeepTearoffs
&
Show Toolbars
\\
\hline
Common/Manual
&
Manual
\\
\hline
Common/NewMIDITracer
&
MIDI Tracer
\\
\hline
Common/Quit
&
Quit
\\
\hline
Common/Reference
&
Reference
\\
\hline
Common/Save
&
Save
\\
\hline
Common/toggle-editor-mixer
&
Toggle Editor+Mixer
\\
\hline
Common/ToggleMaximalEditor
&
Maximise Editor Space
\\
\hline
Common/toggle-meterbridge
&
Meterbridge
\\
\hline
Common/toggle-mixer
&
Mixer
\\
\hline
Common/ToggleRecordEnableTrack10
&
Toggle Record Enable Track 10
\\
\hline
Common/ToggleRecordEnableTrack11
&
Toggle Record Enable Track 11
\\
\hline
Common/ToggleRecordEnableTrack12
&
Toggle Record Enable Track 12
\\
\hline
Common/ToggleRecordEnableTrack13
&
Toggle Record Enable Track 13
\\
\hline
Common/ToggleRecordEnableTrack14
&
Toggle Record Enable Track 14
\\
\hline
Common/ToggleRecordEnableTrack15
&
Toggle Record Enable Track 15
\\
\hline
Common/ToggleRecordEnableTrack16
&
Toggle Record Enable Track 16
\\
\hline
Common/ToggleRecordEnableTrack17
&
Toggle Record Enable Track 17
\\
\hline
Common/ToggleRecordEnableTrack18
&
Toggle Record Enable Track 18
\\
\hline
Common/ToggleRecordEnableTrack19
&
Toggle Record Enable Track 19
\\
\hline
Common/ToggleRecordEnableTrack1
&
Toggle Record Enable Track 1
\\
\hline
Common/ToggleRecordEnableTrack20
&
Toggle Record Enable Track 20
\\
\hline
Common/ToggleRecordEnableTrack21
&
Toggle Record Enable Track 21
\\
\hline
Common/ToggleRecordEnableTrack22
&
Toggle Record Enable Track 22
\\
\hline
Common/ToggleRecordEnableTrack23
&
Toggle Record Enable Track 23
\\
\hline
Common/ToggleRecordEnableTrack24
&
Toggle Record Enable Track 24
\\
\hline
Common/ToggleRecordEnableTrack25
&
Toggle Record Enable Track 25
\\
\hline
Common/ToggleRecordEnableTrack26
&
Toggle Record Enable Track 26
\\
\hline
Common/ToggleRecordEnableTrack27
&
Toggle Record Enable Track 27
\\
\hline
Common/ToggleRecordEnableTrack28
&
Toggle Record Enable Track 28
\\
\hline
Common/ToggleRecordEnableTrack29
&
Toggle Record Enable Track 29
\\
\hline
Common/ToggleRecordEnableTrack2
&
Toggle Record Enable Track 2
\\
\hline
Common/ToggleRecordEnableTrack30
&
Toggle Record Enable Track 30
\\
\hline
Common/ToggleRecordEnableTrack31
&
Toggle Record Enable Track 31
\\
\hline
Common/ToggleRecordEnableTrack32
&
Toggle Record Enable Track 32
\\
\hline
Common/ToggleRecordEnableTrack3
&
Toggle Record Enable Track 3
\\
\hline
Common/ToggleRecordEnableTrack4
&
Toggle Record Enable Track 4
\\
\hline
Common/ToggleRecordEnableTrack5
&
Toggle Record Enable Track 5
\\
\hline
Common/ToggleRecordEnableTrack6
&
Toggle Record Enable Track 6
\\
\hline
Common/ToggleRecordEnableTrack7
&
Toggle Record Enable Track 7
\\
\hline
Common/ToggleRecordEnableTrack8
&
Toggle Record Enable Track 8
\\
\hline
Common/ToggleRecordEnableTrack9
&
Toggle Record Enable Track 9
\\
\hline
Editor/addExistingAudioFiles
&
Import
\\
\hline
Editor/addExternalAudioToRegionLi
st
&
Import to Region List…
\\
\hline
Editor/add-location-from-playhead
&
Add Mark from Playhead
\\
\hline
Editor/center-edit-cursor
&
Center Edit Point
\\
\hline
Editor/center-playhead
&
Center Playhead
\\
\hline
Editor/crop
&
Crop
\\
\hline
Editor/cycle-edit-point
&
Change Edit Point
\\
\hline
Editor/cycle-edit-point-with-mark
er
&
Change Edit Point Including
Marker
\\
\hline
Editor/cycle-snap-mode
&
Next Snap Mode
\\
\hline
Editor/cycle-zoom-focus
&
Next Zoom Focus
\\
\hline
Editor/deselect-all
&
Deselect All
\\
\hline
Editor/duplicate-range
&
Duplicate Range
\\
\hline
Editor/edit-at-mouse
&
Mouse
\\
\hline
Editor/edit-at-playhead
&
Playhead
\\
\hline
Editor/edit-at-selected-marker
&
Marker
\\
\hline
Editor/edit-cursor-to-next-region
-end
&
To Next Region End
\\
\hline
Editor/edit-cursor-to-next-region
-start
&
To Next Region Start
\\
\hline
Editor/edit-cursor-to-next-region
-sync
&
To Next Region Sync
\\
\hline
Editor/edit-cursor-to-previous-re
gion-end
&
To Previous Region End
\\
\hline
Editor/edit-cursor-to-previous-re
gion-start
&
To Previous Region Start
\\
\hline
Editor/edit-cursor-to-previous-re
gion-sync
&
To Previous Region Sync
\\
\hline
Editor/edit-cursor-to-range-end
&
To Range End
\\
\hline
Editor/edit-cursor-to-range-start
&
To Range Start
\\
\hline
Editor/editor-copy
&
Copy
\\
\hline
Editor/editor-crop
&
Crop
\\
\hline
Editor/editor-cut
&
Cut
\\
\hline
Editor/editor-delete
&
Delete
\\
\hline
Editor/editor-paste
&
Paste
\\
\hline
Editor/editor-separate
&
Separate
\\
\hline
Editor/edit-to-playhead
&
Active Mark to Playhead
\\
\hline
Editor/escape
&
Break drag or deselect all
\\
\hline
Editor/expand-tracks
&
Expand Track Height
\\
\hline
Editor/export-audio
&
Export Audio
\\
\hline
Editor/export-range
&
Export Range
\\
\hline
Editor/finish-add-range
&
Finish Add Range
\\
\hline
Editor/finish-range
&
Finish Range
\\
\hline
Editor/fit-tracks
&
Fit Selected Tracks
\\
\hline
Editor/goto-mark-1
&
Locate to Mark 1
\\
\hline
Editor/goto-mark-2
&
Locate to Mark 2
\\
\hline
Editor/goto-mark-3
&
Locate to Mark 3
\\
\hline
Editor/goto-mark-4
&
Locate to Mark 4
\\
\hline
Editor/goto-mark-5
&
Locate to Mark 5
\\
\hline
Editor/goto-mark-6
&
Locate to Mark 6
\\
\hline
Editor/goto-mark-7
&
Locate to Mark 7
\\
\hline
Editor/goto-mark-8
&
Locate to Mark 8
\\
\hline
Editor/goto-mark-9
&
Locate to Mark 9
\\
\hline
Editor/goto-visual-state-10
&
Goto View 10
\\
\hline
Editor/goto-visual-state-11
&
Goto View 11
\\
\hline
Editor/goto-visual-state-12
&
Goto View 12
\\
\hline
Editor/goto-visual-state-1
&
Goto View 1
\\
\hline
Editor/goto-visual-state-2
&
Goto View 2
\\
\hline
Editor/goto-visual-state-3
&
Goto View 3
\\
\hline
Editor/goto-visual-state-4
&
Goto View 4
\\
\hline
Editor/goto-visual-state-5
&
Goto View 5
\\
\hline
Editor/goto-visual-state-6
&
Goto View 6
\\
\hline
Editor/goto-visual-state-7
&
Goto View 7
\\
\hline
Editor/goto-visual-state-8
&
Goto View 8
\\
\hline
Editor/goto-visual-state-9
&
Goto View 9
\\
\hline
Editor/importFromSession
&
Import From Session
\\
\hline
Editor/insert-time
&
Insert Time
\\
\hline
Editor/invert-selection
&
Invert Selection
\\
\hline
Editor/jump-backward-to-mark
&
Jump to Previous Mark
\\
\hline
Editor/jump-forward-to-mark
&
Jump to Next Mark
\\
\hline
Editor/main-menu-play-selected-re
gions
&
Play Selected Regions
\\
\hline
EditorMenu/AlignMenu
&
Align
\\
\hline
EditorMenu/Autoconnect
&
Autoconnect
\\
\hline
EditorMenu/Crossfades
&
Crossfades
\\
\hline
EditorMenu/EditCursorMovementOpti
ons
&
Move Selected Marker
\\
\hline
EditorMenu/Edit
&
Edit
\\
\hline
EditorMenu/EditPointMenu
&
Edit Point
\\
\hline
EditorMenu/EditSelectRangeOptions
&
Select Range Operations
\\
\hline
EditorMenu/EditSelectRegionOption
s
&
Select Regions
\\
\hline
EditorMenu/FadeMenu
&
Fade
\\
\hline
EditorMenu/LatchMenu
&
Latch
\\
\hline
EditorMenu/Link
&
Link
\\
\hline
EditorMenu/LocateToMarker
&
Locate to Markers
\\
\hline
EditorMenu/MarkerMenu
&
Markers
\\
\hline
EditorMenu/MeterFalloff
&
Meter falloff
\\
\hline
EditorMenu/MeterHold
&
Meter hold
\\
\hline
EditorMenu/MIDI
&
MIDI Options
\\
\hline
EditorMenu/MiscOptions
&
Misc Options
\\
\hline
EditorMenu/Monitoring
&
Monitoring
\\
\hline
EditorMenu/MoveActiveMarkMenu
&
Active Mark
\\
\hline
EditorMenu/MovePlayHeadMenu
&
Playhead
\\
\hline
EditorMenu/PlayMenu
&
Play
\\
\hline
EditorMenu/PrimaryClockMenu
&
Primary Clock
\\
\hline
EditorMenu/Pullup
&
Pullup / Pulldown
\\
\hline
EditorMenu/RegionEditOps
&
Region operations
\\
\hline
EditorMenu/RegionGainMenu
&
Gain
\\
\hline
EditorMenu/RegionMenuDuplicate
&
Duplicate
\\
\hline
EditorMenu/RegionMenuEdit
&
Edit
\\
\hline
EditorMenu/RegionMenuFades
&
Fades
\\
\hline
EditorMenu/RegionMenuGain
&
Gain
\\
\hline
EditorMenu/RegionMenu
&
Region
\\
\hline
EditorMenu/RegionMenuLayering
&
Layering
\\
\hline
EditorMenu/RegionMenuMIDI
&
MIDI
\\
\hline
EditorMenu/RegionMenuPosition
&
Position
\\
\hline
EditorMenu/RegionMenuRanges
&
Ranges
\\
\hline
EditorMenu/RegionMenuTrim
&
Trim
\\
\hline
EditorMenu/RulerMenu
&
Rulers
\\
\hline
EditorMenu/SavedViewMenu
&
Views
\\
\hline
EditorMenu/ScrollMenu
&
Scroll
\\
\hline
EditorMenu/SecondaryClockMenu
&
Secondary Clock
\\
\hline
EditorMenu/Select
&
Select
\\
\hline
EditorMenu/SelectMenu
&
Select
\\
\hline
EditorMenu/SeparateMenu
&
Separate
\\
\hline
EditorMenu/SetLoopMenu
&
Loop
\\
\hline
EditorMenu/SetPunchMenu
&
Punch
\\
\hline
EditorMenu/Solo
&
Solo
\\
\hline
EditorMenu/Subframes
&
Subframes
\\
\hline
EditorMenu/SyncMenu
&
Sync
\\
\hline
EditorMenu/TempoMenu
&
Tempo
\\
\hline
EditorMenu/Timecode
&
Timecode fps
\\
\hline
EditorMenu/Tools
&
Tools
\\
\hline
EditorMenu/TrackHeightMenu
&
Height
\\
\hline
EditorMenu/TrackMenu
&
Track
\\
\hline
EditorMenu/VideoMonitorMenu
&
Video Monitor
\\
\hline
EditorMenu/View
&
View
\\
\hline
EditorMenu/ZoomFocus
&
Zoom Focus
\\
\hline
EditorMenu/ZoomFocusMenu
&
Zoom Focus
\\
\hline
EditorMenu/ZoomMenu
&
Zoom
\\
\hline
Editor/move-range-end-to-next-reg
ion-boundary
&
Move Range End to Next Region
Boundary
\\
\hline
Editor/move-range-end-to-previous
-region-boundary
&
Move Range End to Previous Region
Boundary
\\
\hline
Editor/move-range-start-to-next-r
egion-boundary
&
Move Range Start to Next Region
Boundary
\\
\hline
Editor/move-range-start-to-previo
us-region-boundary
&
Move Range Start to Previous
Region Boundary
\\
\hline
Editor/move-selected-tracks-down
&
Move Selected Tracks Down
\\
\hline
Editor/move-selected-tracks-up
&
Move Selected Tracks Up
\\
\hline
Editor/next-snap-choice
&
Next Snap Choice
\\
\hline
Editor/next-snap-choice-music-onl
y
&
Next Musical Snap Choice
\\
\hline
Editor/nudge-next-backward
&
Nudge Next Earlier
\\
\hline
Editor/nudge-next-forward
&
Nudge Next Later
\\
\hline
Editor/nudge-playhead-backward
&
Nudge Playhead Backward
\\
\hline
Editor/nudge-playhead-forward
&
Nudge Playhead Forward
\\
\hline
Editor/play-edit-range
&
Play Edit Range
\\
\hline
Editor/play-from-edit-point-and-r
eturn
&
Play from Edit Point and Return
\\
\hline
Editor/play-from-edit-point
&
Play From Edit Point
\\
\hline
Editor/playhead-backward-to-grid
&
Playhead To Previous Grid
\\
\hline
Editor/playhead-forward-to-grid
&
Playhead To Next Grid
\\
\hline
Editor/playhead-to-edit
&
Playhead to Active Mark
\\
\hline
Editor/playhead-to-next-region-bo
undary
&
Playhead to Next Region Boundary
\\
\hline
Editor/playhead-to-next-region-bo
undary-noselection
&
Playhead to Next Region Boundary
(No Track Selection)
\\
\hline
Editor/playhead-to-next-region-en
d
&
Playhead to Next Region End
\\
\hline
Editor/playhead-to-next-region-st
art
&
Playhead to Next Region Start
\\
\hline
Editor/playhead-to-next-region-sy
nc
&
Playhead to Next Region Sync
\\
\hline
Editor/playhead-to-previous-regio
n-boundary
&
Playhead to Previous Region
Boundary
\\
\hline
Editor/playhead-to-previous-regio
n-boundary-noselection
&
Playhead to Previous Region
Boundary (No Track Selection)
\\
\hline
Editor/playhead-to-previous-regio
n-end
&
Playhead to Previous Region End
\\
\hline
Editor/playhead-to-previous-regio
n-start
&
Playhead to Previous Region Start
\\
\hline
Editor/playhead-to-previous-regio
n-sync
&
Playhead to Previous Region Sync
\\
\hline
Editor/playhead-to-range-end
&
Playhead to Range End
\\
\hline
Editor/playhead-to-range-start
&
Playhead to Range Start
\\
\hline
Editor/prev-snap-choice
&
Previous Snap Choice
\\
\hline
Editor/prev-snap-choice-music-onl
y
&
Previous Musical Snap Choice
\\
\hline
Editor/redo
&
Redo
\\
\hline
Editor/remove-last-capture
&
Remove Last Capture
\\
\hline
Editor/remove-track
&
Remove
\\
\hline
Editor/save-visual-state-10
&
Save View 10
\\
\hline
Editor/save-visual-state-11
&
Save View 11
\\
\hline
Editor/save-visual-state-12
&
Save View 12
\\
\hline
Editor/save-visual-state-1
&
Save View 1
\\
\hline
Editor/save-visual-state-2
&
Save View 2
\\
\hline
Editor/save-visual-state-3
&
Save View 3
\\
\hline
Editor/save-visual-state-4
&
Save View 4
\\
\hline
Editor/save-visual-state-5
&
Save View 5
\\
\hline
Editor/save-visual-state-6
&
Save View 6
\\
\hline
Editor/save-visual-state-7
&
Save View 7
\\
\hline
Editor/save-visual-state-8
&
Save View 8
\\
\hline
Editor/save-visual-state-9
&
Save View 9
\\
\hline
Editor/scroll-backward
&
Scroll Backward
\\
\hline
Editor/scroll-forward
&
Scroll Forward
\\
\hline
Editor/scroll-playhead-backward
&
Playhead Backward
\\
\hline
Editor/scroll-playhead-forward
&
Playhead Forward
\\
\hline
Editor/scroll-tracks-down
&
Scroll Tracks Down
\\
\hline
Editor/scroll-tracks-up
&
Scroll Tracks Up
\\
\hline
Editor/select-all-after-edit-curs
or
&
Select All After Edit Point
\\
\hline
Editor/select-all-before-edit-cur
sor
&
Select All Before Edit Point
\\
\hline
Editor/select-all-between-cursors
&
Select All Overlapping Edit Range
\\
\hline
Editor/select-all-in-loop-range
&
Select All in Loop Range
\\
\hline
Editor/select-all-in-punch-range
&
Select All in Punch Range
\\
\hline
Editor/select-all
&
Select All
\\
\hline
Editor/select-all-within-cursors
&
Select All Inside Edit Range
\\
\hline
Editor/selected-marker-to-next-re
gion-boundary
&
To Next Region Boundary
\\
\hline
Editor/selected-marker-to-next-re
gion-boundary-noselection
&
To Next Region Boundary (No Track
Selection)
\\
\hline
Editor/selected-marker-to-previou
s-region-boundary
&
To Previous Region Boundary
\\
\hline
Editor/selected-marker-to-previou
s-region-boundary-noselection
&
To Previous Region Boundary (No
Track Selection)
\\
\hline
Editor/select-next-route
&
Select Next Track or Bus
\\
\hline
Editor/select-prev-route
&
Select Previous Track or Bus
\\
\hline
Editor/select-range-between-curso
rs
&
Select Edit Range
\\
\hline
Editor/separate-from-loop
&
Separate Using Loop Range
\\
\hline
Editor/separate-from-punch
&
Separate Using Punch Range
\\
\hline
Editor/set-edit-lock
&
Lock
\\
\hline
Editor/set-edit-point
&
Active Marker to Mouse
\\
\hline
Editor/set-edit-slide
&
Slide
\\
\hline
Editor/set-edit-splice
&
Splice
\\
\hline
Editor/set-loop-from-edit-range
&
Set Loop from Edit Range
\\
\hline
Editor/set-playhead
&
Playhead to Mouse
\\
\hline
Editor/set-punch-from-edit-range
&
Set Punch from Edit Range
\\
\hline
Editor/set-tempo-from-edit-range
&
Set Tempo from Edit Range = Bar
\\
\hline
Editor/show-editor-list
&
Show Editor List
\\
\hline
Editor/show-editor-mixer
&
Show Editor Mixer
\\
\hline
Editor/show-marker-lines
&
Show Marker Lines
\\
\hline
Editor/shrink-tracks
&
Shrink Track Height
\\
\hline
Editor/snap-magnetic
&
Magnetic
\\
\hline
Editor/SnapMode
&
Snap Mode
\\
\hline
Editor/snap-normal
&
Grid
\\
\hline
Editor/snap-off
&
No Grid
\\
\hline
Editor/SnapTo
&
Snap to
\\
\hline
Editor/sound-midi-notes
&
Sound Selected MIDI Notes
\\
\hline
Editor/start-range
&
Start Range
\\
\hline
Editor/step-mouse-mode
&
Step Mouse Mode
\\
\hline
Editor/step-tracks-down
&
Step Tracks Down
\\
\hline
Editor/step-tracks-up
&
Step Tracks Up
\\
\hline
Editor/tab-to-transient-backwards
&
Move Earlier to Transient
\\
\hline
Editor/tab-to-transient-forwards
&
Move Later to Transient
\\
\hline
Editor/temporal-zoom-in
&
Zoom In
\\
\hline
Editor/temporal-zoom-out
&
Zoom Out
\\
\hline
Editor/toggle-edit-mode
&
Toggle Edit Mode
\\
\hline
Editor/toggle-follow-playhead
&
Follow Playhead
\\
\hline
Editor/ToggleGroupTabs
&
Show Group Tabs
\\
\hline
Editor/ToggleJadeo
&
Video Monitor
\\
\hline
Editor/ToggleLogoVisibility
&
Show Logo
\\
\hline
Editor/toggle-log-window
&
Log
\\
\hline
Editor/ToggleMeasureVisibility
&
Show Measures
\\
\hline
Editor/toggle-midi-input-active
&
Toggle MIDI Input Active for
Editor-Selected Tracks/Busses
\\
\hline
Editor/toggle-stationary-playhead
&
Stationary Playhead
\\
\hline
Editor/ToggleSummary
&
Show Summary
\\
\hline
Editor/toggle-track-active
&
Toggle Active
\\
\hline
Editor/toggle-vmon-frame
&
Frame number
\\
\hline
Editor/toggle-vmon-fullscreen
&
Fullscreen
\\
\hline
Editor/toggle-vmon-letterbox
&
Letterbox
\\
\hline
Editor/toggle-vmon-ontop
&
Always on Top
\\
\hline
Editor/toggle-vmon-osdbg
&
Timecode Background
\\
\hline
Editor/toggle-vmon-timecode
&
Timecode
\\
\hline
Editor/toggle-zoom
&
Toggle Zoom State
\\
\hline
Editor/track-height-large
&
Large
\\
\hline
Editor/track-height-larger
&
Larger
\\
\hline
Editor/track-height-largest
&
Largest
\\
\hline
Editor/track-height-normal
&
Normal
\\
\hline
Editor/track-height-small
&
Small
\\
\hline
Editor/track-mute-toggle
&
Toggle Mute
\\
\hline
Editor/track-record-enable-toggle
&
Toggle Record Enable
\\
\hline
Editor/track-solo-isolate-toggle
&
Toggle Solo Isolate
\\
\hline
Editor/track-solo-toggle
&
Toggle Solo
\\
\hline
Editor/undo
&
Undo
\\
\hline
Editor/zoom-to-region-both-axes
&
Zoom to Region (Width and Height)
\\
\hline
Editor/zoom-to-region
&
Zoom to Region
\\
\hline
Editor/zoom-to-session
&
Zoom to Session
\\
\hline
Editor/zoom-vmon-100
&
Original Size
\\
\hline
Main/AddTrackBus
&
Add Track or Bus…
\\
\hline
Main/CleanupUnused
&
Clean-up Unused Sources…
\\
\hline
Main/Close
&
Close
\\
\hline
Main/CloseVideo
&
Remove Video
\\
\hline
Main/EditMetadata
&
Edit Metadata…
\\
\hline
Main/ExportAudio
&
Export To Audio File(s)…
\\
\hline
Main/Export
&
Export
\\
\hline
Main/ExportVideo
&
Export To Video File
\\
\hline
Main/FlushWastebasket
&
Flush Wastebasket
\\
\hline
Main/ImportMetadata
&
Import Metadata…
\\
\hline
Main\_menu/AudioFileFormatData
&
Sample Format
\\
\hline
Main\_menu/AudioFileFormatHeader
&
File Type
\\
\hline
Main\_menu/AudioFileFormat
&
Audio File Format
\\
\hline
Main\_menu/Cleanup
&
Clean-up
\\
\hline
Main\_menu/ControlSurfaces
&
Control Surfaces
\\
\hline
Main\_menu/Denormals
&
Denormal Handling
\\
\hline
Main\_menu/Help
&
Help
\\
\hline
Main\_menu/KeyMouseActions
&
Misc. Shortcuts
\\
\hline
Main\_menu/MeteringFallOffRate
&
Fall Off Rate
\\
\hline
Main\_menu/MeteringHoldTime
&
Hold Time
\\
\hline
Main\_menu/Metering
&
Metering
\\
\hline
Main\_menu/Plugins
&
Plugins
\\
\hline
Main\_menu/Session
&
Session
\\
\hline
Main\_menu/Sync
&
Sync
\\
\hline
Main\_menu/TransportOptions
&
Options
\\
\hline
Main\_menu/WindowMenu
&
Window
\\
\hline
Main/Metadata
&
Metadata
\\
\hline
Main/New
&
New…
\\
\hline
Main/Open
&
Open…
\\
\hline
Main/OpenVideo
&
Open Video
\\
\hline
Main/Recent
&
Recent…
\\
\hline
Main/Rename
&
Rename…
\\
\hline
Main/SaveAs
&
Save As…
\\
\hline
Main/SaveTemplate
&
Save Template…
\\
\hline
Main/Snapshot
&
Snapshot…
\\
\hline
Main/StemExport
&
Stem export…
\\
\hline
MIDI/panic
&
Panic
\\
\hline
MouseMode/set-mouse-mode-audition
&
Audition Tool
\\
\hline
MouseMode/set-mouse-mode-draw
&
Note Drawing Tool
\\
\hline
MouseMode/set-mouse-mode-gain
&
Gain Tool
\\
\hline
MouseMode/set-mouse-mode-object
&
Object Tool
\\
\hline
MouseMode/set-mouse-mode-object-r
ange
&
Smart Object Mode
\\
\hline
MouseMode/set-mouse-mode-range
&
Range Tool
\\
\hline
MouseMode/set-mouse-mode-timefx
&
Time FX Tool
\\
\hline
MouseMode/set-mouse-mode-zoom
&
Zoom Tool
\\
\hline
MouseMode/toggle-internal-edit
&
Edit MIDI
\\
\hline
options/SendMidiClock
&
Send MIDI Clock
\\
\hline
options/SendMIDIfeedback
&
Send MIDI Feedback
\\
\hline
options/SendMMC
&
Send MMC
\\
\hline
options/SendMTC
&
Send MTC
\\
\hline
options/UseMMC
&
Use MMC
\\
\hline
ProcessorMenu/ab\_plugins
&
A/B Plugins
\\
\hline
ProcessorMenu/activate\_all
&
Activate All
\\
\hline
ProcessorMenu/clear
&
Clear (all)
\\
\hline
ProcessorMenu/clear\_post
&
Clear (post-fader)
\\
\hline
ProcessorMenu/clear\_pre
&
Clear (pre-fader)
\\
\hline
ProcessorMenu/controls
&
Controls
\\
\hline
ProcessorMenu/copy
&
Copy
\\
\hline
ProcessorMenu/cut
&
Cut
\\
\hline
ProcessorMenu/deactivate\_all
&
Deactivate All
\\
\hline
ProcessorMenu/delete
&
Delete
\\
\hline
ProcessorMenu/deselectall
&
Deselect All
\\
\hline
ProcessorMenu/edit-generic
&
Edit with generic controls…
\\
\hline
ProcessorMenu/edit
&
Edit…
\\
\hline
ProcessorMenu/newaux
&
New Aux Send …
\\
\hline
ProcessorMenu/newinsert
&
New Insert
\\
\hline
ProcessorMenu/newplugin
&
New Plugin
\\
\hline
ProcessorMenu/newsend
&
New External Send …
\\
\hline
ProcessorMenu/paste
&
Paste
\\
\hline
ProcessorMenu/rename
&
Rename
\\
\hline
ProcessorMenu/selectall
&
Select All
\\
\hline
ProcessorMenu/send\_options
&
Send Options
\\
\hline
Region/add-range-marker-from-regi
on
&
Add Single Range Marker
\\
\hline
Region/add-range-markers-from-reg
ion
&
Add Range Marker Per Region
\\
\hline
Region/align-regions-end
&
Align End
\\
\hline
Region/align-regions-end-relative
&
Align End Relative
\\
\hline
Region/align-regions-start
&
Align Start
\\
\hline
Region/align-regions-start-relati
ve
&
Align Start Relative
\\
\hline
Region/align-regions-sync
&
Align Sync
\\
\hline
Region/align-regions-sync-relativ
e
&
Align Sync Relative
\\
\hline
Region/analyze-region
&
Spectral Analysis…
\\
\hline
Region/boost-region-gain
&
Boost Gain
\\
\hline
Region/bounce-regions-processed
&
Bounce (without processing)
\\
\hline
Region/bounce-regions-unprocessed
&
Bounce (with processing)
\\
\hline
Region/choose-top-region-context-
menu
&
Choose Top…
\\
\hline
Region/choose-top-region
&
Choose Top…
\\
\hline
Region/close-region-gaps
&
Close Gaps
\\
\hline
Region/combine-regions
&
Combine
\\
\hline
Region/cut-region-gain
&
Cut Gain
\\
\hline
Region/duplicate-region
&
Duplicate
\\
\hline
Region/export-region
&
Export…
\\
\hline
Region/fork-region
&
Unlink from other copies
\\
\hline
Region/insert-patch-change-contex
t
&
Insert Patch Change…
\\
\hline
Region/insert-patch-change
&
Insert Patch Change…
\\
\hline
Region/insert-region-from-region-
list
&
Insert Region From Region List
\\
\hline
RegionList/RegionListSort
&
Sort
\\
\hline
RegionList/removeUnusedRegions
&
Remove Unused
\\
\hline
RegionList/rlAudition
&
Audition
\\
\hline
RegionList/rlHide
&
Hide
\\
\hline
RegionList/rlShowAll
&
Show All
\\
\hline
RegionList/rlShowAuto
&
Show Automatic Regions
\\
\hline
RegionList/rlShow
&
Show
\\
\hline
RegionList/SortAscending
&
Ascending
\\
\hline
RegionList/SortByRegionEndinFile
&
By Region End in File
\\
\hline
RegionList/SortByRegionLength
&
By Region Length
\\
\hline
RegionList/SortByRegionName
&
By Region Name
\\
\hline
RegionList/SortByRegionPosition
&
By Region Position
\\
\hline
RegionList/SortByRegionStartinFil
e
&
By Region Start in File
\\
\hline
RegionList/SortByRegionTimestamp
&
By Region Timestamp
\\
\hline
RegionList/SortBySourceFileCreati
onDate
&
By Source File Creation Date
\\
\hline
RegionList/SortBySourceFileLength
&
By Source File Length
\\
\hline
RegionList/SortBySourceFileName
&
By Source File Name
\\
\hline
RegionList/SortBySourceFilesystem
&
By Source Filesystem
\\
\hline
RegionList/SortDescending
&
Descending
\\
\hline
Region/loop-region
&
Loop
\\
\hline
Region/lower-region
&
Lower
\\
\hline
Region/lower-region-to-bottom
&
Lower to Bottom
\\
\hline
Region/multi-duplicate-region
&
Multi-Duplicate…
\\
\hline
Region/naturalize-region
&
Move to Original Position
\\
\hline
Region/normalize-region
&
Normalize…
\\
\hline
Region/nudge-backward-by-capture-
offset
&
Nudge Earlier by Capture Offset
\\
\hline
Region/nudge-backward
&
Nudge Earlier
\\
\hline
Region/nudge-forward-by-capture-o
ffset
&
Nudge Later by Capture Offset
\\
\hline
Region/nudge-forward
&
Nudge Later
\\
\hline
Region/pitch-shift-region
&
Pitch Shift…
\\
\hline
Region/place-transient
&
Place Transient
\\
\hline
Region/play-selected-regions
&
Play
\\
\hline
Region/quantize-region
&
Quantize…
\\
\hline
Region/raise-region
&
Raise
\\
\hline
Region/raise-region-to-top
&
Raise to Top
\\
\hline
Region/region-fill-track
&
Fill Track
\\
\hline
Region/remove-region
&
Remove
\\
\hline
Region/remove-region-sync
&
Remove Sync
\\
\hline
Region/rename-region
&
Rename…
\\
\hline
Region/reset-region-gain-envelope
s
&
Reset Envelope
\\
\hline
Region/reset-region-scale-amplitu
de
&
Reset Gain
\\
\hline
Region/reverse-region
&
Reverse
\\
\hline
Region/separate-under-region
&
Separate Under
\\
\hline
Region/set-fade-in-length
&
Set Fade In Length
\\
\hline
Region/set-fade-out-length
&
Set Fade Out Length
\\
\hline
Region/set-loop-from-region
&
Set Loop Range
\\
\hline
Region/set-punch-from-region
&
Set Punch
\\
\hline
Region/set-region-sync-position
&
Set Sync Position
\\
\hline
Region/set-selection-from-region
&
Set Range Selection
\\
\hline
Region/set-tempo-from-region
&
Set Tempo from Region = Bar
\\
\hline
Region/show-region-list-editor
&
List Editor…
\\
\hline
Region/show-region-properties
&
Properties…
\\
\hline
Region/show-rhythm-ferret
&
Rhythm Ferret…
\\
\hline
Region/snap-regions-to-grid
&
Snap Position To Grid
\\
\hline
Region/split-multichannel-region
&
Make Mono Regions
\\
\hline
Region/split-region-at-transients
&
Split at Percussion Onsets
\\
\hline
Region/split-region
&
Split
\\
\hline
Region/strip-region-silence
&
Strip Silence…
\\
\hline
Region/toggle-opaque-region
&
Opaque
\\
\hline
Region/toggle-region-fade-in
&
Fade In
\\
\hline
Region/toggle-region-fade-out
&
Fade Out
\\
\hline
Region/toggle-region-fades
&
Fades
\\
\hline
Region/toggle-region-gain-envelop
e-active
&
Envelope Active
\\
\hline
Region/toggle-region-lock
&
Lock
\\
\hline
Region/toggle-region-lock-style
&
Glue to Bars and Beats
\\
\hline
Region/toggle-region-mute
&
Mute
\\
\hline
Region/toggle-region-video-lock
&
Lock to Video
\\
\hline
Region/transpose-region
&
Transpose…
\\
\hline
Region/trim-back
&
Trim End at Edit Point
\\
\hline
Region/trim-front
&
Trim Start at Edit Point
\\
\hline
Region/trim-region-to-loop
&
Trim to Loop
\\
\hline
Region/trim-region-to-punch
&
Trim to Punch
\\
\hline
Region/trim-to-next-region
&
Trim to Next
\\
\hline
Region/trim-to-previous-region
&
Trim to Previous
\\
\hline
Region/uncombine-regions
&
Uncombine
\\
\hline
Rulers/toggle-bbt-ruler
&
Bars \& Beats
\\
\hline
Rulers/toggle-cd-marker-ruler
&
CD Markers
\\
\hline
Rulers/toggle-loop-punch-ruler
&
Loop/Punch
\\
\hline
Rulers/toggle-marker-ruler
&
Markers
\\
\hline
Rulers/toggle-meter-ruler
&
Meter
\\
\hline
Rulers/toggle-minsec-ruler
&
Min:Sec
\\
\hline
Rulers/toggle-range-ruler
&
Ranges
\\
\hline
Rulers/toggle-samples-ruler
&
Samples
\\
\hline
Rulers/toggle-tempo-ruler
&
Tempo
\\
\hline
Rulers/toggle-timecode-ruler
&
Timecode
\\
\hline
Rulers/toggle-video-ruler
&
Video
\\
\hline
ShuttleActions/SetShuttleUnitsPer
centage
&
Percentage
\\
\hline
ShuttleActions/SetShuttleUnitsSem
itones
&
Semitones
\\
\hline
Snap/snap-to-asixteenthbeat
&
Snap to Sixteenths
\\
\hline
Snap/snap-to-bar
&
Snap to Bar
\\
\hline
Snap/snap-to-beat
&
Snap to Beat
\\
\hline
Snap/snap-to-cd-frame
&
Snap to CD Frame
\\
\hline
Snap/snap-to-eighths
&
Snap to Eighths
\\
\hline
Snap/snap-to-fifths
&
Snap to Fifths
\\
\hline
Snap/snap-to-fourteenths
&
Snap to Fourteenths
\\
\hline
Snap/snap-to-halves
&
Snap to Halves
\\
\hline
Snap/snap-to-mark
&
Snap to Mark
\\
\hline
Snap/snap-to-minutes
&
Snap to Minutes
\\
\hline
Snap/snap-to-onetwentyeighths
&
Snap to One Twenty Eighths
\\
\hline
Snap/snap-to-quarters
&
Snap to Quarters
\\
\hline
Snap/snap-to-region-boundary
&
Snap to Region Boundary
\\
\hline
Snap/snap-to-region-end
&
Snap to Region End
\\
\hline
Snap/snap-to-region-start
&
Snap to Region Start
\\
\hline
Snap/snap-to-region-sync
&
Snap to Region Sync
\\
\hline
Snap/snap-to-seconds
&
Snap to Seconds
\\
\hline
Snap/snap-to-sevenths
&
Snap to Sevenths
\\
\hline
Snap/snap-to-sixths
&
Snap to Sixths
\\
\hline
Snap/snap-to-sixtyfourths
&
Snap to Sixty Fourths
\\
\hline
Snap/snap-to-tenths
&
Snap to Tenths
\\
\hline
Snap/snap-to-thirds
&
Snap to Thirds
\\
\hline
Snap/snap-to-thirtyseconds
&
Snap to Thirty Seconds
\\
\hline
Snap/snap-to-timecode-frame
&
Snap to Timecode Frame
\\
\hline
Snap/snap-to-timecode-minutes
&
Snap to Timecode Minutes
\\
\hline
Snap/snap-to-timecode-seconds
&
Snap to Timecode Seconds
\\
\hline
Snap/snap-to-twelfths
&
Snap to Twelfths
\\
\hline
Snap/snap-to-twentieths
&
Snap to Twentieths
\\
\hline
Snap/snap-to-twentyeighths
&
Snap to Twenty Eighths
\\
\hline
Snap/snap-to-twentyfourths
&
Snap to Twenty Fourths
\\
\hline
Transport/focus-on-clock
&
Focus On Clock
\\
\hline
Transport/ForwardFast
&
Forward (Fast)
\\
\hline
Transport/Forward
&
Forward
\\
\hline
Transport/ForwardSlow
&
Forward (Slow)
\\
\hline
Transport/GotoEnd
&
Goto End
\\
\hline
Transport/GotoStart
&
Goto Start
\\
\hline
Transport/GotoWallClock
&
Goto Wall Clock
\\
\hline
Transport/GotoZero
&
Goto Zero
\\
\hline
Transport/Loop
&
Play Loop Range
\\
\hline
Transport/PlayPreroll
&
Play Selection w/Preroll
\\
\hline
Transport/PlaySelection
&
Play Selected Range
\\
\hline
Transport/primary-clock-bbt
&
Bars \& Beats
\\
\hline
Transport/primary-clock-minsec
&
Minutes \& Seconds
\\
\hline
Transport/primary-clock-samples
&
Samples
\\
\hline
Transport/primary-clock-timecode
&
Timecode
\\
\hline
Transport/Record
&
Enable Record
\\
\hline
Transport/record-roll
&
Start Recording
\\
\hline
Transport/RewindFast
&
Rewind (Fast)
\\
\hline
Transport/Rewind
&
Rewind
\\
\hline
Transport/RewindSlow
&
Rewind (Slow)
\\
\hline
Transport/Roll
&
Roll
\\
\hline
Transport/secondary-clock-bbt
&
Bars \& Beats
\\
\hline
Transport/secondary-clock-minsec
&
Minutes \& Seconds
\\
\hline
Transport/secondary-clock-samples
&
Samples
\\
\hline
Transport/secondary-clock-timecod
e
&
Timecode
\\
\hline
Transport/Stop
&
Stop
\\
\hline
Transport/ToggleAutoInput
&
Auto Input
\\
\hline
Transport/ToggleAutoPlay
&
Auto Play
\\
\hline
Transport/ToggleAutoReturn
&
Auto Return
\\
\hline
Transport/ToggleClick
&
Click
\\
\hline
Transport/ToggleExternalSync
&\\
\hline
Transport/ToggleFollowEdits
&
Follow Edits
\\
\hline
Transport/TogglePunchIn
&
Punch In
\\
\hline
Transport/TogglePunch
&
Punch In/Out
\\
\hline
Transport/TogglePunchOut
&
Punch Out
\\
\hline
Transport/ToggleRollForgetCapture
&
Stop and Forget Capture
\\
\hline
Transport/ToggleRoll
&
Start/Stop
\\
\hline
Transport/ToggleRollMaybe
&
Start/Continue/Stop
\\
\hline
Transport/ToggleTimeMaster
&
Time Master
\\
\hline
Transport/ToggleVideoSync
&
Sync Startup to Video
\\
\hline
Transport/TransitionToReverse
&
Transition To Reverse
\\
\hline
Transport/TransitionToRoll
&
Transition To Roll
\\
\hline
Transport/Transport
&
Transport
\\
\hline
Window/toggle-about
&
About
\\
\hline
Window/toggle-add-routes
&
Add Tracks/Busses
\\
\hline
Window/toggle-add-video
&
Add Tracks/Busses
\\
\hline
Window/toggle-audio-connection-ma
nager
&
Audio Connections
\\
\hline
Window/toggle-audio-midi-setup
&
Audio/MIDI Setup
\\
\hline
Window/toggle-big-clock
&
Big Clock
\\
\hline
Window/toggle-bundle-manager
&
Bundle Manager
\\
\hline
Window/toggle-inspector
&
Tracks and Busses
\\
\hline
Window/toggle-key-editor
&
Key Bindings
\\
\hline
Window/toggle-locations
&
Locations
\\
\hline
Window/toggle-midi-connection-man
ager
&
MIDI Connections
\\
\hline
Window/toggle-rc-options-editor
&
Preferences
\\
\hline
Window/toggle-session-options-edi
tor
&
Properties
\\
\hline
Window/toggle-speaker-config
&
Speaker Configuration
\\
\hline
Window/toggle-theme-manager
&
Theme Manager
\\
\hline
Zoom/zoom-focus-center
&
Zoom Focus Center
\\
\hline
Zoom/zoom-focus-edit
&
Zoom Focus Edit Point
\\
\hline
Zoom/zoom-focus-left
&
Zoom Focus Left
\\
\hline
Zoom/zoom-focus-mouse
&
Zoom Focus Mouse
\\
\hline
Zoom/zoom-focus-playhead
&
Zoom Focus Playhead
\\
\hline
Zoom/zoom-focus-right
&
Zoom Focus Right
\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}


\chapter{77 - Controlling Ardour with Mackie Control Devices}
\label{\detokenize{index:controlling-ardour-with-mackie-control-devices}}
Since Mackie and Logic made the first Logic Control Surface, Mackie and
other surface manufactures have been making control surfaces that use
the same protocol to communicate with a DAW. Ardour supports the MCP and
will work with all these control surfaces.


\chapter{77.1 - Devices Using Mackie/Logic Control Protocol}
\label{\detokenize{index:devices-using-mackie-logic-control-protocol}}
This will walk you through the process of configuring and using a MIDI
control surface with Ardour that uses the Mackie Control protocol (MCP)
or Logic Control protocol. Devices that have been tested and are known
to work include the SSL Nucleus, Mackie Control Pro (plus extenders),
Behringer devices in Mackie/Logic mode, and Steinberg CMC devices.


\section{Enabling Mackie Control in Ardour}
\label{\detokenize{index:enabling-mackie-control-in-ardour}}
Navigate to Edit \textgreater{} Preferences \textgreater{} Control Surfaces. Tick the Mackie
option and click on the Show Protocol Settings button to see the setup
dialog:

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{mackie-control-protocol-settings}.png}
\caption{The Mackie Control Setup Dialog}\label{\detokenize{index:id611}}\end{figure}

From the selector at the top, choose the type of device you are using.
({\hyperref[\detokenize{index:what-to-do-if-your-device-is-not-listed}]{\emph{What to do if your device is not
listed}}}).

Update the controls description

Once your setup is complete, click “OK” to close the dialog. Now click
on the enable checkbox for “Mackie Control”.


\section{Devices using ipMIDI}
\label{\detokenize{index:devices-using-ipmidi}}
If you are using a device that uses ipMIDI, such as the SSL Nucleus, no
MIDI port connections are required—Ardour and your control surface will
be able to talk to each other automatically so long as your control
surface and computer are both connected to the same network.


\section{Connecting control surface and Ardour MIDI ports}
\label{\detokenize{index:connecting-control-surface-and-ardour-midi-ports}}
Before attempting to use a Mackie Control device that communicates via a
standard MIDI cable or a USB cable, you should ensure that {\hyperref[\detokenize{index:midi-on-linux}]{\emph{your Linux
MIDI environment is setup}}}. If you are using a device
that uses normal MIDI (via a standard MIDI or USB cable), you need to
connect Ardour’s Mackie Control in and out ports to the MIDI ports
leading to and coming from the control surface.

When you have made these connections once, Ardour will recreate them for
you in the future, as long as you leave Mackie Control enabled.


\section{Customizing your control surface}
\label{\detokenize{index:customizing-your-control-surface}}
Every possible global Mackie Control button can be bound to any
{\hyperref[\detokenize{index:list-of-menu-actions}]{\emph{action}}} present in Ardour’s GUI. Please check
your control surface page for suggestions.


\section{Preparing your device for use with Ardour}
\label{\detokenize{index:preparing-your-device-for-use-with-ardour}}
Most interfaces will require some configuration to send and respond to
MCP.

When setting up the control surface, do \sphinxstyleemphasis{not} use “Pro Tools” mode. Pro
Tools is the only DAW that still requires HUI. The rest of world uses
Mackie Control Protocol. Ardour does not support HUI at this time.


\chapter{77.2 - SSL Nucleus}
\label{\detokenize{index:ssl-nucleus}}
The Nucleus, from Solid State Logic, is a 16 fader Mackie Control device
that includes many buttons, separate meters, two LCD displays and other
features. The device is not cheap (around US\$5000 at the time of
writing), and has some {\hyperref[\detokenize{index:design}]{\emph{design features}}} (or lack thereof)
which some Ardour developers find questionable. Nevertheless, it is a
very flexible device, and makes a nice 16 fader surface without the need
to somehow attach an extender to your main surface.


\section{Pre-configuring the Nucleus}
\label{\detokenize{index:pre-configuring-the-nucleus}}
Your Nucleus comes complete with a number of “profiles” for a few
well-known DAWs. At the time of writing it does not include one for
Ardour (or related products such as Harrison Mixbus).

We have prepared a profile in which as many buttons as possible send
Mackie Control messages, which makes the device maximally useful with
Ardour (and Mixbus). You can download \sphinxhref{https://community.ardour.org/files/ArdourNucleusProfile.zip}{the
profile}
and load it to your Nucleus using the \sphinxcode{\sphinxupquote{Edit Profiles}} button in SSL’s
Nucleus Remote application. Be sure to select it for the active DAW
layer in order to make Ardour work as well as possible. \sphinxstyleemphasis{Note:
unfortunately, the Nucleus Remote application only runs on OS X or
Windows, so Linux users will need access to another system to load the
profile. We will provide notes on the profile settings at a future
time.}


\section{Connecting the Nucleus}
\label{\detokenize{index:connecting-the-nucleus}}
Unlike most Mackie Control devices, the Nucleus uses an ethernet
connection to send and receive the MIDI messages that make up the Mackie
Control protocol. Specifically, it uses a technology called “ipMIDI”
which essentially “broadcasts” MIDI messages on a local area network, so
that any connected devices (computers, control surfaces, tablets etc.)
can participate.

All other DAWs so far that support the Nucleus have chosen to do so by
using a 3rd party MIDI driver called “ipMIDI”, which creates a number of
“virtual” MIDI ports on your computer. You, the user, tells the DAW
which ports to connect to, and ipMIDI takes care of the rest.

Ardour has builtin ipMIDI support, with no need of any 3rd party
packages, and no need to identify the “ports” to connect to in order to
communicate with the Nucleus. This makes setting it up a bit easier than
most other systems.

Unless … you already installed the ipMIDI driver in order to use some
other DAW with your Nucleus. If ipMIDI is configured to create any
“ports”, it is not possible for Ardour’s own ipMIDI support to function.
We decided to offer both methods of communicating with your Nucleus. If
you regularly use other DAWs, and appreciate having ipMIDI permanently
set up to communication with the Nucleus—that’s OK, you can tell Ardour
to use the ipMIDI driver you already have. But if you’re not using other
DAWs with the Nucleus (and thus have not installed the ipMIDI driver),
then you can ignore the ipMIDI driver entirely, and let Ardour connect
directly with no configuration.


\subsection{Connecting via Ardour’s own ipMIDI support}
\label{\detokenize{index:connecting-via-ardour-s-own-ipmidi-support}}
This is usable only on computers with no 3rd party ipMIDI driver
software installed and configured. If you have the OS X or Windows
ipMIDI driver from nerds.de, it \sphinxstylestrong{MUST} be configured to offer \sphinxstylestrong{ZERO}
ports before using this method.

Open \sphinxcode{\sphinxupquote{Preferences \textgreater{} Control Surfaces}}. Ensure that the Mackie protocol
is enabled, then double-click on it to open the Mackie Control setup
dialog.

Ensure that the device selected is “SSL Nucleus”. The dialog should show
a single numerical selector control below it, defining the ipMIDI port
number to use (it should almost always be left at the default value of
21928).

Communication is automatically established with the Nucleus and you need
do nothing more.

If this does not work, then make sure your network cables are properly
connected, and that you are \sphinxstylestrong{not} running other ipMIDI software on the
computer.


\subsection{Connecting via 3rd party ipMIDI support}
\label{\detokenize{index:connecting-via-3rd-party-ipmidi-support}}
This is usable only on computers with 3rd party ipMIDI driver software
installed and configured for (at least) 2 ports.

Open \sphinxcode{\sphinxupquote{Preferences \textgreater{} Control Surfaces}}. Ensure that the Mackie protocol
is enabled, then double-click on it to open the Mackie Control setup
dialog.

Ensure that the device selected is “SSL Nucleus (via platform MIDI)”.
The dialog should show four combo/dropdown selectors, labelled
(respectively):
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{Main Surface receives via}}

\item {} 
\sphinxcode{\sphinxupquote{Main Surface sends via}}

\item {} 
\sphinxcode{\sphinxupquote{1st extender receives via}}

\item {} 
\sphinxcode{\sphinxupquote{1st extender sends via}}

\end{itemize}

You should choose “ipMIDI port 1”, “ipMIDI port 1”, “ipMIDI port 2” and
“ipMIDI port 2” for each of the 4 combo/dropdown selectors.

Communication should be automatically established with the Nucleus.

If this does not work, then make sure your network cables are properly
connected, and that you are running the appropriate ipMIDI driver and
have configured it for 2 (or more) ports.


\section{Nucleus Design Discussion}
\label{\detokenize{index:nucleus-design-discussion}}
You might be reading this part of the manual seeking some guidance on
whether the Nucleus would make a suitable control surface for your
workflows. We don’t want to try to answer that question definitively,
since the real answer depends on the very specific details of your
workflow and situation, but we would like to point out a number of
design features of the Nucleus that might change your opinion.


\subsection{Cons}
\label{\detokenize{index:cons}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

No Master Faster
&
It is not possible to control the
level of the Master bus or
Monitor section. Really don’t
know what SSL was thinking here.
\\
\hline
No dedicated rec-enable buttons
&
You have to press the “Rec”
button and convert the per-strip
“Select” buttons into rec-enables
\\
\hline
No dedicated automation buttons
&
You have to press the “Auto”
button and convert the first 4
vpots into 4 automation-related
buttons, losing your current view
of the session.
\\
\hline
No buttons with Mackie-defined
“Marker” functionality
&
Mackie’s design intentions for
the interoperation of the Marker,
rewind and ffwd buttons requires
profile editing in order to
function properly.
\\
\hline
No “Dyn” button
&
This is hard to assign in an
edited profile. To be fair, other
Mackie Control devices also lack
this button.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsection{Pros}
\label{\detokenize{index:pros}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

Single cable connectivity
&
No need for multiple MIDI cables
to get 16 faders
\\
\hline
Broadcast connectivity
&
Connecting to multiple computers
does not require recabling
\\
\hline
16 faders from a single box
&
No need to figure out how to keep
extenders together
\\
\hline
Meters separated from displays
&
Contrast with the Mackie Control
Universal Pro, where meters
interfere with the display
\\
\hline
DAW profiles
&
Easy to flip profiles for use by
different DAWs.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsection{Ambiguous}
\label{\detokenize{index:ambiguous}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

Ability to make buttons generate
USB keyboard events
&
The extent to which this is
useful reflects the target DAWs
inability to manage all of its
functionality via Mackie Control
\\
\hline
Sophisticated “profile” editing
&
It is nice to be able to reassign
the functionality of most
buttons, but this is only
necessary because of the
relatively few global buttons on
the surface.
\\
\hline
Builtin analog signal path
&
SSL clearly expects users to
route audio back from their
computer via the Nucleus’ own 2
channel output path, and maybe
even use the input path as well.
They take up a significant amount
of surface space with the
controls for this signal path,
space that could have been used
for a master fader or more Mackie
Control buttons. The USB audio
device requires a proprietary
driver, so Linux users can’t use
this, and OS X/Windows users will
have to install a device driver
(very odd for a USB audio device
these days). The analog path also
no doubt adds notable cost to the
Nucleus. There’s nothing wrong
with this feature for users that
don’t already have a working
analog/digital signal path for
their computers. But who is going
to spend \$5000 on a Nucleus that
doesn’t have this already?
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\chapter{77.3 - Behringer Devices in Mackie/Logic Control Mode}
\label{\detokenize{index:behringer-devices-in-mackie-logic-control-mode}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{index:bcf2000}]{\emph{Behringer BCF-2000}}}

\item {} 
{\hyperref[\detokenize{index:xtouch}]{\emph{Behringer X-Touch}}}

\item {} 
{\hyperref[\detokenize{index:compact}]{\emph{Behringer X-Touch Compact}}}

\item {} 
{\hyperref[\detokenize{index:mini}]{\emph{Behringer X-Touch Mini}}}

\end{itemize}


\section{Behringer BCF-2000 Faders Controller}
\label{\detokenize{index:behringer-bcf-2000-faders-controller}}\label{\detokenize{index:bcf2000}}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{BCF2000}.png}
\caption{Diagrammatic Image of the BCF2000 (click for a full-size view)}\label{\detokenize{index:id612}}\end{figure}

The Behringer BCF-2000 Fader Controller is a control surface with 8
motorized faders, 8 rotary encoders and 30 push buttons. The device is a
class compliant USB Midi Interface and also has standard Midi DIN
IN/OUT/THRU ports. The device has included a Mackie/Logic Control
Emulation Mode since firmware v1.06. Any devices with a firmware older
than v1.06 will require an update before Mackie Control Emulation works
as described here.

In order to put the controller into Mackie/Logic control mode, the unit
must be turned on while holding the third button from the left in the
top most row of buttons (under the rotary encoder row). The button must
be held down until EG or edit global mode is displayed on the LCD screen
of the unit. The global parameters can then be edited using the 8 rotary
encoders in the top row.
\begin{itemize}
\item {} 
Encoder \#1 sets the operating mode and should be set to U-1 or USB
mode 1 if using with a USB cable connection.

\item {} 
Encoder \#3 sets the foot switch mode and should most likely be set to
Auto to detect how the foot switch is wired.

\item {} 
Encoder \#5 sets the device id, if you are using only 1 device the id
should be set to ID 1. If you are using multiple BCF/BCR2000 each
device is required to be set up sequentially and one at a time.

\item {} 
Encoder \#7 controls the MIDI Dead Time or the amount of milliseconds
after a move has been made that the device ignores further changes,
this should be set to 100.

\item {} 
Encoder \#8 controls the MIDI message Send Interval in milliseconds
and should be set to 10

\end{itemize}

To exit the EG mode press the Exit button. The device is now ready to
use with Ardour.


\subsection{Modes of Operation}
\label{\detokenize{index:modes-of-operation}}
The four buttons arranged in a rectangle and located under the Behringer
logo are the mode selection buttons in Logic Control Emulation Mode,
currently Ardour has implemented support for two of these modes.

The surface can be broken into 8 groups of controls:
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
The rotary encoders at the top of the device

\item {} 
The first row of buttons under the encoders

\item {} 
The second row of buttons under the encoders

\end{enumerate}

\#. The row of motorized faders
\#.
\#. The group of 4 buttons at the top right that will be referred to here
\begin{quote}

as the Shift Group
\end{quote}
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
The group of 4 buttons under the Shift Group referred to here as the
Mode Group

\item {} 
The group of 2 buttons under the Mode Group referred to here as the
Select Group

\item {} 
The group of 4 buttons under the Select Group referred to here as the
Transport Group

\end{enumerate}


\subsection{Mixer Pan Mode}
\label{\detokenize{index:mixer-pan-mode}}
This is the standard work mode that organizes the control surface to
emulate a standard mixer layout where controls for each track/bus are
arranged vertically. The order of the faders is either controlled by the
order of the tracks in the mixer or can be set manually by the user.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|*{2}{\X{1}{2}|}}
\hline

Encoders
&
Mixer Pans. The red LEDs show the
amount of pan left or right
\\
\hline
First Row of Buttons
&
Mixer Mutes. The button led
lights up if the track is
currently muted
\\
\hline
Second Row of Buttons
&
Select Active Track/Bus.
Currently selected track/bus is
indicated by the button led
\\
\hline
Faders
&
Mixer Gains
\\
\hline
Shift Group
&\begin{itemize}
\item {} 
The top and bottom left
buttons are simply shifts to
change the function of other
buttons.

\item {} 
The top right is the Fine
Control button that allows the
increment values sent by by
rotary encoders and faders to
be a small value for more
precise editing. This button
can also act as a shift
button.

\item {} 
The bottom right is the Global
Shift button that allows you
to change back to the standard
Mixer Pan view from other
views and modes. This button
can also act as a shift
button.

\end{itemize}
\\
\hline
Mode Group
&\begin{itemize}
\item {} 
The top two buttons functions
are not currently implemented
in Ardour.

\item {} 
The bottom left button sets
the device to Pan mode and
should currently be lit

\item {} 
The bottom right button sets
the device to Send mode but
will only allow the switch if
the currently selected
track/bus has a send or sends
to control.

\end{itemize}
\\
\hline
Select Group
&
In this mode they function as
bank select left and right. If
the current session has more than
8 tracks the next set of 8 tracks
is selected with the right button
and the faders will move to match
the current gain settings of that
bank of 8 tracks/busses. If the
last bank contains less than 8
tracks/busses the unused faders
will move to the bottom and the
pan lights will all turn off. An
unlimited amount of tracks can be
controlled with the device.
\\
\hline
Transport Group
&\begin{itemize}
\item {} 
The upper left button controls
Rewind.

\item {} 
The upper right button
controls Fast Forward

\item {} 
The lower left button controls
Stop

\item {} 
The lower right button
controls Play

\end{itemize}
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}


\subsection{Send Mode}
\label{\detokenize{index:send-mode}}
Send mode allows for the top row of encoders to control the sends for a
selected channel. One interesting option is to flip the controls from
the encoders to the faders by pressing the shift 1 button and the global
view button at the same time.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

Encoders
&
In send mode, the encoders
control sends from left to right
instead of mixer pans. If there
are less than 8 sends the
behavior of the encoder will be
to continue controlling the mixer
pan. Visually it is indicated by
the change in the LED from
originating at the 12 o’clock
position to originating at the 7
o’clock position. If FLIP is
pressed the encoder will control
the mixer gain for the selected
track/bus.
\\
\hline
First row of buttons
&
No Change
\\
\hline
Second row of buttons
&
No Change.
\\
\hline
Faders
&
No change unless FLIPis pressed
then it controls the send for the
selected track/bus.
\\
\hline
Shift Group
&
No Change
\\
\hline
Select Group
&
No Change
\\
\hline
Transport Group
&
No Change
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsection{Mixer Pan While Holding Shift 1}
\label{\detokenize{index:mixer-pan-while-holding-shift-1}}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{BCF2000-Shift1}.png}
\caption{Diagrammatic Image of the Mixer Mode while holding down Shift 1}\label{\detokenize{index:id613}}\end{figure}

The operations of various buttons change while holding down the Shift 1
button:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|*{2}{\X{1}{2}|}}
\hline

Encoders
&
No Change
\\
\hline
First row of buttons
&
These now control the Soloing of
each track/bus in the current
bank
\\
\hline
Second row of buttons
&
These now control the Enable
Record for each track
\\
\hline
Faders
&
No Change
\\
\hline
Shift Group
&
No change
\\
\hline
Mode Group
&
No Change
\\
\hline
Select Group
&
These now change the current bank
of tracks being controlled over
by one. So if tracks 1-8 where
controlled, pushing the right
button will change the controlled
tracks to 2-9, and pressing the
left would then shift back to
controlling tracks 1-8.
\\
\hline
Transport Group
&\begin{itemize}
\item {} 
The upper left now controls
turning on and off Loop mode.

\item {} 
The upper right now toggles
Click.

\item {} 
The lower left toggles
Replace.

\item {} 
The lower right toggles Global
Record.

\end{itemize}
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}


\subsection{Mixer Pan While Holding Shift 2}
\label{\detokenize{index:mixer-pan-while-holding-shift-2}}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{BCF2000-Shift2}.png}
\caption{Diagrammatic Image of the Mixer Mode while holding down Shift 2}\label{\detokenize{index:id614}}\end{figure}

The operations of various buttons change while holding down the Shift 2
button:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

Encoders
&
No Change
\\
\hline
First row of buttons
&
FIX ME
\\
\hline
Second row of buttons
&
These now control setting up
different Views. See below for
more info
\\
\hline
Faders
&
No Change
\\
\hline
Shift Group
&
No change
\\
\hline
Mode Group
&
No Change
\\
\hline
Select Group
&
Left button controls Undo(FIXME:
NEEDS VERIFICATION)
\\
\hline
Transport Group
&
FIX ME
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsection{Views}
\label{\detokenize{index:views}}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{BCF2000-Views}.png}
\caption{Diagrammatic Image of the LED display for different Views}\label{\detokenize{index:id615}}\end{figure}


\section{Behringer X-Touch}
\label{\detokenize{index:behringer-x-touch}}\label{\detokenize{index:xtouch}}
The Behringer X-Touch is a direct emulation of the Mackie Control and
has all the buttons the Mackie device does. There is a “Behringer
X-Touch” map included with Ardour. The X-Touch can be connected to the
computer with USB or through a MIDI port. Using USB keeps MIDI ports
free for other uses. The Ethernet port uses RTP MIDI which should show
up as MIDI devices on MacOS computers.


\section{Behringer X-Touch Compact}
\label{\detokenize{index:behringer-x-touch-compact}}\label{\detokenize{index:compact}}
The Behringer X-Touch Compact has a Mackie Control mode. From the device
manual:

“To switch between standard operating mode and MC (Mackie Control) mode,
press and hold down the MC button in the bottom left corner, and then
turn on the unit’s power switch. Keep holding down the MC button until
the MC MODE LED lights continuously to show that the unit is in MC
mode.”

There is a “Behringer X-Touch Compact” map included with Ardour. The
X-Touch can be connected to the computer with USB or through a MIDI
port. Using USB keeps MIDI ports free for other uses.

The Behringer X-Touch Compact has fewer controls than the Mackie control
and therefore less function as well. See pages 19-21 of the Behringer
X-Touch Compact Quick Start Guide For an explanation of what controls on
the Compact map to which Mackie Control buttons.


\section{Behringer X-Touch Mini}
\label{\detokenize{index:behringer-x-touch-mini}}\label{\detokenize{index:mini}}
The Behringer X-Touch Mini says it can emulate Mackie control as well.
There is a “Behringer X-Touch Mini” map included with Ardour. The
control layout in Mackie Control mode is shown below.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{xtouch-mini-mcp}.png}
\caption{X-Touch Mini MC mode layout}\label{\detokenize{index:id616}}\end{figure}

Missing content


\chapter{77.4 - What to do if your Device is not Listed}
\label{\detokenize{index:what-to-do-if-your-device-is-not-listed}}
All Mackie Control devices are based on the original Logic Control and
the documentation in the user manual that came with it. The Mackie
Control and the Mackie Control Pro and so on, all use this same
protocol. Any units from other manufactures will also use the same
encoding as best the hardware will allow. If the unit in use has more
than one Mackie Control option, it is best to choose Logic Control or
LC. Any Templates for the buttons should be chosen the same way as the
Function key Editor uses these button names. The “Mackie Control” option
should be considered default and should be tried with any unlisted
device before attempting to create a custom definition file.


\chapter{77.5 - Working With Extenders}
\label{\detokenize{index:working-with-extenders}}
There are currently 5 devices pre-configured to work with extenders. Two
of them are for one master and one extender with the master on the right
side or master on the left side. There are three presets for a master
and two extenders with the master on the left, in the center and on the
right. While these files will work for many uses there may be cases
where a custom device profile makes more sense. The best way is to start
with the *.device file in the \sphinxhref{https://github.com/Ardour/ardour/tree/master/mcp}{Source
Tree} that matches
your master device and copy it to a new name such as xt+mc.device in the
{\hyperref[\detokenize{index:files-and-directories-ardour-knows-about}]{\emph{user config}}} sub
directory \sphinxcode{\sphinxupquote{mcp}} and then edit that file. It is best to name the file
with the order the devices are expected to be used in as the position of
the master device is specified in this file.

The three lines of interest are:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{Name} \PYG{n}{value}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Device name}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{Extenders} \PYG{n}{value}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{MasterPosition} \PYG{n}{value}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

Add any lines that are not present.

The \sphinxcode{\sphinxupquote{Name}} value should be a unique name so it is obvious in the list
of devices (so change it).

The \sphinxcode{\sphinxupquote{Extenders}} value is the number of extenders used and should not
include the master in that number.

When an \sphinxcode{\sphinxupquote{Extenders}} value of greater than 0 is used, extra midi ports
will appear for the extenders to be connected to. The MIDI ports for the
controllers will be named \sphinxcode{\sphinxupquote{mackie control in/out}} for the master,
\sphinxcode{\sphinxupquote{mackie control in/out ext \#*}} where * is the position of the
extender from left to right. So for a master in the middle with an
extender on either side, the ports from left to right will be mackie
control in/out ext \#1, mackie control in/out and mackie control in/out
ext \#3.

If using the MCP GUI to connect surfaces the top surface is the leftmost
and the bottom is the rightmost. The GUI shows explicitly the position
of the main or master surface within the group of surfaces.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{mcp-extender-position}.png}
\caption{The Mackie Control Device Dialog}\label{\detokenize{index:id617}}\end{figure}

The \sphinxcode{\sphinxupquote{MasterPosition}} value is the position the master unit (with the
master fader) is located at within the group of surfaces. The surfaces
are numbered from 1 at the left side and up. So if there are three
surfaces, \sphinxcode{\sphinxupquote{\textless{}MasterPosition value="1"/\textgreater{}}} will expect the master on the
left, \sphinxcode{\sphinxupquote{\textless{}MasterPosition value="2"/\textgreater{}}} would be master in the middle and
\sphinxcode{\sphinxupquote{\textless{}MasterPosition value="3"/\textgreater{}}} would be master on the right.

The default value of \sphinxcode{\sphinxupquote{\textless{}MasterPosition value="0"/\textgreater{}}} has the same effect
as \sphinxcode{\sphinxupquote{\textless{}MasterPosition value="1"/\textgreater{}}}.

If the \sphinxcode{\sphinxupquote{MasterPosition}} value does not properly match the physical
position and MIDI port, the master fader and global controls will not
work. The master unit will act like an extender.


\chapter{78 - Generic MIDI}
\label{\detokenize{index:generic-midi}}
Generic Midi allows synthesizers and other devices communicate with
Ardour. MIDI devices can send commands relating to playback (such as
play or stop), performance (such as volume, play, stop, and almost any
other function (such as Edit, or Undo).

Many MIDI control surfaces use predefined MIDI protocols such as the
“Mackie Control Protocol”. In such cases it is best to use Ardour’s
implementation of that protocol as it is likely more feature complete.


\chapter{78.1 - Generic MIDI Binding Maps}
\label{\detokenize{index:generic-midi-binding-maps}}
Ardour 2.X supported {\hyperref[\detokenize{index:generic-midi-learn}]{\emph{MIDI learning}}} for more or
less any control. This was a nice feature that quite a few other DAWs
are providing by now, but it didn’t allow Ardour to work “out of the
box” with sensible defaults for existing commercial MIDI controllers. In
Ardour 3 and later versions, we have augmented the MIDI learn feature
with the ability to load a MIDI binding map for a given controller,
which can set up an arbitrary number of physical controls with anything
inside Ardour that can be controlled.

Currently (August 2016), we have presets for the following
devices/modes:
\begin{itemize}
\item {} 
AKAI MPD-32

\item {} 
AKAI MPK61

\item {} 
AKAI MPKmini

\item {} 
Behringer BCF2000

\item {} 
Behringer BCF2000 (Mackie Emulation mode; better to use Ardour’s
actual Mackie Control Protocol support)

\item {} 
Behringer DDX3216

\item {} 
Korg nanoKONTROL (2 layouts)

\item {} 
Korg nanoKONTROL 2 (2 layouts)

\item {} 
Korg Taktile

\item {} 
M-Audio Axiom 25 (2 layouts)

\item {} 
M-Audio Axiom 61

\item {} 
M-Audio Oxygen 49

\item {} 
M-Audio Oxygen 61v3

\item {} 
M-Audio Oxygen 25

\item {} 
M-Audio Oxygen 8v2

\item {} 
Novation Impulse 49

\item {} 
Novation Impulse 61

\item {} 
Novation LaunchControl XL

\item {} 
Novation LaunchKey 25

\item {} 
Roland SI-24

\item {} 
Roland V Studio 20

\item {} 
Yamaha KX25

\end{itemize}

At this time, new binding maps need to be created with a text editor.

MIDI binding maps are accessible by double-clicking Edit \textgreater{} Preferences \textgreater{}
Control Surfaces \textgreater{} Generic MIDI. Ardour will retain your selection after
you choose one.


\section{Creating new MIDI maps}
\label{\detokenize{index:creating-new-midi-maps}}

\subsection{The Basic Concept}
\label{\detokenize{index:the-basic-concept}}
Since the beginning of time (well, sometime early in the 2.X series),
Ardour has had the concept of identifying each track and bus with a
remote control ID. This ID uniquely identifies a track or bus so that
when messages arrive from elsewhere via MIDI or OSC , we can determine
which track or bus they are intended to control. See {\hyperref[\detokenize{index:controlling-track-ordering}]{\emph{remote control
IDs}}} for more information. You just need
to know that there is a “first track” and its remote control ID is 1,
and so on.


\subsection{Getting Started}
\label{\detokenize{index:getting-started}}
MIDI bindings are stored in files with the suffix “.map” attached to
their name. The minimal content looks like this:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}?xml version=\PYGZdq{}1.0\PYGZdq{} encoding=\PYGZdq{}UTF\PYGZhy{}8\PYGZdq{}?\PYGZgt{}
\PYGZlt{}ArdourMIDIBindings version=\PYGZdq{}1.0.0\PYGZdq{} name=\PYGZdq{}The name of this set of
bindings\PYGZdq{}\PYGZgt{}
\PYGZlt{}/ArdourMIDIBindings\PYGZgt{}
\end{sphinxVerbatim}

So, to start, create a file with that as the initial contents.

The file should be located in the midi\_maps sub directory located in the
{\hyperref[\detokenize{index:files-and-directories-ardour-knows-about}]{\emph{Ardour configuration
directory}}}


\subsection{Finding out what your MIDI control surface sends}
\label{\detokenize{index:finding-out-what-your-midi-control-surface-sends}}
This is the most complex part of the job, but its still not very hard.
You need to connect the control surface to an application that will show
you the information that the device sends each time you modify a knob,
slider, button etc. There are a variety of such applications (notably
\sphinxcode{\sphinxupquote{gmidimon}} and \sphinxcode{\sphinxupquote{kmidimon}}, but you can actually use Ardour for this
if you want. Start Ardour in a terminal window, connect MIDI ports up,
and in the Preferences window, enable “Trace Input” on the relevant MIDI
port. A full trace of the MIDI data received will show up in the
terminal window. (Note: in Ardour3, you get a dedicated, custom dialog
for this kind of tracing.)


\subsection{Types of Bindings}
\label{\detokenize{index:types-of-bindings}}
There are two basic kinds of bindings you can make between a MIDI
message and something inside Ardour. The first is a binding to a
specific parameter of a track or bus. The second is a binding to a
function that will change Ardour’s state in some way.


\subsubsection{Binding to Track/Bus controls}
\label{\detokenize{index:binding-to-track-bus-controls}}
A track/bus binding has one of two basic structures

\sphinxcode{\sphinxupquote{\textless{}Binding msg specification  uri="… control address …"/\textgreater{}   \textless{}Binding msg specification  function="… function name …"/\textgreater{}}}


\subsubsection{Message specifications}
\label{\detokenize{index:message-specifications}}
You can create a binding for either 3 types of channel messages, or for
a system exclusive (“sysex”) message. A channel message specification
looks like this:

\sphinxcode{\sphinxupquote{\textless{}Binding channel="1" ctl="13" …}}

This defines a binding for a MIDI Continuous Controller message
involving controller 13, arriving on channel 1. There are 16 MIDI
channels, numbered 1 to 16. Where the example above says \sphinxcode{\sphinxupquote{ctl}}, you
can alternatively use \sphinxcode{\sphinxupquote{note}} (to create binding for a Note On message)
or \sphinxcode{\sphinxupquote{pgm}} (to create a binding for a Program Change message).

As of Ardour 4.2, \sphinxcode{\sphinxupquote{enc-r}}, \sphinxcode{\sphinxupquote{enc-l}}, \sphinxcode{\sphinxupquote{enc-2}} and \sphinxcode{\sphinxupquote{enc-b}} may be
used for surfaces that have encoders that send offsets rather than
values. These accept Continuous Controller messages but treat them as
offsets. These are good for banked controls as they are always at the
right spot to start adjusting. ( {\hyperref[\detokenize{index:generic-midi-and-encoders}]{\emph{Learn more about working with
encoders}}})
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{\textless{}Binding channel="1" enc-r="13" …}}

\item {} 
\sphinxcode{\sphinxupquote{\textless{}Binding channel="1" enc-l="13" …}}

\item {} 
\sphinxcode{\sphinxupquote{\textless{}Binding channel="1" enc-2="13" …}}

\item {} 
\sphinxcode{\sphinxupquote{\textless{}Binding channel="1" enc-b="13" …}}

\end{itemize}

The \sphinxcode{\sphinxupquote{enc-*}} value is the CC number used by the encoder. Encoders only
work with CC messages.

Ardour 5.12 has a bug with the encoder detection where the first encoder
message resets the control to 0. Setting “Enable Feedback” on allows
encoders to work as expected.

You can also bind sysex messages:

\sphinxcode{\sphinxupquote{\textless{}Binding sysex="f0 0 0 e 9 0 5b f7" ….   \textless{}Binding sysex="f0 7f 0 6 7 f7" ….}}

The string after the \sphinxcode{\sphinxupquote{sysex=}} part is the sequence of MIDI bytes, as
hexadecimal values, that make up the sysex message.

Finally, you can bind a totally arbitrary MIDI message:

\sphinxcode{\sphinxupquote{\textless{}Binding msg="f0 0 0 e 9 0 5b f7" ….   \textless{}Binding msg="80 60 40" ….}}

The string after the \sphinxcode{\sphinxupquote{msg=}} part is the sequence of MIDI bytes, as
hexadecimal values, that make up the message you want to bind. Using
this is slightly less efficient than the other variants shown above, but
is useful for some oddly designed control devices.

As of Ardour 4.6 it is possible to use multi-event MIDI strings such as
two event CC messages, RPN or NRPN.

The \sphinxcode{\sphinxupquote{sysex=}} and \sphinxcode{\sphinxupquote{msg=}} bindings will only work with \sphinxcode{\sphinxupquote{function=}}
or \sphinxcode{\sphinxupquote{action=}} control addresses. They will \sphinxstyleemphasis{not} work with the \sphinxcode{\sphinxupquote{uri=}}
control addresses. Controls used with \sphinxcode{\sphinxupquote{uri=}} require a \sphinxstyleemphasis{Value} which
is only available in a known place with channel mode MIDI events.


\subsubsection{Control address}
\label{\detokenize{index:control-address}}
A control address defines what the binding will actually control. There
are quite a few different things that can be specified here:

Enable Feeback applies to these “Control Addresses” only.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

/route/gain
&
the gain control (“fader”) for
the track/bus
\\
\hline
/route/trim
&
the trim control for the
track/bus (new in 4.1)
\\
\hline
/route/solo
&
a toggleable control for solo
(and listen) of the track/bus
\\
\hline
/route/mute
&
a toggleable control to
mute/unmute the track/bus
\\
\hline
/route/recenable
&
a toggleable control to
record-enable the track
\\
\hline
/route/panwidth
&
interpreted by the track/bus
panner, should control image
“width”
\\
\hline
/route/pandirection
&
interpreted by the track/bus
panner, should control image
“direction”
\\
\hline
/route/plugin/parameter
&
the Mth parameter of the Nth
plugin of a track/bus
\\
\hline
/route/send/gain
&
the gain control (“fader”) of the
Nth send of a track/bus
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

Each of the specifications needs an address, which takes various forms
too. For track-level controls (solo/gain/mute/recenable), the address is
one the following:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

a number, e.g. “1”
&
identifies a track or bus by its
remote control ID
\\
\hline
B, followed by a number
&
identifies a track or bus by its
remote control ID within the
current bank (see below for more
on banks)
\\
\hline
S, followed by a number
&
identifies a selected track in
order they have been selected, S1
should be the same track as the
Editor Mixer
\\
\hline
one or more words
&
identifies a track or bus by its
name
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

For send/insert/plugin controls, the address consists of a track/bus
address (as just described) followed by a number identifying the
plugin/send (starting from 1). For plugin parameters, there is an
additional third component: a number identifying the plugin parameter
number (starting from 1).

One additional feature: for solo and mute bindings, you can also add
\sphinxcode{\sphinxupquote{momentary="yes"}} after the control address. This is useful primarily
for NoteOn bindings—when Ardour gets the NoteOn it will solo or mute the
targetted track or bus, but then when a NoteOff arrives, it will un-solo
or un-mute it.


\subsubsection{Bindings to Ardour “functions”}
\label{\detokenize{index:bindings-to-ardour-functions}}
There is currently no feedback available for functions.

Rather than binding to a specific track/bus control, it may be useful to
have a MIDI controller able to alter some part of Ardour’s state. A
binding definition that does this looks like this:

\sphinxcode{\sphinxupquote{\textless{}Binding channel="1" note="13" function="transport-roll"/\textgreater{}}}

In this case, a NoteOn message for note number 13 (on channel 1) will
start the transport rolling. The following function names are available:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

\sphinxcode{\sphinxupquote{transport-stop}}
&
stop the transport
\\
\hline
\sphinxcode{\sphinxupquote{transport-roll}}
&
start the transport “rolling”
\\
\hline
\sphinxcode{\sphinxupquote{transport-zero}}
&
move the playhead to the zero
position
\\
\hline
\sphinxcode{\sphinxupquote{transport-start}}
&
move the playhead to the start
marker
\\
\hline
\sphinxcode{\sphinxupquote{transport-end}}
&
move the playhead to the end
marker
\\
\hline
\sphinxcode{\sphinxupquote{loop-toggle}}
&
turn on loop playback
\\
\hline
\sphinxcode{\sphinxupquote{rec-enable}}
&
enable the global record button
\\
\hline
\sphinxcode{\sphinxupquote{rec-disable}}
&
disable the global record button
\\
\hline
\sphinxcode{\sphinxupquote{next-bank}}
&
Move track/bus mapping to the
next bank (see Banks below)
\\
\hline
\sphinxcode{\sphinxupquote{prev-bank}}
&
Move track/bus mapping to the
previous bank (see Banks below)
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsubsection{Binding to Ardour “actions”}
\label{\detokenize{index:binding-to-ardour-actions}}
It is not possible to have feedback available for actions because these
represent keyboard shortcuts which are input only.

You can also bind a sysex or arbitrary message to any of the items that
occur in Ardour’s main menu (and its submenus). The {\hyperref[\detokenize{index:list-of-menu-actions}]{\emph{list of
actions}}} shows all available values of
\sphinxstyleemphasis{action-name}.

To create a binding between an arbitrary MIDI message (we’ll use a
note-off on channel 1 of MIDI note 60 (hex) with release velocity 40
(hex)), the binding file would contain:

\sphinxcode{\sphinxupquote{\textless{}Binding msg="80 60 40" action="Editor/temporal-zoom-in"/\textgreater{}}}

The general rule, when taken an item from the keybindings file and using
it in a MIDI binding is to simply strip the \sphinxcode{\sphinxupquote{\textless{}Action\textgreater{}}} prefix of the
second field in the keybinding definition.


\subsection{Banks and Banking}
\label{\detokenize{index:banks-and-banking}}
\begin{DUlineblock}{0em}
\item[] Because many modern control surfaces offer per-track/bus controls for
far fewer tracks \& busses than many users want to control, Ardour
offers the relatively common place concept of banks. Banks allow you
to control any number of tracks and/or busses easily, regardless of
how many faders/knobs etc. your control surface has.
\item[] To use banking, the control addresses must be specified using the bank
relative format mentioned above (“B1” to identify the first track of a
bank of tracks, rather than “1” to identify the first track).
\end{DUlineblock}

One very important extra piece of information is required to use
banking: an extra line near the start of the list of bindings that
specifies how many tracks/busses to use per bank. If the device has 8
faders, then 8 would be a sensible value to use for this. The line looks
like this:

\sphinxcode{\sphinxupquote{\textless{}DeviceInfo bank-size="8"/\textgreater{}}}

In addition, you probably want to ensure that you bind something on the
control surface to the \sphinxcode{\sphinxupquote{next-bank}} and \sphinxcode{\sphinxupquote{prev-bank}} functions,
otherwise you and other users will have to use the mouse and the GUI to
change banks, which rather defeats the purpose of the bindings.


\subsection{The Selected Strip}
\label{\detokenize{index:the-selected-strip}}
Often times one wants to just deal with the strip currently selected by
the GUI (or the control surface). In the same way as with banks above
the selected strip can be designated with \sphinxstyleemphasis{S1}.


\section{A Complete (though muddled) Example}
\label{\detokenize{index:a-complete-though-muddled-example}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}?xml version=\PYGZdq{}1.0\PYGZdq{} encoding=\PYGZdq{}UTF\PYGZhy{}8\PYGZdq{}?\PYGZgt{}
\PYGZlt{}ArdourMIDIBindings version=\PYGZdq{}1.0.0\PYGZdq{} name=\PYGZdq{}pc1600x transport controls\PYGZdq{}\PYGZgt{}
  \PYGZlt{}DeviceInfo bank\PYGZhy{}size=\PYGZdq{}16\PYGZdq{}/\PYGZgt{}
  \PYGZlt{}Binding channel=\PYGZdq{}1\PYGZdq{} ctl=\PYGZdq{}1\PYGZdq{}   uri=\PYGZdq{}/route/gain B1\PYGZdq{}/\PYGZgt{}
  \PYGZlt{}Binding channel=\PYGZdq{}1\PYGZdq{} ctl=\PYGZdq{}2\PYGZdq{}   uri=\PYGZdq{}/route/gain B2\PYGZdq{}/\PYGZgt{}
  \PYGZlt{}Binding channel=\PYGZdq{}1\PYGZdq{} ctl=\PYGZdq{}3\PYGZdq{}   uri=\PYGZdq{}/route/send/gain B1 1\PYGZdq{}/\PYGZgt{}
  \PYGZlt{}Binding channel=\PYGZdq{}1\PYGZdq{} ctl=\PYGZdq{}4\PYGZdq{}   uri=\PYGZdq{}/route/plugin/parameter B1 1 1\PYGZdq{}/\PYGZgt{}
  \PYGZlt{}Binding channel=\PYGZdq{}1\PYGZdq{} ctl=\PYGZdq{}6\PYGZdq{}   uri=\PYGZdq{}/bus/gain master\PYGZdq{}/\PYGZgt{}

  \PYGZlt{}Binding channel=\PYGZdq{}1\PYGZdq{} note=\PYGZdq{}1\PYGZdq{}  uri=\PYGZdq{}/route/solo B1\PYGZdq{}/\PYGZgt{}
  \PYGZlt{}Binding channel=\PYGZdq{}1\PYGZdq{} note=\PYGZdq{}2\PYGZdq{}  uri=\PYGZdq{}/route/solo B2\PYGZdq{} momentary=\PYGZdq{}yes\PYGZdq{}/\PYGZgt{}

  \PYGZlt{}Binding channel=\PYGZdq{}1\PYGZdq{} note=\PYGZdq{}15\PYGZdq{}  uri=\PYGZdq{}/route/mute B1\PYGZdq{} momentary=\PYGZdq{}yes\PYGZdq{}/\PYGZgt{}
  \PYGZlt{}Binding channel=\PYGZdq{}1\PYGZdq{} note=\PYGZdq{}16\PYGZdq{}  uri=\PYGZdq{}/route/mute B2\PYGZdq{} momentary=\PYGZdq{}yes\PYGZdq{}/\PYGZgt{}

  \PYGZlt{}Binding channel=\PYGZdq{}1\PYGZdq{} enc\PYGZhy{}r=\PYGZdq{}11\PYGZdq{}   uri=\PYGZdq{}/route/pandirection B1\PYGZdq{}/\PYGZgt{}
  \PYGZlt{}Binding channel=\PYGZdq{}1\PYGZdq{} enc\PYGZhy{}r=\PYGZdq{}12\PYGZdq{}   uri=\PYGZdq{}/route/pandirection B2\PYGZdq{}/\PYGZgt{}

  \PYGZlt{}Binding sysex=\PYGZdq{}f0 0 0 e 9 0 5b f7\PYGZdq{} function=\PYGZdq{}transport\PYGZhy{}start\PYGZdq{}/\PYGZgt{}
  \PYGZlt{}Binding sysex=\PYGZdq{}f0 7f 0 6 7 f7\PYGZdq{} function=\PYGZdq{}rec\PYGZhy{}disable\PYGZdq{}/\PYGZgt{}
  \PYGZlt{}Binding sysex=\PYGZdq{}f0 7f 0 6 6 f7\PYGZdq{} function=\PYGZdq{}rec\PYGZhy{}enable\PYGZdq{}/\PYGZgt{}
  \PYGZlt{}Binding sysex=\PYGZdq{}f0 0 0 e 9 0 53 0 0 f7\PYGZdq{} function=\PYGZdq{}loop\PYGZhy{}toggle\PYGZdq{}/\PYGZgt{}

  \PYGZlt{}Binding channel=\PYGZdq{}1\PYGZdq{} note=\PYGZdq{}13\PYGZdq{} function=\PYGZdq{}transport\PYGZhy{}roll\PYGZdq{}/\PYGZgt{}
  \PYGZlt{}Binding channel=\PYGZdq{}1\PYGZdq{} note=\PYGZdq{}14\PYGZdq{} function=\PYGZdq{}transport\PYGZhy{}stop\PYGZdq{}/\PYGZgt{}
  \PYGZlt{}Binding channel=\PYGZdq{}1\PYGZdq{} note=\PYGZdq{}12\PYGZdq{} function=\PYGZdq{}transport\PYGZhy{}start\PYGZdq{}/\PYGZgt{}
  \PYGZlt{}Binding channel=\PYGZdq{}1\PYGZdq{} note=\PYGZdq{}11\PYGZdq{} function=\PYGZdq{}transport\PYGZhy{}zero\PYGZdq{}/\PYGZgt{}
  \PYGZlt{}Binding channel=\PYGZdq{}1\PYGZdq{} note=\PYGZdq{}10\PYGZdq{} function=\PYGZdq{}transport\PYGZhy{}end\PYGZdq{}/\PYGZgt{}
\PYGZlt{}/ArdourMIDIBindings\PYGZgt{}
\end{sphinxVerbatim}

Please note that channel, controller and note numbers are specified as
decimal numbers in the ranges 1-16, 0-127 and 0-127 respectively (the
channel range may change at some point).


\chapter{78.2 - Generic MIDI Learn}
\label{\detokenize{index:generic-midi-learn}}

\section{Philosophy}
\label{\detokenize{index:philosophy}}
There are no “best” ways to map an arbitrary MIDI controller for
controlling Ardour. There may be very legitimate reasons for different
users to prefer quite different mappings.

On every platform that Ardour runs on, there are excellent
free-of-charge tools for making connections between MIDI hardware and
“virtual” MIDI ports like the ones that Ardour creates and uses. Rather
than waste precious developer time replicating these connection/patch
managers, we prefer to leverage their existence by having users rely on
them to actually connect Ardour to other MIDI devices and software. On
OS X, we recommend Pete Yandell’s MIDI Patchbay. On Linux, a wide
variety of tools are available including QJackCtl, aconnect, Patchage,
and more.


\section{Basics}
\label{\detokenize{index:basics}}\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
Enable Generic MIDI control: Edit \textgreater{} Preferences \textgreater{} Control Surfaces \textgreater{}
Generic MIDI

\item {} 
Connect Ardour’s MIDI port named control to whatever hardware or
software you want (using a MIDI patchbay app)

\item {} 
Middle-click on whatever on-screen fader, plugin parameter control,
button etc. you want to control

\item {} 
A small window appears that says “Operate Controller now”

\item {} 
Move the hardware knob or fader, or press the note/key.

\item {} 
The binding is complete. Moving the hardware should control the
Ardour fader etc.

\end{enumerate}


\section{Cancelling a Learned MIDI Binding}
\label{\detokenize{index:cancelling-a-learned-midi-binding}}
To unlearn a learned MIDI binding, Middle-click on the control in the
same way as you did to learn it in the first place, but click on the
popup to cancel it.


\section{Avoiding work in the future}
\label{\detokenize{index:avoiding-work-in-the-future}}
If you want the bindings you set up to be used automatically in every
session, the simplest thing to do is to use Session \textgreater{} Save Template.
Then, when creating new sessions, select that template and all the
bindings will be automatically set up for you.


\chapter{78.3 - Generic MIDI and Encoders}
\label{\detokenize{index:generic-midi-and-encoders}}
Encoders are showing up more frequently on controllers. However, they
use the same MIDI events as Continuous Controllers and they have no
standard way of sending that information as MIDI events. Ardour 4.2 has
implemented 4 of the more common ways of sending encoder information.

Encoders that send the same continuous values as a pot would are not
discussed here as they are already supported by \sphinxcode{\sphinxupquote{ctl}}.

Encoders as this page talks about them send direction and offset that
the DAW will add to or subtract from the current value.

The 4 kinds of encoder supported are:
\begin{itemize}
\item {} 
enc-r: On the bcr/bcf2000 this is called “Relative Signed Bit”. The
most significant bit sets positive and the lower 6 significant bits
are the offset.

\item {} 
enc-l: The bcr2000 calls this “Relative Signed Bit 2”. The most
significant bit sets negative and the lower 6 significant bits are
the offset. If you are using one of these two and the values are
right but reversed, use the other. This one is the one the Mackie
Control Protocol uses.

\item {} 
enc-2: The bcr2000 calls this one “Relative 2s Complement”. Positive
offsets are sent as normal from 1 to 64 and negative offsets are sent
as 2s complement negative numbers.

\item {} 
enc-b: The bcr2000 calls this one “Relative Binary Offset”. Positive
offsets are sent as offset plus 64 and negative offsets are sent as
64 minus offset.

\end{itemize}

If the wrong one is chosen, either the positive or negative side will
act incorrectly. It is not really possible to auto detect which one the
controller is using. Trial and error is the only way if the
specification of the controller is not known.

Many controllers have more than one choice as well, check the manual for
the surface.


\chapter{79 - Using the PreSonus FaderPort}
\label{\detokenize{index:using-the-presonus-faderport}}
Since version 4.5, Ardour has had full support for the Presonus
Faderport. This is a compact control surface featuring a single
motorized fader, a single knob (encoder) and 24 buttons with fixed
labels. It is a relatively low-cost device that functions very well to
control a single (selected) track or bus, along with a variety of other
“global” settings and conditions.


\section{Connecting the Faderport}
\label{\detokenize{index:connecting-the-faderport}}
The Faderport comes with a single USB socket on the back. Connect a
suitable USB cable from there to a USB port on your computer. As of the
end of 2015, you should avoid USB3 ports—these cause erratic behaviour
with the device. This issue might get fixed by Presonus in the future.

Ardour uses the Faderport in what Presonus calls “native” mode. You do
not need to do anything to enable this—Ardour will set the device to be
in the correct mode. In native mode, the Faderport sends and receives
ordinary MIDI messages to/from the host, and the host understands the
intended meaning of these messages. We note this detail to avoid
speculation about whether Ardour supports the device via the HUI
protocol—it does not.

The Faderport will be automatically recognized by your operating system,
and will appear in any of the lists of possible MIDI ports in both
Ardour and other similar software.

To connect the Faderport to Ardour, open the Preferences dialog, and
then click on “Control Surfaces”. Click on the “Enable” button in the
line that says “Faderport” in order to activate Ardour’s Faderport
support. Then double click on the line that says “Faderport”. A new
dialog will open, containing (among other things) two dropdown selectors
that will allow you to identify the MIDI ports where your Faderport is
connected.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{faderport_dialog}.png}
\caption{The Faderport configuration dialog}\label{\detokenize{index:id618}}\end{figure}

Once you select the input and output port, Ardour will initialize the
Faderport and it will be ready to use. You only need do this once: once
these ports are connected and your session has been saved, the
connections will be made automatically in this and other future
sessions.

You do not need to use the power supply that comes with the Faderport
but without it, the fader will not be motorized. This makes the overall
experience of using the Faderport much less satisfactory, since the
fader will not move when Ardour tells it to, leading to very out-of-sync
conditions between the physical fader position and the “fader position”
inside the program.


\section{Using the Faderport}
\label{\detokenize{index:using-the-faderport}}
The Faderport’s controls can be divided into three groups:
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
Global controls such as the transport buttons

\item {} 
Controls which change the settings for particular track or bus

\item {} 
Controls which alter which track or bus is modified by the
per-track/bus controls.

\end{enumerate}

Because the Faderport has only a single set of per-track controls, by
default those controls operate on the first selected track or bus. If
there is no selected track or bus, the controls will do nothing.


\subsection{Transport Buttons}
\label{\detokenize{index:transport-buttons}}
The transport buttons all work as you would expect.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

Rewind
&
When pressed on its own, starts
the transport moving backwards.
Successive presses speed up the
“rewind” behaviour.

If pressed while also holding the
Stop button, the playhead will
return to the zero position on
the timeline.

If pressed while also holding the
Shift button, the playhead will
move to the session start marker.
\\
\hline
Fast Forward
&
When pressed on its own, starts
the transport moving faster than
normal. Successive presses speed
up the “fast forward” behaviour.

If pressed while also holding the
Shift button, the playhead will
move to the session end marker.
\\
\hline
Stop
&
Stops the transport. Also used in
combination with the Rewind
button to “return to zero”.
\\
\hline
Play
&
Starts the transport. If pressed
while the transport is already
rolling at normal speed, causes
the playhead to jump to the start
of the last “roll” and continue
rolling (“Poor man’s looping”).
\\
\hline
Record Enable
&
Toggles the global record enable
setting
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsection{Other Global Controls}
\label{\detokenize{index:other-global-controls}}
The Mix, Proj, Trns buttons do not obviously correspond any particular
functions or operations in Ardour. We have therefore allowed users to
choose from a carefully curated set of possible actions that seem
related to the button labels in some clear way. This can be done via the
Faderport configuration dialog accessed via
\sphinxcode{\sphinxupquote{Preferences \textgreater{} Control Surfaces}}. Each button has 3 possible actions
associated with it:
\begin{itemize}
\item {} 
Plain Press: action to be taken when the button is pressed on its
own.

\item {} 
Shift-Press: action to be taken when the button is pressed in
conjunction with the Shift button.

\item {} 
Long Press: action to be taken when the button is pressed on its own
and held down for more than 0.5 seconds.

\end{itemize}

Click on the relevant drop-down selector to pick an action as you
prefer.

The User button also has no obvious mapping to specific Ardour
functionality, so we allow users to choose from \sphinxstyleemphasis{any} possible GUI
action. The menu for selecting the action is somewhat confusing and it
can be hard to find what you’re looking for. However, all possible
actions are there, so keep looking!


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|*{2}{\X{1}{2}|}}
\hline

Mix
&
Possible actions include:
\begin{itemize}
\item {} 
Toggle Editor \& Mixer
visibility

\item {} 
Show/Hide the Editor mixer
strip

\end{itemize}
\\
\hline
Proj
&
Possible actions include:
\begin{itemize}
\item {} 
Toggle Meterbridge visibility

\item {} 
Toggle Session Summary
visibility

\item {} 
Toggle Editor Lists visibility

\item {} 
Zoom to session

\item {} 
Zoom in

\item {} 
Zoom out

\end{itemize}
\\
\hline
Trns
&
Possible actions include:
\begin{itemize}
\item {} 
Toggle Locations window
visibility

\item {} 
Toggle Metronome

\item {} 
Toggle external sync

\item {} 
Set Playhead at current
pointer position

\end{itemize}
\\
\hline
Undo/Redo
&
Undo Causes the last operation
carried out in the editor to be
undone. When pressed in
conjunction with the Shift
button, it causes the most recent
undone operation to be re-done.
\\
\hline
Punch
&
When pressed on its own, toggles
punch recording. If there is no
punch range set for the session,
this will do nothing.

When pressed in conjunction with
the Shift button, this moves the
playhead to the previous Marker
\\
\hline
User
&
See above. Any and all
GUI-initiated actions can be
driven with by pressing this
button on its own, or with a
“long” press.

When pressed in conjunction with
the Shift button, this will move
the playhead to the next marker.
\\
\hline
Loop
&
When pressed on its own, this
toggles loop playback. If the
Ardour preference “Loop-is-mode”
is enabled, this does nothing to
the current transport state. If
that preference is disabled, then
engaging loop playback will also
start the transport.

When pressed in conjunction with
the Shift button, this will
create a new (unnamed) marker at
the current playhead position.
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}


\subsection{Per-track Controls}
\label{\detokenize{index:per-track-controls}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

Mute
&
This toggles the mute setting of
the currently controlled
track/bus. The button will be lit
if the track/bus is muted.
\\
\hline
Solo
&
This toggles the solo (or listen)
setting of the currently
controlled track/bus. The button
will be lit if the track/bus is
soloed (or set to listen mode).
\\
\hline
Rec
&
This toggles the record-enabled
setting of the currently
controlled track/bus. The button
will be lit if the track is
record-enabled. This button will
do nothing if the Faderport is
controlling a bus.
\\
\hline
Fader
&
The fader controls the gain
applied to the currently
controlled track/bus. If the
Faderport is powered, changing
the gain in Ardour’s GUI or via
another control surface, or via
automation, will result in the
fader moving under its own
control.
\\
\hline
Knob/Dial/Encoder
&
The knob controls 1 or 2 pan
settings for the current
controlled track/bus. When used
alone, turning the knob controls
the “azimuth” or “direction”
(between left and right) for the
panner in the track/bus (if any).
This is all you need when
controlling tracks/busses with 1
input and 2 outputs.

If controlling a 2 input/2 output
track/bus, Ardour’s panner has
two controls: azimuth (direction)
and width. The width must be
reduced to less than 100\% before
the azimuth can be changed.
Pressing the “Shift” button while
turning the knob will alter the
width setting.

The knob can also be turned while
the “User” button is held, in
order to modify the input gain
for the currently controlled
track.
\\
\hline
Read
&
Enables playback/use of fader
automation data by the controlled
track/bus.
\\
\hline
Write
&
Puts the fader for the controlled
track/bus into automation write
mode. While the transport is
rolling, all fader changes will
be recorded to the fader
automation lane for the relevant
track/bus.
\\
\hline
Touch
&
Puts the fader for the controlled
track/bus into automation touch
mode. While the transport is
rolling, touching the fader will
initiate recording all fader
changes until the fader is
released. When the fader is not
being touched, existing
automation data will be
played/used to control the gain
level.
\\
\hline
Off
&
This disables all automation
modes for the currently
controlled track/bus. Existing
automation data will be left
unmodified by any fader changes,
and will not be used for
controlling gain.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsection{Track Selection Controls}
\label{\detokenize{index:track-selection-controls}}
You can manually change the track/bus controlled by the Faderport by
changing the selected track in Ardour’s editor window. If you select
more than 1 track, the Faderport will control the first selected track
and \sphinxstyleemphasis{only} that track/bus.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

Left (arrow)
&
This causes the Ardour GUI to
select the previous track/bus
(using the current visual order
in the editor window), which will
in turn cause the Faderport to
control that track. If there is
no previous track/bus, the
selected track/bus is left
unchanged, and the Faderport
continues to control it.
\\
\hline
Right (arrow)
&
This causes the Ardour GUI to
select the next track/bus (using
the current visual order in the
editor window), which will in
turn cause the Faderport to
control that track. If there is
no next track/bus, the selected
track/bus is left unchanged, and
the Faderport continues to
control it.
\\
\hline
Output
&
Pressing the Output button causes
the Faderport to control the
fader, pan, mute and solo
settings of the Master bus. If
your session does not contain a
Master bus, it does nothing. This
is a toggle button—pressing it
again returns Faderport to
controlling whichever track/bus
was selected before the first
press of the Output button.

If your session uses Ardour’s
monitor section, you can use
Shift-Output to assign it to the
Faderport in the same way that
Output assigns the Master bus.
This is also a toggle setting, so
the second Shift-Output will
return the Faderport to
controlling whichever track/bus
was selected before.

If you press Shift-Output after a
single press to Output (i.e.
control the Monitor Section while
currently controlling the Master
bus) or vice versa (i.e. control
the Master bus while currently
controlling the Monitor Section),
the press will be ignored. This
avoids getting into a tricky
situation where it is no longer
apparent what is being controlled
and what will happen if you try
to change it.
\\
\hline
Bank
&
The “Bank” button is currently
not used by Ardour
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\chapter{80 - Using the PreSonus FaderPort 8}
\label{\detokenize{index:using-the-presonus-faderport-8}}\label{\detokenize{index:using-the-presonus-faderport8}}
Since version 5.8-290, Ardour supports for the \sphinxhref{https://www.presonus.com/products/FaderPort-8}{Presonus FaderPort™
8}.

The FaderPort™ 8 is a production control surface with 8 touch-sensitive,
motorized faders, monochromatic digital scribble strips and more than 60
buttons with fixed labels.


\section{Connecting the FaderPort 8}
\label{\detokenize{index:connecting-the-faderport-8}}
The FaderPort 8 (FP8) comes with a USB socket on the back. Connect a
suitable USB cable from there to a USB port on your computer. The FP8
will be automatically recognized by your operating system, and will
appear in any of the lists of possible MIDI ports in both Ardour and
other similar software.

\begin{DUlineblock}{0em}
\item[] Ardour uses the FaderPort 8 in what PreSonus calls “Studio One” or
“native” mode. To use the FaderPort8 with Ardour’s FP8 Control
Surface, make sure that the device is in “Studio One” mode. (If you
would like to change the mode at any point, power on the unit while
holding down the two leftmost Select buttons, see the FaderPort 8
manual for further details. Also note that at least firmware version
1.01 is required. NB. “factory default” resets the firmware, see the
PreSonus FaderPort8 Owner’s manual chapter 9.4.)
\item[] While the FaderPort provides a Mackie Control Universal (MCU) mode,
which works with Ardour’s Mackie Control Surface, MCU does not support
various elements available on the FP8 (e.g. colored buttons, and the
custom mode scribble strips).
\end{DUlineblock}

To connect the FP8 to Ardour, open the Preferences dialog, select
“Control Surfaces” and enable “PreSonus FaderPort 8”. Then open the
“Protocol Settings” dialog for the FP8. Which (among other things)
allows to select the the MIDI ports corresponding to the FP8.

Once you select the input and output port, Ardour will initialize the
FP8 and it will be ready to use. You only need do this once: Once these
ports are connected and your session has been saved, the connections
will be made automatically in this and other future sessions.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{fp8_settings}.png}
\caption{FaderPort8 Control Surface Settings Dialog}\label{\detokenize{index:id619}}\end{figure}


\section{Using the FaderPort 8}
\label{\detokenize{index:using-the-faderport-8}}
The FaderPort’s controls can be divided into five groups:
\begin{itemize}
\item {} 
Transport buttons

\item {} 
Session Navigation controls

\item {} 
Fader modes

\item {} 
Mix management

\item {} 
Channel strip

\end{itemize}

In general the control mapping described in the FaderPort 8 Owner’s
Manual for Studio One (chapter 2) applies to Ardour as well. There are
however subtle differences where the DAWs differ.

Buttons generlaly act on release (not press), with exception of
transport-control (since 6.0pre) and individual exceptions mentioned
below.


\subsection{Transport Buttons}
\label{\detokenize{index:transport-buttons-1}}\label{\detokenize{index:id70}}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{fp8_transport}.png}
\caption{FaderPort8 Transport Buttons}\label{\detokenize{index:id620}}\end{figure}
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
Stop: Stops the transport. Press twice to return to session start.

\item {} 
Loop: Toggles loop playback. A loop-range needs to be defined in the
session for looping to be engaged.

\item {} 
Play/Pause: Roll/Stop the transport (note that Ardour has no “pause”
mode: Pause is equivalent to stop). During vari-speed playback,
pressing “play” resets to 100\% forward speed.

\item {} 
Rewind: Rewind, roll backwards. Successive presses or holding the
button incrementally changes the speed.

\item {} 
Fast Forward: Roll forward. Successive presses or holding the button
accumulate speed. Pressing (Rewind and Fast Forward) simultaneously
stops playback and returns the playhead to zero.

\item {} 
Record: Toggles the global record enable setting.

\end{enumerate}


\subsection{Session Navigation}
\label{\detokenize{index:session-navigation}}
Session Navigation allows quick navigation and provides access to
session-wide controls. Each of the eight buttons alters the function of
the push-button encoder and the Prev, Next buttons. With exception of
Click the seven modes are exclusive (radio buttons).

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{fp8_navigation}.png}
\caption{FaderPort8 Navigation Buttons}\label{\detokenize{index:id621}}\end{figure}
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
Channel: The Prev / Next buttons select the previous/next
mixer-strip. If no strip is selected, Next selects the first, Prev
the last mixer-strip in the session. Pressing the encoder knob moves
the most recently selected mixer-strip into view on the FP8. The
encoder scrolls the editor-canvas up/down.

\item {} 
Master: The encoder controls the master-bus level. If a session
includes a monitor-section, the encoder controls monitor-out by
default. Hold the button to control the master-bus level. Press the
encoder knob to reset the gain to 0dB. The Prev / Next navigation
buttons bank the visible strips on the FP8 by one track left/right.

\item {} 
Zoom: The encoder controls horizontal zoom of the editor. Press the
encoder to \sphinxstyleemphasis{zoom to fit} the session. Prev / Next navigation buttons
zoom selected track(s) vertically (or all tracks if none are
selected).

\item {} 
Click: Toggle the metronome on/off. While holding the Click button,
the encoder modifies the volume of the metronome click (press the
encoder while holding Click to reset the metronome level to 0dBFS).

\item {} 
Scroll: The encoder scrolls the timeline (hold Shift for finer
steps). Pressing the encoder \sphinxstyleemphasis{zooms to fit} the session. The Prev /
Next navigation buttons bank the visible strips on the FP8 by one
track left/right.

\item {} 
Section: The Prev / Next navigation buttons nudge the selected region
by the time configured in the nudge-clock. If no region is selected
the playhead position is nudged. The encoder always nudges the
playhead position.

\item {} 
Bank: Encoder and navigation buttons scroll through mixer-strips in
banks of eight. Pressing the encoder moves the most recently selected
mixer-strip into view on the FP8.

\item {} 
Marker: The encoder scrolls the timeline (hold Shift for finer
steps). The Prev / Next navigation buttons jump to prev/next markers.
Press the encoder to drop a new marker.

\end{enumerate}

When combined with Shift, the eight buttons will access custom
functions, which can be configured in the Preference Dialog. The buttons
will light up if an action has been assigned to a button.

The following tables shows a condensed overview of the
session-navigation modes:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|*{4}{\X{1}{4}|}}
\hline
\sphinxstyletheadfamily &\sphinxstyletheadfamily 
Prev / Next
&\sphinxstyletheadfamily 
Encoder knob
&\sphinxstyletheadfamily 
Encoder Press
\\
\hline
Channel
&
Select
prev/next
mixer-strip
&
Scroll Editor
up/down
&
Bank to show
selected strip
on FP8
\\
\hline
Master
&
Bank visible
strips on FP8
by 1
&
Adjust
master/monitor
level
&
Reset
master/monitor
to 0dB
\\
\hline
Zoom
&
Vertical zoom
(editor
track-height)
&
Horizontal
timeline zoom
(time)
&
Horizontal zoom
to session
\\
\hline
Scroll
&
Bank visible
strips on FP8
by 1
&
Scroll the
timeline (move
playhead)
&
Horizontal zoom
to session
\\
\hline
Section
&
Nudge the
selected region
&
Nudge the
playhead
&\begin{itemize}
\item {} 
\end{itemize}
\\
\hline
Bank
&
Bank visible
strips on FP8
by 8
&
Bank visible
strips on FP8
by 1
&
Bank to show
selected strip
on FP8
\\
\hline
Marker
&
Move to
prev/next
marker
&
Scroll the
timeline (move
playhead)
&
Drop a new
marker
\\
\hline
Press and hold
Click
&
(mode
dependent)
&
Adjust
metronome Level
&
Reset metronome
level to 0dBFS
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}


\subsection{Shift Button}
\label{\detokenize{index:shift-button}}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{fp8_shift_large}.png}
\caption{The FaderPort8 Shift Button}\label{\detokenize{index:id622}}\end{figure}

\begin{DUlineblock}{0em}
\item[] The two Shift buttons are identical, they’re copied to provide
convenient access to the modifiers. Pressing and holding the Shift
button updates the lights (and colors on RGB buttons) to indicate the
modified control.
\item[] Pressing and holding the Shift button for one second without pressing
any other button enters shift-lock mode. Press Shift again to reset.
The Shift button engages directly on press. Activating an action while
the button is held will void the shift-lock mode.
\end{DUlineblock}


\subsection{Fader Modes}
\label{\detokenize{index:fader-modes}}
The eight faders on the FP8 can be assigned to various automatable
controls present in the current session. The four fader-mode buttons
change the behavior of the mixer-strip and scribble strip displays.
(Note: with the 1.01 firmware these buttons always act on press.)

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{fp8_fadermode}.png}
\caption{FaderPort8 Fader Mode Buttons}\label{\detokenize{index:id623}}\end{figure}
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
Track: In Track-mode, the motorized faders display and control a
mixer-strip’s signal level. The Pan/Param encoder modifies the
azimuth of the panner (hold Shift to control the width, if the
track’s panner supports it). Mute and Solo affect the respective
mixer-strip.

\item {} 
Edit Plugins: When Edit Plug-ins mode is active, the motorized faders
will control the parameter settings of a given plugin-insert.
Press the Edit Plugins button to view all available plugin-inserts on
a strip. If no plugins are available, Edit Plugins will not engage
and the FP8 automatically switches back to Track-mode.
\sphinxstylestrong{Select Plugin Mode}: Use the Select buttons under the scribble
strip to pick a plugin to edit.
The Select button color indicates the bypass/enable state of the
plugin (red: bypassed, green: enabled). Use Shift + Select to toggle
the bypass state.
Selecting a plugin enters \sphinxstylestrong{Parameter Edit Mode}: The faders and the
Select buttons will respectively control the parameters and toggle
controls of the selected plugin (once a plugin has been selected, it
stays in edit mode regardless of track selection). If there are more
than eight parameters, the Pan/Param encoder allows to scroll through
available control-parameters (hold Shift to bank by 8).
If the plugin has any presets, pressing the Pan/Param encoder
switches to the \sphinxstylestrong{plugin-preset display}: Plugin preset names are
displayed on the scribble-displays, the Select button below each
loads the preset. The “Pan/Param” encoder can be used to scroll
through presets if there are more than seven (right-most, 8th, slot
is reserved to unload/clear a loaded preset, hold Shift to bank by
7). The Select button color is used to indicate the currently loaded
preset (if any) and blinks if a parameter has been modified since
loading the preset. Loading a preset or pressing the Pan/Param
encoder again switches back to the Plugin Parameter Edit Mode.
In Parameter Edit Mode, the “Open” (Shift + Macro) allows to toggle
the Plugin GUI visibility.
Press the Edit Plugins button again to return to the Select Plugin
Mode.

\item {} 
Sends: In Sends mode, each of the faders is mapped to the send-level
of aux-sends of the selected track. If there are more than eight
sends on a given track, the Pan/Param encoder can scroll through
them. Send-mode follow the selection. If there are no sends on a
given track, the FP8 automatically switches back to Track-mode.

\item {} 
Pan: When Pan mode is active, the motorized faders will display and
control the panner’s azimuth. The Pan/Param controls the pan-width of
the selected mixer-strip.

\end{enumerate}

Shift + Track toggles timecode display on/off (middle row of the
scribble-strip). The timecode format can be configured in the Control
Surface Preference Dialog (Timecode, musical-time: bar/beat/tick).


\subsection{Channel Strip}
\label{\detokenize{index:channel-strip}}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{fp8_strip}.png}
\caption{The FaderPort8 Channel Strip}\label{\detokenize{index:id624}}\end{figure}
\begin{itemize}
\item {} 
\sphinxstylestrong{Touch-Sensitive Fader}: The fader can be used to control volume
levels, aux send levels, panning, or plugin parameters, depending on
the fader-mode (see above).

\item {} 
\sphinxstylestrong{Pan/Param}: The encoder controls panning in Track and Pan mode. In
Plugin and Send fader-modes, the encoder banks parameters. See Fader
modes above for details. When “Link” is engaged, the encoder can
control any automatable parameter (see Miscellaneous below).

\item {} 
Mute: Toggle the mute-control of the corresponding mixer-strip. Mute
engages on press, and disengages on release. Press and hold the
button for at least 0.5sec for momentary.

\item {} 
Solo: Toggle the solo or listen (AFL,PFL) control of the
corresponding mixer-strip. Solo engages on press, and disengages on
release. Press and hold the button for at least 500ms for momentary.

\item {} 
Select: In Track and Sends and Pan mode the Select button
select/de-select a given mixer-strip.
Since selection is not limited to a single mixer-strip, the button
acts in tri-state. A mixer-strip light indicates selection:
\begin{itemize}
\item {} 
\sphinxstylestrong{Any Selected Track}: The select button is lit with the track’s
color.

\item {} 
\sphinxstylestrong{Any Not Selected Track}: The select button is off (dimly
showing the track’s color).

\item {} 
\sphinxstylestrong{Most Recently Selected Track}: Only one track at a time. The
select button blinks with the track’s color.

\end{itemize}

Operations such as Edit Plugins or Sends use the
most-recently-selected (focused) track. To modify the selection, the
button’s action depends on the current selection:
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
\sphinxstylestrong{Select}: The track is exclusively selected and also becomes the
most-recently selected.

\item {} 
\sphinxstylestrong{Shift + Select any selected track}: Deselect the track.

\item {} 
\sphinxstylestrong{Shift + Select any unselected track}: Adds the given track to
the selection and make it most-recently selected).

\end{enumerate}

\end{itemize}

In Track-mode, pressing the Select button of the most recently selected
track (blinking Select button) will reset the fader-gain to unity (0dB).
(since Ardour 5.11-207, Mixbus 4.2-66)

While holding the ARM button the Select button lights change to red and
the Select buttons controls the record-arm of the given track.
Mixer-strips that cannot be record-armed have a dim white light.

Shift + ARM record-arms all tracks in the session.


\subsection{Mix Management}
\label{\detokenize{index:mix-management}}
These buttons allows to select which mixer-strips are spilled on the FP8
channel-strips.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{fp8_mixmanage}.png}
\caption{FaderPort8 Mix Management Buttons}\label{\detokenize{index:id625}}\end{figure}
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
Audio: View Audio Tracks only.

\item {} 
VI: Show tracks with virtual instrument plugins.

\item {} 
Bus: Display only Busses.

\item {} 
VCA: Show VCAs.

\item {} 
All: Display all Tracks, Busses (incl master-bus) and VCAs.

\end{enumerate}

In combination with the Shift modifier ten total filters are available:
\begin{itemize}
\item {} 
Shift + Audio \sphinxstylestrong{Inputs}: shows all record-armed tracks (Audio and
MIDI).

\item {} 
Shift + VI \sphinxstylestrong{MIDI}: View all MIDI tracks.

\item {} 
Shift + Bus \sphinxstylestrong{Outputs}: Show the Master and Monitor Bus.

\item {} 
Shift + VCA \sphinxstylestrong{FX}: Shows Aux-Busess.

\item {} 
Shift + All \sphinxstylestrong{User}: Display all currently selected mixer-strips
only.

\end{itemize}


\subsection{Automation Controls}
\label{\detokenize{index:automation-controls}}
The Automation Controls provide access to the currently selected
mixer-strips. The automation enable lights indicates the mode of the
most recently selected mixer-strip (blinking selection button). The
action affects all selected mixer-strips. The automation controls are
currently only available in Track and Pan fader modes where they affect
the fader and pan automation modes respectively.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{fp8_automation}.png}
\caption{FaderPort8 Automation Buttons}\label{\detokenize{index:id626}}\end{figure}
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
Latch: Currently not available in Ardour.

\item {} 
Trim: Currently not available in Ardour.

\item {} 
Off: Select “Manual” automation mode.

\item {} 
Read: Select “Play” automation mode.

\item {} 
Write: Select “Write” automation mode (note at the end of a write
pass, Ardour automatically puts the track into “Touch” mode.

\item {} 
Touch Select “Touch” automation mode.

\end{enumerate}

The Automation Controls also double as session state controls when
combined with Shift.
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
Shift + Latch \sphinxstylestrong{Save}: Save the session. The button lights up red if
the session is modified.

\item {} 
Shift + Trim \sphinxstylestrong{Redo}: Redo a previously undone operation. The button
lights up green if redo is possible.

\item {} 
Shift + Off \sphinxstylestrong{Undo}: Undo the most recent operation. The button
lights up green if undo is possible.

\end{enumerate}

With Shift, the bottom row allows to bind three custom user actions.


\subsection{Miscellaneous}
\label{\detokenize{index:miscellaneous}}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{fp8_misc}.png}
\caption{FaderPort8 Misc Buttons}\label{\detokenize{index:id627}}\end{figure}
\begin{itemize}
\item {} 
Solo Clear: Reset all solo controls in the session. If the FP8 was
used to clear solo-state, pressing the button again will restore the
previous state (unless solo state was modified manually since).

\item {} 
Mute Clear: Unmute all mixer-strips in the session. If the FP8 was
used to clear mute-state, pressing the button again will restore the
previous mute state (unless mute-state was changed manually since).

\item {} 
Bypass: The behavior depends on the edit-mode:
\begin{itemize}
\item {} 
\sphinxstylestrong{Track + Pan Mode}: A/B bypass toggle any plugins on all
selected mixer-strips.

\item {} 
\sphinxstylestrong{Edit Plugin Parameter}: Toggle bypass of of the plugin that is
currently being edited. Bypass state is indicated by color: red
for bypassed, green for enabled (not bypassed).

\end{itemize}

\item {} 
Shift + Bypass \sphinxstylestrong{Bypass All}: A/B bypass toggle any plugins on all
selected mixer-strips.

\item {} 
Macro: Toggle Editor and Mixer Windows/Tabs.

\item {} 
Shift + Macro \sphinxstylestrong{Open}: The behavior depends on the edit-mode:
\begin{itemize}
\item {} 
\sphinxstylestrong{Edit Plugin Parameter}: Toggle Plugin GUI visibility (if it has
a GUI) of the plugin that is currently being edited.

\item {} 
\sphinxstylestrong{all other modes}: Show the Import Audio Dialog.

\end{itemize}

\item {} 
Link: Activate Control-Link Mode (only available in Track and Pan
modes).
The Pan/Param encoder controls the element over which the
mouse-cursor hovers in the GUI. One can access any parameter which
can be automated.
Pressing the Pan/Param encoder resets the control-parameter to the
default value.
The buttons color is used to indicate the link-state:
\begin{itemize}
\item {} 
\sphinxstylestrong{orange}: Link is enabled, but the mouse-cursor is not over an
element which can be controlled.

\item {} 
\sphinxstylestrong{yellow}: Link is enabled, and the cursor is hovering over a
controllable element.

\item {} 
\sphinxstylestrong{green}: Link is locked to a given element (see below).

\item {} 
\sphinxstylestrong{turquoise}: Link lock is possible (when pressing Shift while
link-mode is enabled).

\item {} 
\sphinxstylestrong{red}: Link-lock is not possible (only when pressing Shift while
link-mode is enabled without a valid element to control.

\end{itemize}

\item {} 
Shift + Link \sphinxstylestrong{Lock}: When in Link-mode (see above), this allows to
lock the current control to the Pan/Param encoder. Link will no
longer follow the GUI mouse-cursor.
If Link-mode is not enabled, Lock, locks the GUI (alike Session \textgreater{}
Lock) to prevent accidental changes.

\end{itemize}

Link and Link-Lock mode will automatically disengage when entering Sends
or Edit Plugins mode.


\subsection{Harrison Mixbus}
\label{\detokenize{index:harrison-mixbus}}
The above also applies to Ardour-derivatives Harrison-Mixbus and Mixbus
32C with a few subtle differences:
\begin{itemize}
\item {} 
Mix Management \sphinxstylestrong{Bus} shows Mixbusses only, while \sphinxstylestrong{FX} spills
Aux-busses.

\item {} 
The Mixbus built-in EQ and Compressor are present on every track and
bus and always available. They are displayed as special plugins on
right-side in \sphinxstylestrong{Select Plugin Mode}. When editing those processors,
the parameters follows track selection (for other plugins this is not
possible since they may not be present).

\item {} 
Fader mode \sphinxstylestrong{Sends} shows mixbus-assigns first (before any optional
aux-sends). The master-bus-assign is available on the “S”olo button
of the right-most strip.

\end{itemize}


\chapter{81 - Using the Ableton Push 2}
\label{\detokenize{index:using-the-ableton-push-2}}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{push2-main}.jpg}
\caption{The Ableton Push 2 surface}\label{\detokenize{index:id628}}\end{figure}

Since version 5.4, Ardour has had extensive support for the Ableton
Push2. This is an expensive but beautifully engineered control surface
primarily targeting the workflow found in Ableton’s Live software and
other similar tools such as Bitwig. As of version 5.4, Ardour does not
offer the same kind of workflow, so we have designed our support for the
Push 2 around mixing and editing and musical performance, without the
clip/scene oriented approach in Live. This may change in future versions
of Ardour.


\section{Connecting the Push 2}
\label{\detokenize{index:connecting-the-push-2}}
Plug the USB cable from the Push 2 into a USB2 or USB3 port on your
computer. For brighter backlighting, also plug in the power supply (this
is not necessary for use).

The Push 2 will be automatically recognized by your operating system,
and will appear in any of the lists of possible MIDI ports in both
Ardour and other similar software.

To connect the Push 2 to Ardour, open the Preferences dialog, and then
click on “Control Surfaces”. Click on the “Enable” button in the line
that says “Ableton Push 2” in order to activate Ardour’s Push 2 support.

Once you select the input and output port, Ardour will initialize the
Push 2 and it will be ready to use. You only need do this once: once
these ports are connected and your session has been saved, the
connections will be made automatically in this and other future
sessions.


\section{Push 2 Configuration}
\label{\detokenize{index:push-2-configuration}}
The only configuration option at this time is whether the pads send
aftertouch or polyphonic pressure messages. You can alter this setting
via the Push 2 GUI, accessed by double-clicking on the “Push 2” entry in
the control surfaces list.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{push2-gui}.png}
\caption{The Push 2 configuration dialog}\label{\detokenize{index:id629}}\end{figure}


\section{Basic Concepts}
\label{\detokenize{index:basic-concepts-1}}\label{\detokenize{index:id71}}
With the Push 2 support in Ardour 5.4, you can do the following things:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

Perform using the 8 x 8 pad
“grid”
&
The Push 2 has really lovely
pressure-sensitive pads that can
also generate either aftertouch
or note (polyphonic) pressure.
\\
\hline
Global Mixing
&
See many tracks at once, and
control numerous parameters for
each.
\\
\hline
Track/Bus Mixing
&
View a single track/bus, with
even more parameters for the
track.
\\
\hline
Choose the mode/scale, root note
and more for the pads
&
37 scales are available. Like
Live, Ardour offers both “in-key”
and “chromatic” pad layouts.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

… plus a variety of tasks related to transport control, selection,
import, click track control and more.


\section{Musical Performance}
\label{\detokenize{index:musical-performance}}
Messages sent from the 8x8 pad grid and the “pitch bend bar” are routed
to a special MIDI port within Ardour called “Push 2 Pads” (no extra
latency is incurred from this routing). Although you can manually
connect this port to whatever you wish, the normal behaviour of Ardour’s
Push 2 support is to connect the pads to the most recently selected MIDI
track.

This means that to play a soft-synth/instrument plugin in a given MIDI
track with the Push 2, you just need to select that track.

If multiple MIDI tracks are selected at once, the first selected track
will be used. Note that messages originating from all other controls on
the Push 2 will \sphinxstyleemphasis{not} not be delivered to the “Push 2 Pads” port. This
makes no difference in practice, because the other controls do not send
messages that are useful for musical performance.


\section{Global Mix}
\label{\detokenize{index:global-mix}}
This is the default mode that Ardour will start the Push 2 in. In this
mode, the 8 knobs at the top of the device, the 8 buttons below them,
the video display and the 8 buttons below that are combined to provide a
global view of the session mix.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{push2-globalmix}.png}
\caption{Global mix mode on Push2 screen}\label{\detokenize{index:id630}}\end{figure}

The upper buttons are labelled by text in the video display just below
them. Pressing one of the buttons changes the function of the knobs, and
the parameters that will shown for each track/bus in the display.

As of Ardour 5.4, the possible parameters are:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

Volumes
&
The display shows a knob and text
displaying the current gain
setting for the track, and a
meter that corresponds precisely
to the meter shown in the Ardour
GUI for that track. Changing the
meter type (e.g. from Peak to
K12) in the GUI will also change
it in the Push 2 display. The
physical knob will alter
track/bus gain.
\\
\hline
Pans
&
The display shows a knob
indicating the pan
direction/azimuth for the
corresponding track/bus. Turning
the physical knob will pan the
track left and right. If the
track/bus has no panner (i.e. it
has only a single output), no
knob is shown and the physical
knob will do nothing.
\\
\hline
Pan Widths
&
For tracks with 2 outputs, the
display will show a knob
indicating the pan width setting
for the corresponding track/bus.
The physical knob can be turned
to adjust the width.

Unlike many DAWs, Ardour’s stereo
panners have “width” parameter
that defaults to 100\%. You cannot
change the pan direction/azimuth
of a track with 100\% width, but
must first reduce the width in
order to pan it. Similarly, a
track panned anywhere other than
dead center has limits on the
maximum width setting. If these
concepts are not familiar to you,
please be aware than many DAWs
use a “panner” that actually
implement “balance” and not
“panning”, hence the difference.
\\
\hline
A Sends
&
The display shows a knob
indicating the gain level for the
first send in that track. If the
track has no send, no knob will
be shown, and the physical knob
for that track will do nothing.
\\
\hline
B Sends, C Sends, D Sends
&
Like “A Sends”, but for the 2nd,
3rd and 4th sends of a track/bus
respectively.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

To change which tracks are shown while in global mix mode, use the left
and right arrow/cursor keys just below and to the right of the display.
Tracks and busses that are hidden in Ardour’s GUI will also be hidden
from display on the Push 2.

To select a track/bus directly from the Push 2, press the corresponding
button below the display. The track name will be highlighted, and the
selection will change in Ardour’s GUI as well (and also any other
control surfaces).


\subsection{Soloing and Muting in Global Mix mode}
\label{\detokenize{index:soloing-and-muting-in-global-mix-mode}}
The Solo and Mute buttons to the left of the video display can be used
to solo and mute tracks while in Global Mix mode. The operation will be
applied to the \sphinxstyleemphasis{first} currently selected track(s).

There are two indications that one or more tracks are soloed:
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
The solo button will blink red

\item {} 
Track names will be prefixed by “*” if they are soloed, and “-” if
they are muted due to soloing.

\end{enumerate}

To cancel solo, either:
\begin{itemize}
\item {} 
Select the soloed track(s) and press the solo button again

\item {} 
Press and hold the solo button for more than 1 second

\end{itemize}


\section{Track Mix}
\label{\detokenize{index:track-mix}}
Track Mix mode allows you to focus on a single track in more detail than
is possible in Global Mix mode. To enter (or leave) Track Mix mode,
press the “Mix” button.

In Track Mix mode, various aspects of the state of the first selected
track/bus will be displayed on the Push 2. Above the display, the first
4 knobs control track volume (gain), pan directiom/azimuth, pan width,
and where appropriate, track input trim.

Below the display, 7 buttons provide immediate control of mute, solo,
rec-enable, monitoring (input or disk or automatic), solo isolate and
solo safe state. When a a track is muted due to other track(s) soloing,
the mute button will flash (to differentiate from its state when it is
explicitly muted).

The video display also shows meters for the track, which as in Global
Mix mode, precisely match the meter type shown in Ardour’s GUI. There
are also two time displays showing the current playhead position in both
musical (beats\textbar{}bars\textbar{}ticks) format, and as hours:minutes:seconds.

To change which track is visible in Track Mix mode, use the left/right
arrow/cursor keys just below and to the right of the video display.


\section{Scale Selection}
\label{\detokenize{index:scale-selection}}
Press the Scale button to enter Scale mode. The display will look like
this:

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{push2-scale}.png}
\caption{Track mix mode on Push2 screen}\label{\detokenize{index:id631}}\end{figure}

In the center, 37 scales are presented. Scroll through them by either
using the cursor/arrow keys to the lower right of the display, or the
knobs above the display. The scale will change dynamically as you
scroll. You can also scroll in whole pages using the upper right and
upper left buttons above the display (they will display “\textless{}” and “\textgreater{}” if
scrolling is possible).

To change the root note of the scale, press the corresponding button
above or below the video display.The button will be lit to indicate your
selection (and the text will be highlighted).

By default, Ardour configures the Push 2 pads to use “in-key” mode,
where all pads correspond to notes “in” the chosen scale. Notes
corresponding to the root note, or the equivalent note in higher
octaves, are highlighted with the color of the current target MIDI
track.

In “chromatic” mode, the pads correspond to a continuous sequence of
notes starting with your selected root note. Pads corresponding to notes
in the scale are illuminated; those corresponding to the root note are
lit with the color the current target MIDI track. Other pads are left
dark, but you can still play them.

To switch between them, press button on the lower left of the video
display; the text above it will display the current mode (though it is
usually visually self-evident from the pad lighting pattern).

To leave Scale mode, press the “Scale” button again. You may also use
the upper left button above the display, though if you have scrolled
left, it may require more than one press.


\section{Specific Button/Knob Functions}
\label{\detokenize{index:specific-button-knob-functions}}
In addition to the layouts described above, many (but not all) of the
buttons and knobs around the edges of the Push 2 will carry out various
functions related to their (illuminated) label. As of Ardour 5.4, this
includes:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

Metronome (button and adjacent
knob)
&
Enables/disables the click
(metronome). The knob directly
above it will control the volume
(gain) of the click.
\\
\hline
Undo/Redo
&
Undo or redo the previous editing
operation.
\\
\hline
Delete
&
Deletes the currently selected
region, or range, or note.
Equivalent to using Ctrl/Cmd-x on
the keyboard.
\\
\hline
Quantize
&
If a MIDI region is selected in
Ardour, this will open the
quantize dialog.
\\
\hline
Duplicate
&
Duplicates the current region or
range selection.
\\
\hline
Rec-Enable
&
Enables and disables Ardour’s
global record enable state.
\\
\hline
Play
&
Starts and stops the transport.
Press Shift-Play to return to the
session start.
\\
\hline
Add Track
&
Opens Ardour’s Add Track/Bus
dialog.
\\
\hline
Browse
&
Open’s Ardour’s import dialog to
select and audition existing
audio and MIDI files.
\\
\hline
Master
&
Pressing this button jumps
directly to Track Mix mode, with
the master out bus displayed.
\\
\hline
Cursor arrows
&
These are used by some modes to
navigate within the display (e.g
Scale mode). In other modes, the
up/down cursor arrows will scroll
the GUI display up and down,
while the left/right cursor
arrows will generally scroll
within the Push 2 display itself.
\\
\hline
Repeat
&
Enables/disables loop playback.
This will follow Ardour’s “loop
is mode” preference, just like
the loop button in the Ardour
GUI.
\\
\hline
Octave buttons
&
These shift the root note of the
current pad scale up or down by 1
octave.
\\
\hline
Page buttons
&
These scroll Ardour’s editor
display left and right along the
timeline.
\\
\hline
Master (top right) knob
&
This knob controls the
gain/volume of Ardour’s main
output. If the session has a
monitor section.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\chapter{Part XII - Scripting}
\label{\detokenize{index:part-xii-scripting}}\label{\detokenize{index:scripting}}

\chapter{82 - Lua Scripting}
\label{\detokenize{index:lua-scripting}}
Starting with version 4.7.213, Ardour supports Lua scripts.

This Documentation is Work in Progress and far from complete. Also the
documented API may be subject to change.


\section{Preface}
\label{\detokenize{index:preface}}\label{\detokenize{index:id72}}
There are cases that Ardour cannot reasonably cater to with core
functionality alone, either because they’re session specific or user
specific edge cases.

Examples for these include voice-activate (record-arm specific tracks
and roll transport depending on signal levels), rename all regions after
a specific timecode, launch an external application when a certain track
is soloed, generate automation curves or simply provide a quick shortcut
for a custom batch operation.

Cases like this call for means to extend the DAW without actually
changing the DAW itself. This is where scripting comes in.

“Scripting” refers to tasks that could alternatively be executed
step-by-step by a human operator.

Lua is a tiny and simple language which is easy to learn, yet allows for
comprehensive solutions. Lua is also a glue language it allows to tie
existing component in Ardour together in unprecedented ways, and most
importantly Lua is one of the few scripting-languages which can be
safely used in a real-time environment.

A good introduction to Lua is the book \sphinxhref{http://www.lua.org/pil/}{Programming in
Lua}. The first edition is available online,
but if you have the means buy a copy of the book, it not only helps to
support the Lua project, but provides for a much nicer reading and
learning experience.


\section{Overview}
\label{\detokenize{index:id73}}\label{\detokenize{index:id74}}
The core of Ardour is a real-time audio engine that runs and processes
audio. One interfaces with an engine by sending it commands. Scripting
can be used to interact with or modify the active Ardour session, just
like a user uses the Editor/Mixer GUI to modify the state or parameters
of the session.

Doing this programmatically requires some knowledge about the objects
used internally. Most Ardour C++ objects and their methods are directly
exposed to Lua and one can call functions or modify variables:





C++
\sphinxcode{\sphinxupquote{session-\textgreater{}set\_transport\_speed (1.0);}}





Lua
\sphinxcode{\sphinxupquote{Session:set\_transport\_speed (1.0)}}









You may notice that there is only a small syntactic difference in this
case. While C++ requires recompiling the application for every change,
Lua script can be loaded, written or modified while the application is
running. Lua also abstracts away many of the C++ complexities such as
object lifetime, type conversion and null-pointer checks.

Close ties with the underlying C++ components is where the power of
scripting comes from. A script can orchestrate interaction of
lower-level components which take the bulk of the CPU time of the final
program.

At the time of writing Ardour integrates Lua 5.3.2: \sphinxhref{http://www.lua.org/manual/5.3/manual.html}{Lua 5.3 reference
manual}.


\section{Integration}
\label{\detokenize{index:integration}}\label{\detokenize{index:id75}}
Like Control surfaces and the GUI, Lua Scripts are confined to certain
aspects of the program. Ardour provides the framework and runs Lua (not
the other way around).

In Ardour’s case Lua is available:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

Editor Action Scripts
&
User initiated actions (menu,
shortcuts) for batch processing
\\
\hline
Editor Hooks/Callbacks
&
Event triggered actions for the
Editor/Mixer GUI
\\
\hline
Session Scripts
&
Scripts called at the start of
every audio cycle (session,
real-time)
\\
\hline
DSP Scripts
&
Audio/Midi processor - plugins
with access to the Ardour session
(per track/bus, real-time)
\\
\hline
Script Console
&
Action Script commandline
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

There are is also a special mode:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

Commandline Tool
&
Replaces the complete Editor GUI,
direct access to libardour (no
GUI) from the commandline.
\sphinxstyleemphasis{Be aware that the vast majority
of complex functionality is
provided by the Editor UI.}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\section{Managing Scripts}
\label{\detokenize{index:managing-scripts}}\label{\detokenize{index:id76}}
Ardour searches for Lua scripts in the \sphinxcode{\sphinxupquote{scripts}} folder in
\sphinxcode{\sphinxupquote{\$ARDOUR\_DATA\_PATH}}, Apart from scripts included directly with Ardour,
this includes


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

GNU/Linux
&
\sphinxcode{\sphinxupquote{\$HOME/.config/ardour5/scripts}}
\\
\hline
Mac OS X
&
\sphinxcode{\sphinxupquote{\$HOME/Library/Preferences/Ardour5/scripts}}
\\
\hline
Windows
&
\sphinxcode{\sphinxupquote{\%localappdata\%\textbackslash{}ardour5\textbackslash{}scripts}}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

Files must end with \sphinxcode{\sphinxupquote{.lua}} file extension.

Scripts are managed via the GUI


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

Editor Action Scripts
&
Menu \(\rightarrow\) Edit \(\rightarrow\) Scripted Actions \(\rightarrow\)
Manage
\\
\hline
Editor Hooks/Callbacks
&
Menu \(\rightarrow\) Edit \(\rightarrow\) Scripted Actions \(\rightarrow\)
Manage
\\
\hline
Session Scripts
&
Menu \(\rightarrow\) Session \(\rightarrow\) Scripting \(\rightarrow\)
Add/Remove Script
\\
\hline
DSP Scripts
&
Mixer-strip \(\rightarrow\) context menu (right
click) \(\rightarrow\) New Lua Proc
\\
\hline
Script Console
&
Menu \(\rightarrow\) Window \(\rightarrow\) Scripting
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\section{Script Layout}
\label{\detokenize{index:script-layout}}\label{\detokenize{index:id77}}\begin{itemize}
\item {} 
Every script must include an \sphinxcode{\sphinxupquote{ardour}} descriptor table. Required
fields are “Name” and “Type”.

\item {} 
A script must provide a \sphinxstyleemphasis{Factory method}: A function with optional
instantiation parameters which returns the actual script.

\item {} 
{[}optional{]}: list of parameters for the “factory”.

\item {} 
in case of DSP scripts, an optional list of automatable parameters
and possible audio/midi port configurations, and a \sphinxcode{\sphinxupquote{dsp\_run}}
function, more on that later.

\end{itemize}

A minimal example script looks like:



\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ardour} \PYG{p}{\PYGZob{}}
  \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{type}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}    \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{EditorAction}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
  \PYG{n}{name}        \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Rewind}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
\PYG{p}{\PYGZcb{}}

\PYG{n}{function} \PYG{n}{factory} \PYG{p}{(}\PYG{n}{unused\PYGZus{}params}\PYG{p}{)}
  \PYG{k}{return} \PYG{n}{function} \PYG{p}{(}\PYG{p}{)}
   \PYG{n}{Session}\PYG{p}{:}\PYG{n}{goto\PYGZus{}start}\PYG{p}{(}\PYG{p}{)}  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{n}{rewind} \PYG{n}{the} \PYG{n}{transport}
  \PYG{n}{end}
\PYG{n}{end}
\end{sphinxVerbatim}



The common part for all scripts is the “Descriptor”. It’s a Lua function
which returns a table (key/values) with the following keys (the keys are
case-sensitive):


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

type {[}required{]}
&
one of “\sphinxcode{\sphinxupquote{DSP}}”, “\sphinxcode{\sphinxupquote{Session}}”,
“\sphinxcode{\sphinxupquote{EditorHook}}”,
“\sphinxcode{\sphinxupquote{EditorAction}}” (the type is
not case-sensitive)
\\
\hline
name {[}required{]}
&
Name/Title of the script
\\
\hline
author
&
Your Name
\\
\hline
license
&
The license of the script (e.g.
“GPL” or “MIT”)
\\
\hline
description
&
A longer text explaining to the
user what the script does
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

Scripts that come with Ardour (currently mostly examples) can be found
in the \sphinxhref{https://github.com/Ardour/ardour/tree/master/scripts}{Source
Tree}.


\subsection{Action Scripts}
\label{\detokenize{index:action-scripts}}\label{\detokenize{index:id78}}
Action scripts are the simplest form. An anonymous Lua function is
called whenever the action is triggered. A simple action script is shown
above.

There are 10 action script slots available, each of which is a standard
GUI action available from the menu and hence can be bound to a keyboard
shortcut.


\subsection{Session Scripts}
\label{\detokenize{index:session-scripts}}\label{\detokenize{index:id79}}
Session scripts similar to Actions Scripts, except the anonymous
function is called periodically every process cycle. The function
receives a single parameter - the number of audio samples which are
processed in the given cycle



\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ardour} \PYG{p}{\PYGZob{}}
  \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{type}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}    \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{session}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
  \PYG{n}{name}        \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Example Session Script}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
  \PYG{n}{description} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}
  \PYG{n}{An} \PYG{n}{Example} \PYG{n}{Ardour} \PYG{n}{Session} \PYG{n}{Script}\PYG{o}{.}
  \PYG{n}{This} \PYG{n}{example} \PYG{n}{stops} \PYG{n}{the} \PYG{n}{transport} \PYG{n}{after} \PYG{n}{rolling} \PYG{k}{for} \PYG{n}{a} \PYG{n}{specific} \PYG{n}{time}\PYG{o}{.}\PYG{p}{]}\PYG{p}{]}
\PYG{p}{\PYGZcb{}}


\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{n}{instantiation} \PYG{n}{options}\PYG{p}{,} \PYG{n}{these} \PYG{n}{are} \PYG{n}{passed} \PYG{n}{to} \PYG{n}{the} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{factory}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{method} \PYG{n}{below}
\PYG{n}{function} \PYG{n}{sess\PYGZus{}params} \PYG{p}{(}\PYG{p}{)}
  \PYG{k}{return}
  \PYG{p}{\PYGZob{}}
    \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{print}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}  \PYG{o}{=} \PYG{p}{\PYGZob{}} \PYG{n}{title} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Debug Print (yes/no)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{default} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{no}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{optional} \PYG{o}{=} \PYG{n}{true} \PYG{p}{\PYGZcb{}}\PYG{p}{,}
    \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{time}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]} \PYG{o}{=} \PYG{p}{\PYGZob{}} \PYG{n}{title} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Timeout (sec)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{default} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{90}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{optional} \PYG{o}{=} \PYG{n}{false} \PYG{p}{\PYGZcb{}}\PYG{p}{,}
  \PYG{p}{\PYGZcb{}}
\PYG{n}{end}

\PYG{n}{function} \PYG{n}{factory} \PYG{p}{(}\PYG{n}{params}\PYG{p}{)}
  \PYG{k}{return} \PYG{n}{function} \PYG{p}{(}\PYG{n}{n\PYGZus{}samples}\PYG{p}{)}
    \PYG{n}{local} \PYG{n}{p} \PYG{o}{=} \PYG{n}{params}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{print}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]} \PYG{o+ow}{or} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{no}\PYG{l+s+s2}{\PYGZdq{}}
    \PYG{n}{local} \PYG{n}{timeout} \PYG{o}{=} \PYG{n}{params}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{time}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]} \PYG{o+ow}{or} \PYG{l+m+mi}{90}
    \PYG{n}{a} \PYG{o}{=} \PYG{n}{a} \PYG{o+ow}{or} \PYG{l+m+mi}{0}
    \PYG{k}{if} \PYG{n}{p} \PYG{o}{\PYGZti{}}\PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{no}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{then} \PYG{n+nb}{print} \PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{n\PYGZus{}samples}\PYG{p}{,} \PYG{n}{Session}\PYG{p}{:}\PYG{n}{frame\PYGZus{}rate} \PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{Session}\PYG{p}{:}\PYG{n}{transport\PYGZus{}rolling} \PYG{p}{(}\PYG{p}{)}\PYG{p}{)} \PYG{n}{end} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{n}{debug} \PYG{n}{output} \PYG{p}{(}\PYG{o+ow}{not} \PYG{n}{rt} \PYG{n}{safe}\PYG{p}{)}
    \PYG{k}{if} \PYG{p}{(}\PYG{o+ow}{not} \PYG{n}{Session}\PYG{p}{:}\PYG{n}{transport\PYGZus{}rolling}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)} \PYG{n}{then}
      \PYG{n}{a} \PYG{o}{=} \PYG{l+m+mi}{0}
      \PYG{k}{return}
    \PYG{n}{end}
    \PYG{n}{a} \PYG{o}{=} \PYG{n}{a} \PYG{o}{+} \PYG{n}{n\PYGZus{}samples}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{a} \PYG{o}{\PYGZgt{}} \PYG{n}{timeout} \PYG{o}{*} \PYG{n}{Session}\PYG{p}{:}\PYG{n}{frame\PYGZus{}rate}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)} \PYG{n}{then}
      \PYG{n}{Session}\PYG{p}{:}\PYG{n}{request\PYGZus{}transport\PYGZus{}speed}\PYG{p}{(}\PYG{l+m+mf}{0.0}\PYG{p}{,} \PYG{n}{true}\PYG{p}{)}
    \PYG{n}{end}
  \PYG{n}{end}
\PYG{n}{end}
\end{sphinxVerbatim}




\subsection{Action Hooks}
\label{\detokenize{index:action-hooks}}\label{\detokenize{index:id80}}
Action hook scripts must define an additional function which returns a
\sphinxstyleemphasis{Set} of Signal that which trigger the callback (documenting available
slots and their parameters remains to be done).



\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ardour} \PYG{p}{\PYGZob{}}
  \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{type}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}    \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{EditorHook}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
  \PYG{n}{name}        \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Hook Example}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
  \PYG{n}{description} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Rewind On Solo Change, Write a file when regions are moved.}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
\PYG{p}{\PYGZcb{}}

\PYG{n}{function} \PYG{n}{signals} \PYG{p}{(}\PYG{p}{)}
  \PYG{n}{s} \PYG{o}{=} \PYG{n}{LuaSignal}\PYG{o}{.}\PYG{n}{Set}\PYG{p}{(}\PYG{p}{)}
  \PYG{n}{s}\PYG{p}{:}\PYG{n}{add} \PYG{p}{(}
    \PYG{p}{\PYGZob{}}
      \PYG{p}{[}\PYG{n}{LuaSignal}\PYG{o}{.}\PYG{n}{SoloActive}\PYG{p}{]} \PYG{o}{=} \PYG{n}{true}\PYG{p}{,}
      \PYG{p}{[}\PYG{n}{LuaSignal}\PYG{o}{.}\PYG{n}{RegionPropertyChanged}\PYG{p}{]} \PYG{o}{=} \PYG{n}{true}
    \PYG{p}{\PYGZcb{}}
  \PYG{p}{)}
  \PYG{k}{return} \PYG{n}{s}
\PYG{n}{end}

\PYG{n}{function} \PYG{n}{factory} \PYG{p}{(}\PYG{n}{params}\PYG{p}{)}
  \PYG{k}{return} \PYG{n}{function} \PYG{p}{(}\PYG{n}{signal}\PYG{p}{,} \PYG{n}{ref}\PYG{p}{,} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{)}
    \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{n+nb}{print} \PYG{p}{(}\PYG{n}{signal}\PYG{p}{,} \PYG{n}{ref}\PYG{p}{,} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{)}

    \PYG{k}{if} \PYG{p}{(}\PYG{n}{signal} \PYG{o}{==} \PYG{n}{LuaSignal}\PYG{o}{.}\PYG{n}{SoloActive}\PYG{p}{)} \PYG{n}{then}
      \PYG{n}{Session}\PYG{p}{:}\PYG{n}{goto\PYGZus{}start}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{end}

    \PYG{k}{if} \PYG{p}{(}\PYG{n}{signal} \PYG{o}{==} \PYG{n}{LuaSignal}\PYG{o}{.}\PYG{n}{RegionPropertyChanged}\PYG{p}{)} \PYG{n}{then}
      \PYG{n}{obj}\PYG{p}{,}\PYG{n}{pch} \PYG{o}{=} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
      \PYG{n}{file} \PYG{o}{=} \PYG{n}{io}\PYG{o}{.}\PYG{n}{open} \PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{/tmp/test}\PYG{l+s+s2}{\PYGZdq{}} \PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{a}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
      \PYG{n}{io}\PYG{o}{.}\PYG{n}{output} \PYG{p}{(}\PYG{n}{file}
      \PYG{n}{io}\PYG{o}{.}\PYG{n}{write} \PYG{p}{(}\PYG{n}{string}\PYG{o}{.}\PYG{n}{format} \PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Region: }\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{ pos\PYGZhy{}changed: }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s+s2}{, length\PYGZhy{}changed: }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
        \PYG{n}{obj}\PYG{p}{:}\PYG{n}{name} \PYG{p}{(}\PYG{p}{)}\PYG{p}{,}
        \PYG{n}{tostring} \PYG{p}{(}\PYG{n}{pch}\PYG{p}{:}\PYG{n}{containsFramePos} \PYG{p}{(}\PYG{n}{ARDOUR}\PYG{o}{.}\PYG{n}{Properties}\PYG{o}{.}\PYG{n}{Start}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}
        \PYG{n}{tostring} \PYG{p}{(}\PYG{n}{pch}\PYG{p}{:}\PYG{n}{containsFramePos} \PYG{p}{(}\PYG{n}{ARDOUR}\PYG{o}{.}\PYG{n}{Properties}\PYG{o}{.}\PYG{n}{Length}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{)}\PYG{p}{)}
      \PYG{n}{io}\PYG{o}{.}\PYG{n}{close} \PYG{p}{(}\PYG{n}{file}\PYG{p}{)}
    \PYG{n}{end}
  \PYG{n}{end}
\PYG{n}{end}
\end{sphinxVerbatim}




\subsection{DSP Scripts}
\label{\detokenize{index:dsp-scripts}}\label{\detokenize{index:id81}}
See the scripts folder for examples for now.

Some notes for further doc:
\begin{itemize}
\item {} 
required function: \sphinxcode{\sphinxupquote{dsp\_ioconfig ()}}: return a list of possible
audio I/O configurations - follows Audio Unit conventions.

\item {} 
optional function: \sphinxcode{\sphinxupquote{dsp\_dsp\_midi\_input ()}}: return true if the
plugin can receive midi input

\item {} 
optional function: \sphinxcode{\sphinxupquote{dsp\_params ()}}: return a table of possible
parameters (automatable)

\item {} 
optional function: \sphinxcode{\sphinxupquote{dsp\_init (samplerate)}}: called when
instantiation the plugin with given samplerate.

\item {} 
optional function: \sphinxcode{\sphinxupquote{dsp\_configure (in, out)}}: called after
instantiation with configured plugin i/o.

\item {} 
required function: \sphinxcode{\sphinxupquote{dsp\_run (ins, outs, n\_samples)}} OR
\sphinxcode{\sphinxupquote{dsp\_runmap (bufs, in\_map, out\_map, n\_samples,     offset)}}: DSP
process callback. The former is a convenient abstraction that passes
mapped buffers (as table). The latter is a direct pass-through
matching Ardour’s internal \sphinxcode{\sphinxupquote{::connect\_and\_run()}} API, which
requires the caller to map and offset raw buffers.

\item {} 
plugin parameters are handled via the global variable \sphinxcode{\sphinxupquote{CtrlPorts}}.

\item {} 
midi data is passed via the global variable \sphinxcode{\sphinxupquote{mididata}} which is
valid during \sphinxcode{\sphinxupquote{dsp\_run}} only. (dsp\_runmap requires the script to
pass raw data from the buffers according to in\_map)

\item {} 
The script has access to the current session via the global variable
Session, but access to the session methods are limited to realtime
safe functions

\end{itemize}


\section{Accessing Ardour Objects}
\label{\detokenize{index:accessing-ardour-objects}}\label{\detokenize{index:id82}}
The top most object in Ardour is the \sphinxcode{\sphinxupquote{ARDOUR::Session}}. Fundamentally,
a Session is just a collection of other things: Routes (tracks, busses),
Sources (Audio/Midi), Regions, Playlists, Locations, Tempo map,
Undo/Redo history, Ports, Transport state and controls, etc.

Every Lua interpreter can access it via the global variable \sphinxcode{\sphinxupquote{Session}}.

GUI context interpreters also have an additional object in the global
environment: The Ardour \sphinxcode{\sphinxupquote{Editor}}. The Editor provides access to high
level functionality which is otherwise triggered via GUI interaction
such as undo/redo, open/close windows, select objects, drag/move
regions. It also holds the current UI state: snap-mode, zoom-range, etc.
The Editor also provides complex operations such as “import audio” which
under the hood, creates a new Track, adds a new Source Objects (for
every channel) with optional resampling, creates both playlist and
regions and loads the region onto the Track all the while displaying a
progress information to the user.

Documenting the bound C++ methods and class hierarchy is somewhere on
the ToDo list. Meanwhile
\sphinxhref{https://github.com/Ardour/ardour/blob/master/libs/ardour/luabindings.cc}{luabindings.cc}
is the best we can offer.


\section{Concepts}
\label{\detokenize{index:concepts}}\label{\detokenize{index:id83}}\begin{itemize}
\item {} 
There are no bound constructors: Lua asks Ardour to create objects
(e.g. add a new track), then receives a reference to the object to
modify it.

\item {} 
Scripts, once loaded, are saved with the Session (no reference to
external files). This provides for portable Sessions.

\item {} 
Lua Scripts are never executed directly. They provide a “factory”
method which can have optional instantiation parameters, which
returns a Lua closure.

\item {} 
No external Lua modules/libraries can be used, scripts need to be
self contained (portable across different systems (libs written in
Lua can be used, and important c-libs/functions can be included with
Ardour if needed).

\end{itemize}

Ardour is a highly multithreaded application and interaction between the
different threads, particularly real-time threads, needs to to be done
with care. This part has been abstracted away by providing separate Lua
interpreters in different contexts and restricting available
interaction:
\begin{itemize}
\item {} 
Editor Actions run in a single instance interpreter in the GUI
thread.

\item {} 
Editor Hooks connect to libardour signals. Every Callback uses a
dedicated Lua interpreter which is in the GUI thread context.

\item {} 
All Session scripts run in a single instance in the main real-time
thread (audio callback)

\item {} 
DSP scripts have a separate instance per script and run in one of the
DSP threads.

\end{itemize}

The available interfaces differ between contexts. For example, it is not
possible to create new tracks or import audio from real-time context;
while it is not possible to modify audio buffers from the GUI thread.


\section{Current State}
\label{\detokenize{index:current-state}}\label{\detokenize{index:id84}}
Fully functional, yet still in a prototyping stage:
\begin{itemize}
\item {} 
The GUI to add/configure scripts is rather minimalistic.

\item {} 
The interfaces may change (particularly DSP, and Session script
\sphinxcode{\sphinxupquote{run()}}.

\item {} 
Further planned work includes:
\begin{itemize}
\item {} 
Built-in Script editor (customize/modify Scripts in-place)

\item {} 
convenience methods (wrap more complex Ardour actions into a
library). e.g set plugin parameters, write automation lists from a
Lua table

\item {} 
Add some useful scripts and more examples

\item {} 
Documentation (Ardour API), also usable for tab-expansion, syntax
highlighting

\item {} 
bindings for GUI Widgets (plugin UIs, message boxes, etc)

\end{itemize}

\item {} 
\end{itemize}


\section{Examples}
\label{\detokenize{index:examples}}\label{\detokenize{index:id85}}
Apart from the \sphinxhref{https://github.com/Ardour/ardour/tree/master/scripts}{scripts included with the
source-code}
here are a few examples without further comments…


\subsection{Editor Console Examples}
\label{\detokenize{index:editor-console-examples}}\label{\detokenize{index:id86}}


\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print} \PYG{p}{(}\PYG{n}{Session}\PYG{p}{:}\PYG{n}{route\PYGZus{}by\PYGZus{}remote\PYGZus{}id}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}\PYG{n}{name}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}

\PYG{n}{a} \PYG{o}{=} \PYG{n}{Session}\PYG{p}{:}\PYG{n}{route\PYGZus{}by\PYGZus{}remote\PYGZus{}id}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nb}{print} \PYG{p}{(}\PYG{n}{a}\PYG{p}{:}\PYG{n}{name}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{Session}\PYG{p}{:}\PYG{n}{get\PYGZus{}tracks}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}

\PYG{k}{for} \PYG{n}{i}\PYG{p}{,} \PYG{n}{v} \PYG{o+ow}{in} \PYG{n}{ipairs}\PYG{p}{(}\PYG{n}{Session}\PYG{p}{:}\PYG{n}{unknown\PYGZus{}processors}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}\PYG{n}{table}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)} \PYG{n}{do} \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)} \PYG{n}{end}
\PYG{k}{for} \PYG{n}{i}\PYG{p}{,} \PYG{n}{v} \PYG{o+ow}{in} \PYG{n}{ipairs}\PYG{p}{(}\PYG{n}{Session}\PYG{p}{:}\PYG{n}{get\PYGZus{}tracks}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}\PYG{n}{table}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)} \PYG{n}{do} \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{v}\PYG{p}{:}\PYG{n}{name}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)} \PYG{n}{end}

\PYG{k}{for} \PYG{n}{t} \PYG{o+ow}{in} \PYG{n}{Session}\PYG{p}{:}\PYG{n}{get\PYGZus{}tracks}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}\PYG{n+nb}{iter}\PYG{p}{(}\PYG{p}{)} \PYG{n}{do} \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{t}\PYG{p}{:}\PYG{n}{name}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)} \PYG{n}{end}
\PYG{k}{for} \PYG{n}{r} \PYG{o+ow}{in} \PYG{n}{Session}\PYG{p}{:}\PYG{n}{get\PYGZus{}routes}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}\PYG{n+nb}{iter}\PYG{p}{(}\PYG{p}{)} \PYG{n}{do} \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{r}\PYG{p}{:}\PYG{n}{name}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)} \PYG{n}{end}


\PYG{n}{Session}\PYG{p}{:}\PYG{n}{tempo\PYGZus{}map}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}\PYG{n}{add\PYGZus{}tempo}\PYG{p}{(}\PYG{n}{ARDOUR}\PYG{o}{.}\PYG{n}{Tempo}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{,} \PYG{n}{Timecode}\PYG{o}{.}\PYG{n}{BBT\PYGZus{}TIME}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)}


\PYG{n}{Editor}\PYG{p}{:}\PYG{n}{set\PYGZus{}zoom\PYGZus{}focus}\PYG{p}{(}\PYG{n}{Editing}\PYG{o}{.}\PYG{n}{ZoomFocusRight}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{Editing}\PYG{o}{.}\PYG{n}{ZoomFocusRight}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Editor}\PYG{p}{:}\PYG{n}{set\PYGZus{}zoom\PYGZus{}focus}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}


\PYG{n}{files} \PYG{o}{=} \PYG{n}{C}\PYG{o}{.}\PYG{n}{StringVector}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{files}\PYG{p}{:}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{/home/rgareus/data/coding/ltc\PYGZhy{}tools/smpte.wav}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{pos} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}
\PYG{n}{Editor}\PYG{p}{:}\PYG{n}{do\PYGZus{}import}\PYG{p}{(}\PYG{n}{files}\PYG{p}{,} \PYG{n}{Editing}\PYG{o}{.}\PYG{n}{ImportDistinctFiles}\PYG{p}{,} \PYG{n}{Editing}\PYG{o}{.}\PYG{n}{ImportAsTrack}\PYG{p}{,} \PYG{n}{ARDOUR}\PYG{o}{.}\PYG{n}{SrcQuality}\PYG{o}{.}\PYG{n}{SrcBest}\PYG{p}{,} \PYG{n}{pos}\PYG{p}{,} \PYG{n}{ARDOUR}\PYG{o}{.}\PYG{n}{PluginInfo}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{}or in one line:}
\PYG{n}{Editor}\PYG{p}{:}\PYG{n}{do\PYGZus{}import}\PYG{p}{(}\PYG{n}{C}\PYG{o}{.}\PYG{n}{StringVector}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}\PYG{n}{add}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{/path/to/file.wav}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{,} \PYG{n}{Editing}\PYG{o}{.}\PYG{n}{ImportDistinctFiles}\PYG{p}{,} \PYG{n}{Editing}\PYG{o}{.}\PYG{n}{ImportAsTrack}\PYG{p}{,} \PYG{n}{ARDOUR}\PYG{o}{.}\PYG{n}{SrcQuality}\PYG{o}{.}\PYG{n}{SrcBest}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{ARDOUR}\PYG{o}{.}\PYG{n}{PluginInfo}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} called when a new session is loaded:}
\PYG{n}{function} \PYG{n}{new\PYGZus{}session} \PYG{p}{(}\PYG{n}{name}\PYG{p}{)} \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{NEW SESSION:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{name}\PYG{p}{)} \PYG{n}{end}


\PYG{c+c1}{\PYGZsh{} read/set/describe a plugin parameter}
\PYG{n}{route} \PYG{o}{=} \PYG{n}{Session}\PYG{p}{:}\PYG{n}{route\PYGZus{}by\PYGZus{}remote\PYGZus{}id}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{processor} \PYG{o}{=} \PYG{n}{route}\PYG{p}{:}\PYG{n}{nth\PYGZus{}plugin}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n}{plugininsert} \PYG{o}{=} \PYG{n}{processor}\PYG{p}{:}\PYG{n}{to\PYGZus{}insert}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{plugin} \PYG{o}{=} \PYG{n}{plugininsert}\PYG{p}{:}\PYG{n}{plugin}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n+nb}{print} \PYG{p}{(}\PYG{n}{plugin}\PYG{p}{:}\PYG{n}{label}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print} \PYG{p}{(}\PYG{n}{plugin}\PYG{p}{:}\PYG{n}{parameter\PYGZus{}count}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}

\PYG{n}{x} \PYG{o}{=} \PYG{n}{ARDOUR}\PYG{o}{.}\PYG{n}{ParameterDescriptor} \PYG{p}{(}\PYG{p}{)}
\PYG{n}{\PYGZus{}}\PYG{p}{,} \PYG{n}{t} \PYG{o}{=} \PYG{n}{plugin}\PYG{p}{:}\PYG{n}{get\PYGZus{}parameter\PYGZus{}descriptor}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{x}\PYG{p}{)} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{n}{port} \PYG{c+c1}{\PYGZsh{}2}
\PYG{n}{paramdesc} \PYG{o}{=} \PYG{n}{t}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}
\PYG{n+nb}{print} \PYG{p}{(}\PYG{n}{paramdesc}\PYG{o}{.}\PYG{n}{lower}\PYG{p}{)}

\PYG{n}{ctrl} \PYG{o}{=} \PYG{n}{Evoral}\PYG{o}{.}\PYG{n}{Parameter}\PYG{p}{(}\PYG{n}{ARDOUR}\PYG{o}{.}\PYG{n}{AutomationType}\PYG{o}{.}\PYG{n}{PluginAutomation}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{ac} \PYG{o}{=} \PYG{n}{plugininsert}\PYG{p}{:}\PYG{n}{automation\PYGZus{}control}\PYG{p}{(}\PYG{n}{ctrl}\PYG{p}{,} \PYG{n}{false}\PYG{p}{)}
\PYG{n+nb}{print} \PYG{p}{(}\PYG{n}{ac}\PYG{p}{:}\PYG{n}{get\PYGZus{}value} \PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{ac}\PYG{p}{:}\PYG{n}{set\PYGZus{}value}\PYG{p}{(}\PYG{l+m+mf}{1.0}\PYG{p}{,} \PYG{n}{PBD}\PYG{o}{.}\PYG{n}{GroupControlDisposition}\PYG{o}{.}\PYG{n}{NoGroup}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} the same using a convenience wrapper:}
\PYG{n}{route} \PYG{o}{=} \PYG{n}{Session}\PYG{p}{:}\PYG{n}{route\PYGZus{}by\PYGZus{}remote\PYGZus{}id}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{proc} \PYG{o}{=} \PYG{n}{t}\PYG{p}{:}\PYG{n}{nth\PYGZus{}plugin} \PYG{p}{(}\PYG{n}{i}\PYG{p}{)}
\PYG{n}{ARDOUR}\PYG{o}{.}\PYG{n}{LuaAPI}\PYG{o}{.}\PYG{n}{set\PYGZus{}processor\PYGZus{}param} \PYG{p}{(}\PYG{n}{proc}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mf}{1.0}\PYG{p}{)}
\end{sphinxVerbatim}




\subsection{Commandline Session}
\label{\detokenize{index:commandline-session}}\label{\detokenize{index:id87}}
The standalone tool \sphinxcode{\sphinxupquote{luasession}} allows one to access an Ardour
session directly from the commandline. Interaction is limited by the
fact that most actions in Ardour are provided by the Editor GUI.

\sphinxcode{\sphinxupquote{luasession}} provides only two special functions \sphinxcode{\sphinxupquote{load\_session}} and
\sphinxcode{\sphinxupquote{close\_session}} and exposes the \sphinxcode{\sphinxupquote{AudioEngine}} instance as global
variable.



\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{n}{i}\PYG{p}{,}\PYG{n}{\PYGZus{}} \PYG{o+ow}{in} \PYG{n}{AudioEngine}\PYG{p}{:}\PYG{n}{available\PYGZus{}backends}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}\PYG{n+nb}{iter}\PYG{p}{(}\PYG{p}{)} \PYG{n}{do} \PYG{n+nb}{print} \PYG{p}{(}\PYG{n}{i}\PYG{o}{.}\PYG{n}{name}\PYG{p}{)} \PYG{n}{end}

\PYG{n}{backend} \PYG{o}{=} \PYG{n}{AudioEngine}\PYG{p}{:}\PYG{n}{set\PYGZus{}backend}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ALSA}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{print} \PYG{p}{(}\PYG{n}{AudioEngine}\PYG{p}{:}\PYG{n}{current\PYGZus{}backend\PYGZus{}name}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}

\PYG{k}{for} \PYG{n}{i}\PYG{p}{,}\PYG{n}{\PYGZus{}} \PYG{o+ow}{in} \PYG{n}{backend}\PYG{p}{:}\PYG{n}{enumerate\PYGZus{}devices}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}\PYG{n+nb}{iter}\PYG{p}{(}\PYG{p}{)} \PYG{n}{do} \PYG{n+nb}{print} \PYG{p}{(}\PYG{n}{i}\PYG{o}{.}\PYG{n}{name}\PYG{p}{)} \PYG{n}{end}

\PYG{n}{backend}\PYG{p}{:}\PYG{n}{set\PYGZus{}input\PYGZus{}device\PYGZus{}name}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{HDA Intel PCH}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{backend}\PYG{p}{:}\PYG{n}{set\PYGZus{}output\PYGZus{}device\PYGZus{}name}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{HDA Intel PCH}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{n+nb}{print} \PYG{p}{(}\PYG{n}{backend}\PYG{p}{:}\PYG{n}{buffer\PYGZus{}size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print} \PYG{p}{(}\PYG{n}{AudioEngine}\PYG{p}{:}\PYG{n}{get\PYGZus{}last\PYGZus{}backend\PYGZus{}error}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}

\PYG{n}{s} \PYG{o}{=} \PYG{n}{load\PYGZus{}session} \PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{/home/rgareus/Documents/ArdourSessions/lua2/}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{lua2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{s}\PYG{p}{:}\PYG{n}{request\PYGZus{}transport\PYGZus{}speed} \PYG{p}{(}\PYG{l+m+mf}{1.0}\PYG{p}{)}
\PYG{n+nb}{print} \PYG{p}{(}\PYG{n}{s}\PYG{p}{:}\PYG{n}{transport\PYGZus{}rolling}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{s}\PYG{p}{:}\PYG{n}{goto\PYGZus{}start}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{close\PYGZus{}session}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}




\chapter{83 - Lua Bindings Class Reference}
\label{\detokenize{index:lua-bindings-class-reference}}\label{\detokenize{index:class-reference}}
This documentation is far from complete may be inaccurate and subject to
change.


\subsubsection*{Overview}

The top-level entry point are {\hyperref[\detokenize{index:ARDOUR:Session}]{\emph{ARDOUR:Session}}} and
{\hyperref[\detokenize{index:ArdourUI:Editor}]{\emph{ArdourUI:Editor}}}. Most other Classes are used
indirectly starting with a Session function. e.g. Session:get\_routes().

A few classes are dedicated to certain script types, e.g. Lua DSP
processors have exclusive access to {\hyperref[\detokenize{index:ARDOUR:DSP}]{\emph{ARDOUR.DSP}}} and
{\hyperref[\detokenize{index:ARDOUR:ChanMapping}]{\emph{ARDOUR:ChanMapping}}}. Action Hooks Scripts to
{\hyperref[\detokenize{index:LuaSignal:Set}]{\emph{LuaSignal:Set}}} etc.

Detailed documentation (parameter names, method description) is not yet
available. Please stay tuned.
\subsubsection*{Short introduction to Ardour classes}

Ardour’s structure is object oriented. The main object is the Session. A
Session contains Audio Tracks, Midi Tracks and Busses. Audio and Midi
tracks are derived from a more general “Track” Object, which in turn is
derived from a “Route” (aka Bus). (We say “An Audio Track \sphinxstyleemphasis{is-a} Track
\sphinxstyleemphasis{is-a} Route”). Tracks contain specifics. For Example a track \sphinxstyleemphasis{has-a}
diskstream (for file i/o).

Operations are performed on objects. One gets a reference to an object
and then calls a method. e.g
\sphinxcode{\sphinxupquote{obj = Session:route\_by\_name("Audio")   obj:set\_name("Guitar")}}.

Lua automatically follows C++ class inheritance. e.g one can directly
call all SessionObject and Route methods on Track object. However lua
does not automatically promote objects. A Route object which just
happens to be a Track needs to be explicitly cast to a Track. Methods
for casts are provided with each class. Note that the cast may fail and
return a \sphinxstyleemphasis{nil} reference.

Likewise multiple inheritance is a \sphinxhref{http://www.lua.org/pil/16.3.html}{non-trivial
issue} in lua. To avoid performance
penalties involved with lookups, explicit casts are required in this
case. One example is {\hyperref[\detokenize{index:ARDOUR:SessionObject}]{\emph{ARDOUR:SessionObject}}}
which is-a StatefulDestructible which inherits from both Stateful and
Destructible.

Object lifetimes are managed by the Session. Most Objects cannot be
directly created, but one asks the Session to create or destroy them.
This is mainly due to realtime constrains: you cannot simply remove a
track that is currently processing audio. There are various \sphinxstyleemphasis{factory}
methods for object creation or removal.
\subsubsection*{Pass by Reference}

Since lua functions are closures, C++ methods that pass arguments by
reference cannot be used as-is. All parameters passed to a C++ method
which uses references are returned as Lua Table. If the C++ method also
returns a value it is prefixed. Two parameters are returned: the value
and a Lua Table holding the parameters.





C++

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{void} \PYG{n}{set\PYGZus{}ref} \PYG{p}{(}\PYG{n+nb}{int}\PYG{o}{\PYGZam{}} \PYG{n}{var}\PYG{p}{,} \PYG{n}{long}\PYG{o}{\PYGZam{}} \PYG{n}{val}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{printf} \PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s+s2}{ }\PYG{l+s+si}{\PYGZpc{}ld}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{var}\PYG{p}{,} \PYG{n}{val}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{var} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{;}
    \PYG{n}{val} \PYG{o}{=} \PYG{l+m+mi}{7}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}





Lua

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{local} \PYG{n}{var} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{n}{ref} \PYG{o}{=} \PYG{n}{set\PYGZus{}ref} \PYG{p}{(}\PYG{n}{var}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{n}{output} \PYG{k+kn}{from} \PYG{n+nn}{C}\PYG{o}{+}\PYG{o}{+} \PYG{n}{printf}\PYG{p}{(}\PYG{p}{)}
\PYG{l+m+mi}{0} \PYG{l+m+mi}{2}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{n}{var} \PYG{o+ow}{is} \PYG{n}{still} \PYG{l+m+mi}{0} \PYG{n}{here}
\PYG{n+nb}{print} \PYG{p}{(}\PYG{n}{ref}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{ref}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}
\PYG{l+m+mi}{5} \PYG{l+m+mi}{7}
\end{sphinxVerbatim}













\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{int} \PYG{n}{set\PYGZus{}ref2} \PYG{p}{(}\PYG{n+nb}{int} \PYG{o}{\PYGZam{}}\PYG{n}{var}\PYG{p}{,} \PYG{n}{std}\PYG{p}{:}\PYG{p}{:}\PYG{n}{string} \PYG{n}{unused}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{var} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{;}
    \PYG{k}{return} \PYG{l+m+mi}{3}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}





\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{rv}\PYG{p}{,} \PYG{n}{ref} \PYG{o}{=} \PYG{n}{set\PYGZus{}ref2} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{hello}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nb}{print} \PYG{p}{(}\PYG{n}{rv}\PYG{p}{,} \PYG{n}{ref}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{ref}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}
\PYG{l+m+mi}{3} \PYG{l+m+mi}{5} \PYG{n}{hello}
\end{sphinxVerbatim}








\subsubsection*{Pointer Classes}

Libardour makes extensive use of reference counted \sphinxcode{\sphinxupquote{boost::shared\_ptr}}
to manage lifetimes. The Lua bindings provide a complete abstraction of
this. There are no pointers in lua. For example a
{\hyperref[\detokenize{index:ARDOUR:Route}]{\emph{ARDOUR:Route}}} is a pointer in C++, but lua functions
operate on it like it was a class instance.

\sphinxcode{\sphinxupquote{shared\_ptr}} are reference counted. Once assigned to a lua variable,
the C++ object will be kept and remains valid. It is good practice to
assign references to lua \sphinxcode{\sphinxupquote{local}} variables or reset the variable to
\sphinxcode{\sphinxupquote{nil}} to drop the ref.

All pointer classes have a \sphinxcode{\sphinxupquote{isnil ()}} method. This is for two cases:
Construction may fail. e.g. \sphinxcode{\sphinxupquote{ARDOUR.LuaAPI.newplugin()}} may not be
able to find the given plugin and hence cannot create an object.

The second case if for \sphinxcode{\sphinxupquote{boost::weak\_ptr}}. As opposed to
\sphinxcode{\sphinxupquote{boost::shared\_ptr}} weak-pointers are not reference counted. The
object may vanish at any time. If lua code calls a method on a nil
object, the interpreter will raise an exception and the script will not
continue. This is not unlike \sphinxcode{\sphinxupquote{a = nil a:test()}} which results in en
error “\sphinxstyleemphasis{attempt to index a nil value}”.

From the lua side of things there is no distinction between weak and
shared pointers. They behave identically. Below they’re indicated in
orange and have an arrow to indicate the pointer type. Pointer Classes
cannot be created in lua scripts. It always requires a call to C++ to
create the Object and obtain a reference to it.
\subsubsection*{Class Documentation}
\subsubsection*{ℕ ARDOUR}





Methods



{\hyperref[\detokenize{index:ARDOUR:RCConfiguration}]{\emph{RCConfiguration}}}

config()


\section{↠ ARDOUR:Amp}
\label{\detokenize{index:ardour-amp}}\label{\detokenize{index:id88}}
\sphinxstyleemphasis{C‡}: boost::shared\_ptr\textless{} ARDOUR::Amp \textgreater{}, boost::weak\_ptr\textless{} ARDOUR::Amp \textgreater{}

is-a: {\hyperref[\detokenize{index:ARDOUR:Processor}]{\emph{ARDOUR:Processor}}}







Applies a declick operation to all audio inputs, passing the same number
of audio outputs, and passing through any other types unchanged.



Methods

{\hyperref[\detokenize{index:ARDOUR:GainControl}]{\emph{GainControl}}}

gain\_control()

bool

isnil()


\subsection{Inherited from ARDOUR:Processor}
\label{\detokenize{index:inherited-from-ardour-processor}}
Methods

void

activate()

bool

active()

void

deactivate()

std::string

display\_name()

bool

display\_to\_user()

{\hyperref[\detokenize{index:ARDOUR:ChanCount}]{\emph{ChanCount}}}

input\_streams()

{\hyperref[\detokenize{index:ARDOUR:ChanCount}]{\emph{ChanCount}}}

output\_streams()

Cast

{\hyperref[\detokenize{index:ARDOUR:Amp}]{\emph{Amp}}}

to\_amp()

{\hyperref[\detokenize{index:ARDOUR:Automatable}]{\emph{Automatable}}}

to\_automatable()

{\hyperref[\detokenize{index:ARDOUR:PluginInsert}]{\emph{PluginInsert}}}

to\_insert()

{\hyperref[\detokenize{index:ARDOUR:IOProcessor}]{\emph{IOProcessor}}}

to\_ioprocessor()

{\hyperref[\detokenize{index:ARDOUR:PeakMeter}]{\emph{PeakMeter}}}

to\_meter()

{\hyperref[\detokenize{index:ARDOUR:MonitorProcessor}]{\emph{MonitorProcessor}}}

to\_monitorprocessor()

{\hyperref[\detokenize{index:ARDOUR:PeakMeter}]{\emph{PeakMeter}}}

to\_peakmeter()

{\hyperref[\detokenize{index:ARDOUR:PluginInsert}]{\emph{PluginInsert}}}

to\_plugininsert()

{\hyperref[\detokenize{index:ARDOUR:SideChain}]{\emph{SideChain}}}

to\_sidechain()

{\hyperref[\detokenize{index:ARDOUR:UnknownProcessor}]{\emph{UnknownProcessor}}}

to\_unknownprocessor()


\subsection{Inherited from ARDOUR:SessionObjectPtr}
\label{\detokenize{index:inherited-from-ardour-sessionobjectptr}}
Methods

std::string

name()

Cast

{\hyperref[\detokenize{index:PBD:Stateful}]{\emph{Stateful}}}

to\_stateful()

{\hyperref[\detokenize{index:PBD:StatefulDestructible}]{\emph{StatefulDestructible}}}

to\_statefuldestructible()


\section{↠ ARDOUR:AudioBackend}
\label{\detokenize{index:ardour-audiobackend}}\label{\detokenize{index:id89}}
\sphinxstyleemphasis{C‡}: boost::shared\_ptr\textless{} ARDOUR::AudioBackend \textgreater{}, boost::weak\_ptr\textless{}
ARDOUR::AudioBackend \textgreater{}







AudioBackend is an high-level abstraction for interacting with the
operating system’s audio and midi I/O.



Methods

unsigned int

buffer\_size()

std::string

device\_name()

std::string

driver\_name()



override this if this implementation returns true from
requires\_driver\_selection()



float

dsp\_load()



return the fraction of the time represented by the current buffer size
that is being used for each buffer process cycle, as a value from 0.0 to
1.0

E.g. if the buffer size represents 5msec and current processing takes
1msec, the returned value should be 0.2.

Implementations can feel free to smooth the values returned over time
(e.g. high pass filtering, or its equivalent).



{\hyperref[\detokenize{index:ARDOUR:DeviceStatusVector}]{\emph{DeviceStatusVector}}}

enumerate\_devices()



Returns a collection of DeviceStatuses identifying devices discovered by
this backend since the start of the process.

Any of the names in each DeviceStatus may be used to identify a device
in other calls to the backend, though any of them may become invalid at
any time.



{\hyperref[\detokenize{index:C:StringVector}]{\emph{StringVector}}}

enumerate\_drivers()



If the return value of requires\_driver\_selection() is true, then this
function can return the list of known driver names.

If the return value of requires\_driver\_selection() is false, then this
function should not be called. If it is called its return value is an
empty vector of strings.



{\hyperref[\detokenize{index:ARDOUR:DeviceStatusVector}]{\emph{DeviceStatusVector}}}

enumerate\_input\_devices()



Returns a collection of DeviceStatuses identifying input devices
discovered by this backend since the start of the process.

Any of the names in each DeviceStatus may be used to identify a device
in other calls to the backend, though any of them may become invalid at
any time.



{\hyperref[\detokenize{index:ARDOUR:DeviceStatusVector}]{\emph{DeviceStatusVector}}}

enumerate\_output\_devices()



Returns a collection of DeviceStatuses identifying output devices
discovered by this backend since the start of the process.

Any of the names in each DeviceStatus may be used to identify a device
in other calls to the backend, though any of them may become invalid at
any time.



{\hyperref[\detokenize{index:ARDOUR:AudioBackendInfo}]{\emph{AudioBackendInfo}}}

info()



Return the AudioBackendInfo object from which this backend was
constructed.



unsigned int

input\_channels()

std::string

input\_device\_name()

bool

isnil()

unsigned int

output\_channels()

std::string

output\_device\_name()

unsigned int

period\_size()

float

sample\_rate()

int

set\_buffer\_size(unsigned int)



Set the buffer size to be used.

The device is assumed to use a double buffering scheme, so that one
buffer’s worth of data can be processed by hardware while software works
on the other buffer. All known suitable audio APIs support this model
(though ALSA allows for alternate numbers of buffers, and CoreAudio
doesn’t directly expose the concept).



int

set\_device\_name(std::string)



Set the name of the device to be used



int

set\_driver(std::string)



Returns zero if the backend can successfully use

Should not be used unless the backend returns true from
requires\_driver\_selection()
\begin{description}
\item[{name}] \leavevmode
as the driver, non-zero otherwise.

\end{description}



int

set\_input\_device\_name(std::string)



Set the name of the input device to be used if using separate
input/output devices.

use\_separate\_input\_and\_output\_devices()



int

set\_output\_device\_name(std::string)



Set the name of the output device to be used if using separate
input/output devices.

use\_separate\_input\_and\_output\_devices()



int

set\_peridod\_size(unsigned int)



Set the period size to be used. must be called before starting the
backend.



int

set\_sample\_rate(float)



Set the sample rate to be used



bool

use\_separate\_input\_and\_output\_devices()



An optional alternate interface for backends to provide a facility to
select separate input and output devices.

If a backend returns true then enumerate\_input\_devices() and
enumerate\_output\_devices() will be used instead of enumerate\_devices()
to enumerate devices. Similarly set\_input/output\_device\_name() should be
used to set devices instead of set\_device\_name().




\section{∁ ARDOUR:AudioBackendInfo}
\label{\detokenize{index:ardour-audiobackendinfo}}\label{\detokenize{index:id90}}
\sphinxstyleemphasis{C‡}: ARDOUR::AudioBackendInfo





Data Members

char*

name


\section{∁ ARDOUR:AudioBuffer}
\label{\detokenize{index:ardour-audiobuffer}}\label{\detokenize{index:id91}}
\sphinxstyleemphasis{C‡}: ARDOUR::AudioBuffer







Buffer containing audio data.



Methods

void

apply\_gain(float, long)

bool

check\_silence(unsigned int, unsigned int\&)



check buffer for silence
\begin{description}
\item[{nframes}] \leavevmode
number of frames to check

\item[{n}] \leavevmode
first non zero sample (if any)

\end{description}



Returns true if all samples are zero





{\hyperref[\detokenize{index:C:FloatArray}]{\emph{FloatArray}}}

data(long)

void

read\_from({\hyperref[\detokenize{index:C:FloatArray}]{\emph{FloatArray}}}, long, long, long)

void

silence(long, long)



silence buffer
\begin{description}
\item[{len}] \leavevmode
number of samples to clear

\item[{offset}] \leavevmode
start offset

\end{description}




\section{∁ ARDOUR:AudioEngine}
\label{\detokenize{index:ardour-audioengine}}\label{\detokenize{index:id92}}
\sphinxstyleemphasis{C‡}: ARDOUR::AudioEngine

is-a: {\hyperref[\detokenize{index:ARDOUR:PortManager}]{\emph{ARDOUR:PortManager}}}





Methods

{\hyperref[\detokenize{index:ARDOUR:BackendVector}]{\emph{BackendVector}}}

available\_backends()

std::string

current\_backend\_name()

float

get\_dsp\_load()

std::string

get\_last\_backend\_error()

{\hyperref[\detokenize{index:ARDOUR:AudioBackend}]{\emph{AudioBackend}}}

set\_backend(std::string, std::string, std::string)

int

set\_buffer\_size(unsigned int)

int

set\_device\_name(std::string)

int

set\_sample\_rate(float)

bool

setup\_required()

int

start(bool)

int

stop(bool)


\subsection{Inherited from ARDOUR:PortManager}
\label{\detokenize{index:inherited-from-ardour-portmanager}}
Methods

int

connect(std::string, std::string)

bool

connected(std::string)

int

disconnect(std::string, std::string)

int

disconnect\_port({\hyperref[\detokenize{index:ARDOUR:Port}]{\emph{Port}}})

\sphinxstyleemphasis{LuaTable}(int, …)

get\_backend\_ports(std::string,{\hyperref[\detokenize{index:ARDOUR:DataType}]{\emph{DataType}}},{\hyperref[\detokenize{index:ARDOUR.PortFlags}]{\emph{PortFlags}}},{\hyperref[\detokenize{index:C:StringVector}]{\emph{StringVector\&}}})

\sphinxstyleemphasis{LuaTable}(int, …)

get\_connections(std::string,{\hyperref[\detokenize{index:C:StringVector}]{\emph{StringVector\&}}})

void

get\_physical\_inputs({\hyperref[\detokenize{index:ARDOUR:DataType}]{\emph{DataType}}},{\hyperref[\detokenize{index:C:StringVector}]{\emph{StringVector\&}}},{\hyperref[\detokenize{index:ARDOUR.MidiPortFlags}]{\emph{MidiPortFlags}}},{\hyperref[\detokenize{index:ARDOUR.MidiPortFlags}]{\emph{MidiPortFlags}}})

void

get\_physical\_outputs({\hyperref[\detokenize{index:ARDOUR:DataType}]{\emph{DataType}}},{\hyperref[\detokenize{index:C:StringVector}]{\emph{StringVector\&}}},{\hyperref[\detokenize{index:ARDOUR.MidiPortFlags}]{\emph{MidiPortFlags}}},{\hyperref[\detokenize{index:ARDOUR.MidiPortFlags}]{\emph{MidiPortFlags}}})

{\hyperref[\detokenize{index:ARDOUR:Port}]{\emph{Port}}}

get\_port\_by\_name(std::string)


\begin{description}
\item[{name}] \leavevmode
Full or short name of port

\end{description}



Returns Corresponding Port or 0.





\sphinxstyleemphasis{LuaTable}(int, …)

get\_ports({\hyperref[\detokenize{index:ARDOUR:DataType}]{\emph{DataType}}},{\hyperref[\detokenize{index:ARDOUR:PortList}]{\emph{PortList\&}}})

std::string

get\_pretty\_name\_by\_name(std::string)

{\hyperref[\detokenize{index:ARDOUR:ChanCount}]{\emph{ChanCount}}}

n\_physical\_inputs()

{\hyperref[\detokenize{index:ARDOUR:ChanCount}]{\emph{ChanCount}}}

n\_physical\_outputs()

bool

physically\_connected(std::string)

{\hyperref[\detokenize{index:ARDOUR:PortEngine}]{\emph{PortEngine}}}

port\_engine()

bool

port\_is\_physical(std::string)


\section{↠ ARDOUR:AudioPlaylist}
\label{\detokenize{index:ardour-audioplaylist}}\label{\detokenize{index:id93}}
\sphinxstyleemphasis{C‡}: boost::shared\_ptr\textless{} ARDOUR::AudioPlaylist \textgreater{}, boost::weak\_ptr\textless{}
ARDOUR::AudioPlaylist \textgreater{}

is-a: {\hyperref[\detokenize{index:ARDOUR:Playlist}]{\emph{ARDOUR:Playlist}}}







A named object associated with a Session. Objects derived from this
class are expected to be destroyed before the session calls
drop\_references().



Methods

bool

isnil()

long

read({\hyperref[\detokenize{index:C:FloatArray}]{\emph{FloatArray}}},{\hyperref[\detokenize{index:C:FloatArray}]{\emph{FloatArray}}},{\hyperref[\detokenize{index:C:FloatArray}]{\emph{FloatArray}}},
long, long, unsigned int)


\subsection{Inherited from ARDOUR:Playlist}
\label{\detokenize{index:inherited-from-ardour-playlist}}
Methods

void

add\_region({\hyperref[\detokenize{index:ARDOUR:Region}]{\emph{Region}}}, long, float, bool, int,
double, bool)



Note: this calls set\_layer (…, DBL\_MAX) so it will reset the layering
index of region



{\hyperref[\detokenize{index:ARDOUR:Region}]{\emph{Region}}}

combine({\hyperref[\detokenize{index:ARDOUR:RegionList}]{\emph{RegionList}}})

unsigned int

count\_regions\_at(long)

{\hyperref[\detokenize{index:ARDOUR:Playlist}]{\emph{Playlist}}}

cut({\hyperref[\detokenize{index:ARDOUR:AudioRangeList}]{\emph{AudioRangeList\&}}}, bool)

{\hyperref[\detokenize{index:ARDOUR:DataType}]{\emph{DataType}}}

data\_type()

void

duplicate({\hyperref[\detokenize{index:ARDOUR:Region}]{\emph{Region}}}, long, long, float)


\begin{description}
\item[{gap}] \leavevmode
from the beginning of the region to the next beginning

\end{description}



void

duplicate\_range({\hyperref[\detokenize{index:ARDOUR:AudioRange}]{\emph{AudioRange\&}}}, float)

void

duplicate\_until({\hyperref[\detokenize{index:ARDOUR:Region}]{\emph{Region}}}, long, long, long)


\begin{description}
\item[{gap}] \leavevmode
from the beginning of the region to the next beginning

\item[{end}] \leavevmode
the first frame that does \_not\_ contain a duplicated frame

\end{description}



{\hyperref[\detokenize{index:ARDOUR:Region}]{\emph{Region}}}

find\_next\_region(long,{\hyperref[\detokenize{index:ARDOUR.RegionPoint}]{\emph{RegionPoint}}}, int)

long

find\_next\_region\_boundary(long, int)

long

find\_next\_transient(long, int)

void

lower\_region({\hyperref[\detokenize{index:ARDOUR:Region}]{\emph{Region}}})

void

lower\_region\_to\_bottom({\hyperref[\detokenize{index:ARDOUR:Region}]{\emph{Region}}})

unsigned int

n\_regions()

void

raise\_region({\hyperref[\detokenize{index:ARDOUR:Region}]{\emph{Region}}})

void

raise\_region\_to\_top({\hyperref[\detokenize{index:ARDOUR:Region}]{\emph{Region}}})

{\hyperref[\detokenize{index:ARDOUR:Region}]{\emph{Region}}}

region\_by\_id({\hyperref[\detokenize{index:PBD:ID}]{\emph{ID}}})

{\hyperref[\detokenize{index:ARDOUR:RegionListPtr}]{\emph{RegionListPtr}}}

region\_list()

{\hyperref[\detokenize{index:ARDOUR:RegionListPtr}]{\emph{RegionListPtr}}}

regions\_at(long)

{\hyperref[\detokenize{index:ARDOUR:RegionListPtr}]{\emph{RegionListPtr}}}

regions\_touched(long, long)


\begin{description}
\item[{start}] \leavevmode
Range start.

\item[{end}] \leavevmode
Range end.

\end{description}



Returns regions which have some part within this range.





{\hyperref[\detokenize{index:ARDOUR:RegionListPtr}]{\emph{RegionListPtr}}}

regions\_with\_end\_within({\hyperref[\detokenize{index:Evoral:Range}]{\emph{Range}}})

{\hyperref[\detokenize{index:ARDOUR:RegionListPtr}]{\emph{RegionListPtr}}}

regions\_with\_start\_within({\hyperref[\detokenize{index:Evoral:Range}]{\emph{Range}}})

void

remove\_region({\hyperref[\detokenize{index:ARDOUR:Region}]{\emph{Region}}})

void

split(long)

void

split\_region({\hyperref[\detokenize{index:ARDOUR:Region}]{\emph{Region}}},{\hyperref[\detokenize{index:ARDOUR:MusicFrame}]{\emph{MusicFrame}}})

{\hyperref[\detokenize{index:ARDOUR:Region}]{\emph{Region}}}

top\_region\_at(long)

{\hyperref[\detokenize{index:ARDOUR:Region}]{\emph{Region}}}

top\_unmuted\_region\_at(long)

void

uncombine({\hyperref[\detokenize{index:ARDOUR:Region}]{\emph{Region}}})

Cast

{\hyperref[\detokenize{index:ARDOUR:AudioPlaylist}]{\emph{AudioPlaylist}}}

to\_audioplaylist()

{\hyperref[\detokenize{index:ARDOUR:MidiPlaylist}]{\emph{MidiPlaylist}}}

to\_midiplaylist()


\subsection{Inherited from ARDOUR:SessionObjectPtr}
\label{\detokenize{index:inherited-from-ardoursessionobjectptr-1}}\label{\detokenize{index:id94}}
Methods

std::string

name()

Cast

{\hyperref[\detokenize{index:PBD:Stateful}]{\emph{Stateful}}}

to\_stateful()

{\hyperref[\detokenize{index:PBD:StatefulDestructible}]{\emph{StatefulDestructible}}}

to\_statefuldestructible()


\section{↠ ARDOUR:AudioPort}
\label{\detokenize{index:ardour-audioport}}\label{\detokenize{index:id95}}
\sphinxstyleemphasis{C‡}: boost::shared\_ptr\textless{} ARDOUR::AudioPort \textgreater{}, boost::weak\_ptr\textless{}
ARDOUR::AudioPort \textgreater{}

is-a: {\hyperref[\detokenize{index:ARDOUR:Port}]{\emph{ARDOUR:Port}}}





Methods

bool

isnil()


\subsection{Inherited from ARDOUR:Port}
\label{\detokenize{index:inherited-from-ardour-port}}
Methods

int

connect(std::string)

bool

connected()





Returns true if this port is connected to anything





bool

connected\_to(std::string)


\begin{description}
\item[{o}] \leavevmode
Port name

\end{description}



Returns true if this port is connected to o, otherwise false.





int

disconnect(std::string)

int

disconnect\_all()

std::string

name()





Returns Port short name





std::string

pretty\_name(bool)





Returns Port human readable name





bool

receives\_input()





Returns true if this Port receives input, otherwise false





bool

sends\_output()





Returns true if this Port sends output, otherwise false





Cast

{\hyperref[\detokenize{index:ARDOUR:AudioPort}]{\emph{AudioPort}}}

to\_audioport()

{\hyperref[\detokenize{index:ARDOUR:MidiPort}]{\emph{MidiPort}}}

to\_midiport()


\section{∁ ARDOUR:AudioRange}
\label{\detokenize{index:ardour-audiorange}}\label{\detokenize{index:id96}}
\sphinxstyleemphasis{C‡}: ARDOUR::AudioRange





Constructor

ℂ

ARDOUR.AudioRange(long, long, unsigned int)

Methods

bool

equal({\hyperref[\detokenize{index:ARDOUR:AudioRange}]{\emph{AudioRange}}})

long

length()

Data Members

long

end

unsigned int

id

long

start


\section{∁ ARDOUR:AudioRangeList}
\label{\detokenize{index:ardour-audiorangelist}}\label{\detokenize{index:id97}}
\sphinxstyleemphasis{C‡}: std::list\textless{}ARDOUR::AudioRange \textgreater{}





Constructor

ℂ

ARDOUR.AudioRangeList()

Methods

{\hyperref[\detokenize{index:ARDOUR:AudioRange}]{\emph{AudioRange}}}

back()

bool

empty()

{\hyperref[\detokenize{index:ARDOUR:AudioRange}]{\emph{AudioRange}}}

front()

\sphinxstyleemphasis{LuaIter}

iter()

void

reverse()

unsigned long

size()

\sphinxstyleemphasis{LuaTable}

table()


\section{↠ ARDOUR:AudioRegion}
\label{\detokenize{index:ardour-audioregion}}\label{\detokenize{index:id98}}
\sphinxstyleemphasis{C‡}: boost::shared\_ptr\textless{} ARDOUR::AudioRegion \textgreater{}, boost::weak\_ptr\textless{}
ARDOUR::AudioRegion \textgreater{}

is-a: {\hyperref[\detokenize{index:ARDOUR:Region}]{\emph{ARDOUR:Region}}}







A named object associated with a Session. Objects derived from this
class are expected to be destroyed before the session calls
drop\_references().



Methods

{\hyperref[\detokenize{index:ARDOUR:AudioSource}]{\emph{AudioSource}}}

audio\_source(unsigned int)

bool

isnil()

double

maximum\_amplitude({\hyperref[\detokenize{index:ARDOUR:Progress}]{\emph{Progress}}})





Returns the maximum (linear) amplitude of the region, or a -ve number if
the Progress object reports that the process was cancelled.





double

rms({\hyperref[\detokenize{index:ARDOUR:Progress}]{\emph{Progress}}})





Returns the maximum (rms) signal power of the region, or a -1 if the
Progress object reports that the process was cancelled.





float

scale\_amplitude()

\sphinxstyleemphasis{LuaTable}(int, …)

separate\_by\_channel({\hyperref[\detokenize{index:ARDOUR:RegionVector}]{\emph{RegionVector\&}}})

void

set\_scale\_amplitude(float)


\subsection{Inherited from ARDOUR:Region}
\label{\detokenize{index:inherited-from-ardour-region}}
Methods

bool

at\_natural\_position()

bool

automatic()

bool

can\_move()

bool

captured()

void

clear\_sync\_position()

{\hyperref[\detokenize{index:Evoral:Control}]{\emph{Control}}}

control({\hyperref[\detokenize{index:Evoral:Parameter}]{\emph{Parameter}}}, bool)

bool

covers(long)

void

cut\_end(long, int)

void

cut\_front(long, int)

{\hyperref[\detokenize{index:ARDOUR:DataType}]{\emph{DataType}}}

data\_type()

bool

external()

bool

has\_transients()

bool

hidden()

bool

import()

bool

is\_compound()

unsigned int

layer()

long

length()

bool

locked()

void

lower()

void

lower\_to\_bottom()

{\hyperref[\detokenize{index:C:StringVector}]{\emph{StringVector}}}

master\_source\_names()

{\hyperref[\detokenize{index:ARDOUR:SourceList}]{\emph{SourceList}}}

master\_sources()

void

move\_start(long, int)

void

move\_to\_natural\_position()

bool

muted()

unsigned int

n\_channels()

void

nudge\_position(long)

bool

opaque()

long

position()



How the region parameters play together:

POSITION: first frame of the region along the timeline START: first
frame of the region within its source(s) LENGTH: number of frames the
region represents



bool

position\_locked()

double

quarter\_note()

void

raise()

void

raise\_to\_top()

void

set\_hidden(bool)

void

set\_initial\_position(long)



A gui may need to create a region, then place it in an initial position
determined by the user. When this takes place within one gui operation,
we have to reset \_last\_position to prevent an implied move.



void

set\_length(long, int)

void

set\_locked(bool)

void

set\_muted(bool)

void

set\_opaque(bool)

void

set\_position(long, int)

void

set\_position\_locked(bool)

void

set\_start(long)

void

set\_sync\_position(long)



Set the region’s sync point.
\begin{description}
\item[{absolute\_pos}] \leavevmode
Session time.

\end{description}



void

set\_video\_locked(bool)

float

shift()

{\hyperref[\detokenize{index:ARDOUR:Source}]{\emph{Source}}}

source(unsigned int)

long

start()

float

stretch()

bool

sync\_marked()

\sphinxstyleemphasis{LuaTable}(long, …)

sync\_offset(int\&)

long

sync\_position()





Returns Sync position in session time





{\hyperref[\detokenize{index:C:Int64List}]{\emph{Int64List}}}

transients()

void

trim\_end(long, int)

void

trim\_front(long, int)

void

trim\_to(long, long, int)

bool

video\_locked()

bool

whole\_file()

Cast

{\hyperref[\detokenize{index:ARDOUR:AudioRegion}]{\emph{AudioRegion}}}

to\_audioregion()

{\hyperref[\detokenize{index:ARDOUR:MidiRegion}]{\emph{MidiRegion}}}

to\_midiregion()

{\hyperref[\detokenize{index:ARDOUR:Readable}]{\emph{Readable}}}

to\_readable()


\subsection{Inherited from ARDOUR:SessionObjectPtr}
\label{\detokenize{index:inherited-from-ardoursessionobjectptr-2}}\label{\detokenize{index:id99}}
Methods

std::string

name()

Cast

{\hyperref[\detokenize{index:PBD:Stateful}]{\emph{Stateful}}}

to\_stateful()

{\hyperref[\detokenize{index:PBD:StatefulDestructible}]{\emph{StatefulDestructible}}}

to\_statefuldestructible()


\section{↠ ARDOUR:AudioSource}
\label{\detokenize{index:ardour-audiosource}}\label{\detokenize{index:id100}}
\sphinxstyleemphasis{C‡}: boost::shared\_ptr\textless{} ARDOUR::AudioSource \textgreater{}, boost::weak\_ptr\textless{}
ARDOUR::AudioSource \textgreater{}

is-a: {\hyperref[\detokenize{index:ARDOUR:Source}]{\emph{ARDOUR:Source}}}







A named object associated with a Session. Objects derived from this
class are expected to be destroyed before the session calls
drop\_references().



Methods

std::string

captured\_for()

bool

empty()

bool

isnil()

bool

isnil()

long

length(long)

unsigned int

n\_channels()

unsigned int

n\_channels()

long

read({\hyperref[\detokenize{index:C:FloatArray}]{\emph{FloatArray}}}, long, long, int)

long

readable\_length()

long

readable\_length()

float

sample\_rate()

Cast

{\hyperref[\detokenize{index:ARDOUR:Readable}]{\emph{Readable}}}

to\_readable()


\subsection{Inherited from ARDOUR:Source}
\label{\detokenize{index:inherited-from-ardour-source}}
Methods

std::string

ancestor\_name()

bool

can\_be\_analysed()

bool

destructive()

bool

has\_been\_analysed()

long

natural\_position()

long

timeline\_position()

long

timestamp()

int

use\_count()

bool

used()

bool

writable()

Cast

{\hyperref[\detokenize{index:ARDOUR:AudioSource}]{\emph{AudioSource}}}

to\_audiosource()

{\hyperref[\detokenize{index:ARDOUR:FileSource}]{\emph{FileSource}}}

to\_filesource()

{\hyperref[\detokenize{index:ARDOUR:MidiSource}]{\emph{MidiSource}}}

to\_midisource()


\subsection{Inherited from ARDOUR:SessionObjectPtr}
\label{\detokenize{index:inherited-from-ardoursessionobjectptr-3}}\label{\detokenize{index:id101}}
Methods

std::string

name()

Cast

{\hyperref[\detokenize{index:PBD:Stateful}]{\emph{Stateful}}}

to\_stateful()

{\hyperref[\detokenize{index:PBD:StatefulDestructible}]{\emph{StatefulDestructible}}}

to\_statefuldestructible()


\section{↠ ARDOUR:AudioTrack}
\label{\detokenize{index:ardour-audiotrack}}\label{\detokenize{index:id102}}
\sphinxstyleemphasis{C‡}: boost::shared\_ptr\textless{} ARDOUR::AudioTrack \textgreater{}, boost::weak\_ptr\textless{}
ARDOUR::AudioTrack \textgreater{}

is-a: {\hyperref[\detokenize{index:ARDOUR:Track}]{\emph{ARDOUR:Track}}}







A track is an route (bus) with a recordable diskstream and related
objects relevant to tracking, playback and editing.

Specifically a track has regions and playlist objects.



Methods

bool

isnil()


\subsection{Inherited from ARDOUR:Track}
\label{\detokenize{index:inherited-from-ardour-track}}
Methods

{\hyperref[\detokenize{index:ARDOUR:Region}]{\emph{Region}}}

bounce({\hyperref[\detokenize{index:ARDOUR:InterThreadInfo}]{\emph{InterThreadInfo\&}}})



bounce track from session start to session end to new region
\begin{description}
\item[{itt}] \leavevmode
asynchronous progress report and cancel

\end{description}



Returns a new audio region (or nil in case of error)





{\hyperref[\detokenize{index:ARDOUR:Region}]{\emph{Region}}}

bounce\_range(long,
long,{\hyperref[\detokenize{index:ARDOUR:InterThreadInfo}]{\emph{InterThreadInfo\&}}},{\hyperref[\detokenize{index:ARDOUR:Processor}]{\emph{Processor}}},
bool)



Bounce the given range to a new audio region.
\begin{description}
\item[{start}] \leavevmode
start time (in samples)

\item[{end}] \leavevmode
end time (in samples)

\item[{itt}] \leavevmode
asynchronous progress report and cancel

\item[{endpoint}] \leavevmode
the processor to tap the signal off (or nil for the top)

\item[{include\_endpoint}] \leavevmode
include the given processor in the bounced audio.

\end{description}



Returns a new audio region (or nil in case of error)





bool

bounceable({\hyperref[\detokenize{index:ARDOUR:Processor}]{\emph{Processor}}}, bool)



Test if the track can be bounced with the given settings. If
sends/inserts/returns are present in the signal path or the given track
has no audio outputs bouncing is not possible.
\begin{description}
\item[{endpoint}] \leavevmode
the processor to tap the signal off (or nil for the top)

\item[{include\_endpoint}] \leavevmode
include the given processor in the bounced audio.

\end{description}



Returns true if the track can be bounced, or false otherwise.





bool

can\_record()

{\hyperref[\detokenize{index:ARDOUR:Playlist}]{\emph{Playlist}}}

playlist()

bool

set\_name(std::string)

Cast

{\hyperref[\detokenize{index:ARDOUR:AudioTrack}]{\emph{AudioTrack}}}

to\_audio\_track()

{\hyperref[\detokenize{index:ARDOUR:MidiTrack}]{\emph{MidiTrack}}}

to\_midi\_track()


\subsection{Inherited from ARDOUR:Route}
\label{\detokenize{index:inherited-from-ardour-route}}
Methods

bool

active()

int

add\_processor\_by\_index({\hyperref[\detokenize{index:ARDOUR:Processor}]{\emph{Processor}}},
int,{\hyperref[\detokenize{index:ARDOUR:Route:ProcessorStreams}]{\emph{ProcessorStreams}}}, bool)



Add a processor to a route such that it ends up with a given index into
the visible processors.
\begin{description}
\item[{index}] \leavevmode
Index to add the processor at, or -1 to add at the end of the list.

\end{description}



Returns 0 on success, non-0 on failure.





bool

add\_sidechain({\hyperref[\detokenize{index:ARDOUR:Processor}]{\emph{Processor}}})

{\hyperref[\detokenize{index:ARDOUR:Amp}]{\emph{Amp}}}

amp()

std::string

comment()

bool

customize\_plugin\_insert({\hyperref[\detokenize{index:ARDOUR:Processor}]{\emph{Processor}}}, unsigned
int,{\hyperref[\detokenize{index:ARDOUR:ChanCount}]{\emph{ChanCount}}},{\hyperref[\detokenize{index:ARDOUR:ChanCount}]{\emph{ChanCount}}})



enable custom plugin-insert configuration
\begin{description}
\item[{proc}] \leavevmode
Processor to customize

\item[{count}] \leavevmode
number of plugin instances to use (if zero, reset to default)

\item[{outs}] \leavevmode
output port customization

\item[{sinks}] \leavevmode
input pins for variable-I/O plugins

\end{description}



Returns true if successful





{\hyperref[\detokenize{index:ARDOUR:IO}]{\emph{IO}}}

input()

{\hyperref[\detokenize{index:ARDOUR:Delivery}]{\emph{Delivery}}}

main\_outs()



the signal processor at at end of the processing chain which produces
output



bool

muted()

{\hyperref[\detokenize{index:ARDOUR:ChanCount}]{\emph{ChanCount}}}

n\_inputs()

{\hyperref[\detokenize{index:ARDOUR:ChanCount}]{\emph{ChanCount}}}

n\_outputs()

{\hyperref[\detokenize{index:ARDOUR:Processor}]{\emph{Processor}}}

nth\_plugin(unsigned int)

{\hyperref[\detokenize{index:ARDOUR:Processor}]{\emph{Processor}}}

nth\_processor(unsigned int)

{\hyperref[\detokenize{index:ARDOUR:Processor}]{\emph{Processor}}}

nth\_send(unsigned int)

{\hyperref[\detokenize{index:ARDOUR:IO}]{\emph{IO}}}

output()

{\hyperref[\detokenize{index:ARDOUR:PannerShell}]{\emph{PannerShell}}}

panner\_shell()

{\hyperref[\detokenize{index:ARDOUR:PeakMeter}]{\emph{PeakMeter}}}

peak\_meter()



************************************************************* Pure
interface begins
here*************************************************************



int

remove\_processor({\hyperref[\detokenize{index:ARDOUR:Processor}]{\emph{Processor}}},{\hyperref[\detokenize{index:ARDOUR:Route:ProcessorStreams}]{\emph{ProcessorStreams}}},
bool)



remove plugin/processor
\begin{description}
\item[{proc}] \leavevmode
processor to remove

\item[{err}] \leavevmode
error report (index where removal failed, channel-count why it
failed) may be nil

\item[{need\_process\_lock}] \leavevmode
if locking is required (set to true, unless called from RT context
with lock)

\end{description}



Returns 0 on success





int

remove\_processors({\hyperref[\detokenize{index:ARDOUR:ProcessorList}]{\emph{ProcessorList}}},{\hyperref[\detokenize{index:ARDOUR:Route:ProcessorStreams}]{\emph{ProcessorStreams}}})

bool

remove\_sidechain({\hyperref[\detokenize{index:ARDOUR:Processor}]{\emph{Processor}}})

int

reorder\_processors({\hyperref[\detokenize{index:ARDOUR:ProcessorList}]{\emph{ProcessorList}}},{\hyperref[\detokenize{index:ARDOUR:Route:ProcessorStreams}]{\emph{ProcessorStreams}}})

int

replace\_processor({\hyperref[\detokenize{index:ARDOUR:Processor}]{\emph{Processor}}},{\hyperref[\detokenize{index:ARDOUR:Processor}]{\emph{Processor}}},{\hyperref[\detokenize{index:ARDOUR:Route:ProcessorStreams}]{\emph{ProcessorStreams}}})



replace plugin/processor with another
\begin{description}
\item[{old}] \leavevmode
processor to remove

\item[{sub}] \leavevmode
processor to substitute the old one with

\item[{err}] \leavevmode
error report (index where removal failed, channel-count why it
failed) may be nil

\end{description}



Returns 0 on success





bool

reset\_plugin\_insert({\hyperref[\detokenize{index:ARDOUR:Processor}]{\emph{Processor}}})



reset plugin-insert configuration to default, disable customizations.

This is equivalent to calling

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{customize\PYGZus{}plugin\PYGZus{}insert} \PYG{p}{(}\PYG{n}{proc}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{unused}\PYG{p}{)}
\end{sphinxVerbatim}
\begin{description}
\item[{proc}] \leavevmode
Processor to reset

\end{description}



Returns true if successful





void

set\_active(bool, void*)

void

set\_comment(std::string, void*)

void

set\_meter\_point({\hyperref[\detokenize{index:ARDOUR.MeterPoint}]{\emph{MeterPoint}}}, bool)

bool

set\_strict\_io(bool)

bool

soloed()

bool

strict\_io()

{\hyperref[\detokenize{index:ARDOUR:Processor}]{\emph{Processor}}}

the\_instrument()



Return the first processor that accepts has at least one MIDI input and
at least one audio output. In the vast majority of cases, this will be
“the instrument”. This does not preclude other MIDI-\textgreater{}audio processors
later in the processing chain, but that would be a special case not
covered by this utility function.



{\hyperref[\detokenize{index:ARDOUR:Amp}]{\emph{Amp}}}

trim()

Cast

{\hyperref[\detokenize{index:ARDOUR:Automatable}]{\emph{Automatable}}}

to\_automatable()

{\hyperref[\detokenize{index:ARDOUR:Slavable}]{\emph{Slavable}}}

to\_slavable()

{\hyperref[\detokenize{index:ARDOUR:Track}]{\emph{Track}}}

to\_track()


\subsection{Inherited from ARDOUR:Stripable}
\label{\detokenize{index:inherited-from-ardour-stripable}}
Methods

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

comp\_enable\_control()

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

comp\_makeup\_control()

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

comp\_mode\_control()

std::string

comp\_mode\_name(unsigned int)

{\hyperref[\detokenize{index:ARDOUR:ReadOnlyControl}]{\emph{ReadOnlyControl}}}

comp\_redux\_control()

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

comp\_speed\_control()

std::string

comp\_speed\_name(unsigned int)

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

comp\_threshold\_control()

unsigned int

eq\_band\_cnt()

std::string

eq\_band\_name(unsigned int)

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

eq\_enable\_control()

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

eq\_freq\_control(unsigned int)

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

eq\_gain\_control(unsigned int)

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

eq\_q\_control(unsigned int)

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

eq\_shape\_control(unsigned int)

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

filter\_enable\_controllable(bool)

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

filter\_freq\_controllable(bool)

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

filter\_slope\_controllable(bool)

{\hyperref[\detokenize{index:ARDOUR:GainControl}]{\emph{GainControl}}}

gain\_control()

bool

is\_auditioner()

bool

is\_hidden()

bool

is\_master()

bool

is\_monitor()

bool

is\_selected()

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

master\_send\_enable\_control()

{\hyperref[\detokenize{index:ARDOUR:MonitorProcessor}]{\emph{MonitorProcessor}}}

monitor\_control()

{\hyperref[\detokenize{index:ARDOUR:MuteControl}]{\emph{MuteControl}}}

mute\_control()

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

pan\_azimuth\_control()

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

pan\_elevation\_control()

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

pan\_frontback\_control()

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

pan\_lfe\_control()

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

pan\_width\_control()

{\hyperref[\detokenize{index:ARDOUR:PhaseControl}]{\emph{PhaseControl}}}

phase\_control()

{\hyperref[\detokenize{index:ARDOUR:PresentationInfo}]{\emph{PresentationInfo}}}

presentation\_info\_ptr()

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

rec\_enable\_control()

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

rec\_safe\_control()

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

send\_enable\_control(unsigned int)

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

send\_level\_control(unsigned int)

std::string

send\_name(unsigned int)

void

set\_presentation\_order(unsigned int)

{\hyperref[\detokenize{index:ARDOUR:SoloControl}]{\emph{SoloControl}}}

solo\_control()

{\hyperref[\detokenize{index:ARDOUR:SoloIsolateControl}]{\emph{SoloIsolateControl}}}

solo\_isolate\_control()

{\hyperref[\detokenize{index:ARDOUR:SoloSafeControl}]{\emph{SoloSafeControl}}}

solo\_safe\_control()

{\hyperref[\detokenize{index:ARDOUR:GainControl}]{\emph{GainControl}}}

trim\_control()

Cast

{\hyperref[\detokenize{index:ARDOUR:Route}]{\emph{Route}}}

to\_route()

{\hyperref[\detokenize{index:ARDOUR:VCA}]{\emph{VCA}}}

to\_vca()


\subsection{Inherited from ARDOUR:SessionObjectPtr}
\label{\detokenize{index:inherited-from-ardoursessionobjectptr-4}}\label{\detokenize{index:id103}}
Methods

std::string

name()

Cast

{\hyperref[\detokenize{index:PBD:Stateful}]{\emph{Stateful}}}

to\_stateful()

{\hyperref[\detokenize{index:PBD:StatefulDestructible}]{\emph{StatefulDestructible}}}

to\_statefuldestructible()


\section{∁ ARDOUR:AudioTrackList}
\label{\detokenize{index:ardour-audiotracklist}}\label{\detokenize{index:id104}}
\sphinxstyleemphasis{C‡}: std::list\textless{}boost::shared\_ptr\textless{}ARDOUR::AudioTrack\textgreater{} \textgreater{}





Constructor

ℂ

ARDOUR.AudioTrackList()

Methods

\sphinxstyleemphasis{LuaTable}

add(LuaTable \{{\hyperref[\detokenize{index:ARDOUR:AudioTrack}]{\emph{AudioTrack}}}\})

{\hyperref[\detokenize{index:ARDOUR:AudioTrack}]{\emph{AudioTrack}}}

back()

bool

empty()

{\hyperref[\detokenize{index:ARDOUR:AudioTrack}]{\emph{AudioTrack}}}

front()

\sphinxstyleemphasis{LuaIter}

iter()

void

push\_back({\hyperref[\detokenize{index:ARDOUR:AudioTrack}]{\emph{AudioTrack}}})

void

reverse()

unsigned long

size()

\sphinxstyleemphasis{LuaTable}

table()

void

unique()


\section{↠ ARDOUR:Automatable}
\label{\detokenize{index:ardour-automatable}}\label{\detokenize{index:id105}}
\sphinxstyleemphasis{C‡}: boost::shared\_ptr\textless{} ARDOUR::Automatable \textgreater{}, boost::weak\_ptr\textless{}
ARDOUR::Automatable \textgreater{}

is-a: {\hyperref[\detokenize{index:Evoral:ControlSet}]{\emph{Evoral:ControlSet}}}





Methods

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

automation\_control({\hyperref[\detokenize{index:Evoral:Parameter}]{\emph{Parameter}}}, bool)

bool

isnil()

Cast

{\hyperref[\detokenize{index:ARDOUR:Slavable}]{\emph{Slavable}}}

to\_slavable()


\section{↠ ARDOUR:AutomatableSequence}
\label{\detokenize{index:ardour-automatablesequence}}\label{\detokenize{index:id106}}
\sphinxstyleemphasis{C‡}: boost::shared\_ptr\textless{} ARDOUR::AutomatableSequence\textless{}Evoral::Beats\textgreater{} \textgreater{},
boost::weak\_ptr\textless{} ARDOUR::AutomatableSequence\textless{}Evoral::Beats\textgreater{} \textgreater{}

is-a: {\hyperref[\detokenize{index:ARDOUR:Automatable}]{\emph{ARDOUR:Automatable}}}





Methods

bool

isnil()

Cast

{\hyperref[\detokenize{index:Evoral:Sequence}]{\emph{Sequence}}}

to\_sequence()


\subsection{Inherited from ARDOUR:Automatable}
\label{\detokenize{index:inherited-from-ardour-automatable}}
Methods

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

automation\_control({\hyperref[\detokenize{index:Evoral:Parameter}]{\emph{Parameter}}}, bool)

Cast

{\hyperref[\detokenize{index:ARDOUR:Slavable}]{\emph{Slavable}}}

to\_slavable()


\section{↠ ARDOUR:AutomationControl}
\label{\detokenize{index:ardour-automationcontrol}}\label{\detokenize{index:id107}}
\sphinxstyleemphasis{C‡}: boost::shared\_ptr\textless{} ARDOUR::AutomationControl \textgreater{}, boost::weak\_ptr\textless{}
ARDOUR::AutomationControl \textgreater{}

is-a: {\hyperref[\detokenize{index:PBD:Controllable}]{\emph{PBD:Controllable}}}







A PBD::Controllable with associated automation data (AutomationList)



Methods

{\hyperref[\detokenize{index:ARDOUR:AutomationList}]{\emph{AutomationList}}}

alist()

{\hyperref[\detokenize{index:ARDOUR.AutoState}]{\emph{AutoState}}}

automation\_state()

double

get\_value()



Get the current effective {}`user’ value based on automation state



bool

isnil()

void

set\_automation\_state({\hyperref[\detokenize{index:ARDOUR.AutoState}]{\emph{AutoState}}})

void

set\_value(double,{\hyperref[\detokenize{index:PBD.Controllable.GroupControlDisposition}]{\emph{GroupControlDisposition}}})



Get and Set {}`internal’ value

All derived classes must implement this.

Basic derived classes will ignore
\begin{description}
\item[{group\_override,}] \leavevmode
but more sophisticated children, notably those that proxy the value
setting logic via an object that is aware of group relationships
between this control and others, will find it useful.

\end{description}



void

start\_touch(double)

void

stop\_touch(double)

bool

writable()

Cast

{\hyperref[\detokenize{index:Evoral:Control}]{\emph{Control}}}

to\_ctrl()

{\hyperref[\detokenize{index:ARDOUR:SlavableAutomationControl}]{\emph{SlavableAutomationControl}}}

to\_slavable()


\subsection{Inherited from PBD:Controllable}
\label{\detokenize{index:inherited-from-pbd-controllable}}
Methods

std::string

name()


\subsection{Inherited from PBD:StatefulPtr}
\label{\detokenize{index:inherited-from-pbd-statefulptr}}
Methods

void

clear\_changes()



Forget about any changes to this object’s properties



{\hyperref[\detokenize{index:PBD:ID}]{\emph{ID}}}

id()

{\hyperref[\detokenize{index:ARDOUR:OwnedPropertyList}]{\emph{OwnedPropertyList}}}

properties()


\section{↠ ARDOUR:AutomationList}
\label{\detokenize{index:ardour-automationlist}}\label{\detokenize{index:id108}}
\sphinxstyleemphasis{C‡}: boost::shared\_ptr\textless{} ARDOUR::AutomationList \textgreater{}, boost::weak\_ptr\textless{}
ARDOUR::AutomationList \textgreater{}

is-a: {\hyperref[\detokenize{index:Evoral:ControlList}]{\emph{Evoral:ControlList}}}







AutomationList is a stateful wrapper around Evoral::ControlList. It
includes session-specifics (such as automation state), control logic
(e.g. touch, signals) and acts as proxy to the underlying ControlList
which holds the actual data.



Methods

{\hyperref[\detokenize{index:PBD:XMLNode}]{\emph{XMLNode}}}

get\_state()

bool

isnil()

{\hyperref[\detokenize{index:PBD:Command}]{\emph{Command}}}

memento\_command({\hyperref[\detokenize{index:PBD:XMLNode}]{\emph{XMLNode}}},{\hyperref[\detokenize{index:PBD:XMLNode}]{\emph{XMLNode}}})

bool

touch\_enabled()

bool

touching()

bool

writing()

Cast

{\hyperref[\detokenize{index:Evoral:ControlList}]{\emph{ControlList}}}

list()

{\hyperref[\detokenize{index:PBD:Stateful}]{\emph{Stateful}}}

to\_stateful()

{\hyperref[\detokenize{index:PBD:StatefulDestructible}]{\emph{StatefulDestructible}}}

to\_statefuldestructible()


\subsection{Inherited from Evoral:ControlList}
\label{\detokenize{index:inherited-from-evoral-controllist}}
Methods

void

add(double, double, bool, bool)



add automation events
\begin{description}
\item[{when}] \leavevmode
absolute time in samples

\item[{value}] \leavevmode
parameter value

\item[{with\_guards}] \leavevmode
if true, add guard-points

\item[{with\_initial}] \leavevmode
if true, add an initial point if the list is empty

\end{description}



void

clear(double, double)



remove all automation events between the given time range
\begin{description}
\item[{start}] \leavevmode
start of range (inclusive) in audio samples

\item[{end}] \leavevmode
end of range (inclusive) in audio samples

\end{description}



void

clear\_list()

double

eval(double)



query value at given time (takes a read-lock, not safe while writing
automation)
\begin{description}
\item[{where}] \leavevmode
absolute time in samples

\end{description}



Returns parameter value





{\hyperref[\detokenize{index:ARDOUR:EventList}]{\emph{EventList}}}

events()

bool

in\_write\_pass()

{\hyperref[\detokenize{index:Evoral.ControlList.InterpolationStyle}]{\emph{InterpolationStyle}}}

interpolation()



query interpolation style of the automation data



Returns Interpolation Style





\sphinxstyleemphasis{LuaTable}(double, …)

rt\_safe\_eval(double, bool\&)



realtime safe version of eval, may fail if read-lock cannot be taken
\begin{description}
\item[{where}] \leavevmode
absolute time in samples

\item[{ok}] \leavevmode
boolean reference if returned value is valid

\end{description}



Returns parameter value





bool

set\_interpolation({\hyperref[\detokenize{index:Evoral.ControlList.InterpolationStyle}]{\emph{InterpolationStyle}}})



set the interpolation style of the automation data.

This will fail when asking for Logarithmic scale and min,max crosses 0
or Exponential scale with min != 0.
\begin{description}
\item[{is}] \leavevmode
interpolation style

\end{description}



Returns true if style change was successful





void

thin(double)



Thin the number of events in this list.

The thinning factor corresponds to the area of a triangle computed
between three points in the list (time-difference * value-difference).
If the area is large, it indicates significant non-linearity between the
points.

Time is measured in samples, value is usually normalized to 0..1.

During automation recording we thin the recorded points using this
value. If a point is sufficiently co-linear with its neighbours (as
defined by the area of the triangle formed by three of them), we will
not include it in the list. The larger the value, the more points are
excluded, so this effectively measures the amount of thinning to be
done.
\begin{description}
\item[{thinning\_factor}] \leavevmode
area-size (default: 20)

\end{description}



void

truncate\_end(double)



truncate the event list after the given time
\begin{description}
\item[{last\_coordinate}] \leavevmode
last event to include

\end{description}



void

truncate\_start(double)



truncate the event list to the given time
\begin{description}
\item[{overall\_length}] \leavevmode
overall length

\end{description}




\section{∁ ARDOUR:BackendVector}
\label{\detokenize{index:ardour-backendvector}}\label{\detokenize{index:id109}}
\sphinxstyleemphasis{C‡}: std::vector\textless{}ARDOUR::AudioBackendInfo const* \textgreater{}





Constructor

ℂ

ARDOUR.BackendVector()

Methods

{\hyperref[\detokenize{index:ARDOUR:AudioBackendInfo}]{\emph{AudioBackendInfo}}}

at(unsigned long)

bool

empty()

\sphinxstyleemphasis{LuaIter}

iter()

unsigned long

size()

\sphinxstyleemphasis{LuaTable}

table()


\section{∁ ARDOUR:BeatsFramesConverter}
\label{\detokenize{index:ardour-beatsframesconverter}}\label{\detokenize{index:id110}}
\sphinxstyleemphasis{C‡}: ARDOUR::BeatsFramesConverter







Converter between quarter-note beats and frames. Takes distances in
quarter-note beats or frames from some origin (supplied to the
constructor in frames), and converts them to the opposite unit, taking
tempo changes into account.



Constructor

ℂ

ARDOUR.BeatsFramesConverter({\hyperref[\detokenize{index:ARDOUR:TempoMap}]{\emph{TempoMap}}}, long)

Methods

{\hyperref[\detokenize{index:Evoral:Beats}]{\emph{Beats}}}

from(long)



Convert B time to A time (A from B)



long

to({\hyperref[\detokenize{index:Evoral:Beats}]{\emph{Beats}}})



Convert A time to B time (A to B)




\section{∁ ARDOUR:BufferSet}
\label{\detokenize{index:ardour-bufferset}}\label{\detokenize{index:id111}}
\sphinxstyleemphasis{C‡}: ARDOUR::BufferSet







A set of buffers of various types.

These are mainly accessed from Session and passed around as scratch
buffers (e.g. as parameters to run() methods) to do in-place signal
processing.

There are two types of counts associated with a BufferSet - available,
and the ‘use count’. Available is the actual number of allocated buffers
(and so is the maximum acceptable value for the use counts).

The use counts are how things determine the form of their input and
inform others the form of their output (e.g. what they did to the
BufferSet). Setting the use counts is realtime safe.



Methods

{\hyperref[\detokenize{index:ARDOUR:ChanCount}]{\emph{ChanCount}}}

count()

{\hyperref[\detokenize{index:ARDOUR:AudioBuffer}]{\emph{AudioBuffer}}}

get\_audio(unsigned long)

{\hyperref[\detokenize{index:ARDOUR:MidiBuffer}]{\emph{MidiBuffer}}}

get\_midi(unsigned long)


\section{∁ ARDOUR:ChanCount}
\label{\detokenize{index:ardour-chancount}}\label{\detokenize{index:id112}}
\sphinxstyleemphasis{C‡}: ARDOUR::ChanCount







A count of channels, possibly with many types.

Operators are defined so this may safely be used as if it were a simple
(single-typed) integer count of channels.



Constructor

ℂ

ARDOUR.ChanCount({\hyperref[\detokenize{index:ARDOUR:DataType}]{\emph{DataType}}}, unsigned int)



Convenience constructor for making single-typed streams (mono, stereo,
midi, etc)
\begin{description}
\item[{type}] \leavevmode
data type

\item[{count}] \leavevmode
number of channels

\end{description}



Methods

unsigned int

get({\hyperref[\detokenize{index:ARDOUR:DataType}]{\emph{DataType}}})



query channel count for given type
\begin{description}
\item[{type}] \leavevmode
data type

\end{description}



Returns channel count for given type





unsigned int

n\_audio()



query number of audio channels



Returns number of audio channels





unsigned int

n\_midi()



query number of midi channels



Returns number of midi channels





unsigned int

n\_total()



query total channel count of all data types



Returns total channel count (audio + midi)





void

reset()



zero count of all data types



void

set({\hyperref[\detokenize{index:ARDOUR:DataType}]{\emph{DataType}}}, unsigned int)



set channel count for given type
\begin{description}
\item[{count}] \leavevmode
number of channels

\item[{type}] \leavevmode
data type

\end{description}




\section{∁ ARDOUR:ChanMapping}
\label{\detokenize{index:ardour-chanmapping}}\label{\detokenize{index:id113}}
\sphinxstyleemphasis{C‡}: ARDOUR::ChanMapping







A mapping from one set of channels to another. The general form is 1
source (from), many sinks (to). numeric IDs are used to identify sources
and sinks.

for plugins this is used to map “plugin-pin” to “audio-buffer”



Constructor

ℂ

ARDOUR.ChanMapping()

Methods

{\hyperref[\detokenize{index:ARDOUR:ChanCount}]{\emph{ChanCount}}}

count()

unsigned int

get({\hyperref[\detokenize{index:ARDOUR:DataType}]{\emph{DataType}}}, unsigned int)



get buffer mapping for given data type and pin
\begin{description}
\item[{from}] \leavevmode
numeric source id

\item[{type}] \leavevmode
data type

\end{description}



Returns mapped buffer number (or ChanMapping::Invalid)





bool

is\_monotonic()



Test if this mapping is monotonic (useful to see if inplace processing
is feasible)



Returns true if the map is a strict monotonic set





unsigned int

n\_total()

void

set({\hyperref[\detokenize{index:ARDOUR:DataType}]{\emph{DataType}}}, unsigned int, unsigned int)



set buffer mapping for given data type
\begin{description}
\item[{from}] \leavevmode
numeric source id

\item[{to}] \leavevmode
buffer

\item[{type}] \leavevmode
data type

\end{description}




\section{∁ ARDOUR:ControlList}
\label{\detokenize{index:ardour-controllist}}\label{\detokenize{index:id114}}
\sphinxstyleemphasis{C‡}: std::list\textless{}boost::shared\_ptr\textless{}ARDOUR::AutomationControl\textgreater{} \textgreater{}





Constructor

ℂ

ARDOUR.ControlList()

Methods

\sphinxstyleemphasis{LuaTable}

add(LuaTable \{{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}\})

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

back()

bool

empty()

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

front()

\sphinxstyleemphasis{LuaIter}

iter()

void

push\_back({\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}})

void

reverse()

unsigned long

size()

\sphinxstyleemphasis{LuaTable}

table()

void

unique()


\section{∁ ARDOUR:ControlListPtr}
\label{\detokenize{index:ardour-controllistptr}}\label{\detokenize{index:id115}}
\sphinxstyleemphasis{C‡}:
boost::shared\_ptr\textless{}std::list\textless{}boost::shared\_ptr\textless{}ARDOUR::AutomationControl\textgreater{}
\textgreater{} \textgreater{}





Constructor

ℂ

ARDOUR.ControlListPtr()

Methods

\sphinxstyleemphasis{LuaTable}

add(LuaTable \{{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}\})

bool

empty()

\sphinxstyleemphasis{LuaIter}

iter()

void

push\_back({\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}})

void

reverse()

unsigned long

size()

\sphinxstyleemphasis{LuaTable}

table()

void

unique()


\section{ℕ ARDOUR.DSP}
\label{\detokenize{index:ardour-dsp}}\label{\detokenize{index:id116}}




Methods

float

accurate\_coefficient\_to\_dB(float)

void

apply\_gain\_to\_buffer({\hyperref[\detokenize{index:C:FloatArray}]{\emph{FloatArray}}}, unsigned int,
float)

float

compute\_peak({\hyperref[\detokenize{index:C:FloatArray}]{\emph{FloatArray}}}, unsigned int, float)

void

copy\_vector({\hyperref[\detokenize{index:C:FloatArray}]{\emph{FloatArray}}},{\hyperref[\detokenize{index:C:FloatArray}]{\emph{FloatArray}}},
unsigned int)

float

dB\_to\_coefficient(float)

float

fast\_coefficient\_to\_dB(float)

void

find\_peaks({\hyperref[\detokenize{index:C:FloatArray}]{\emph{FloatArray}}}, unsigned
int,{\hyperref[\detokenize{index:C:FloatArray}]{\emph{FloatArray}}},{\hyperref[\detokenize{index:C:FloatArray}]{\emph{FloatArray}}})

float

log\_meter(float)



non-linear power-scale meter deflection
\begin{description}
\item[{power}] \leavevmode
signal power (dB)

\end{description}



Returns deflected value





float

log\_meter\_coeff(float)



non-linear power-scale meter deflection
\begin{description}
\item[{coeff}] \leavevmode
signal value

\end{description}



Returns deflected value





void

memset({\hyperref[\detokenize{index:C:FloatArray}]{\emph{FloatArray}}}, float, unsigned int)



lua wrapper to memset()



void

mix\_buffers\_no\_gain({\hyperref[\detokenize{index:C:FloatArray}]{\emph{FloatArray}}},{\hyperref[\detokenize{index:C:FloatArray}]{\emph{FloatArray}}},
unsigned int)

void

mix\_buffers\_with\_gain({\hyperref[\detokenize{index:C:FloatArray}]{\emph{FloatArray}}},{\hyperref[\detokenize{index:C:FloatArray}]{\emph{FloatArray}}},
unsigned int, float)

void

mmult({\hyperref[\detokenize{index:C:FloatArray}]{\emph{FloatArray}}},{\hyperref[\detokenize{index:C:FloatArray}]{\emph{FloatArray}}},
unsigned int)



matrix multiply multiply every sample of {}`data’ with the corresponding
sample at {}`mult’.
\begin{description}
\item[{data}] \leavevmode
multiplicand

\item[{mult}] \leavevmode
multiplicand

\item[{n\_samples}] \leavevmode
number of samples in data and mmult

\end{description}



\sphinxstyleemphasis{LuaTable}(…)

peaks({\hyperref[\detokenize{index:C:FloatArray}]{\emph{FloatArray}}}, float\&, float\&, unsigned int)

void

process\_map({\hyperref[\detokenize{index:ARDOUR:BufferSet}]{\emph{BufferSet}}},{\hyperref[\detokenize{index:ARDOUR:ChanMapping}]{\emph{ChanMapping}}},{\hyperref[\detokenize{index:ARDOUR:ChanMapping}]{\emph{ChanMapping}}},
unsigned int, long,{\hyperref[\detokenize{index:ARDOUR:DataType}]{\emph{DataType}}})


\section{∁ ARDOUR:DSP:Biquad}
\label{\detokenize{index:ardour-dsp-biquad}}\label{\detokenize{index:id117}}
\sphinxstyleemphasis{C‡}: ARDOUR::DSP::Biquad







Biquad Filter



Constructor

ℂ

ARDOUR.DSP.Biquad(double)



Instantiate Biquad Filter
\begin{description}
\item[{samplerate}] \leavevmode
Samplerate

\end{description}



Methods

void

compute({\hyperref[\detokenize{index:ARDOUR.DSP.Biquad.Type}]{\emph{Type}}}, double, double, double)



setup filter, compute coefficients
\begin{description}
\item[{type}] \leavevmode
filter type (LowPass, HighPass, etc)

\item[{freq}] \leavevmode
filter frequency

\item[{Q}] \leavevmode
filter quality

\item[{gain}] \leavevmode
filter gain

\end{description}



void

configure(double, double, double, double, double)



setup filter, set coefficients directly



float

dB\_at\_freq(float)



filter transfer function (filter response for spectrum visualization)
\begin{description}
\item[{freq}] \leavevmode
frequency

\end{description}



Returns gain at given frequency in dB (clamped to -120..+120)





void

reset()



reset filter state



void

run({\hyperref[\detokenize{index:C:FloatArray}]{\emph{FloatArray}}}, unsigned int)



process audio data
\begin{description}
\item[{data}] \leavevmode
pointer to audio-data

\item[{n\_samples}] \leavevmode
number of samples to process

\end{description}




\section{∁ ARDOUR:DSP:DspShm}
\label{\detokenize{index:ardour-dsp-dspshm}}\label{\detokenize{index:id118}}
\sphinxstyleemphasis{C‡}: ARDOUR::DSP::DspShm







C/C++ Shared Memory

A convenience class representing a C array of float{[}{]} or int32\_t{[}{]} data
values. This is useful for lua scripts to perform DSP operations
directly using C/C++ with CPU Hardware acceleration.

Access to this memory area is always 4 byte aligned. The data is
interpreted either as float or as int.

This memory area can also be shared between different instances or the
same lua plugin (DSP, GUI).

Since memory allocation is not realtime safe it should be allocated
during dsp\_init() or dsp\_configure(). The memory is free()ed
automatically when the lua instance is destroyed.



Constructor

ℂ

ARDOUR.DSP.DspShm(unsigned long)

Methods

void

allocate(unsigned long)



{[}re{]} allocate memory in host’s memory space
\begin{description}
\item[{s}] \leavevmode
size, total number of float or integer elements to store.

\end{description}



int

atomic\_get\_int(unsigned long)



atomically read integer at offset

This involves a memory barrier. This call is intended for buffers which
are shared with another instance.
\begin{description}
\item[{off}] \leavevmode
offset in shared memory region

\end{description}



Returns value at offset





void

atomic\_set\_int(unsigned long, int)



atomically set integer at offset

This involves a memory barrier. This call is intended for buffers which
are shared with another instance.
\begin{description}
\item[{off}] \leavevmode
offset in shared memory region

\item[{val}] \leavevmode
value to set

\end{description}



void

clear()



clear memory (set to zero)



{\hyperref[\detokenize{index:C:FloatArray}]{\emph{FloatArray}}}

to\_float(unsigned long)



access memory as float array
\begin{description}
\item[{off}] \leavevmode
offset in shared memory region

\end{description}



Returns float{[}{]}





{\hyperref[\detokenize{index:C:IntArray}]{\emph{IntArray}}}

to\_int(unsigned long)



access memory as integer array
\begin{description}
\item[{off}] \leavevmode
offset in shared memory region

\end{description}



Returns int\_32\_t{[}{]}






\section{∁ ARDOUR:DSP:FFTSpectrum}
\label{\detokenize{index:ardour-dsp-fftspectrum}}\label{\detokenize{index:id119}}
\sphinxstyleemphasis{C‡}: ARDOUR::DSP::FFTSpectrum





Constructor

ℂ

ARDOUR.DSP.FFTSpectrum(unsigned int, double)

Methods

void

execute()



process current data in buffer



float

freq\_at\_bin(unsigned int)

float

power\_at\_bin(unsigned int, float)



query
\begin{description}
\item[{b}] \leavevmode
the frequency bin 0 .. window\_size / 2

\item[{norm}] \leavevmode
gain factor (set equal to for 1/f normalization)

\end{description}



Returns signal power at given bin (in dBFS)





void

set\_data\_hann({\hyperref[\detokenize{index:C:FloatArray}]{\emph{FloatArray}}}, unsigned int, unsigned
int)


\section{∁ ARDOUR:DSP:LowPass}
\label{\detokenize{index:ardour-dsp-lowpass}}\label{\detokenize{index:id120}}
\sphinxstyleemphasis{C‡}: ARDOUR::DSP::LowPass







1st order Low Pass filter



Constructor

ℂ

ARDOUR.DSP.LowPass(double, float)



instantiate a LPF
\begin{description}
\item[{samplerate}] \leavevmode
samplerate

\item[{freq}] \leavevmode
cut-off frequency

\end{description}



Methods

void

ctrl({\hyperref[\detokenize{index:C:FloatArray}]{\emph{FloatArray}}}, float, unsigned int)



filter control data

This is useful for parameter smoothing.
\begin{description}
\item[{data}] \leavevmode
pointer to control-data array

\item[{val}] \leavevmode
target value

\item[{array}] \leavevmode
length

\end{description}



void

proc({\hyperref[\detokenize{index:C:FloatArray}]{\emph{FloatArray}}}, unsigned int)



process audio data
\begin{description}
\item[{data}] \leavevmode
pointer to audio-data

\item[{n\_samples}] \leavevmode
number of samples to process

\end{description}



void

reset()



reset filter state



void

set\_cutoff(float)



update filter cut-off frequency
\begin{description}
\item[{freq}] \leavevmode
cut-off frequency

\end{description}




\section{∁ ARDOUR:DataType}
\label{\detokenize{index:ardour-datatype}}\label{\detokenize{index:id121}}
\sphinxstyleemphasis{C‡}: ARDOUR::DataType







A type of Data Ardour is capable of processing.

The majority of this class is dedicated to conversion to and from
various other type representations, simple comparison between then, etc.
This code is deliberately ‘ugly’ so other code doesn’t have to be.



Constructor

ℂ

ARDOUR.DataType(std::string)

Methods

{\hyperref[\detokenize{index:ARDOUR:DataType}]{\emph{DataType}}}

audio()



convenience constructor for DataType::AUDIO with managed lifetime



Returns DataType::AUDIO





{\hyperref[\detokenize{index:ARDOUR:DataType}]{\emph{DataType}}}

midi()



convenience constructor for DataType::MIDI with managed lifetime



Returns DataType::MIDI





{\hyperref[\detokenize{index:ARDOUR:DataType}]{\emph{DataType}}}

null()



convenience constructor for DataType::NIL with managed lifetime



Returns DataType::NIL





char*

to\_string()



Inverse of the from-string constructor




\section{↠ ARDOUR:Delivery}
\label{\detokenize{index:ardour-delivery}}\label{\detokenize{index:id122}}
\sphinxstyleemphasis{C‡}: boost::shared\_ptr\textless{} ARDOUR::Delivery \textgreater{}, boost::weak\_ptr\textless{}
ARDOUR::Delivery \textgreater{}

is-a: {\hyperref[\detokenize{index:ARDOUR:IOProcessor}]{\emph{ARDOUR:IOProcessor}}}







A mixer strip element (Processor) with 1 or 2 IO elements.



Methods

bool

isnil()

{\hyperref[\detokenize{index:ARDOUR:PannerShell}]{\emph{PannerShell}}}

panner\_shell()


\subsection{Inherited from ARDOUR:IOProcessor}
\label{\detokenize{index:inherited-from-ardour-ioprocessor}}
Methods

{\hyperref[\detokenize{index:ARDOUR:IO}]{\emph{IO}}}

input()

{\hyperref[\detokenize{index:ARDOUR:ChanCount}]{\emph{ChanCount}}}

natural\_input\_streams()

{\hyperref[\detokenize{index:ARDOUR:ChanCount}]{\emph{ChanCount}}}

natural\_output\_streams()

{\hyperref[\detokenize{index:ARDOUR:IO}]{\emph{IO}}}

output()


\subsection{Inherited from ARDOUR:Processor}
\label{\detokenize{index:inherited-from-ardourprocessor-1}}\label{\detokenize{index:id123}}
Methods

void

activate()

bool

active()

void

deactivate()

std::string

display\_name()

bool

display\_to\_user()

{\hyperref[\detokenize{index:ARDOUR:ChanCount}]{\emph{ChanCount}}}

input\_streams()

{\hyperref[\detokenize{index:ARDOUR:ChanCount}]{\emph{ChanCount}}}

output\_streams()

Cast

{\hyperref[\detokenize{index:ARDOUR:Amp}]{\emph{Amp}}}

to\_amp()

{\hyperref[\detokenize{index:ARDOUR:Automatable}]{\emph{Automatable}}}

to\_automatable()

{\hyperref[\detokenize{index:ARDOUR:PluginInsert}]{\emph{PluginInsert}}}

to\_insert()

{\hyperref[\detokenize{index:ARDOUR:IOProcessor}]{\emph{IOProcessor}}}

to\_ioprocessor()

{\hyperref[\detokenize{index:ARDOUR:PeakMeter}]{\emph{PeakMeter}}}

to\_meter()

{\hyperref[\detokenize{index:ARDOUR:MonitorProcessor}]{\emph{MonitorProcessor}}}

to\_monitorprocessor()

{\hyperref[\detokenize{index:ARDOUR:PeakMeter}]{\emph{PeakMeter}}}

to\_peakmeter()

{\hyperref[\detokenize{index:ARDOUR:PluginInsert}]{\emph{PluginInsert}}}

to\_plugininsert()

{\hyperref[\detokenize{index:ARDOUR:SideChain}]{\emph{SideChain}}}

to\_sidechain()

{\hyperref[\detokenize{index:ARDOUR:UnknownProcessor}]{\emph{UnknownProcessor}}}

to\_unknownprocessor()


\subsection{Inherited from ARDOUR:SessionObjectPtr}
\label{\detokenize{index:inherited-from-ardoursessionobjectptr-5}}\label{\detokenize{index:id124}}
Methods

std::string

name()

Cast

{\hyperref[\detokenize{index:PBD:Stateful}]{\emph{Stateful}}}

to\_stateful()

{\hyperref[\detokenize{index:PBD:StatefulDestructible}]{\emph{StatefulDestructible}}}

to\_statefuldestructible()


\section{∁ ARDOUR:DeviceStatus}
\label{\detokenize{index:ardour-devicestatus}}\label{\detokenize{index:id125}}
\sphinxstyleemphasis{C‡}: ARDOUR::AudioBackend::DeviceStatus







used to list device names along with whether or not they are currently
available.



Data Members

bool

available

std::string

name


\section{∁ ARDOUR:DeviceStatusVector}
\label{\detokenize{index:ardour-devicestatusvector}}\label{\detokenize{index:id126}}
\sphinxstyleemphasis{C‡}: std::vector\textless{}ARDOUR::AudioBackend::DeviceStatus \textgreater{}





Constructor

ℂ

ARDOUR.DeviceStatusVector()

ℂ

ARDOUR.DeviceStatusVector()

Methods

\sphinxstyleemphasis{LuaTable}

add(LuaTable \{{\hyperref[\detokenize{index:ARDOUR:DeviceStatus}]{\emph{DeviceStatus}}}\})

{\hyperref[\detokenize{index:ARDOUR:DeviceStatus}]{\emph{DeviceStatus}}}

at(unsigned long)

bool

empty()

\sphinxstyleemphasis{LuaIter}

iter()

void

push\_back({\hyperref[\detokenize{index:ARDOUR:DeviceStatus}]{\emph{DeviceStatus}}})

unsigned long

size()

\sphinxstyleemphasis{LuaTable}

table()


\section{∁ ARDOUR:DoubleBeatsFramesConverter}
\label{\detokenize{index:ardour-doublebeatsframesconverter}}\label{\detokenize{index:id127}}
\sphinxstyleemphasis{C‡}: ARDOUR::DoubleBeatsFramesConverter







Converter between quarter-note beats and frames. Takes distances in
quarter-note beats or frames from some origin (supplied to the
constructor in frames), and converts them to the opposite unit, taking
tempo changes into account.



Constructor

ℂ

ARDOUR.DoubleBeatsFramesConverter({\hyperref[\detokenize{index:ARDOUR:TempoMap}]{\emph{TempoMap}}},
long)

Methods

double

from(long)



Convert B time to A time (A from B)



long

to(double)



Convert A time to B time (A to B)




\section{∁ ARDOUR:EventList}
\label{\detokenize{index:ardour-eventlist}}\label{\detokenize{index:id128}}
\sphinxstyleemphasis{C‡}: std::list\textless{}Evoral::ControlEvent* \textgreater{}





Constructor

ℂ

ARDOUR.EventList()

Methods

{\hyperref[\detokenize{index:Evoral:ControlEvent}]{\emph{ControlEvent}}}

back()

bool

empty()

{\hyperref[\detokenize{index:Evoral:ControlEvent}]{\emph{ControlEvent}}}

front()

\sphinxstyleemphasis{LuaIter}

iter()

void

reverse()

unsigned long

size()

\sphinxstyleemphasis{LuaTable}

table()


\section{↠ ARDOUR:FileSource}
\label{\detokenize{index:ardour-filesource}}\label{\detokenize{index:id129}}
\sphinxstyleemphasis{C‡}: boost::shared\_ptr\textless{} ARDOUR::FileSource \textgreater{}, boost::weak\_ptr\textless{}
ARDOUR::FileSource \textgreater{}

is-a: {\hyperref[\detokenize{index:ARDOUR:Source}]{\emph{ARDOUR:Source}}}







A source associated with a file on disk somewhere



Methods

unsigned short

channel()

float

gain()

bool

isnil()

std::string

origin()

std::string

path()

std::string

take\_id()

bool

within\_session()


\subsection{Inherited from ARDOUR:Source}
\label{\detokenize{index:inherited-from-ardoursource-1}}\label{\detokenize{index:id130}}
Methods

std::string

ancestor\_name()

bool

can\_be\_analysed()

bool

destructive()

bool

empty()

bool

has\_been\_analysed()

long

length(long)

long

natural\_position()

long

timeline\_position()

long

timestamp()

int

use\_count()

bool

used()

bool

writable()

Cast

{\hyperref[\detokenize{index:ARDOUR:AudioSource}]{\emph{AudioSource}}}

to\_audiosource()

{\hyperref[\detokenize{index:ARDOUR:FileSource}]{\emph{FileSource}}}

to\_filesource()

{\hyperref[\detokenize{index:ARDOUR:MidiSource}]{\emph{MidiSource}}}

to\_midisource()


\subsection{Inherited from ARDOUR:SessionObjectPtr}
\label{\detokenize{index:inherited-from-ardoursessionobjectptr-6}}\label{\detokenize{index:id131}}
Methods

std::string

name()

Cast

{\hyperref[\detokenize{index:PBD:Stateful}]{\emph{Stateful}}}

to\_stateful()

{\hyperref[\detokenize{index:PBD:StatefulDestructible}]{\emph{StatefulDestructible}}}

to\_statefuldestructible()


\section{∁ ARDOUR:FluidSynth}
\label{\detokenize{index:ardour-fluidsynth}}\label{\detokenize{index:id132}}
\sphinxstyleemphasis{C‡}: ARDOUR::FluidSynth





Constructor

ℂ

ARDOUR.FluidSynth(float, int)



instantiate a Synth
\begin{description}
\item[{samplerate}] \leavevmode
samplerate

\end{description}



Methods

bool

load\_sf2(std::string)

bool

midi\_event(unsigned char*, unsigned long)

void

panic()

unsigned int

program\_count()

std::string

program\_name(unsigned int)

bool

select\_program(unsigned int, unsigned char)

bool

synth({\hyperref[\detokenize{index:C:FloatArray}]{\emph{FloatArray}}},{\hyperref[\detokenize{index:C:FloatArray}]{\emph{FloatArray}}},
unsigned int)


\section{↠ ARDOUR:GainControl}
\label{\detokenize{index:ardour-gaincontrol}}\label{\detokenize{index:id133}}
\sphinxstyleemphasis{C‡}: boost::shared\_ptr\textless{} ARDOUR::GainControl \textgreater{}, boost::weak\_ptr\textless{}
ARDOUR::GainControl \textgreater{}

is-a:
{\hyperref[\detokenize{index:ARDOUR:SlavableAutomationControl}]{\emph{ARDOUR:SlavableAutomationControl}}}







A PBD::Controllable with associated automation data (AutomationList)



Methods

bool

isnil()


\subsection{Inherited from ARDOUR:SlavableAutomationControl}
\label{\detokenize{index:inherited-from-ardour-slavableautomationcontrol}}
Methods

void

add\_master({\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}})

void

clear\_masters()

int

get\_boolean\_masters()

double

get\_masters\_value()

void

remove\_master({\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}})

bool

slaved()

bool

slaved\_to({\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}})


\subsection{Inherited from ARDOUR:AutomationControl}
\label{\detokenize{index:inherited-from-ardour-automationcontrol}}
Methods

{\hyperref[\detokenize{index:ARDOUR:AutomationList}]{\emph{AutomationList}}}

alist()

{\hyperref[\detokenize{index:ARDOUR.AutoState}]{\emph{AutoState}}}

automation\_state()

double

get\_value()



Get the current effective {}`user’ value based on automation state



void

set\_automation\_state({\hyperref[\detokenize{index:ARDOUR.AutoState}]{\emph{AutoState}}})

void

set\_value(double,{\hyperref[\detokenize{index:PBD.Controllable.GroupControlDisposition}]{\emph{GroupControlDisposition}}})



Get and Set {}`internal’ value

All derived classes must implement this.

Basic derived classes will ignore
\begin{description}
\item[{group\_override,}] \leavevmode
but more sophisticated children, notably those that proxy the value
setting logic via an object that is aware of group relationships
between this control and others, will find it useful.

\end{description}



void

start\_touch(double)

void

stop\_touch(double)

bool

writable()

Cast

{\hyperref[\detokenize{index:Evoral:Control}]{\emph{Control}}}

to\_ctrl()

{\hyperref[\detokenize{index:ARDOUR:SlavableAutomationControl}]{\emph{SlavableAutomationControl}}}

to\_slavable()


\subsection{Inherited from PBD:Controllable}
\label{\detokenize{index:inherited-from-pbdcontrollable-1}}\label{\detokenize{index:id134}}
Methods

std::string

name()


\subsection{Inherited from PBD:StatefulPtr}
\label{\detokenize{index:inherited-from-pbdstatefulptr-1}}\label{\detokenize{index:id135}}
Methods

void

clear\_changes()



Forget about any changes to this object’s properties



{\hyperref[\detokenize{index:PBD:ID}]{\emph{ID}}}

id()

{\hyperref[\detokenize{index:ARDOUR:OwnedPropertyList}]{\emph{OwnedPropertyList}}}

properties()


\section{↠ ARDOUR:IO}
\label{\detokenize{index:ardour-io}}\label{\detokenize{index:id136}}
\sphinxstyleemphasis{C‡}: boost::shared\_ptr\textless{} ARDOUR::IO \textgreater{}, boost::weak\_ptr\textless{} ARDOUR::IO \textgreater{}

is-a: {\hyperref[\detokenize{index:ARDOUR:SessionObjectPtr}]{\emph{ARDOUR:SessionObjectPtr}}}







A collection of ports (all input or all output) with connections.

An IO can contain ports of varying types, making routes/inserts/etc with
varied combinations of types (e.g. MIDI and audio) possible.



Methods

bool

active()

int

add\_port(std::string, void*,{\hyperref[\detokenize{index:ARDOUR:DataType}]{\emph{DataType}}})



Add a port.
\begin{description}
\item[{destination}] \leavevmode
Name of port to connect new port to.

\item[{src}] \leavevmode
Source for emitted ConfigurationChanged signal.

\item[{type}] \leavevmode
Data type of port. Default value (NIL) will use this IO’s default
type.

\end{description}



{\hyperref[\detokenize{index:ARDOUR:AudioPort}]{\emph{AudioPort}}}

audio(unsigned int)

int

connect({\hyperref[\detokenize{index:ARDOUR:Port}]{\emph{Port}}}, std::string, void*)

int

disconnect({\hyperref[\detokenize{index:ARDOUR:Port}]{\emph{Port}}}, std::string, void*)

int

disconnect\_all(void*)

bool

has\_port({\hyperref[\detokenize{index:ARDOUR:Port}]{\emph{Port}}})

bool

isnil()

{\hyperref[\detokenize{index:ARDOUR:MidiPort}]{\emph{MidiPort}}}

midi(unsigned int)

{\hyperref[\detokenize{index:ARDOUR:ChanCount}]{\emph{ChanCount}}}

n\_ports()

{\hyperref[\detokenize{index:ARDOUR:Port}]{\emph{Port}}}

nth(unsigned int)

bool

physically\_connected()

{\hyperref[\detokenize{index:ARDOUR:Port}]{\emph{Port}}}

port\_by\_name(unsigned int)

int

remove\_port({\hyperref[\detokenize{index:ARDOUR:Port}]{\emph{Port}}}, void*)


\subsection{Inherited from ARDOUR:SessionObjectPtr}
\label{\detokenize{index:inherited-from-ardoursessionobjectptr-7}}\label{\detokenize{index:id137}}
Methods

std::string

name()

Cast

{\hyperref[\detokenize{index:PBD:Stateful}]{\emph{Stateful}}}

to\_stateful()

{\hyperref[\detokenize{index:PBD:StatefulDestructible}]{\emph{StatefulDestructible}}}

to\_statefuldestructible()


\section{↠ ARDOUR:IOProcessor}
\label{\detokenize{index:ardour-ioprocessor}}\label{\detokenize{index:id138}}
\sphinxstyleemphasis{C‡}: boost::shared\_ptr\textless{} ARDOUR::IOProcessor \textgreater{}, boost::weak\_ptr\textless{}
ARDOUR::IOProcessor \textgreater{}

is-a: {\hyperref[\detokenize{index:ARDOUR:Processor}]{\emph{ARDOUR:Processor}}}







A mixer strip element (Processor) with 1 or 2 IO elements.



Methods

{\hyperref[\detokenize{index:ARDOUR:IO}]{\emph{IO}}}

input()

bool

isnil()

{\hyperref[\detokenize{index:ARDOUR:ChanCount}]{\emph{ChanCount}}}

natural\_input\_streams()

{\hyperref[\detokenize{index:ARDOUR:ChanCount}]{\emph{ChanCount}}}

natural\_output\_streams()

{\hyperref[\detokenize{index:ARDOUR:IO}]{\emph{IO}}}

output()


\subsection{Inherited from ARDOUR:Processor}
\label{\detokenize{index:inherited-from-ardourprocessor-2}}\label{\detokenize{index:id139}}
Methods

void

activate()

bool

active()

void

deactivate()

std::string

display\_name()

bool

display\_to\_user()

{\hyperref[\detokenize{index:ARDOUR:ChanCount}]{\emph{ChanCount}}}

input\_streams()

{\hyperref[\detokenize{index:ARDOUR:ChanCount}]{\emph{ChanCount}}}

output\_streams()

Cast

{\hyperref[\detokenize{index:ARDOUR:Amp}]{\emph{Amp}}}

to\_amp()

{\hyperref[\detokenize{index:ARDOUR:Automatable}]{\emph{Automatable}}}

to\_automatable()

{\hyperref[\detokenize{index:ARDOUR:PluginInsert}]{\emph{PluginInsert}}}

to\_insert()

{\hyperref[\detokenize{index:ARDOUR:IOProcessor}]{\emph{IOProcessor}}}

to\_ioprocessor()

{\hyperref[\detokenize{index:ARDOUR:PeakMeter}]{\emph{PeakMeter}}}

to\_meter()

{\hyperref[\detokenize{index:ARDOUR:MonitorProcessor}]{\emph{MonitorProcessor}}}

to\_monitorprocessor()

{\hyperref[\detokenize{index:ARDOUR:PeakMeter}]{\emph{PeakMeter}}}

to\_peakmeter()

{\hyperref[\detokenize{index:ARDOUR:PluginInsert}]{\emph{PluginInsert}}}

to\_plugininsert()

{\hyperref[\detokenize{index:ARDOUR:SideChain}]{\emph{SideChain}}}

to\_sidechain()

{\hyperref[\detokenize{index:ARDOUR:UnknownProcessor}]{\emph{UnknownProcessor}}}

to\_unknownprocessor()


\subsection{Inherited from ARDOUR:SessionObjectPtr}
\label{\detokenize{index:inherited-from-ardoursessionobjectptr-8}}\label{\detokenize{index:id140}}
Methods

std::string

name()

Cast

{\hyperref[\detokenize{index:PBD:Stateful}]{\emph{Stateful}}}

to\_stateful()

{\hyperref[\detokenize{index:PBD:StatefulDestructible}]{\emph{StatefulDestructible}}}

to\_statefuldestructible()


\section{∁ ARDOUR:InterThreadInfo}
\label{\detokenize{index:ardour-interthreadinfo}}\label{\detokenize{index:id141}}
\sphinxstyleemphasis{C‡}: ARDOUR::InterThreadInfo





Constructor

ℂ

ARDOUR.InterThreadInfo()

Data Members

bool

done

float

progress


\section{∁ ARDOUR:Location}
\label{\detokenize{index:ardour-location}}\label{\detokenize{index:id142}}
\sphinxstyleemphasis{C‡}: ARDOUR::Location

is-a: {\hyperref[\detokenize{index:PBD:StatefulDestructible}]{\emph{PBD:StatefulDestructible}}}







Location on Timeline - abstract representation for Markers, Loop/Punch
Ranges, CD-Markers etc.



Methods

long

end()

{\hyperref[\detokenize{index:ARDOUR.Location.Flags}]{\emph{Flags}}}

flags()

bool

is\_auto\_loop()

bool

is\_auto\_punch()

bool

is\_cd\_marker()

bool

is\_hidden()

bool

is\_mark()

bool

is\_range\_marker()

bool

is\_session\_range()

long

length()

void

lock()

bool

locked()

bool

matches({\hyperref[\detokenize{index:ARDOUR.Location.Flags}]{\emph{Flags}}})

int

move\_to(long, unsigned int)

std::string

name()

int

set\_end(long, bool, bool, unsigned int)



Set end position.
\begin{description}
\item[{force}] \leavevmode
true to force setting, even if the given new end is before the
current start.

\item[{allow\_beat\_recompute}] \leavevmode
True to recompute BEAT end time from the new given end time.

\item[{s}] \leavevmode
New end.

\end{description}



int

set\_length(long, long, bool, unsigned int)

int

set\_start(long, bool, bool, unsigned int)



Set start position.
\begin{description}
\item[{s}] \leavevmode
New start.

\item[{force}] \leavevmode
true to force setting, even if the given new start is after the
current end.

\item[{allow\_beat\_recompute}] \leavevmode
True to recompute BEAT start time from the new given start time.

\end{description}



long

start()

void

unlock()


\subsection{Inherited from PBD:Stateful}
\label{\detokenize{index:inherited-from-pbd-stateful}}
Methods

void

clear\_changes()



Forget about any changes to this object’s properties



{\hyperref[\detokenize{index:PBD:ID}]{\emph{ID}}}

id()

{\hyperref[\detokenize{index:ARDOUR:OwnedPropertyList}]{\emph{OwnedPropertyList}}}

properties()


\section{∁ ARDOUR:LocationList}
\label{\detokenize{index:ardour-locationlist}}\label{\detokenize{index:id143}}
\sphinxstyleemphasis{C‡}: std::list\textless{}ARDOUR::Location* \textgreater{}





Constructor

ℂ

ARDOUR.LocationList()

Methods

{\hyperref[\detokenize{index:ARDOUR:Location}]{\emph{Location}}}

back()

bool

empty()

{\hyperref[\detokenize{index:ARDOUR:Location}]{\emph{Location}}}

front()

\sphinxstyleemphasis{LuaIter}

iter()

void

reverse()

unsigned long

size()

\sphinxstyleemphasis{LuaTable}

table()


\section{∁ ARDOUR:Locations}
\label{\detokenize{index:ardour-locations}}\label{\detokenize{index:id144}}
\sphinxstyleemphasis{C‡}: ARDOUR::Locations

is-a: {\hyperref[\detokenize{index:PBD:StatefulDestructible}]{\emph{PBD:StatefulDestructible}}}







A collection of session locations including unique dedicated locations
(loop, punch, etc)



Methods

{\hyperref[\detokenize{index:ARDOUR:Location}]{\emph{Location}}}

auto\_loop\_location()

{\hyperref[\detokenize{index:ARDOUR:Location}]{\emph{Location}}}

auto\_punch\_location()

\sphinxstyleemphasis{LuaTable}(…)

find\_all\_between(long,
long,{\hyperref[\detokenize{index:ARDOUR:LocationList}]{\emph{LocationList\&}}},{\hyperref[\detokenize{index:ARDOUR.Location.Flags}]{\emph{Flags}}})

long

first\_mark\_after(long, bool)

{\hyperref[\detokenize{index:ARDOUR:Location}]{\emph{Location}}}

first\_mark\_at(long, long)

long

first\_mark\_before(long, bool)

{\hyperref[\detokenize{index:ARDOUR:LocationList}]{\emph{LocationList}}}

list()

\sphinxstyleemphasis{LuaTable}(…)

marks\_either\_side(long, long\&, long\&)



Look for the {}`marks’ (either locations which are marks, or start/end
points of range markers) either side of a frame. Note that if frame is
exactly on a {}`mark’, that mark will not be considered for returning as
before/after.
\begin{description}
\item[{frame}] \leavevmode
Frame to look for.

\item[{before}] \leavevmode
Filled in with the position of the last {}`mark’ before {}`frame’ (or
max\_framepos if none exists)

\item[{after}] \leavevmode
Filled in with the position of the next {}`mark’ after {}`frame’ (or
max\_framepos if none exists)

\end{description}



void

remove({\hyperref[\detokenize{index:ARDOUR:Location}]{\emph{Location}}})

{\hyperref[\detokenize{index:ARDOUR:Location}]{\emph{Location}}}

session\_range\_location()


\subsection{Inherited from PBD:Stateful}
\label{\detokenize{index:inherited-from-pbdstateful-1}}\label{\detokenize{index:id145}}
Methods

void

clear\_changes()



Forget about any changes to this object’s properties



{\hyperref[\detokenize{index:PBD:ID}]{\emph{ID}}}

id()

{\hyperref[\detokenize{index:ARDOUR:OwnedPropertyList}]{\emph{OwnedPropertyList}}}

properties()


\section{ℕ ARDOUR.LuaAPI}
\label{\detokenize{index:ardour-luaapi}}\label{\detokenize{index:id146}}




Methods

…

build\_filename(\textendash{}lua\textendash{})



Creates a filename from a series of elements using the correct separator
for filenames.

No attempt is made to force the resulting filename to be an absolute
path. If the first element is a relative path, the result will be a
relative path.



…

color\_to\_rgba(\textendash{}lua\textendash{})



A convenience function to expand RGBA parameters from an integer

convert a Canvas::Color (uint32\_t 0xRRGGBBAA) into double RGBA values
which can be passed as parameters to Cairo::Context::set\_source\_rgba

Example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{local} \PYG{n}{r}\PYG{p}{,} \PYG{n}{g}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{a} \PYG{o}{=} \PYG{n}{ARDOUR}\PYG{o}{.}\PYG{n}{LuaAPI}\PYG{o}{.}\PYG{n}{color\PYGZus{}to\PYGZus{}rgba} \PYG{p}{(}\PYG{l+m+mh}{0x88aa44ff}\PYG{p}{)}
\PYG{n}{cairo\PYGZus{}ctx}\PYG{p}{:}\PYG{n}{set\PYGZus{}source\PYGZus{}rgba} \PYG{p}{(}\PYG{n}{ARDOUR}\PYG{o}{.}\PYG{n}{LuaAPI}\PYG{o}{.}\PYG{n}{color\PYGZus{}to\PYGZus{}rgba} \PYG{p}{(}\PYG{l+m+mh}{0x11336699}\PYG{p}{)}
\end{sphinxVerbatim}



Returns 4 parameters: red, green, blue, alpha (in range 0..1)





\sphinxstyleemphasis{LuaTable}(float, …)

get\_plugin\_insert\_param({\hyperref[\detokenize{index:ARDOUR:PluginInsert}]{\emph{PluginInsert}}},
unsigned int, bool\&)



get a plugin control parameter value
\begin{description}
\item[{which}] \leavevmode
control port to query (starting at 0, including ports of type input
and output)

\item[{ok}] \leavevmode
boolean variable contains true or false after call returned. to be
checked by caller before using value.

\item[{proc}] \leavevmode
Plugin-Insert

\end{description}



Returns value





\sphinxstyleemphasis{LuaTable}(float, …)

get\_processor\_param({\hyperref[\detokenize{index:ARDOUR:Processor}]{\emph{Processor}}}, unsigned int,
bool\&)



get a plugin control parameter value
\begin{description}
\item[{proc}] \leavevmode
Plugin-Processor

\item[{which}] \leavevmode
control port to set (starting at 0, including ports of type input and
output))

\item[{ok}] \leavevmode
boolean variable contains true or false after call returned. to be
checked by caller before using value.

\end{description}



Returns value





…

hsla\_to\_rgba(\textendash{}lua\textendash{})



A convenience function for colorspace HSL to RGB conversion. All ranges
are 0..1

Example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{local} \PYG{n}{r}\PYG{p}{,} \PYG{n}{g}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{a} \PYG{o}{=} \PYG{n}{ARDOUR}\PYG{o}{.}\PYG{n}{LuaAPI}\PYG{o}{.}\PYG{n}{hsla\PYGZus{}to\PYGZus{}rgba} \PYG{p}{(}\PYG{n}{hue}\PYG{p}{,} \PYG{n}{saturation}\PYG{p}{,} \PYG{n}{luminosity}\PYG{p}{,} \PYG{n}{alpha}\PYG{p}{)}
\end{sphinxVerbatim}



Returns 4 parameters: red, green, blue, alpha (in range 0..1)





long

monotonic\_time()

{\hyperref[\detokenize{index:ARDOUR:Processor}]{\emph{Processor}}}

new\_luaproc({\hyperref[\detokenize{index:ARDOUR:Session}]{\emph{Session}}}, std::string)



create a new Lua Processor (Plugin)
\begin{description}
\item[{s}] \leavevmode
Session Handle

\item[{p}] \leavevmode
Identifier or Name of the Processor

\end{description}



Returns Processor object (may be nil)





{\hyperref[\detokenize{index:Evoral:NotePtr}]{\emph{NotePtr}}}

new\_noteptr(unsigned
char,{\hyperref[\detokenize{index:Evoral:Beats}]{\emph{Beats}}},{\hyperref[\detokenize{index:Evoral:Beats}]{\emph{Beats}}},
unsigned char, unsigned char)

{\hyperref[\detokenize{index:ARDOUR:Processor}]{\emph{Processor}}}

new\_plugin({\hyperref[\detokenize{index:ARDOUR:Session}]{\emph{Session}}},
std::string,{\hyperref[\detokenize{index:ARDOUR.PluginType}]{\emph{PluginType}}}, std::string)



create a new Plugin Instance
\begin{description}
\item[{s}] \leavevmode
Session Handle

\item[{id}] \leavevmode
Plugin Name, ID or URI

\item[{type}] \leavevmode
Plugin Type

\end{description}



Returns Processor or nil





{\hyperref[\detokenize{index:ARDOUR:PluginInfo}]{\emph{PluginInfo}}}

new\_plugin\_info(std::string,{\hyperref[\detokenize{index:ARDOUR.PluginType}]{\emph{PluginType}}})



search a Plugin
\begin{description}
\item[{id}] \leavevmode
Plugin Name, ID or URI

\item[{type}] \leavevmode
Plugin Type

\end{description}



Returns PluginInfo or nil if not found





{\hyperref[\detokenize{index:ARDOUR:Processor}]{\emph{Processor}}}

nil\_proc()

{\hyperref[\detokenize{index:ARDOUR:NotePtrList}]{\emph{NotePtrList}}}

note\_list({\hyperref[\detokenize{index:ARDOUR:MidiModel}]{\emph{MidiModel}}})

…

plugin\_automation(\textendash{}lua\textendash{})



A convenience function to get a Automation Lists and ParamaterDescriptor
for a given plugin control.

This is equivalent to the following lua code

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{function} \PYG{p}{(}\PYG{n}{processor}\PYG{p}{,} \PYG{n}{param\PYGZus{}id}\PYG{p}{)}
 \PYG{n}{local} \PYG{n}{plugininsert} \PYG{o}{=} \PYG{n}{processor}\PYG{p}{:}\PYG{n}{to\PYGZus{}insert} \PYG{p}{(}\PYG{p}{)}
 \PYG{n}{local} \PYG{n}{plugin} \PYG{o}{=} \PYG{n}{plugininsert}\PYG{p}{:}\PYG{n}{plugin}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
 \PYG{n}{local} \PYG{n}{\PYGZus{}}\PYG{p}{,} \PYG{n}{t} \PYG{o}{=} \PYG{n}{plugin}\PYG{p}{:}\PYG{n}{get\PYGZus{}parameter\PYGZus{}descriptor}\PYG{p}{(}\PYG{n}{param\PYGZus{}id}\PYG{p}{,} \PYG{n}{ARDOUR}\PYG{o}{.}\PYG{n}{ParameterDescriptor} \PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
 \PYG{n}{local} \PYG{n}{ctrl} \PYG{o}{=} \PYG{n}{Evoral}\PYG{o}{.}\PYG{n}{Parameter} \PYG{p}{(}\PYG{n}{ARDOUR}\PYG{o}{.}\PYG{n}{AutomationType}\PYG{o}{.}\PYG{n}{PluginAutomation}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{param\PYGZus{}id}\PYG{p}{)}
 \PYG{n}{local} \PYG{n}{ac} \PYG{o}{=} \PYG{n}{pi}\PYG{p}{:}\PYG{n}{automation\PYGZus{}control} \PYG{p}{(}\PYG{n}{ctrl}\PYG{p}{,} \PYG{n}{false}\PYG{p}{)}
 \PYG{n}{local} \PYG{n}{acl} \PYG{o}{=} \PYG{n}{ac}\PYG{p}{:}\PYG{n}{alist}\PYG{p}{(}\PYG{p}{)}
 \PYG{k}{return} \PYG{n}{ac}\PYG{p}{:}\PYG{n}{alist}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{ac}\PYG{p}{:}\PYG{n}{to\PYGZus{}ctrl}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}\PYG{n+nb}{list}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{t}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}
\PYG{n}{end}
\end{sphinxVerbatim}

Example usage: get the third input parameter of first plugin on the
given route (Ardour starts counting at zero).

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{local} \PYG{n}{al}\PYG{p}{,} \PYG{n}{cl}\PYG{p}{,} \PYG{n}{pd} \PYG{o}{=} \PYG{n}{ARDOUR}\PYG{o}{.}\PYG{n}{LuaAPI}\PYG{o}{.}\PYG{n}{plugin\PYGZus{}automation} \PYG{p}{(}\PYG{n}{route}\PYG{p}{:}\PYG{n}{nth\PYGZus{}plugin} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}
\end{sphinxVerbatim}



Returns 3 parameters: AutomationList, ControlList, ParamaterDescriptor





bool

reset\_processor\_to\_default({\hyperref[\detokenize{index:ARDOUR:Processor}]{\emph{Processor}}})



reset a processor to its default values (only works for plugins )

This is a wrapper which looks up the Processor by plugin-insert.
\begin{description}
\item[{proc}] \leavevmode
Plugin-Insert

\end{description}



Returns true on success, false when the processor is not a plugin





…

sample\_to\_timecode(\textendash{}lua\textendash{})



Generic conversion from audio sample count to timecode. (TimecodeType,
sample-rate, sample-pos)



bool

set\_plugin\_insert\_param({\hyperref[\detokenize{index:ARDOUR:PluginInsert}]{\emph{PluginInsert}}},
unsigned int, float)



set a plugin control-input parameter value

This is a wrapper around set\_processor\_param which looks up the
Processor by plugin-insert.
\begin{description}
\item[{which}] \leavevmode
control-input to set (starting at 0)

\item[{proc}] \leavevmode
Plugin-Insert

\item[{value}] \leavevmode
value to set

\end{description}



Returns true on success, false on error or out-of-bounds value





bool

set\_processor\_param({\hyperref[\detokenize{index:ARDOUR:Processor}]{\emph{Processor}}}, unsigned int,
float)



set a plugin control-input parameter value
\begin{description}
\item[{proc}] \leavevmode
Plugin-Processor

\item[{which}] \leavevmode
control-input to set (starting at 0)

\item[{value}] \leavevmode
value to set

\end{description}



Returns true on success, false on error or out-of-bounds value





…

timecode\_to\_sample(\textendash{}lua\textendash{})



Generic conversion from timecode to audio sample count. (TimecodeType,
sample-rate, hh, mm, ss, ff)



void

usleep(unsigned long)


\section{∁ ARDOUR:LuaAPI:Vamp}
\label{\detokenize{index:ardour-luaapi-vamp}}\label{\detokenize{index:id147}}
\sphinxstyleemphasis{C‡}: ARDOUR::LuaAPI::Vamp





Constructor

ℂ

ARDOUR.LuaAPI.Vamp(std::string, float)

Methods

int

analyze({\hyperref[\detokenize{index:ARDOUR:Readable}]{\emph{Readable}}}, unsigned int, Lua-Function)



high-level abstraction to process a single channel of the given
Readable.

If the plugin is not yet initialized, initialize() is called.

if is not nil, it is called with the immediate Vamp::Plugin::Features on
every process call.
\begin{description}
\item[{r}] \leavevmode
readable

\item[{channel}] \leavevmode
channel to process

\item[{fn}] \leavevmode
lua callback function

\end{description}



Returns 0 on success





bool

initialize()



initialize the plugin for use with analyze().

This is equivalent to plugin():initialise (1, ssiz, bsiz) and prepares a
plugin for analyze. (by preferred step and block sizes are used. if the
plugin does not specify them or they’re larger than 8K, both are set to
1024)

Manual initialization is only required to set plugin-parameters which
depend on prior initialization of the plugin.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{vamp}\PYG{p}{:}\PYG{n}{reset} \PYG{p}{(}\PYG{p}{)}
\PYG{n}{vamp}\PYG{p}{:}\PYG{n}{initialize} \PYG{p}{(}\PYG{p}{)}
\PYG{n}{vamp}\PYG{p}{:}\PYG{n}{plugin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}\PYG{n}{setParameter} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{1.5}\PYG{p}{,} \PYG{n}{nil}\PYG{p}{)}
\PYG{n}{vamp}\PYG{p}{:}\PYG{n}{analyze} \PYG{p}{(}\PYG{n}{r}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}
\end{sphinxVerbatim}



{\hyperref[\detokenize{index:C:StringVector}]{\emph{StringVector}}}

list\_plugins()

{\hyperref[\detokenize{index:Vamp:Plugin}]{\emph{Plugin}}}

plugin()

{\hyperref[\detokenize{index:Vamp:Plugin:FeatureSet}]{\emph{FeatureSet}}}

process({\hyperref[\detokenize{index:C:FloatArrayVector}]{\emph{FloatArrayVector}}},{\hyperref[\detokenize{index:Vamp:RealTime}]{\emph{RealTime}}})



process given array of audio-samples.

This is a lua-binding for vamp:plugin():process ()
\begin{description}
\item[{d}] \leavevmode
audio-data, the vector must match the configured channel count and
hold a complete buffer for every channel as set during
plugin():initialise()

\item[{rt}] \leavevmode
timestamp matching the provided buffer.

\end{description}



Returns features extracted from that data (if the plugin is causal)





void

reset()



call plugin():reset() and clear intialization flag




\section{∁ ARDOUR:LuaOSC:Address}
\label{\detokenize{index:ardour-luaosc-address}}\label{\detokenize{index:id148}}
\sphinxstyleemphasis{C‡}: ARDOUR::LuaOSC::Address







OSC transmitter

A Class to send OSC messages.



Constructor

ℂ

ARDOUR.LuaOSC.Address(std::string)



Construct a new OSC transmitter object
\begin{description}
\item[{uri}] \leavevmode
the destination uri e.g. “osc.udp://localhost:7890”

\end{description}



Methods

\sphinxstyleemphasis{…}

send(\textendash{}lua\textendash{})



Transmit an OSC message

Path (string) and type (string) must always be given. The number of
following args must match the type. Supported types are:

‘i’: integer (lua number)

‘f’: float (lua number)

‘d’: double (lua number)

‘h’: 64bit integer (lua number)

‘s’: string (lua string)

‘c’: character (lua string)

‘T’: boolean (lua bool) \textendash{} this is not implicily True, a lua true/false
must be given

‘F’: boolean (lua bool) \textendash{} this is not implicily False, a lua true/false
must be given
\begin{description}
\item[{lua:}] \leavevmode
lua arguments: path, types, …

\end{description}



Returns boolean true if successful, false on error.






\section{↠ ARDOUR:LuaProc}
\label{\detokenize{index:ardour-luaproc}}\label{\detokenize{index:id149}}
\sphinxstyleemphasis{C‡}: boost::shared\_ptr\textless{} ARDOUR::LuaProc \textgreater{}, boost::weak\_ptr\textless{}
ARDOUR::LuaProc \textgreater{}

is-a: {\hyperref[\detokenize{index:ARDOUR:Plugin}]{\emph{ARDOUR:Plugin}}}







A plugin is an external module (usually 3rd party provided) loaded into
Ardour for the purpose of digital signal processing.

This class provides an abstraction for methords provided by all
supported plugin standards such as presets, name, parameters etc.

Plugins are not used directly in Ardour but always wrapped by a
PluginInsert.



Methods

bool

isnil()

{\hyperref[\detokenize{index:ARDOUR:DSP:DspShm}]{\emph{DspShm}}}

shmem()

{\hyperref[\detokenize{index:ARDOUR:LuaTableRef}]{\emph{LuaTableRef}}}

table()


\subsection{Inherited from ARDOUR:Plugin}
\label{\detokenize{index:inherited-from-ardour-plugin}}
Methods

{\hyperref[\detokenize{index:ARDOUR:Plugin:IOPortDescription}]{\emph{IOPortDescription}}}

describe\_io\_port({\hyperref[\detokenize{index:ARDOUR:DataType}]{\emph{DataType}}}, bool, unsigned
int)

std::string

get\_docs()

{\hyperref[\detokenize{index:ARDOUR:PluginInfo}]{\emph{PluginInfo}}}

get\_info()

\sphinxstyleemphasis{LuaTable}(int, …)

get\_parameter\_descriptor(unsigned
int,{\hyperref[\detokenize{index:ARDOUR:ParameterDescriptor}]{\emph{ParameterDescriptor\&}}})

std::string

get\_parameter\_docs(unsigned int)

char*

label()

bool

load\_preset({\hyperref[\detokenize{index:ARDOUR:PresetRecord}]{\emph{PresetRecord}}})



Set parameters using a preset



char*

maker()

char*

name()

\sphinxstyleemphasis{LuaTable}(unsigned int, …)

nth\_parameter(unsigned int, bool\&)

unsigned int

parameter\_count()

bool

parameter\_is\_audio(unsigned int)

bool

parameter\_is\_control(unsigned int)

bool

parameter\_is\_input(unsigned int)

bool

parameter\_is\_output(unsigned int)

std::string

parameter\_label(unsigned int)

{\hyperref[\detokenize{index:ARDOUR:PresetRecord}]{\emph{PresetRecord}}}

preset\_by\_label(std::string)

{\hyperref[\detokenize{index:ARDOUR:PresetRecord}]{\emph{PresetRecord}}}

preset\_by\_uri(std::string)

std::string

unique\_id()

Cast

{\hyperref[\detokenize{index:ARDOUR:LuaProc}]{\emph{LuaProc}}}

to\_luaproc()


\subsection{Inherited from PBD:StatefulPtr}
\label{\detokenize{index:inherited-from-pbdstatefulptr-2}}\label{\detokenize{index:id150}}
Methods

void

clear\_changes()



Forget about any changes to this object’s properties



{\hyperref[\detokenize{index:PBD:ID}]{\emph{ID}}}

id()

{\hyperref[\detokenize{index:ARDOUR:OwnedPropertyList}]{\emph{OwnedPropertyList}}}

properties()


\section{∁ ARDOUR:LuaTableRef}
\label{\detokenize{index:ardour-luatableref}}\label{\detokenize{index:id151}}
\sphinxstyleemphasis{C‡}: ARDOUR::LuaTableRef





Methods

\sphinxstyleemphasis{…}

get(\textendash{}lua\textendash{})

\sphinxstyleemphasis{…}

set(\textendash{}lua\textendash{})


\section{∁ ARDOUR:Meter}
\label{\detokenize{index:ardour-meter}}\label{\detokenize{index:id152}}
\sphinxstyleemphasis{C‡}: ARDOUR::Meter







Meter, or time signature (beats per bar, and which note type is a beat).



Constructor

ℂ

ARDOUR.Meter(double, double)

Methods

double

divisions\_per\_bar()

double

frames\_per\_bar({\hyperref[\detokenize{index:ARDOUR:Tempo}]{\emph{Tempo}}}, long)

double

frames\_per\_grid({\hyperref[\detokenize{index:ARDOUR:Tempo}]{\emph{Tempo}}}, long)

double

note\_divisor()


\section{∁ ARDOUR:MeterSection}
\label{\detokenize{index:ardour-metersection}}\label{\detokenize{index:id153}}
\sphinxstyleemphasis{C‡}: ARDOUR::MeterSection

is-a: {\hyperref[\detokenize{index:ARDOUR:MetricSection}]{\emph{ARDOUR:MetricSection}}}







A section of timeline with a certain Meter.



Methods

void

set\_beat(double)

void

set\_pulse(double)

Cast

{\hyperref[\detokenize{index:ARDOUR:Meter}]{\emph{Meter}}}

to\_meter()


\subsection{Inherited from ARDOUR:MetricSection}
\label{\detokenize{index:inherited-from-ardour-metricsection}}
Methods

double

pulse()


\section{∁ ARDOUR:MetricSection}
\label{\detokenize{index:ardour-metricsection}}\label{\detokenize{index:id154}}
\sphinxstyleemphasis{C‡}: ARDOUR::MetricSection







A section of timeline with a certain Tempo or Meter.



Methods

double

pulse()

void

set\_pulse(double)


\section{∁ ARDOUR:MidiBuffer}
\label{\detokenize{index:ardour-midibuffer}}\label{\detokenize{index:id155}}
\sphinxstyleemphasis{C‡}: ARDOUR::MidiBuffer







Buffer containing 8-bit unsigned char (MIDI) data.



Methods

void

copy({\hyperref[\detokenize{index:ARDOUR:MidiBuffer}]{\emph{MidiBuffer}}})

bool

empty()

bool

push\_back(long, unsigned long, unsigned char*)

bool

push\_event({\hyperref[\detokenize{index:Evoral:Event}]{\emph{Event}}})

void

resize(unsigned long)



Reallocate the buffer used internally to handle at least \sphinxstyleemphasis{size\_t} units
of data.

The buffer is not silent after this operation. the \sphinxstyleemphasis{capacity} argument
passed to the constructor must have been non-zero.



void

silence(long, long)



Clear (e.g. zero, or empty) buffer



unsigned long

size()

\sphinxstyleemphasis{…}

table(\textendash{}lua\textendash{})


\section{↠ ARDOUR:MidiModel}
\label{\detokenize{index:ardour-midimodel}}\label{\detokenize{index:id156}}
\sphinxstyleemphasis{C‡}: boost::shared\_ptr\textless{} ARDOUR::MidiModel \textgreater{}, boost::weak\_ptr\textless{}
ARDOUR::MidiModel \textgreater{}

is-a: {\hyperref[\detokenize{index:ARDOUR:AutomatableSequence}]{\emph{ARDOUR:AutomatableSequence}}}







This is a higher level (than MidiBuffer) model of MIDI data, with
separate representations for notes (instead of just unassociated note
on/off events) and controller data. Controller data is represented as
part of the Automatable base (i.e. in a map of AutomationList, keyed by
Parameter). Because of this MIDI controllers and automatable
controllers/widgets/etc are easily interchangeable.



Methods

void

apply\_command({\hyperref[\detokenize{index:ARDOUR:Session}]{\emph{Session}}},{\hyperref[\detokenize{index:PBD:Command}]{\emph{Command}}})

bool

isnil()

{\hyperref[\detokenize{index:ARDOUR:MidiModel:NoteDiffCommand}]{\emph{NoteDiffCommand}}}

new\_note\_diff\_command(std::string)



Start a new NoteDiff command.

This has no side-effects on the model or Session, the returned command
can be held on to for as long as the caller wishes, or discarded without
formality, until apply\_command is called and ownership is taken.




\subsection{Inherited from ARDOUR:AutomatableSequence}
\label{\detokenize{index:inherited-from-ardour-automatablesequence}}
Cast

{\hyperref[\detokenize{index:Evoral:Sequence}]{\emph{Sequence}}}

to\_sequence()


\subsection{Inherited from ARDOUR:Automatable}
\label{\detokenize{index:inherited-from-ardourautomatable-1}}\label{\detokenize{index:id157}}
Methods

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

automation\_control({\hyperref[\detokenize{index:Evoral:Parameter}]{\emph{Parameter}}}, bool)

Cast

{\hyperref[\detokenize{index:ARDOUR:Slavable}]{\emph{Slavable}}}

to\_slavable()


\section{∅ ARDOUR:MidiModel:DiffCommand}
\label{\detokenize{index:ardour-midimodel-diffcommand}}\label{\detokenize{index:id158}}
\sphinxstyleemphasis{C‡}: ARDOUR::MidiModel::DiffCommand

is-a: {\hyperref[\detokenize{index:PBD:Command}]{\emph{PBD:Command}}}







Base class for Undo/Redo commands and changesets



This class object is only used indirectly as return-value and
function-parameter. It provides no methods by itself.


\subsection{Inherited from PBD:Command}
\label{\detokenize{index:inherited-from-pbd-command}}
Methods

std::string

name()

void

set\_name(std::string)


\subsection{Inherited from PBD:Stateful}
\label{\detokenize{index:inherited-from-pbdstateful-2}}\label{\detokenize{index:id159}}
Methods

void

clear\_changes()



Forget about any changes to this object’s properties



{\hyperref[\detokenize{index:PBD:ID}]{\emph{ID}}}

id()

{\hyperref[\detokenize{index:ARDOUR:OwnedPropertyList}]{\emph{OwnedPropertyList}}}

properties()


\section{∁ ARDOUR:MidiModel:NoteDiffCommand}
\label{\detokenize{index:ardour-midimodel-notediffcommand}}\label{\detokenize{index:id160}}
\sphinxstyleemphasis{C‡}: ARDOUR::MidiModel::NoteDiffCommand

is-a: {\hyperref[\detokenize{index:ARDOUR:MidiModel:DiffCommand}]{\emph{ARDOUR:MidiModel:DiffCommand}}}







Base class for Undo/Redo commands and changesets



Methods

void

add({\hyperref[\detokenize{index:Evoral:NotePtr}]{\emph{NotePtr}}})

void

remove({\hyperref[\detokenize{index:Evoral:NotePtr}]{\emph{NotePtr}}})


\subsection{Inherited from PBD:Command}
\label{\detokenize{index:inherited-from-pbdcommand-1}}\label{\detokenize{index:id161}}
Methods

std::string

name()

void

set\_name(std::string)


\subsection{Inherited from PBD:Stateful}
\label{\detokenize{index:inherited-from-pbdstateful-3}}\label{\detokenize{index:id162}}
Methods

void

clear\_changes()



Forget about any changes to this object’s properties



{\hyperref[\detokenize{index:PBD:ID}]{\emph{ID}}}

id()

{\hyperref[\detokenize{index:ARDOUR:OwnedPropertyList}]{\emph{OwnedPropertyList}}}

properties()


\section{↠ ARDOUR:MidiPlaylist}
\label{\detokenize{index:ardour-midiplaylist}}\label{\detokenize{index:id163}}
\sphinxstyleemphasis{C‡}: boost::shared\_ptr\textless{} ARDOUR::MidiPlaylist \textgreater{}, boost::weak\_ptr\textless{}
ARDOUR::MidiPlaylist \textgreater{}

is-a: {\hyperref[\detokenize{index:ARDOUR:Playlist}]{\emph{ARDOUR:Playlist}}}







A named object associated with a Session. Objects derived from this
class are expected to be destroyed before the session calls
drop\_references().



Methods

bool

isnil()

void

set\_note\_mode({\hyperref[\detokenize{index:ARDOUR.NoteMode}]{\emph{NoteMode}}})


\subsection{Inherited from ARDOUR:Playlist}
\label{\detokenize{index:inherited-from-ardourplaylist-1}}\label{\detokenize{index:id164}}
Methods

void

add\_region({\hyperref[\detokenize{index:ARDOUR:Region}]{\emph{Region}}}, long, float, bool, int,
double, bool)



Note: this calls set\_layer (…, DBL\_MAX) so it will reset the layering
index of region



{\hyperref[\detokenize{index:ARDOUR:Region}]{\emph{Region}}}

combine({\hyperref[\detokenize{index:ARDOUR:RegionList}]{\emph{RegionList}}})

unsigned int

count\_regions\_at(long)

{\hyperref[\detokenize{index:ARDOUR:Playlist}]{\emph{Playlist}}}

cut({\hyperref[\detokenize{index:ARDOUR:AudioRangeList}]{\emph{AudioRangeList\&}}}, bool)

{\hyperref[\detokenize{index:ARDOUR:DataType}]{\emph{DataType}}}

data\_type()

void

duplicate({\hyperref[\detokenize{index:ARDOUR:Region}]{\emph{Region}}}, long, long, float)


\begin{description}
\item[{gap}] \leavevmode
from the beginning of the region to the next beginning

\end{description}



void

duplicate\_range({\hyperref[\detokenize{index:ARDOUR:AudioRange}]{\emph{AudioRange\&}}}, float)

void

duplicate\_until({\hyperref[\detokenize{index:ARDOUR:Region}]{\emph{Region}}}, long, long, long)


\begin{description}
\item[{gap}] \leavevmode
from the beginning of the region to the next beginning

\item[{end}] \leavevmode
the first frame that does \_not\_ contain a duplicated frame

\end{description}



{\hyperref[\detokenize{index:ARDOUR:Region}]{\emph{Region}}}

find\_next\_region(long,{\hyperref[\detokenize{index:ARDOUR.RegionPoint}]{\emph{RegionPoint}}}, int)

long

find\_next\_region\_boundary(long, int)

long

find\_next\_transient(long, int)

void

lower\_region({\hyperref[\detokenize{index:ARDOUR:Region}]{\emph{Region}}})

void

lower\_region\_to\_bottom({\hyperref[\detokenize{index:ARDOUR:Region}]{\emph{Region}}})

unsigned int

n\_regions()

void

raise\_region({\hyperref[\detokenize{index:ARDOUR:Region}]{\emph{Region}}})

void

raise\_region\_to\_top({\hyperref[\detokenize{index:ARDOUR:Region}]{\emph{Region}}})

{\hyperref[\detokenize{index:ARDOUR:Region}]{\emph{Region}}}

region\_by\_id({\hyperref[\detokenize{index:PBD:ID}]{\emph{ID}}})

{\hyperref[\detokenize{index:ARDOUR:RegionListPtr}]{\emph{RegionListPtr}}}

region\_list()

{\hyperref[\detokenize{index:ARDOUR:RegionListPtr}]{\emph{RegionListPtr}}}

regions\_at(long)

{\hyperref[\detokenize{index:ARDOUR:RegionListPtr}]{\emph{RegionListPtr}}}

regions\_touched(long, long)


\begin{description}
\item[{start}] \leavevmode
Range start.

\item[{end}] \leavevmode
Range end.

\end{description}



Returns regions which have some part within this range.





{\hyperref[\detokenize{index:ARDOUR:RegionListPtr}]{\emph{RegionListPtr}}}

regions\_with\_end\_within({\hyperref[\detokenize{index:Evoral:Range}]{\emph{Range}}})

{\hyperref[\detokenize{index:ARDOUR:RegionListPtr}]{\emph{RegionListPtr}}}

regions\_with\_start\_within({\hyperref[\detokenize{index:Evoral:Range}]{\emph{Range}}})

void

remove\_region({\hyperref[\detokenize{index:ARDOUR:Region}]{\emph{Region}}})

void

split(long)

void

split\_region({\hyperref[\detokenize{index:ARDOUR:Region}]{\emph{Region}}},{\hyperref[\detokenize{index:ARDOUR:MusicFrame}]{\emph{MusicFrame}}})

{\hyperref[\detokenize{index:ARDOUR:Region}]{\emph{Region}}}

top\_region\_at(long)

{\hyperref[\detokenize{index:ARDOUR:Region}]{\emph{Region}}}

top\_unmuted\_region\_at(long)

void

uncombine({\hyperref[\detokenize{index:ARDOUR:Region}]{\emph{Region}}})

Cast

{\hyperref[\detokenize{index:ARDOUR:AudioPlaylist}]{\emph{AudioPlaylist}}}

to\_audioplaylist()

{\hyperref[\detokenize{index:ARDOUR:MidiPlaylist}]{\emph{MidiPlaylist}}}

to\_midiplaylist()


\subsection{Inherited from ARDOUR:SessionObjectPtr}
\label{\detokenize{index:inherited-from-ardoursessionobjectptr-9}}\label{\detokenize{index:id165}}
Methods

std::string

name()

Cast

{\hyperref[\detokenize{index:PBD:Stateful}]{\emph{Stateful}}}

to\_stateful()

{\hyperref[\detokenize{index:PBD:StatefulDestructible}]{\emph{StatefulDestructible}}}

to\_statefuldestructible()


\section{↠ ARDOUR:MidiPort}
\label{\detokenize{index:ardour-midiport}}\label{\detokenize{index:id166}}
\sphinxstyleemphasis{C‡}: boost::shared\_ptr\textless{} ARDOUR::MidiPort \textgreater{}, boost::weak\_ptr\textless{}
ARDOUR::MidiPort \textgreater{}

is-a: {\hyperref[\detokenize{index:ARDOUR:Port}]{\emph{ARDOUR:Port}}}





Methods

{\hyperref[\detokenize{index:ARDOUR:MidiBuffer}]{\emph{MidiBuffer}}}

get\_midi\_buffer(unsigned int)

bool

input\_active()

bool

isnil()

void

set\_input\_active(bool)


\subsection{Inherited from ARDOUR:Port}
\label{\detokenize{index:inherited-from-ardourport-1}}\label{\detokenize{index:id167}}
Methods

int

connect(std::string)

bool

connected()





Returns true if this port is connected to anything





bool

connected\_to(std::string)


\begin{description}
\item[{o}] \leavevmode
Port name

\end{description}



Returns true if this port is connected to o, otherwise false.





int

disconnect(std::string)

int

disconnect\_all()

std::string

name()





Returns Port short name





std::string

pretty\_name(bool)





Returns Port human readable name





bool

receives\_input()





Returns true if this Port receives input, otherwise false





bool

sends\_output()





Returns true if this Port sends output, otherwise false





Cast

{\hyperref[\detokenize{index:ARDOUR:AudioPort}]{\emph{AudioPort}}}

to\_audioport()

{\hyperref[\detokenize{index:ARDOUR:MidiPort}]{\emph{MidiPort}}}

to\_midiport()


\section{↠ ARDOUR:MidiRegion}
\label{\detokenize{index:ardour-midiregion}}\label{\detokenize{index:id168}}
\sphinxstyleemphasis{C‡}: boost::shared\_ptr\textless{} ARDOUR::MidiRegion \textgreater{}, boost::weak\_ptr\textless{}
ARDOUR::MidiRegion \textgreater{}

is-a: {\hyperref[\detokenize{index:ARDOUR:Region}]{\emph{ARDOUR:Region}}}







A named object associated with a Session. Objects derived from this
class are expected to be destroyed before the session calls
drop\_references().



Methods

bool

do\_export(std::string)



Export the MIDI data of the MidiRegion to a new MIDI file (SMF).



bool

isnil()

double

length\_beats()

{\hyperref[\detokenize{index:ARDOUR:MidiSource}]{\emph{MidiSource}}}

midi\_source(unsigned int)

{\hyperref[\detokenize{index:ARDOUR:MidiModel}]{\emph{MidiModel}}}

model()

double

start\_beats()


\subsection{Inherited from ARDOUR:Region}
\label{\detokenize{index:inherited-from-ardourregion-1}}\label{\detokenize{index:id169}}
Methods

bool

at\_natural\_position()

bool

automatic()

bool

can\_move()

bool

captured()

void

clear\_sync\_position()

{\hyperref[\detokenize{index:Evoral:Control}]{\emph{Control}}}

control({\hyperref[\detokenize{index:Evoral:Parameter}]{\emph{Parameter}}}, bool)

bool

covers(long)

void

cut\_end(long, int)

void

cut\_front(long, int)

{\hyperref[\detokenize{index:ARDOUR:DataType}]{\emph{DataType}}}

data\_type()

bool

external()

bool

has\_transients()

bool

hidden()

bool

import()

bool

is\_compound()

unsigned int

layer()

long

length()

bool

locked()

void

lower()

void

lower\_to\_bottom()

{\hyperref[\detokenize{index:C:StringVector}]{\emph{StringVector}}}

master\_source\_names()

{\hyperref[\detokenize{index:ARDOUR:SourceList}]{\emph{SourceList}}}

master\_sources()

void

move\_start(long, int)

void

move\_to\_natural\_position()

bool

muted()

unsigned int

n\_channels()

void

nudge\_position(long)

bool

opaque()

long

position()



How the region parameters play together:

POSITION: first frame of the region along the timeline START: first
frame of the region within its source(s) LENGTH: number of frames the
region represents



bool

position\_locked()

double

quarter\_note()

void

raise()

void

raise\_to\_top()

void

set\_hidden(bool)

void

set\_initial\_position(long)



A gui may need to create a region, then place it in an initial position
determined by the user. When this takes place within one gui operation,
we have to reset \_last\_position to prevent an implied move.



void

set\_length(long, int)

void

set\_locked(bool)

void

set\_muted(bool)

void

set\_opaque(bool)

void

set\_position(long, int)

void

set\_position\_locked(bool)

void

set\_start(long)

void

set\_sync\_position(long)



Set the region’s sync point.
\begin{description}
\item[{absolute\_pos}] \leavevmode
Session time.

\end{description}



void

set\_video\_locked(bool)

float

shift()

{\hyperref[\detokenize{index:ARDOUR:Source}]{\emph{Source}}}

source(unsigned int)

long

start()

float

stretch()

bool

sync\_marked()

\sphinxstyleemphasis{LuaTable}(long, …)

sync\_offset(int\&)

long

sync\_position()





Returns Sync position in session time





{\hyperref[\detokenize{index:C:Int64List}]{\emph{Int64List}}}

transients()

void

trim\_end(long, int)

void

trim\_front(long, int)

void

trim\_to(long, long, int)

bool

video\_locked()

bool

whole\_file()

Cast

{\hyperref[\detokenize{index:ARDOUR:AudioRegion}]{\emph{AudioRegion}}}

to\_audioregion()

{\hyperref[\detokenize{index:ARDOUR:MidiRegion}]{\emph{MidiRegion}}}

to\_midiregion()

{\hyperref[\detokenize{index:ARDOUR:Readable}]{\emph{Readable}}}

to\_readable()


\subsection{Inherited from ARDOUR:SessionObjectPtr}
\label{\detokenize{index:inherited-from-ardoursessionobjectptr-10}}\label{\detokenize{index:id170}}
Methods

std::string

name()

Cast

{\hyperref[\detokenize{index:PBD:Stateful}]{\emph{Stateful}}}

to\_stateful()

{\hyperref[\detokenize{index:PBD:StatefulDestructible}]{\emph{StatefulDestructible}}}

to\_statefuldestructible()


\section{↠ ARDOUR:MidiSource}
\label{\detokenize{index:ardour-midisource}}\label{\detokenize{index:id171}}
\sphinxstyleemphasis{C‡}: boost::shared\_ptr\textless{} ARDOUR::MidiSource \textgreater{}, boost::weak\_ptr\textless{}
ARDOUR::MidiSource \textgreater{}

is-a: {\hyperref[\detokenize{index:ARDOUR:Source}]{\emph{ARDOUR:Source}}}







Source for MIDI data



Methods

bool

empty()

bool

isnil()

long

length(long)

{\hyperref[\detokenize{index:ARDOUR:MidiModel}]{\emph{MidiModel}}}

model()


\subsection{Inherited from ARDOUR:Source}
\label{\detokenize{index:inherited-from-ardoursource-2}}\label{\detokenize{index:id172}}
Methods

std::string

ancestor\_name()

bool

can\_be\_analysed()

bool

destructive()

bool

has\_been\_analysed()

long

natural\_position()

long

timeline\_position()

long

timestamp()

int

use\_count()

bool

used()

bool

writable()

Cast

{\hyperref[\detokenize{index:ARDOUR:AudioSource}]{\emph{AudioSource}}}

to\_audiosource()

{\hyperref[\detokenize{index:ARDOUR:FileSource}]{\emph{FileSource}}}

to\_filesource()

{\hyperref[\detokenize{index:ARDOUR:MidiSource}]{\emph{MidiSource}}}

to\_midisource()


\subsection{Inherited from ARDOUR:SessionObjectPtr}
\label{\detokenize{index:inherited-from-ardoursessionobjectptr-11}}\label{\detokenize{index:id173}}
Methods

std::string

name()

Cast

{\hyperref[\detokenize{index:PBD:Stateful}]{\emph{Stateful}}}

to\_stateful()

{\hyperref[\detokenize{index:PBD:StatefulDestructible}]{\emph{StatefulDestructible}}}

to\_statefuldestructible()


\section{↠ ARDOUR:MidiTrack}
\label{\detokenize{index:ardour-miditrack}}\label{\detokenize{index:id174}}
\sphinxstyleemphasis{C‡}: boost::shared\_ptr\textless{} ARDOUR::MidiTrack \textgreater{}, boost::weak\_ptr\textless{}
ARDOUR::MidiTrack \textgreater{}

is-a: {\hyperref[\detokenize{index:ARDOUR:Track}]{\emph{ARDOUR:Track}}}







A track is an route (bus) with a recordable diskstream and related
objects relevant to tracking, playback and editing.

Specifically a track has regions and playlist objects.



Methods

bool

isnil()


\subsection{Inherited from ARDOUR:Track}
\label{\detokenize{index:inherited-from-ardourtrack-1}}\label{\detokenize{index:id175}}
Methods

{\hyperref[\detokenize{index:ARDOUR:Region}]{\emph{Region}}}

bounce({\hyperref[\detokenize{index:ARDOUR:InterThreadInfo}]{\emph{InterThreadInfo\&}}})



bounce track from session start to session end to new region
\begin{description}
\item[{itt}] \leavevmode
asynchronous progress report and cancel

\end{description}



Returns a new audio region (or nil in case of error)





{\hyperref[\detokenize{index:ARDOUR:Region}]{\emph{Region}}}

bounce\_range(long,
long,{\hyperref[\detokenize{index:ARDOUR:InterThreadInfo}]{\emph{InterThreadInfo\&}}},{\hyperref[\detokenize{index:ARDOUR:Processor}]{\emph{Processor}}},
bool)



Bounce the given range to a new audio region.
\begin{description}
\item[{start}] \leavevmode
start time (in samples)

\item[{end}] \leavevmode
end time (in samples)

\item[{itt}] \leavevmode
asynchronous progress report and cancel

\item[{endpoint}] \leavevmode
the processor to tap the signal off (or nil for the top)

\item[{include\_endpoint}] \leavevmode
include the given processor in the bounced audio.

\end{description}



Returns a new audio region (or nil in case of error)





bool

bounceable({\hyperref[\detokenize{index:ARDOUR:Processor}]{\emph{Processor}}}, bool)



Test if the track can be bounced with the given settings. If
sends/inserts/returns are present in the signal path or the given track
has no audio outputs bouncing is not possible.
\begin{description}
\item[{endpoint}] \leavevmode
the processor to tap the signal off (or nil for the top)

\item[{include\_endpoint}] \leavevmode
include the given processor in the bounced audio.

\end{description}



Returns true if the track can be bounced, or false otherwise.





bool

can\_record()

{\hyperref[\detokenize{index:ARDOUR:Playlist}]{\emph{Playlist}}}

playlist()

bool

set\_name(std::string)

Cast

{\hyperref[\detokenize{index:ARDOUR:AudioTrack}]{\emph{AudioTrack}}}

to\_audio\_track()

{\hyperref[\detokenize{index:ARDOUR:MidiTrack}]{\emph{MidiTrack}}}

to\_midi\_track()


\subsection{Inherited from ARDOUR:Route}
\label{\detokenize{index:inherited-from-ardourroute-1}}\label{\detokenize{index:id176}}
Methods

bool

active()

int

add\_processor\_by\_index({\hyperref[\detokenize{index:ARDOUR:Processor}]{\emph{Processor}}},
int,{\hyperref[\detokenize{index:ARDOUR:Route:ProcessorStreams}]{\emph{ProcessorStreams}}}, bool)



Add a processor to a route such that it ends up with a given index into
the visible processors.
\begin{description}
\item[{index}] \leavevmode
Index to add the processor at, or -1 to add at the end of the list.

\end{description}



Returns 0 on success, non-0 on failure.





bool

add\_sidechain({\hyperref[\detokenize{index:ARDOUR:Processor}]{\emph{Processor}}})

{\hyperref[\detokenize{index:ARDOUR:Amp}]{\emph{Amp}}}

amp()

std::string

comment()

bool

customize\_plugin\_insert({\hyperref[\detokenize{index:ARDOUR:Processor}]{\emph{Processor}}}, unsigned
int,{\hyperref[\detokenize{index:ARDOUR:ChanCount}]{\emph{ChanCount}}},{\hyperref[\detokenize{index:ARDOUR:ChanCount}]{\emph{ChanCount}}})



enable custom plugin-insert configuration
\begin{description}
\item[{proc}] \leavevmode
Processor to customize

\item[{count}] \leavevmode
number of plugin instances to use (if zero, reset to default)

\item[{outs}] \leavevmode
output port customization

\item[{sinks}] \leavevmode
input pins for variable-I/O plugins

\end{description}



Returns true if successful





{\hyperref[\detokenize{index:ARDOUR:IO}]{\emph{IO}}}

input()

{\hyperref[\detokenize{index:ARDOUR:Delivery}]{\emph{Delivery}}}

main\_outs()



the signal processorat at end of the processing chain which produces
output



bool

muted()

{\hyperref[\detokenize{index:ARDOUR:ChanCount}]{\emph{ChanCount}}}

n\_inputs()

{\hyperref[\detokenize{index:ARDOUR:ChanCount}]{\emph{ChanCount}}}

n\_outputs()

{\hyperref[\detokenize{index:ARDOUR:Processor}]{\emph{Processor}}}

nth\_plugin(unsigned int)

{\hyperref[\detokenize{index:ARDOUR:Processor}]{\emph{Processor}}}

nth\_processor(unsigned int)

{\hyperref[\detokenize{index:ARDOUR:Processor}]{\emph{Processor}}}

nth\_send(unsigned int)

{\hyperref[\detokenize{index:ARDOUR:IO}]{\emph{IO}}}

output()

{\hyperref[\detokenize{index:ARDOUR:PannerShell}]{\emph{PannerShell}}}

panner\_shell()

{\hyperref[\detokenize{index:ARDOUR:PeakMeter}]{\emph{PeakMeter}}}

peak\_meter()



************************************************************* Pure
interface begins
here*************************************************************



int

remove\_processor({\hyperref[\detokenize{index:ARDOUR:Processor}]{\emph{Processor}}},{\hyperref[\detokenize{index:ARDOUR:Route:ProcessorStreams}]{\emph{ProcessorStreams}}},
bool)



remove plugin/processor
\begin{description}
\item[{proc}] \leavevmode
processor to remove

\item[{err}] \leavevmode
error report (index where removal vailed, channel-count why it
failed) may be nil

\item[{need\_process\_lock}] \leavevmode
if locking is required (set to true, unless called from RT context
with lock)

\end{description}



Returns 0 on success





int

remove\_processors({\hyperref[\detokenize{index:ARDOUR:ProcessorList}]{\emph{ProcessorList}}},{\hyperref[\detokenize{index:ARDOUR:Route:ProcessorStreams}]{\emph{ProcessorStreams}}})

bool

remove\_sidechain({\hyperref[\detokenize{index:ARDOUR:Processor}]{\emph{Processor}}})

int

reorder\_processors({\hyperref[\detokenize{index:ARDOUR:ProcessorList}]{\emph{ProcessorList}}},{\hyperref[\detokenize{index:ARDOUR:Route:ProcessorStreams}]{\emph{ProcessorStreams}}})

int

replace\_processor({\hyperref[\detokenize{index:ARDOUR:Processor}]{\emph{Processor}}},{\hyperref[\detokenize{index:ARDOUR:Processor}]{\emph{Processor}}},{\hyperref[\detokenize{index:ARDOUR:Route:ProcessorStreams}]{\emph{ProcessorStreams}}})



replace plugin/processor with another
\begin{description}
\item[{old}] \leavevmode
processor to remove

\item[{sub}] \leavevmode
processor to substitute the old one with

\item[{err}] \leavevmode
error report (index where removal vailed, channel-count why it
failed) may be nil

\end{description}



Returns 0 on success





bool

reset\_plugin\_insert({\hyperref[\detokenize{index:ARDOUR:Processor}]{\emph{Processor}}})



reset plugin-insert configuration to default, disable customizations.

This is equivalent to calling

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{customize\PYGZus{}plugin\PYGZus{}insert} \PYG{p}{(}\PYG{n}{proc}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{unused}\PYG{p}{)}
\end{sphinxVerbatim}
\begin{description}
\item[{proc}] \leavevmode
Processor to reset

\end{description}



Returns true if successful





void

set\_active(bool, void*)

void

set\_comment(std::string, void*)

void

set\_meter\_point({\hyperref[\detokenize{index:ARDOUR.MeterPoint}]{\emph{MeterPoint}}}, bool)

bool

set\_strict\_io(bool)

bool

soloed()

bool

strict\_io()

{\hyperref[\detokenize{index:ARDOUR:Processor}]{\emph{Processor}}}

the\_instrument()



Return the first processor that accepts has at least one MIDI input and
at least one audio output. In the vast majority of cases, this will be
“the instrument”. This does not preclude other MIDI-\textgreater{}audio processors
later in the processing chain, but that would be a special case not
covered by this utility function.



{\hyperref[\detokenize{index:ARDOUR:Amp}]{\emph{Amp}}}

trim()

Cast

{\hyperref[\detokenize{index:ARDOUR:Automatable}]{\emph{Automatable}}}

to\_automatable()

{\hyperref[\detokenize{index:ARDOUR:Slavable}]{\emph{Slavable}}}

to\_slavable()

{\hyperref[\detokenize{index:ARDOUR:Track}]{\emph{Track}}}

to\_track()


\subsection{Inherited from ARDOUR:Stripable}
\label{\detokenize{index:inherited-from-ardourstripable-1}}\label{\detokenize{index:id177}}
Methods

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

comp\_enable\_control()

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

comp\_makeup\_control()

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

comp\_mode\_control()

std::string

comp\_mode\_name(unsigned int)

{\hyperref[\detokenize{index:ARDOUR:ReadOnlyControl}]{\emph{ReadOnlyControl}}}

comp\_redux\_control()

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

comp\_speed\_control()

std::string

comp\_speed\_name(unsigned int)

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

comp\_threshold\_control()

unsigned int

eq\_band\_cnt()

std::string

eq\_band\_name(unsigned int)

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

eq\_enable\_control()

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

eq\_freq\_control(unsigned int)

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

eq\_gain\_control(unsigned int)

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

eq\_q\_control(unsigned int)

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

eq\_shape\_control(unsigned int)

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

filter\_enable\_controllable(bool)

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

filter\_freq\_controllable(bool)

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

filter\_slope\_controllable(bool)

{\hyperref[\detokenize{index:ARDOUR:GainControl}]{\emph{GainControl}}}

gain\_control()

bool

is\_auditioner()

bool

is\_hidden()

bool

is\_master()

bool

is\_monitor()

bool

is\_selected()

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

master\_send\_enable\_control()

{\hyperref[\detokenize{index:ARDOUR:MonitorProcessor}]{\emph{MonitorProcessor}}}

monitor\_control()

{\hyperref[\detokenize{index:ARDOUR:MuteControl}]{\emph{MuteControl}}}

mute\_control()

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

pan\_azimuth\_control()

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

pan\_elevation\_control()

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

pan\_frontback\_control()

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

pan\_lfe\_control()

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

pan\_width\_control()

{\hyperref[\detokenize{index:ARDOUR:PhaseControl}]{\emph{PhaseControl}}}

phase\_control()

{\hyperref[\detokenize{index:ARDOUR:PresentationInfo}]{\emph{PresentationInfo}}}

presentation\_info\_ptr()

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

rec\_enable\_control()

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

rec\_safe\_control()

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

send\_enable\_control(unsigned int)

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

send\_level\_control(unsigned int)

std::string

send\_name(unsigned int)

void

set\_presentation\_order(unsigned int)

{\hyperref[\detokenize{index:ARDOUR:SoloControl}]{\emph{SoloControl}}}

solo\_control()

{\hyperref[\detokenize{index:ARDOUR:SoloIsolateControl}]{\emph{SoloIsolateControl}}}

solo\_isolate\_control()

{\hyperref[\detokenize{index:ARDOUR:SoloSafeControl}]{\emph{SoloSafeControl}}}

solo\_safe\_control()

{\hyperref[\detokenize{index:ARDOUR:GainControl}]{\emph{GainControl}}}

trim\_control()

Cast

{\hyperref[\detokenize{index:ARDOUR:Route}]{\emph{Route}}}

to\_route()

{\hyperref[\detokenize{index:ARDOUR:VCA}]{\emph{VCA}}}

to\_vca()


\subsection{Inherited from ARDOUR:SessionObjectPtr}
\label{\detokenize{index:inherited-from-ardoursessionobjectptr-12}}\label{\detokenize{index:id178}}
Methods

std::string

name()

Cast

{\hyperref[\detokenize{index:PBD:Stateful}]{\emph{Stateful}}}

to\_stateful()

{\hyperref[\detokenize{index:PBD:StatefulDestructible}]{\emph{StatefulDestructible}}}

to\_statefuldestructible()


\section{∁ ARDOUR:MidiTrackList}
\label{\detokenize{index:ardour-miditracklist}}\label{\detokenize{index:id179}}
\sphinxstyleemphasis{C‡}: std::list\textless{}boost::shared\_ptr\textless{}ARDOUR::MidiTrack\textgreater{} \textgreater{}





Constructor

ℂ

ARDOUR.MidiTrackList()

Methods

\sphinxstyleemphasis{LuaTable}

add(LuaTable \{{\hyperref[\detokenize{index:ARDOUR:MidiTrack}]{\emph{MidiTrack}}}\})

{\hyperref[\detokenize{index:ARDOUR:MidiTrack}]{\emph{MidiTrack}}}

back()

bool

empty()

{\hyperref[\detokenize{index:ARDOUR:MidiTrack}]{\emph{MidiTrack}}}

front()

\sphinxstyleemphasis{LuaIter}

iter()

void

push\_back({\hyperref[\detokenize{index:ARDOUR:MidiTrack}]{\emph{MidiTrack}}})

void

reverse()

unsigned long

size()

\sphinxstyleemphasis{LuaTable}

table()

void

unique()


\section{↠ ARDOUR:MonitorProcessor}
\label{\detokenize{index:ardour-monitorprocessor}}\label{\detokenize{index:id180}}
\sphinxstyleemphasis{C‡}: boost::shared\_ptr\textless{} ARDOUR::MonitorProcessor \textgreater{}, boost::weak\_ptr\textless{}
ARDOUR::MonitorProcessor \textgreater{}

is-a: {\hyperref[\detokenize{index:ARDOUR:Processor}]{\emph{ARDOUR:Processor}}}







A mixer strip element - plugin, send, meter, etc



Methods

{\hyperref[\detokenize{index:PBD:Controllable}]{\emph{Controllable}}}

channel\_cut\_control(unsigned int)

{\hyperref[\detokenize{index:PBD:Controllable}]{\emph{Controllable}}}

channel\_dim\_control(unsigned int)

{\hyperref[\detokenize{index:PBD:Controllable}]{\emph{Controllable}}}

channel\_polarity\_control(unsigned int)

{\hyperref[\detokenize{index:PBD:Controllable}]{\emph{Controllable}}}

channel\_solo\_control(unsigned int)

bool

cut(unsigned int)

bool

cut\_all()

{\hyperref[\detokenize{index:PBD:Controllable}]{\emph{Controllable}}}

cut\_control()

bool

dim\_all()

{\hyperref[\detokenize{index:PBD:Controllable}]{\emph{Controllable}}}

dim\_control()

float

dim\_level()

{\hyperref[\detokenize{index:PBD:Controllable}]{\emph{Controllable}}}

dim\_level\_control()

bool

dimmed(unsigned int)

bool

inverted(unsigned int)

bool

isnil()

bool

monitor\_active()

bool

mono()

{\hyperref[\detokenize{index:PBD:Controllable}]{\emph{Controllable}}}

mono\_control()

void

set\_cut(unsigned int, bool)

void

set\_cut\_all(bool)

void

set\_dim(unsigned int, bool)

void

set\_dim\_all(bool)

void

set\_mono(bool)

void

set\_polarity(unsigned int, bool)

void

set\_solo(unsigned int, bool)

{\hyperref[\detokenize{index:PBD:Controllable}]{\emph{Controllable}}}

solo\_boost\_control()

float

solo\_boost\_level()

bool

soloed(unsigned int)


\subsection{Inherited from ARDOUR:Processor}
\label{\detokenize{index:inherited-from-ardourprocessor-3}}\label{\detokenize{index:id181}}
Methods

void

activate()

bool

active()

void

deactivate()

std::string

display\_name()

bool

display\_to\_user()

{\hyperref[\detokenize{index:ARDOUR:ChanCount}]{\emph{ChanCount}}}

input\_streams()

{\hyperref[\detokenize{index:ARDOUR:ChanCount}]{\emph{ChanCount}}}

output\_streams()

Cast

{\hyperref[\detokenize{index:ARDOUR:Amp}]{\emph{Amp}}}

to\_amp()

{\hyperref[\detokenize{index:ARDOUR:Automatable}]{\emph{Automatable}}}

to\_automatable()

{\hyperref[\detokenize{index:ARDOUR:PluginInsert}]{\emph{PluginInsert}}}

to\_insert()

{\hyperref[\detokenize{index:ARDOUR:IOProcessor}]{\emph{IOProcessor}}}

to\_ioprocessor()

{\hyperref[\detokenize{index:ARDOUR:PeakMeter}]{\emph{PeakMeter}}}

to\_meter()

{\hyperref[\detokenize{index:ARDOUR:MonitorProcessor}]{\emph{MonitorProcessor}}}

to\_monitorprocessor()

{\hyperref[\detokenize{index:ARDOUR:PeakMeter}]{\emph{PeakMeter}}}

to\_peakmeter()

{\hyperref[\detokenize{index:ARDOUR:PluginInsert}]{\emph{PluginInsert}}}

to\_plugininsert()

{\hyperref[\detokenize{index:ARDOUR:SideChain}]{\emph{SideChain}}}

to\_sidechain()

{\hyperref[\detokenize{index:ARDOUR:UnknownProcessor}]{\emph{UnknownProcessor}}}

to\_unknownprocessor()


\subsection{Inherited from ARDOUR:SessionObjectPtr}
\label{\detokenize{index:inherited-from-ardoursessionobjectptr-13}}\label{\detokenize{index:id182}}
Methods

std::string

name()

Cast

{\hyperref[\detokenize{index:PBD:Stateful}]{\emph{Stateful}}}

to\_stateful()

{\hyperref[\detokenize{index:PBD:StatefulDestructible}]{\emph{StatefulDestructible}}}

to\_statefuldestructible()


\section{∁ ARDOUR:MusicFrame}
\label{\detokenize{index:ardour-musicframe}}\label{\detokenize{index:id183}}
\sphinxstyleemphasis{C‡}: ARDOUR::MusicFrame





Constructor

ℂ

ARDOUR.MusicFrame(long, int)

Methods

void

set(long, int)

Data Members

int

division

long

frame


\section{↠ ARDOUR:MuteControl}
\label{\detokenize{index:ardour-mutecontrol}}\label{\detokenize{index:id184}}
\sphinxstyleemphasis{C‡}: boost::shared\_ptr\textless{} ARDOUR::MuteControl \textgreater{}, boost::weak\_ptr\textless{}
ARDOUR::MuteControl \textgreater{}

is-a:
{\hyperref[\detokenize{index:ARDOUR:SlavableAutomationControl}]{\emph{ARDOUR:SlavableAutomationControl}}}







A PBD::Controllable with associated automation data (AutomationList)



Methods

bool

isnil()

bool

muted()

bool

muted\_by\_self()


\subsection{Inherited from ARDOUR:SlavableAutomationControl}
\label{\detokenize{index:inherited-from-ardourslavableautomationcontrol-1}}\label{\detokenize{index:id185}}
Methods

void

add\_master({\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}})

void

clear\_masters()

int

get\_boolean\_masters()

double

get\_masters\_value()

void

remove\_master({\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}})

bool

slaved()

bool

slaved\_to({\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}})


\subsection{Inherited from ARDOUR:AutomationControl}
\label{\detokenize{index:inherited-from-ardourautomationcontrol-1}}\label{\detokenize{index:id186}}
Methods

{\hyperref[\detokenize{index:ARDOUR:AutomationList}]{\emph{AutomationList}}}

alist()

{\hyperref[\detokenize{index:ARDOUR.AutoState}]{\emph{AutoState}}}

automation\_state()

double

get\_value()



Get the current effective {}`user’ value based on automation state



void

set\_automation\_state({\hyperref[\detokenize{index:ARDOUR.AutoState}]{\emph{AutoState}}})

void

set\_value(double,{\hyperref[\detokenize{index:PBD.Controllable.GroupControlDisposition}]{\emph{GroupControlDisposition}}})



Get and Set {}`internal’ value

All derived classes must implement this.

Basic derived classes will ignore
\begin{description}
\item[{group\_override,}] \leavevmode
but more sophisticated children, notably those that proxy the value
setting logic via an object that is aware of group relationships
between this control and others, will find it useful.

\end{description}



void

start\_touch(double)

void

stop\_touch(double)

bool

writable()

Cast

{\hyperref[\detokenize{index:Evoral:Control}]{\emph{Control}}}

to\_ctrl()

{\hyperref[\detokenize{index:ARDOUR:SlavableAutomationControl}]{\emph{SlavableAutomationControl}}}

to\_slavable()


\subsection{Inherited from PBD:Controllable}
\label{\detokenize{index:inherited-from-pbdcontrollable-2}}\label{\detokenize{index:id187}}
Methods

std::string

name()


\subsection{Inherited from PBD:StatefulPtr}
\label{\detokenize{index:inherited-from-pbdstatefulptr-3}}\label{\detokenize{index:id188}}
Methods

void

clear\_changes()



Forget about any changes to this object’s properties



{\hyperref[\detokenize{index:PBD:ID}]{\emph{ID}}}

id()

{\hyperref[\detokenize{index:ARDOUR:OwnedPropertyList}]{\emph{OwnedPropertyList}}}

properties()


\section{∁ ARDOUR:NotePtrList}
\label{\detokenize{index:ardour-noteptrlist}}\label{\detokenize{index:id189}}
\sphinxstyleemphasis{C‡}: std::list\textless{}boost::shared\_ptr\textless{}Evoral::Note\textless{}Evoral::Beats\textgreater{} \textgreater{} \textgreater{} \textgreater{}





Constructor

ℂ

ARDOUR.NotePtrList()

Methods

\sphinxstyleemphasis{LuaTable}

add(LuaTable \{{\hyperref[\detokenize{index:Evoral:Beats}]{\emph{Beats}}}\})

{\hyperref[\detokenize{index:Evoral:NotePtr}]{\emph{NotePtr}}}

back()

bool

empty()

{\hyperref[\detokenize{index:Evoral:NotePtr}]{\emph{NotePtr}}}

front()

\sphinxstyleemphasis{LuaIter}

iter()

void

push\_back({\hyperref[\detokenize{index:Evoral:NotePtr}]{\emph{NotePtr}}})

void

reverse()

unsigned long

size()

\sphinxstyleemphasis{LuaTable}

table()

void

unique()


\section{∅ ARDOUR:OwnedPropertyList}
\label{\detokenize{index:ardour-ownedpropertylist}}\label{\detokenize{index:id190}}
\sphinxstyleemphasis{C‡}: PBD::OwnedPropertyList

is-a: {\hyperref[\detokenize{index:ARDOUR:PropertyList}]{\emph{ARDOUR:PropertyList}}}







Persistent Property List

A variant of PropertyList that does not delete its property list in its
destructor. Objects with their own Properties store them in an
OwnedPropertyList to avoid having them deleted at the wrong time.



This class object is only used indirectly as return-value and
function-parameter. It provides no methods by itself.


\section{↠ ARDOUR:PannerShell}
\label{\detokenize{index:ardour-pannershell}}\label{\detokenize{index:id191}}
\sphinxstyleemphasis{C‡}: boost::shared\_ptr\textless{} ARDOUR::PannerShell \textgreater{}, boost::weak\_ptr\textless{}
ARDOUR::PannerShell \textgreater{}

is-a: {\hyperref[\detokenize{index:ARDOUR:SessionObjectPtr}]{\emph{ARDOUR:SessionObjectPtr}}}







Class to manage panning by instantiating and controlling an appropriate
Panner object for a given in/out configuration.



Methods

bool

bypassed()

bool

isnil()

void

set\_bypassed(bool)


\subsection{Inherited from ARDOUR:SessionObjectPtr}
\label{\detokenize{index:inherited-from-ardoursessionobjectptr-14}}\label{\detokenize{index:id192}}
Methods

std::string

name()

Cast

{\hyperref[\detokenize{index:PBD:Stateful}]{\emph{Stateful}}}

to\_stateful()

{\hyperref[\detokenize{index:PBD:StatefulDestructible}]{\emph{StatefulDestructible}}}

to\_statefuldestructible()


\section{∁ ARDOUR:ParameterDescriptor}
\label{\detokenize{index:ardour-parameterdescriptor}}\label{\detokenize{index:id193}}
\sphinxstyleemphasis{C‡}: ARDOUR::ParameterDescriptor

is-a: {\hyperref[\detokenize{index:Evoral:ParameterDescriptor}]{\emph{Evoral:ParameterDescriptor}}}







Descriptor of a parameter or control.

Essentially a union of LADSPA, VST and LV2 info.



Constructor

ℂ

ARDOUR.ParameterDescriptor()

Methods

std::string

midi\_note\_name(unsigned char, bool)

Data Members

std::string

label


\subsection{Inherited from Evoral:ParameterDescriptor}
\label{\detokenize{index:inherited-from-evoral-parameterdescriptor}}
Constructor

ℂ

Evoral.ParameterDescriptor()

Data Members

bool

logarithmic



True for log-scale parameters



float

lower



Minimum value (in Hz, for frequencies)



float

normal



Default value



bool

toggled



True iff parameter is boolean



float

upper



Maximum value (in Hz, for frequencies)




\section{↠ ARDOUR:PeakMeter}
\label{\detokenize{index:ardour-peakmeter}}\label{\detokenize{index:id194}}
\sphinxstyleemphasis{C‡}: boost::shared\_ptr\textless{} ARDOUR::PeakMeter \textgreater{}, boost::weak\_ptr\textless{}
ARDOUR::PeakMeter \textgreater{}

is-a: {\hyperref[\detokenize{index:ARDOUR:Processor}]{\emph{ARDOUR:Processor}}}







Meters peaks on the input and stores them for access.



Methods

bool

isnil()

float

meter\_level(unsigned int,{\hyperref[\detokenize{index:ARDOUR.MeterType}]{\emph{MeterType}}})

void

reset\_max()

void

set\_type({\hyperref[\detokenize{index:ARDOUR.MeterType}]{\emph{MeterType}}})


\subsection{Inherited from ARDOUR:Processor}
\label{\detokenize{index:inherited-from-ardourprocessor-4}}\label{\detokenize{index:id195}}
Methods

void

activate()

bool

active()

void

deactivate()

std::string

display\_name()

bool

display\_to\_user()

{\hyperref[\detokenize{index:ARDOUR:ChanCount}]{\emph{ChanCount}}}

input\_streams()

{\hyperref[\detokenize{index:ARDOUR:ChanCount}]{\emph{ChanCount}}}

output\_streams()

Cast

{\hyperref[\detokenize{index:ARDOUR:Amp}]{\emph{Amp}}}

to\_amp()

{\hyperref[\detokenize{index:ARDOUR:Automatable}]{\emph{Automatable}}}

to\_automatable()

{\hyperref[\detokenize{index:ARDOUR:PluginInsert}]{\emph{PluginInsert}}}

to\_insert()

{\hyperref[\detokenize{index:ARDOUR:IOProcessor}]{\emph{IOProcessor}}}

to\_ioprocessor()

{\hyperref[\detokenize{index:ARDOUR:PeakMeter}]{\emph{PeakMeter}}}

to\_meter()

{\hyperref[\detokenize{index:ARDOUR:MonitorProcessor}]{\emph{MonitorProcessor}}}

to\_monitorprocessor()

{\hyperref[\detokenize{index:ARDOUR:PeakMeter}]{\emph{PeakMeter}}}

to\_peakmeter()

{\hyperref[\detokenize{index:ARDOUR:PluginInsert}]{\emph{PluginInsert}}}

to\_plugininsert()

{\hyperref[\detokenize{index:ARDOUR:SideChain}]{\emph{SideChain}}}

to\_sidechain()

{\hyperref[\detokenize{index:ARDOUR:UnknownProcessor}]{\emph{UnknownProcessor}}}

to\_unknownprocessor()


\subsection{Inherited from ARDOUR:SessionObjectPtr}
\label{\detokenize{index:inherited-from-ardoursessionobjectptr-15}}\label{\detokenize{index:id196}}
Methods

std::string

name()

Cast

{\hyperref[\detokenize{index:PBD:Stateful}]{\emph{Stateful}}}

to\_stateful()

{\hyperref[\detokenize{index:PBD:StatefulDestructible}]{\emph{StatefulDestructible}}}

to\_statefuldestructible()


\section{↠ ARDOUR:PhaseControl}
\label{\detokenize{index:ardour-phasecontrol}}\label{\detokenize{index:id197}}
\sphinxstyleemphasis{C‡}: boost::shared\_ptr\textless{} ARDOUR::PhaseControl \textgreater{}, boost::weak\_ptr\textless{}
ARDOUR::PhaseControl \textgreater{}

is-a: {\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{ARDOUR:AutomationControl}}}







A PBD::Controllable with associated automation data (AutomationList)



Methods

bool

inverted(unsigned int)

bool

isnil()

void

set\_phase\_invert(unsigned int, bool)


\begin{description}
\item[{c}] \leavevmode
Audio channel index.

\item[{yn}] \leavevmode
true to invert phase, otherwise false.

\end{description}




\subsection{Inherited from ARDOUR:AutomationControl}
\label{\detokenize{index:inherited-from-ardourautomationcontrol-2}}\label{\detokenize{index:id198}}
Methods

{\hyperref[\detokenize{index:ARDOUR:AutomationList}]{\emph{AutomationList}}}

alist()

{\hyperref[\detokenize{index:ARDOUR.AutoState}]{\emph{AutoState}}}

automation\_state()

double

get\_value()



Get the current effective {}`user’ value based on automation state



void

set\_automation\_state({\hyperref[\detokenize{index:ARDOUR.AutoState}]{\emph{AutoState}}})

void

set\_value(double,{\hyperref[\detokenize{index:PBD.Controllable.GroupControlDisposition}]{\emph{GroupControlDisposition}}})



Get and Set {}`internal’ value

All derived classes must implement this.

Basic derived classes will ignore
\begin{description}
\item[{group\_override,}] \leavevmode
but more sophisticated children, notably those that proxy the value
setting logic via an object that is aware of group relationships
between this control and others, will find it useful.

\end{description}



void

start\_touch(double)

void

stop\_touch(double)

bool

writable()

Cast

{\hyperref[\detokenize{index:Evoral:Control}]{\emph{Control}}}

to\_ctrl()

{\hyperref[\detokenize{index:ARDOUR:SlavableAutomationControl}]{\emph{SlavableAutomationControl}}}

to\_slavable()


\subsection{Inherited from PBD:Controllable}
\label{\detokenize{index:inherited-from-pbdcontrollable-3}}\label{\detokenize{index:id199}}
Methods

std::string

name()


\subsection{Inherited from PBD:StatefulPtr}
\label{\detokenize{index:inherited-from-pbdstatefulptr-4}}\label{\detokenize{index:id200}}
Methods

void

clear\_changes()



Forget about any changes to this object’s properties



{\hyperref[\detokenize{index:PBD:ID}]{\emph{ID}}}

id()

{\hyperref[\detokenize{index:ARDOUR:OwnedPropertyList}]{\emph{OwnedPropertyList}}}

properties()


\section{↠ ARDOUR:Playlist}
\label{\detokenize{index:ardour-playlist}}\label{\detokenize{index:id201}}
\sphinxstyleemphasis{C‡}: boost::shared\_ptr\textless{} ARDOUR::Playlist \textgreater{}, boost::weak\_ptr\textless{}
ARDOUR::Playlist \textgreater{}

is-a: {\hyperref[\detokenize{index:ARDOUR:SessionObjectPtr}]{\emph{ARDOUR:SessionObjectPtr}}}







A named object associated with a Session. Objects derived from this
class are expected to be destroyed before the session calls
drop\_references().



Methods

void

add\_region({\hyperref[\detokenize{index:ARDOUR:Region}]{\emph{Region}}}, long, float, bool, int,
double, bool)



Note: this calls set\_layer (…, DBL\_MAX) so it will reset the layering
index of region



{\hyperref[\detokenize{index:ARDOUR:Region}]{\emph{Region}}}

combine({\hyperref[\detokenize{index:ARDOUR:RegionList}]{\emph{RegionList}}})

unsigned int

count\_regions\_at(long)

{\hyperref[\detokenize{index:ARDOUR:Playlist}]{\emph{Playlist}}}

cut({\hyperref[\detokenize{index:ARDOUR:AudioRangeList}]{\emph{AudioRangeList\&}}}, bool)

{\hyperref[\detokenize{index:ARDOUR:DataType}]{\emph{DataType}}}

data\_type()

void

duplicate({\hyperref[\detokenize{index:ARDOUR:Region}]{\emph{Region}}}, long, long, float)


\begin{description}
\item[{gap}] \leavevmode
from the beginning of the region to the next beginning

\end{description}



void

duplicate\_range({\hyperref[\detokenize{index:ARDOUR:AudioRange}]{\emph{AudioRange\&}}}, float)

void

duplicate\_until({\hyperref[\detokenize{index:ARDOUR:Region}]{\emph{Region}}}, long, long, long)


\begin{description}
\item[{gap}] \leavevmode
from the beginning of the region to the next beginning

\item[{end}] \leavevmode
the first frame that does \_not\_ contain a duplicated frame

\end{description}



{\hyperref[\detokenize{index:ARDOUR:Region}]{\emph{Region}}}

find\_next\_region(long,{\hyperref[\detokenize{index:ARDOUR.RegionPoint}]{\emph{RegionPoint}}}, int)

long

find\_next\_region\_boundary(long, int)

long

find\_next\_transient(long, int)

bool

isnil()

void

lower\_region({\hyperref[\detokenize{index:ARDOUR:Region}]{\emph{Region}}})

void

lower\_region\_to\_bottom({\hyperref[\detokenize{index:ARDOUR:Region}]{\emph{Region}}})

unsigned int

n\_regions()

void

raise\_region({\hyperref[\detokenize{index:ARDOUR:Region}]{\emph{Region}}})

void

raise\_region\_to\_top({\hyperref[\detokenize{index:ARDOUR:Region}]{\emph{Region}}})

{\hyperref[\detokenize{index:ARDOUR:Region}]{\emph{Region}}}

region\_by\_id({\hyperref[\detokenize{index:PBD:ID}]{\emph{ID}}})

{\hyperref[\detokenize{index:ARDOUR:RegionListPtr}]{\emph{RegionListPtr}}}

region\_list()

{\hyperref[\detokenize{index:ARDOUR:RegionListPtr}]{\emph{RegionListPtr}}}

regions\_at(long)

{\hyperref[\detokenize{index:ARDOUR:RegionListPtr}]{\emph{RegionListPtr}}}

regions\_touched(long, long)


\begin{description}
\item[{start}] \leavevmode
Range start.

\item[{end}] \leavevmode
Range end.

\end{description}



Returns regions which have some part within this range.





{\hyperref[\detokenize{index:ARDOUR:RegionListPtr}]{\emph{RegionListPtr}}}

regions\_with\_end\_within({\hyperref[\detokenize{index:Evoral:Range}]{\emph{Range}}})

{\hyperref[\detokenize{index:ARDOUR:RegionListPtr}]{\emph{RegionListPtr}}}

regions\_with\_start\_within({\hyperref[\detokenize{index:Evoral:Range}]{\emph{Range}}})

void

remove\_region({\hyperref[\detokenize{index:ARDOUR:Region}]{\emph{Region}}})

void

split(long)

void

split\_region({\hyperref[\detokenize{index:ARDOUR:Region}]{\emph{Region}}},{\hyperref[\detokenize{index:ARDOUR:MusicFrame}]{\emph{MusicFrame}}})

{\hyperref[\detokenize{index:ARDOUR:Region}]{\emph{Region}}}

top\_region\_at(long)

{\hyperref[\detokenize{index:ARDOUR:Region}]{\emph{Region}}}

top\_unmuted\_region\_at(long)

void

uncombine({\hyperref[\detokenize{index:ARDOUR:Region}]{\emph{Region}}})

Cast

{\hyperref[\detokenize{index:ARDOUR:AudioPlaylist}]{\emph{AudioPlaylist}}}

to\_audioplaylist()

{\hyperref[\detokenize{index:ARDOUR:MidiPlaylist}]{\emph{MidiPlaylist}}}

to\_midiplaylist()


\subsection{Inherited from ARDOUR:SessionObjectPtr}
\label{\detokenize{index:inherited-from-ardoursessionobjectptr-16}}\label{\detokenize{index:id202}}
Methods

std::string

name()

Cast

{\hyperref[\detokenize{index:PBD:Stateful}]{\emph{Stateful}}}

to\_stateful()

{\hyperref[\detokenize{index:PBD:StatefulDestructible}]{\emph{StatefulDestructible}}}

to\_statefuldestructible()


\section{↠ ARDOUR:Plugin}
\label{\detokenize{index:ardour-plugin}}\label{\detokenize{index:id203}}
\sphinxstyleemphasis{C‡}: boost::shared\_ptr\textless{} ARDOUR::Plugin \textgreater{}, boost::weak\_ptr\textless{}
ARDOUR::Plugin \textgreater{}

is-a: {\hyperref[\detokenize{index:PBD:StatefulDestructiblePtr}]{\emph{PBD:StatefulDestructiblePtr}}}







A plugin is an external module (usually 3rd party provided) loaded into
Ardour for the purpose of digital signal processing.

This class provides an abstraction for methords provided by all
supported plugin standards such as presets, name, parameters etc.

Plugins are not used directly in Ardour but always wrapped by a
PluginInsert.



Methods

{\hyperref[\detokenize{index:ARDOUR:Plugin:IOPortDescription}]{\emph{IOPortDescription}}}

describe\_io\_port({\hyperref[\detokenize{index:ARDOUR:DataType}]{\emph{DataType}}}, bool, unsigned
int)

std::string

get\_docs()

{\hyperref[\detokenize{index:ARDOUR:PluginInfo}]{\emph{PluginInfo}}}

get\_info()

\sphinxstyleemphasis{LuaTable}(int, …)

get\_parameter\_descriptor(unsigned
int,{\hyperref[\detokenize{index:ARDOUR:ParameterDescriptor}]{\emph{ParameterDescriptor\&}}})

std::string

get\_parameter\_docs(unsigned int)

bool

isnil()

char*

label()

bool

load\_preset({\hyperref[\detokenize{index:ARDOUR:PresetRecord}]{\emph{PresetRecord}}})



Set parameters using a preset



char*

maker()

char*

name()

\sphinxstyleemphasis{LuaTable}(unsigned int, …)

nth\_parameter(unsigned int, bool\&)

unsigned int

parameter\_count()

bool

parameter\_is\_audio(unsigned int)

bool

parameter\_is\_control(unsigned int)

bool

parameter\_is\_input(unsigned int)

bool

parameter\_is\_output(unsigned int)

std::string

parameter\_label(unsigned int)

{\hyperref[\detokenize{index:ARDOUR:PresetRecord}]{\emph{PresetRecord}}}

preset\_by\_label(std::string)

{\hyperref[\detokenize{index:ARDOUR:PresetRecord}]{\emph{PresetRecord}}}

preset\_by\_uri(std::string)

std::string

unique\_id()

Cast

{\hyperref[\detokenize{index:ARDOUR:LuaProc}]{\emph{LuaProc}}}

to\_luaproc()


\subsection{Inherited from PBD:StatefulPtr}
\label{\detokenize{index:inherited-from-pbdstatefulptr-5}}\label{\detokenize{index:id204}}
Methods

void

clear\_changes()



Forget about any changes to this object’s properties



{\hyperref[\detokenize{index:PBD:ID}]{\emph{ID}}}

id()

{\hyperref[\detokenize{index:ARDOUR:OwnedPropertyList}]{\emph{OwnedPropertyList}}}

properties()


\section{∁ ARDOUR:Plugin:IOPortDescription}
\label{\detokenize{index:ardour-plugin-ioportdescription}}\label{\detokenize{index:id205}}
\sphinxstyleemphasis{C‡}: ARDOUR::Plugin::IOPortDescription





Data Members

unsigned int

group\_channel

std::string

group\_name

bool

is\_sidechain

std::string

name


\section{↠ ARDOUR:PluginControl}
\label{\detokenize{index:ardour-plugincontrol}}\label{\detokenize{index:id206}}
\sphinxstyleemphasis{C‡}: boost::shared\_ptr\textless{} ARDOUR::PluginInsert::PluginControl \textgreater{},
boost::weak\_ptr\textless{} ARDOUR::PluginInsert::PluginControl \textgreater{}

is-a: {\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{ARDOUR:AutomationControl}}}







A control that manipulates a plugin parameter (control port).



Methods

bool

isnil()


\subsection{Inherited from ARDOUR:AutomationControl}
\label{\detokenize{index:inherited-from-ardourautomationcontrol-3}}\label{\detokenize{index:id207}}
Methods

{\hyperref[\detokenize{index:ARDOUR:AutomationList}]{\emph{AutomationList}}}

alist()

{\hyperref[\detokenize{index:ARDOUR.AutoState}]{\emph{AutoState}}}

automation\_state()

double

get\_value()



Get the current effective {}`user’ value based on automation state



void

set\_automation\_state({\hyperref[\detokenize{index:ARDOUR.AutoState}]{\emph{AutoState}}})

void

set\_value(double,{\hyperref[\detokenize{index:PBD.Controllable.GroupControlDisposition}]{\emph{GroupControlDisposition}}})



Get and Set {}`internal’ value

All derived classes must implement this.

Basic derived classes will ignore
\begin{description}
\item[{group\_override,}] \leavevmode
but more sophisticated children, notably those that proxy the value
setting logic via an object that is aware of group relationships
between this control and others, will find it useful.

\end{description}



void

start\_touch(double)

void

stop\_touch(double)

bool

writable()

Cast

{\hyperref[\detokenize{index:Evoral:Control}]{\emph{Control}}}

to\_ctrl()

{\hyperref[\detokenize{index:ARDOUR:SlavableAutomationControl}]{\emph{SlavableAutomationControl}}}

to\_slavable()


\subsection{Inherited from PBD:Controllable}
\label{\detokenize{index:inherited-from-pbdcontrollable-4}}\label{\detokenize{index:id208}}
Methods

std::string

name()


\subsection{Inherited from PBD:StatefulPtr}
\label{\detokenize{index:inherited-from-pbdstatefulptr-6}}\label{\detokenize{index:id209}}
Methods

void

clear\_changes()



Forget about any changes to this object’s properties



{\hyperref[\detokenize{index:PBD:ID}]{\emph{ID}}}

id()

{\hyperref[\detokenize{index:ARDOUR:OwnedPropertyList}]{\emph{OwnedPropertyList}}}

properties()


\section{↠ ARDOUR:PluginInfo}
\label{\detokenize{index:ardour-plugininfo}}\label{\detokenize{index:id210}}
\sphinxstyleemphasis{C‡}: boost::shared\_ptr\textless{} ARDOUR::PluginInfo \textgreater{}, boost::weak\_ptr\textless{}
ARDOUR::PluginInfo \textgreater{}





Constructor

ℵ

ARDOUR.PluginInfo()

Methods

{\hyperref[\detokenize{index:ARDOUR:PresetVector}]{\emph{PresetVector}}}

get\_presets(bool)

bool

is\_instrument()

bool

isnil()

Data Members

std::string

category

std::string

creator

{\hyperref[\detokenize{index:ARDOUR:ChanCount}]{\emph{ARDOUR:ChanCount}}}

n\_inputs

{\hyperref[\detokenize{index:ARDOUR:ChanCount}]{\emph{ARDOUR:ChanCount}}}

n\_outputs

std::string

name

std::string

path

{\hyperref[\detokenize{index:ARDOUR.PluginType}]{\emph{ARDOUR.PluginType}}}

type

std::string

unique\_id


\section{↠ ARDOUR:PluginInsert}
\label{\detokenize{index:ardour-plugininsert}}\label{\detokenize{index:id211}}
\sphinxstyleemphasis{C‡}: boost::shared\_ptr\textless{} ARDOUR::PluginInsert \textgreater{}, boost::weak\_ptr\textless{}
ARDOUR::PluginInsert \textgreater{}

is-a: {\hyperref[\detokenize{index:ARDOUR:Processor}]{\emph{ARDOUR:Processor}}}







Plugin inserts: send data through a plugin



Methods

void

activate()

void

deactivate()

{\hyperref[\detokenize{index:ARDOUR:ChanMapping}]{\emph{ChanMapping}}}

input\_map(unsigned int)

bool

isnil()

{\hyperref[\detokenize{index:ARDOUR:ChanCount}]{\emph{ChanCount}}}

natural\_input\_streams()

{\hyperref[\detokenize{index:ARDOUR:ChanCount}]{\emph{ChanCount}}}

natural\_output\_streams()

{\hyperref[\detokenize{index:ARDOUR:ChanMapping}]{\emph{ChanMapping}}}

output\_map(unsigned int)

{\hyperref[\detokenize{index:ARDOUR:Plugin}]{\emph{Plugin}}}

plugin(unsigned int)

bool

reset\_parameters\_to\_default()

void

set\_input\_map(unsigned int,{\hyperref[\detokenize{index:ARDOUR:ChanMapping}]{\emph{ChanMapping}}})

void

set\_output\_map(unsigned int,{\hyperref[\detokenize{index:ARDOUR:ChanMapping}]{\emph{ChanMapping}}})

bool

strict\_io\_configured()


\subsection{Inherited from ARDOUR:Processor}
\label{\detokenize{index:inherited-from-ardourprocessor-5}}\label{\detokenize{index:id212}}
Methods

bool

active()

std::string

display\_name()

bool

display\_to\_user()

{\hyperref[\detokenize{index:ARDOUR:ChanCount}]{\emph{ChanCount}}}

input\_streams()

{\hyperref[\detokenize{index:ARDOUR:ChanCount}]{\emph{ChanCount}}}

output\_streams()

Cast

{\hyperref[\detokenize{index:ARDOUR:Amp}]{\emph{Amp}}}

to\_amp()

{\hyperref[\detokenize{index:ARDOUR:Automatable}]{\emph{Automatable}}}

to\_automatable()

{\hyperref[\detokenize{index:ARDOUR:PluginInsert}]{\emph{PluginInsert}}}

to\_insert()

{\hyperref[\detokenize{index:ARDOUR:IOProcessor}]{\emph{IOProcessor}}}

to\_ioprocessor()

{\hyperref[\detokenize{index:ARDOUR:PeakMeter}]{\emph{PeakMeter}}}

to\_meter()

{\hyperref[\detokenize{index:ARDOUR:MonitorProcessor}]{\emph{MonitorProcessor}}}

to\_monitorprocessor()

{\hyperref[\detokenize{index:ARDOUR:PeakMeter}]{\emph{PeakMeter}}}

to\_peakmeter()

{\hyperref[\detokenize{index:ARDOUR:PluginInsert}]{\emph{PluginInsert}}}

to\_plugininsert()

{\hyperref[\detokenize{index:ARDOUR:SideChain}]{\emph{SideChain}}}

to\_sidechain()

{\hyperref[\detokenize{index:ARDOUR:UnknownProcessor}]{\emph{UnknownProcessor}}}

to\_unknownprocessor()


\subsection{Inherited from ARDOUR:SessionObjectPtr}
\label{\detokenize{index:inherited-from-ardoursessionobjectptr-17}}\label{\detokenize{index:id213}}
Methods

std::string

name()

Cast

{\hyperref[\detokenize{index:PBD:Stateful}]{\emph{Stateful}}}

to\_stateful()

{\hyperref[\detokenize{index:PBD:StatefulDestructible}]{\emph{StatefulDestructible}}}

to\_statefuldestructible()


\section{↠ ARDOUR:Port}
\label{\detokenize{index:ardour-port}}\label{\detokenize{index:id214}}
\sphinxstyleemphasis{C‡}: boost::shared\_ptr\textless{} ARDOUR::Port \textgreater{}, boost::weak\_ptr\textless{} ARDOUR::Port \textgreater{}





Methods

int

connect(std::string)

bool

connected()





Returns true if this port is connected to anything





bool

connected\_to(std::string)


\begin{description}
\item[{o}] \leavevmode
Port name

\end{description}



Returns true if this port is connected to o, otherwise false.





int

disconnect(std::string)

int

disconnect\_all()

bool

isnil()

std::string

name()





Returns Port short name





std::string

pretty\_name(bool)





Returns Port human readable name





bool

receives\_input()





Returns true if this Port receives input, otherwise false





bool

sends\_output()





Returns true if this Port sends output, otherwise false





Cast

{\hyperref[\detokenize{index:ARDOUR:AudioPort}]{\emph{AudioPort}}}

to\_audioport()

{\hyperref[\detokenize{index:ARDOUR:MidiPort}]{\emph{MidiPort}}}

to\_midiport()


\section{∅ ARDOUR:PortEngine}
\label{\detokenize{index:ardour-portengine}}\label{\detokenize{index:id215}}
\sphinxstyleemphasis{C‡}: ARDOUR::PortEngine







PortEngine is an abstract base class that defines the functionality
required by Ardour.

A Port is basically an endpoint for a datastream (which can either be
continuous, like audio, or event-based, like MIDI). Ports have buffers
associated with them into which data can be written (if they are output
ports) and from which data can be read (if they input ports). Ports can
be connected together so that data written to an output port can be read
from an input port. These connections can be 1:1, 1:N OR N:1.

Ports may be associated with software only, or with hardware. Hardware
related ports are often referred to as physical, and correspond to some
relevant physical entity on a hardware device, such as an audio jack or
a MIDI connector. Physical ports may be potentially asked to monitor
their inputs, though some implementations may not support this.

Most physical ports will also be considered “terminal”, which means that
data delivered there or read from there will go to or comes from a
system outside of the PortEngine implementation’s control (e.g. the
analog domain for audio, or external MIDI devices for MIDI).
Non-physical ports can also be considered “terminal”. For example, the
output port of a software synthesizer is a terminal port, because the
data contained in its buffer does not and cannot be considered to come
from any other port - it is synthesized by its owner.

Ports also have latency associated with them. Each port has a playback
latency and a capture latency:

\sphinxstylestrong{capture latency}: how long since the data read from the buffer of a
port arrived at at a terminal port. The data will have come from the
“outside world” if the terminal port is also physical, or will have been
synthesized by the entity that owns the terminal port.

\sphinxstylestrong{playback latency}: how long until the data written to the buffer of
port will reach a terminal port.

For more detailed questions about the PortEngine API, consult the JACK
API documentation, on which this entire object is based.



This class object is only used indirectly as return-value and
function-parameter. It provides no methods by itself.


\section{∁ ARDOUR:PortList}
\label{\detokenize{index:ardour-portlist}}\label{\detokenize{index:id216}}
\sphinxstyleemphasis{C‡}: std::list\textless{}boost::shared\_ptr\textless{}ARDOUR::Port\textgreater{} \textgreater{}





Constructor

ℂ

ARDOUR.PortList()

Methods

{\hyperref[\detokenize{index:ARDOUR:Port}]{\emph{Port}}}

back()

bool

empty()

{\hyperref[\detokenize{index:ARDOUR:Port}]{\emph{Port}}}

front()

\sphinxstyleemphasis{LuaIter}

iter()

void

reverse()

unsigned long

size()

\sphinxstyleemphasis{LuaTable}

table()


\section{∁ ARDOUR:PortManager}
\label{\detokenize{index:ardour-portmanager}}\label{\detokenize{index:id217}}
\sphinxstyleemphasis{C‡}: ARDOUR::PortManager





Methods

int

connect(std::string, std::string)

bool

connected(std::string)

int

disconnect(std::string, std::string)

int

disconnect\_port({\hyperref[\detokenize{index:ARDOUR:Port}]{\emph{Port}}})

\sphinxstyleemphasis{LuaTable}(int, …)

get\_backend\_ports(std::string,{\hyperref[\detokenize{index:ARDOUR:DataType}]{\emph{DataType}}},{\hyperref[\detokenize{index:ARDOUR.PortFlags}]{\emph{PortFlags}}},{\hyperref[\detokenize{index:C:StringVector}]{\emph{StringVector\&}}})

\sphinxstyleemphasis{LuaTable}(int, …)

get\_connections(std::string,{\hyperref[\detokenize{index:C:StringVector}]{\emph{StringVector\&}}})

void

get\_physical\_inputs({\hyperref[\detokenize{index:ARDOUR:DataType}]{\emph{DataType}}},{\hyperref[\detokenize{index:C:StringVector}]{\emph{StringVector\&}}},{\hyperref[\detokenize{index:ARDOUR.MidiPortFlags}]{\emph{MidiPortFlags}}},{\hyperref[\detokenize{index:ARDOUR.MidiPortFlags}]{\emph{MidiPortFlags}}})

void

get\_physical\_outputs({\hyperref[\detokenize{index:ARDOUR:DataType}]{\emph{DataType}}},{\hyperref[\detokenize{index:C:StringVector}]{\emph{StringVector\&}}},{\hyperref[\detokenize{index:ARDOUR.MidiPortFlags}]{\emph{MidiPortFlags}}},{\hyperref[\detokenize{index:ARDOUR.MidiPortFlags}]{\emph{MidiPortFlags}}})

{\hyperref[\detokenize{index:ARDOUR:Port}]{\emph{Port}}}

get\_port\_by\_name(std::string)


\begin{description}
\item[{name}] \leavevmode
Full or short name of port

\end{description}



Returns Corresponding Port or 0.





\sphinxstyleemphasis{LuaTable}(int, …)

get\_ports({\hyperref[\detokenize{index:ARDOUR:DataType}]{\emph{DataType}}},{\hyperref[\detokenize{index:ARDOUR:PortList}]{\emph{PortList\&}}})

std::string

get\_pretty\_name\_by\_name(std::string)

{\hyperref[\detokenize{index:ARDOUR:ChanCount}]{\emph{ChanCount}}}

n\_physical\_inputs()

{\hyperref[\detokenize{index:ARDOUR:ChanCount}]{\emph{ChanCount}}}

n\_physical\_outputs()

bool

physically\_connected(std::string)

{\hyperref[\detokenize{index:ARDOUR:PortEngine}]{\emph{PortEngine}}}

port\_engine()

bool

port\_is\_physical(std::string)


\section{↠ ARDOUR:PortSet}
\label{\detokenize{index:ardour-portset}}\label{\detokenize{index:id218}}
\sphinxstyleemphasis{C‡}: boost::shared\_ptr\textless{} ARDOUR::PortSet \textgreater{}, boost::weak\_ptr\textless{}
ARDOUR::PortSet \textgreater{}







An ordered list of Ports, possibly of various types.

This allows access to all the ports as a list, ignoring type, or
accessing the nth port of a given type. Note that port(n) and
nth\_audio\_port(n) may NOT return the same port.

Each port is held twice; once in a per-type vector of vectors (\_ports)
and once in a vector of all port (\_all\_ports). This is to speed up the
fairly common case of iterating over all ports.



Methods

void

add({\hyperref[\detokenize{index:ARDOUR:Port}]{\emph{Port}}})

void

clear()



Remove all ports from the PortSet. Ports are not deregistered with the
engine, it’s the caller’s responsibility to not leak here!



bool

contains({\hyperref[\detokenize{index:ARDOUR:Port}]{\emph{Port}}})

bool

empty()

bool

isnil()

unsigned long

num\_ports({\hyperref[\detokenize{index:ARDOUR:DataType}]{\emph{DataType}}})

{\hyperref[\detokenize{index:ARDOUR:Port}]{\emph{Port}}}

port({\hyperref[\detokenize{index:ARDOUR:DataType}]{\emph{DataType}}}, unsigned long)



nth port of type \sphinxstyleemphasis{t,} or nth port if t = NIL
\begin{description}
\item[{t}] \leavevmode
data type

\item[{index}] \leavevmode
port index

\end{description}



bool

remove({\hyperref[\detokenize{index:ARDOUR:Port}]{\emph{Port}}})


\section{∁ ARDOUR:PresentationInfo}
\label{\detokenize{index:ardour-presentationinfo}}\label{\detokenize{index:id219}}
\sphinxstyleemphasis{C‡}: ARDOUR::PresentationInfo

is-a: {\hyperref[\detokenize{index:PBD:Stateful}]{\emph{PBD:Stateful}}}







Base class for objects with saveable and undoable state



Methods

unsigned int

color()

{\hyperref[\detokenize{index:ARDOUR.PresentationInfo.Flag}]{\emph{Flag}}}

flags()

unsigned int

order()

void

set\_color(unsigned int)

bool

special(bool)


\subsection{Inherited from PBD:Stateful}
\label{\detokenize{index:inherited-from-pbdstateful-4}}\label{\detokenize{index:id220}}
Methods

void

clear\_changes()



Forget about any changes to this object’s properties



{\hyperref[\detokenize{index:PBD:ID}]{\emph{ID}}}

id()

{\hyperref[\detokenize{index:ARDOUR:OwnedPropertyList}]{\emph{OwnedPropertyList}}}

properties()


\section{∁ ARDOUR:PresetRecord}
\label{\detokenize{index:ardour-presetrecord}}\label{\detokenize{index:id221}}
\sphinxstyleemphasis{C‡}: ARDOUR::Plugin::PresetRecord





Constructor

ℂ

ARDOUR.PresetRecord()

Data Members

std::string

label

std::string

uri

bool

user

bool

valid


\section{∁ ARDOUR:PresetVector}
\label{\detokenize{index:ardour-presetvector}}\label{\detokenize{index:id222}}
\sphinxstyleemphasis{C‡}: std::vector\textless{}ARDOUR::Plugin::PresetRecord \textgreater{}





Constructor

ℂ

ARDOUR.PresetVector()

ℂ

ARDOUR.PresetVector()

Methods

\sphinxstyleemphasis{LuaTable}

add(LuaTable \{{\hyperref[\detokenize{index:ARDOUR:PresetRecord}]{\emph{PresetRecord}}}\})

{\hyperref[\detokenize{index:ARDOUR:PresetRecord}]{\emph{PresetRecord}}}

at(unsigned long)

bool

empty()

\sphinxstyleemphasis{LuaIter}

iter()

void

push\_back({\hyperref[\detokenize{index:ARDOUR:PresetRecord}]{\emph{PresetRecord}}})

unsigned long

size()

\sphinxstyleemphasis{LuaTable}

table()


\section{↠ ARDOUR:Processor}
\label{\detokenize{index:ardour-processor}}\label{\detokenize{index:id223}}
\sphinxstyleemphasis{C‡}: boost::shared\_ptr\textless{} ARDOUR::Processor \textgreater{}, boost::weak\_ptr\textless{}
ARDOUR::Processor \textgreater{}

is-a: {\hyperref[\detokenize{index:ARDOUR:SessionObjectPtr}]{\emph{ARDOUR:SessionObjectPtr}}}







A mixer strip element - plugin, send, meter, etc



Methods

void

activate()

bool

active()

void

deactivate()

std::string

display\_name()

bool

display\_to\_user()

{\hyperref[\detokenize{index:ARDOUR:ChanCount}]{\emph{ChanCount}}}

input\_streams()

bool

isnil()

{\hyperref[\detokenize{index:ARDOUR:ChanCount}]{\emph{ChanCount}}}

output\_streams()

Cast

{\hyperref[\detokenize{index:ARDOUR:Amp}]{\emph{Amp}}}

to\_amp()

{\hyperref[\detokenize{index:ARDOUR:Automatable}]{\emph{Automatable}}}

to\_automatable()

{\hyperref[\detokenize{index:ARDOUR:PluginInsert}]{\emph{PluginInsert}}}

to\_insert()

{\hyperref[\detokenize{index:ARDOUR:IOProcessor}]{\emph{IOProcessor}}}

to\_ioprocessor()

{\hyperref[\detokenize{index:ARDOUR:PeakMeter}]{\emph{PeakMeter}}}

to\_meter()

{\hyperref[\detokenize{index:ARDOUR:MonitorProcessor}]{\emph{MonitorProcessor}}}

to\_monitorprocessor()

{\hyperref[\detokenize{index:ARDOUR:PeakMeter}]{\emph{PeakMeter}}}

to\_peakmeter()

{\hyperref[\detokenize{index:ARDOUR:PluginInsert}]{\emph{PluginInsert}}}

to\_plugininsert()

{\hyperref[\detokenize{index:ARDOUR:SideChain}]{\emph{SideChain}}}

to\_sidechain()

{\hyperref[\detokenize{index:ARDOUR:UnknownProcessor}]{\emph{UnknownProcessor}}}

to\_unknownprocessor()


\subsection{Inherited from ARDOUR:SessionObjectPtr}
\label{\detokenize{index:inherited-from-ardoursessionobjectptr-18}}\label{\detokenize{index:id224}}
Methods

std::string

name()

Cast

{\hyperref[\detokenize{index:PBD:Stateful}]{\emph{Stateful}}}

to\_stateful()

{\hyperref[\detokenize{index:PBD:StatefulDestructible}]{\emph{StatefulDestructible}}}

to\_statefuldestructible()


\section{∁ ARDOUR:ProcessorList}
\label{\detokenize{index:ardour-processorlist}}\label{\detokenize{index:id225}}
\sphinxstyleemphasis{C‡}: std::list\textless{}boost::shared\_ptr\textless{}ARDOUR::Processor\textgreater{} \textgreater{}





Constructor

ℂ

ARDOUR.ProcessorList()

Methods

\sphinxstyleemphasis{LuaTable}

add(LuaTable \{{\hyperref[\detokenize{index:ARDOUR:Processor}]{\emph{Processor}}}\})

{\hyperref[\detokenize{index:ARDOUR:Processor}]{\emph{Processor}}}

back()

bool

empty()

{\hyperref[\detokenize{index:ARDOUR:Processor}]{\emph{Processor}}}

front()

\sphinxstyleemphasis{LuaIter}

iter()

void

push\_back({\hyperref[\detokenize{index:ARDOUR:Processor}]{\emph{Processor}}})

void

reverse()

unsigned long

size()

\sphinxstyleemphasis{LuaTable}

table()

void

unique()


\section{∁ ARDOUR:ProcessorVector}
\label{\detokenize{index:ardour-processorvector}}\label{\detokenize{index:id226}}
\sphinxstyleemphasis{C‡}: std::vector\textless{}boost::shared\_ptr\textless{}ARDOUR::Processor\textgreater{} \textgreater{}





Constructor

ℂ

ARDOUR.ProcessorVector()

ℂ

ARDOUR.ProcessorVector()

Methods

\sphinxstyleemphasis{LuaTable}

add(LuaTable \{{\hyperref[\detokenize{index:ARDOUR:Processor}]{\emph{Processor}}}\})

{\hyperref[\detokenize{index:ARDOUR:Processor}]{\emph{Processor}}}

at(unsigned long)

bool

empty()

\sphinxstyleemphasis{LuaIter}

iter()

void

push\_back({\hyperref[\detokenize{index:ARDOUR:Processor}]{\emph{Processor}}})

unsigned long

size()

\sphinxstyleemphasis{LuaTable}

table()


\section{∅ ARDOUR:Progress}
\label{\detokenize{index:ardour-progress}}\label{\detokenize{index:id227}}
\sphinxstyleemphasis{C‡}: ARDOUR::Progress







A class to handle reporting of progress of something



This class object is only used indirectly as return-value and
function-parameter. It provides no methods by itself.


\section{∅ ARDOUR:Properties:BoolProperty}
\label{\detokenize{index:ardour-properties-boolproperty}}\label{\detokenize{index:id228}}
\sphinxstyleemphasis{C‡}: PBD::PropertyDescriptor\textless{}bool\textgreater{}





This class object is only used indirectly as return-value and
function-parameter. It provides no methods by itself.


\section{∅ ARDOUR:Properties:FloatProperty}
\label{\detokenize{index:ardour-properties-floatproperty}}\label{\detokenize{index:id229}}
\sphinxstyleemphasis{C‡}: PBD::PropertyDescriptor\textless{}float\textgreater{}





This class object is only used indirectly as return-value and
function-parameter. It provides no methods by itself.


\section{∅ ARDOUR:Properties:FrameposProperty}
\label{\detokenize{index:ardour-properties-frameposproperty}}\label{\detokenize{index:id230}}
\sphinxstyleemphasis{C‡}: PBD::PropertyDescriptor\textless{}long\textgreater{}





This class object is only used indirectly as return-value and
function-parameter. It provides no methods by itself.


\section{∁ ARDOUR:PropertyChange}
\label{\detokenize{index:ardour-propertychange}}\label{\detokenize{index:id231}}
\sphinxstyleemphasis{C‡}: PBD::PropertyChange







A list of IDs of Properties that have changed in some situation or other



Methods

bool

containsBool({\hyperref[\detokenize{index:ARDOUR:Properties:BoolProperty}]{\emph{BoolProperty}}})

bool

containsFloat({\hyperref[\detokenize{index:ARDOUR:Properties:FloatProperty}]{\emph{FloatProperty}}})

bool

containsFramePos({\hyperref[\detokenize{index:ARDOUR:Properties:FrameposProperty}]{\emph{FrameposProperty}}})


\section{∅ ARDOUR:PropertyList}
\label{\detokenize{index:ardour-propertylist}}\label{\detokenize{index:id232}}
\sphinxstyleemphasis{C‡}: PBD::PropertyList







A list of properties, mapped using their ID



This class object is only used indirectly as return-value and
function-parameter. It provides no methods by itself.


\section{∁ ARDOUR:RCConfiguration}
\label{\detokenize{index:ardour-rcconfiguration}}\label{\detokenize{index:id233}}
\sphinxstyleemphasis{C‡}: ARDOUR::RCConfiguration

is-a: {\hyperref[\detokenize{index:PBD:Configuration}]{\emph{PBD:Configuration}}}







Base class for objects with saveable and undoable state



Methods

{\hyperref[\detokenize{index:ARDOUR.AFLPosition}]{\emph{AFLPosition}}}

get\_afl\_position()

bool

get\_all\_safe()

bool

get\_allow\_special\_bus\_removal()

bool

get\_ask\_replace\_instrument()

bool

get\_ask\_setup\_instrument()

float

get\_audio\_capture\_buffer\_seconds()

float

get\_audio\_playback\_buffer\_seconds()

std::string

get\_auditioner\_output\_left()

std::string

get\_auditioner\_output\_right()

bool

get\_auto\_analyse\_audio()

bool

get\_auto\_connect\_standard\_busses()

{\hyperref[\detokenize{index:ARDOUR.AutoReturnTarget}]{\emph{AutoReturnTarget}}}

get\_auto\_return\_target\_list()

bool

get\_automation\_follows\_regions()

float

get\_automation\_interval\_msecs()

double

get\_automation\_thinning\_factor()

{\hyperref[\detokenize{index:ARDOUR.BufferingPreset}]{\emph{BufferingPreset}}}

get\_buffering\_preset()

std::string

get\_click\_emphasis\_sound()

float

get\_click\_gain()

bool

get\_click\_record\_only()

std::string

get\_click\_sound()

bool

get\_clicking()

bool

get\_copy\_demo\_sessions()

bool

get\_create\_xrun\_marker()

{\hyperref[\detokenize{index:ARDOUR.FadeShape}]{\emph{FadeShape}}}

get\_default\_fade\_shape()

std::string

get\_default\_session\_parent\_dir()

{\hyperref[\detokenize{index:ARDOUR.DenormalModel}]{\emph{DenormalModel}}}

get\_denormal\_model()

bool

get\_denormal\_protection()

bool

get\_disable\_disarm\_during\_roll()

bool

get\_discover\_audio\_units()

bool

get\_discover\_vst\_on\_start()

unsigned int

get\_disk\_choice\_space\_threshold()

std::string

get\_donate\_url()

{\hyperref[\detokenize{index:ARDOUR.EditMode}]{\emph{EditMode}}}

get\_edit\_mode()

bool

get\_exclusive\_solo()

float

get\_export\_preroll()

float

get\_export\_silence\_threshold()

unsigned int

get\_feedback\_interval\_ms()

bool

get\_first\_midi\_bank\_is\_zero()

std::string

get\_freesound\_download\_dir()

bool

get\_hide\_dummy\_backend()

bool

get\_hiding\_groups\_deactivates\_groups()

int

get\_history\_depth()

int

get\_initial\_program\_change()

{\hyperref[\detokenize{index:ARDOUR.AutoConnectOption}]{\emph{AutoConnectOption}}}

get\_input\_auto\_connect()

int

get\_inter\_scene\_gap\_frames()

bool

get\_latched\_record\_enable()

{\hyperref[\detokenize{index:ARDOUR.LayerModel}]{\emph{LayerModel}}}

get\_layer\_model()

bool

get\_link\_send\_and\_route\_panner()

std::string

get\_linux\_pingback\_url()

{\hyperref[\detokenize{index:ARDOUR.ListenPosition}]{\emph{ListenPosition}}}

get\_listen\_position()

bool

get\_locate\_while\_waiting\_for\_sync()

bool

get\_loop\_is\_mode()

std::string

get\_ltc\_output\_port()

float

get\_ltc\_output\_volume()

bool

get\_ltc\_send\_continuously()

std::string

get\_ltc\_source\_port()

float

get\_max\_gain()

unsigned int

get\_max\_recent\_sessions()

unsigned int

get\_max\_recent\_templates()

float

get\_meter\_falloff()

{\hyperref[\detokenize{index:ARDOUR.MeterType}]{\emph{MeterType}}}

get\_meter\_type\_bus()

{\hyperref[\detokenize{index:ARDOUR.MeterType}]{\emph{MeterType}}}

get\_meter\_type\_master()

{\hyperref[\detokenize{index:ARDOUR.MeterType}]{\emph{MeterType}}}

get\_meter\_type\_track()

std::string

get\_midi\_audition\_synth\_uri()

bool

get\_midi\_feedback()

bool

get\_midi\_input\_follows\_selection()

float

get\_midi\_readahead()

float

get\_midi\_track\_buffer\_seconds()

unsigned int

get\_minimum\_disk\_read\_bytes()

unsigned int

get\_minimum\_disk\_write\_bytes()

bool

get\_mmc\_control()

int

get\_mmc\_receive\_device\_id()

int

get\_mmc\_send\_device\_id()

std::string

get\_monitor\_bus\_preferred\_bundle()

{\hyperref[\detokenize{index:ARDOUR.MonitorModel}]{\emph{MonitorModel}}}

get\_monitoring\_model()

int

get\_mtc\_qf\_speed\_tolerance()

bool

get\_mute\_affects\_control\_outs()

bool

get\_mute\_affects\_main\_outs()

bool

get\_mute\_affects\_post\_fader()

bool

get\_mute\_affects\_pre\_fader()

bool

get\_new\_plugins\_active()

unsigned int

get\_osc\_port()

std::string

get\_osx\_pingback\_url()

{\hyperref[\detokenize{index:ARDOUR.AutoConnectOption}]{\emph{AutoConnectOption}}}

get\_output\_auto\_connect()

unsigned int

get\_periodic\_safety\_backup\_interval()

bool

get\_periodic\_safety\_backups()

{\hyperref[\detokenize{index:ARDOUR.PFLPosition}]{\emph{PFLPosition}}}

get\_pfl\_position()

std::string

get\_plugin\_path\_lxvst()

std::string

get\_plugin\_path\_vst()

bool

get\_plugins\_stop\_with\_transport()

long

get\_postroll()

long

get\_preroll()

float

get\_preroll\_seconds()

int

get\_processor\_usage()

bool

get\_quieten\_at\_speed()

long

get\_range\_location\_minimum()

std::string

get\_reference\_manual\_url()

bool

get\_region\_boundaries\_from\_onscreen\_tracks()

bool

get\_region\_boundaries\_from\_selected\_tracks()

{\hyperref[\detokenize{index:ARDOUR.RegionSelectionAfterSplit}]{\emph{RegionSelectionAfterSplit}}}

get\_region\_selection\_after\_split()

bool

get\_replicate\_missing\_region\_channels()

float

get\_rf\_speed()

bool

get\_save\_history()

int

get\_saved\_history\_depth()

bool

get\_seamless\_loop()

bool

get\_send\_ltc()

bool

get\_send\_midi\_clock()

bool

get\_send\_mmc()

bool

get\_send\_mtc()

bool

get\_show\_solo\_mutes()

bool

get\_show\_video\_export\_info()

bool

get\_show\_video\_server\_dialog()

{\hyperref[\detokenize{index:ARDOUR.ShuttleBehaviour}]{\emph{ShuttleBehaviour}}}

get\_shuttle\_behaviour()

float

get\_shuttle\_max\_speed()

float

get\_shuttle\_speed\_factor()

float

get\_shuttle\_speed\_threshold()

{\hyperref[\detokenize{index:ARDOUR.ShuttleUnits}]{\emph{ShuttleUnits}}}

get\_shuttle\_units()

bool

get\_skip\_playback()

bool

get\_solo\_control\_is\_listen\_control()

float

get\_solo\_mute\_gain()

bool

get\_solo\_mute\_override()

bool

get\_stop\_at\_session\_end()

bool

get\_stop\_recording\_on\_xrun()

bool

get\_strict\_io()

{\hyperref[\detokenize{index:ARDOUR.SyncSource}]{\emph{SyncSource}}}

get\_sync\_source()

bool

get\_tape\_machine\_mode()

bool

get\_timecode\_source\_2997()

bool

get\_timecode\_source\_is\_synced()

bool

get\_timecode\_sync\_frame\_rate()

bool

get\_trace\_midi\_input()

bool

get\_trace\_midi\_output()

{\hyperref[\detokenize{index:ARDOUR.TracksAutoNamingRule}]{\emph{TracksAutoNamingRule}}}

get\_tracks\_auto\_naming()

float

get\_transient\_sensitivity()

bool

get\_try\_autostart\_engine()

std::string

get\_tutorial\_manual\_url()

std::string

get\_updates\_url()

bool

get\_use\_click\_emphasis()

bool

get\_use\_lxvst()

bool

get\_use\_macvst()

bool

get\_use\_monitor\_bus()

bool

get\_use\_osc()

bool

get\_use\_overlap\_equivalency()

bool

get\_use\_plugin\_own\_gui()

bool

get\_use\_tranzport()

bool

get\_use\_windows\_vst()

bool

get\_verbose\_plugin\_scan()

bool

get\_verify\_remove\_last\_capture()

bool

get\_video\_advanced\_setup()

std::string

get\_video\_server\_docroot()

std::string

get\_video\_server\_url()

int

get\_vst\_scan\_timeout()

std::string

get\_windows\_pingback\_url()

bool

set\_afl\_position({\hyperref[\detokenize{index:ARDOUR.AFLPosition}]{\emph{AFLPosition}}})

bool

set\_all\_safe(bool)

bool

set\_allow\_special\_bus\_removal(bool)

bool

set\_ask\_replace\_instrument(bool)

bool

set\_ask\_setup\_instrument(bool)

bool

set\_audio\_capture\_buffer\_seconds(float)

bool

set\_audio\_playback\_buffer\_seconds(float)

bool

set\_auditioner\_output\_left(std::string)

bool

set\_auditioner\_output\_right(std::string)

bool

set\_auto\_analyse\_audio(bool)

bool

set\_auto\_connect\_standard\_busses(bool)

bool

set\_auto\_return\_target\_list({\hyperref[\detokenize{index:ARDOUR.AutoReturnTarget}]{\emph{AutoReturnTarget}}})

bool

set\_automation\_follows\_regions(bool)

bool

set\_automation\_interval\_msecs(float)

bool

set\_automation\_thinning\_factor(double)

bool

set\_buffering\_preset({\hyperref[\detokenize{index:ARDOUR.BufferingPreset}]{\emph{BufferingPreset}}})

bool

set\_click\_emphasis\_sound(std::string)

bool

set\_click\_gain(float)

bool

set\_click\_record\_only(bool)

bool

set\_click\_sound(std::string)

bool

set\_clicking(bool)

bool

set\_copy\_demo\_sessions(bool)

bool

set\_create\_xrun\_marker(bool)

bool

set\_default\_fade\_shape({\hyperref[\detokenize{index:ARDOUR.FadeShape}]{\emph{FadeShape}}})

bool

set\_default\_session\_parent\_dir(std::string)

bool

set\_denormal\_model({\hyperref[\detokenize{index:ARDOUR.DenormalModel}]{\emph{DenormalModel}}})

bool

set\_denormal\_protection(bool)

bool

set\_disable\_disarm\_during\_roll(bool)

bool

set\_discover\_audio\_units(bool)

bool

set\_discover\_vst\_on\_start(bool)

bool

set\_disk\_choice\_space\_threshold(unsigned int)

bool

set\_donate\_url(std::string)

bool

set\_edit\_mode({\hyperref[\detokenize{index:ARDOUR.EditMode}]{\emph{EditMode}}})

bool

set\_exclusive\_solo(bool)

bool

set\_export\_preroll(float)

bool

set\_export\_silence\_threshold(float)

bool

set\_feedback\_interval\_ms(unsigned int)

bool

set\_first\_midi\_bank\_is\_zero(bool)

bool

set\_freesound\_download\_dir(std::string)

bool

set\_hide\_dummy\_backend(bool)

bool

set\_hiding\_groups\_deactivates\_groups(bool)

bool

set\_history\_depth(int)

bool

set\_initial\_program\_change(int)

bool

set\_input\_auto\_connect({\hyperref[\detokenize{index:ARDOUR.AutoConnectOption}]{\emph{AutoConnectOption}}})

bool

set\_inter\_scene\_gap\_frames(int)

bool

set\_latched\_record\_enable(bool)

bool

set\_layer\_model({\hyperref[\detokenize{index:ARDOUR.LayerModel}]{\emph{LayerModel}}})

bool

set\_link\_send\_and\_route\_panner(bool)

bool

set\_linux\_pingback\_url(std::string)

bool

set\_listen\_position({\hyperref[\detokenize{index:ARDOUR.ListenPosition}]{\emph{ListenPosition}}})

bool

set\_locate\_while\_waiting\_for\_sync(bool)

bool

set\_loop\_is\_mode(bool)

bool

set\_ltc\_output\_port(std::string)

bool

set\_ltc\_output\_volume(float)

bool

set\_ltc\_send\_continuously(bool)

bool

set\_ltc\_source\_port(std::string)

bool

set\_max\_gain(float)

bool

set\_max\_recent\_sessions(unsigned int)

bool

set\_max\_recent\_templates(unsigned int)

bool

set\_meter\_falloff(float)

bool

set\_meter\_type\_bus({\hyperref[\detokenize{index:ARDOUR.MeterType}]{\emph{MeterType}}})

bool

set\_meter\_type\_master({\hyperref[\detokenize{index:ARDOUR.MeterType}]{\emph{MeterType}}})

bool

set\_meter\_type\_track({\hyperref[\detokenize{index:ARDOUR.MeterType}]{\emph{MeterType}}})

bool

set\_midi\_audition\_synth\_uri(std::string)

bool

set\_midi\_feedback(bool)

bool

set\_midi\_input\_follows\_selection(bool)

bool

set\_midi\_readahead(float)

bool

set\_midi\_track\_buffer\_seconds(float)

bool

set\_minimum\_disk\_read\_bytes(unsigned int)

bool

set\_minimum\_disk\_write\_bytes(unsigned int)

bool

set\_mmc\_control(bool)

bool

set\_mmc\_receive\_device\_id(int)

bool

set\_mmc\_send\_device\_id(int)

bool

set\_monitor\_bus\_preferred\_bundle(std::string)

bool

set\_monitoring\_model({\hyperref[\detokenize{index:ARDOUR.MonitorModel}]{\emph{MonitorModel}}})

bool

set\_mtc\_qf\_speed\_tolerance(int)

bool

set\_mute\_affects\_control\_outs(bool)

bool

set\_mute\_affects\_main\_outs(bool)

bool

set\_mute\_affects\_post\_fader(bool)

bool

set\_mute\_affects\_pre\_fader(bool)

bool

set\_new\_plugins\_active(bool)

bool

set\_osc\_port(unsigned int)

bool

set\_osx\_pingback\_url(std::string)

bool

set\_output\_auto\_connect({\hyperref[\detokenize{index:ARDOUR.AutoConnectOption}]{\emph{AutoConnectOption}}})

bool

set\_periodic\_safety\_backup\_interval(unsigned int)

bool

set\_periodic\_safety\_backups(bool)

bool

set\_pfl\_position({\hyperref[\detokenize{index:ARDOUR.PFLPosition}]{\emph{PFLPosition}}})

bool

set\_plugin\_path\_lxvst(std::string)

bool

set\_plugin\_path\_vst(std::string)

bool

set\_plugins\_stop\_with\_transport(bool)

bool

set\_postroll(long)

bool

set\_preroll(long)

bool

set\_preroll\_seconds(float)

bool

set\_processor\_usage(int)

bool

set\_quieten\_at\_speed(bool)

bool

set\_range\_location\_minimum(long)

bool

set\_reference\_manual\_url(std::string)

bool

set\_region\_boundaries\_from\_onscreen\_tracks(bool)

bool

set\_region\_boundaries\_from\_selected\_tracks(bool)

bool

set\_region\_selection\_after\_split({\hyperref[\detokenize{index:ARDOUR.RegionSelectionAfterSplit}]{\emph{RegionSelectionAfterSplit}}})

bool

set\_replicate\_missing\_region\_channels(bool)

bool

set\_rf\_speed(float)

bool

set\_save\_history(bool)

bool

set\_saved\_history\_depth(int)

bool

set\_seamless\_loop(bool)

bool

set\_send\_ltc(bool)

bool

set\_send\_midi\_clock(bool)

bool

set\_send\_mmc(bool)

bool

set\_send\_mtc(bool)

bool

set\_show\_solo\_mutes(bool)

bool

set\_show\_video\_export\_info(bool)

bool

set\_show\_video\_server\_dialog(bool)

bool

set\_shuttle\_behaviour({\hyperref[\detokenize{index:ARDOUR.ShuttleBehaviour}]{\emph{ShuttleBehaviour}}})

bool

set\_shuttle\_max\_speed(float)

bool

set\_shuttle\_speed\_factor(float)

bool

set\_shuttle\_speed\_threshold(float)

bool

set\_shuttle\_units({\hyperref[\detokenize{index:ARDOUR.ShuttleUnits}]{\emph{ShuttleUnits}}})

bool

set\_skip\_playback(bool)

bool

set\_solo\_control\_is\_listen\_control(bool)

bool

set\_solo\_mute\_gain(float)

bool

set\_solo\_mute\_override(bool)

bool

set\_stop\_at\_session\_end(bool)

bool

set\_stop\_recording\_on\_xrun(bool)

bool

set\_strict\_io(bool)

bool

set\_sync\_source({\hyperref[\detokenize{index:ARDOUR.SyncSource}]{\emph{SyncSource}}})

bool

set\_tape\_machine\_mode(bool)

bool

set\_timecode\_source\_2997(bool)

bool

set\_timecode\_source\_is\_synced(bool)

bool

set\_timecode\_sync\_frame\_rate(bool)

bool

set\_trace\_midi\_input(bool)

bool

set\_trace\_midi\_output(bool)

bool

set\_tracks\_auto\_naming({\hyperref[\detokenize{index:ARDOUR.TracksAutoNamingRule}]{\emph{TracksAutoNamingRule}}})

bool

set\_transient\_sensitivity(float)

bool

set\_try\_autostart\_engine(bool)

bool

set\_tutorial\_manual\_url(std::string)

bool

set\_updates\_url(std::string)

bool

set\_use\_click\_emphasis(bool)

bool

set\_use\_lxvst(bool)

bool

set\_use\_macvst(bool)

bool

set\_use\_monitor\_bus(bool)

bool

set\_use\_osc(bool)

bool

set\_use\_overlap\_equivalency(bool)

bool

set\_use\_plugin\_own\_gui(bool)

bool

set\_use\_tranzport(bool)

bool

set\_use\_windows\_vst(bool)

bool

set\_verbose\_plugin\_scan(bool)

bool

set\_verify\_remove\_last\_capture(bool)

bool

set\_video\_advanced\_setup(bool)

bool

set\_video\_server\_docroot(std::string)

bool

set\_video\_server\_url(std::string)

bool

set\_vst\_scan\_timeout(int)

bool

set\_windows\_pingback\_url(std::string)

Properties

{\hyperref[\detokenize{index:ARDOUR.AFLPosition}]{\emph{ARDOUR.AFLPosition}}}

afl\_position

bool

all\_safe

bool

allow\_special\_bus\_removal

bool

ask\_replace\_instrument

bool

ask\_setup\_instrument

float

audio\_capture\_buffer\_seconds

float

audio\_playback\_buffer\_seconds

std::string

auditioner\_output\_left

std::string

auditioner\_output\_right

bool

auto\_analyse\_audio

bool

auto\_connect\_standard\_busses

{\hyperref[\detokenize{index:ARDOUR.AutoReturnTarget}]{\emph{ARDOUR.AutoReturnTarget}}}

auto\_return\_target\_list

bool

automation\_follows\_regions

float

automation\_interval\_msecs

double

automation\_thinning\_factor

{\hyperref[\detokenize{index:ARDOUR.BufferingPreset}]{\emph{ARDOUR.BufferingPreset}}}

buffering\_preset

std::string

click\_emphasis\_sound

float

click\_gain

bool

click\_record\_only

std::string

click\_sound

bool

clicking

bool

copy\_demo\_sessions

bool

create\_xrun\_marker

{\hyperref[\detokenize{index:ARDOUR.FadeShape}]{\emph{ARDOUR.FadeShape}}}

default\_fade\_shape

std::string

default\_session\_parent\_dir

{\hyperref[\detokenize{index:ARDOUR.DenormalModel}]{\emph{ARDOUR.DenormalModel}}}

denormal\_model

bool

denormal\_protection

bool

disable\_disarm\_during\_roll

bool

discover\_audio\_units

bool

discover\_vst\_on\_start

unsigned int

disk\_choice\_space\_threshold

std::string

donate\_url

{\hyperref[\detokenize{index:ARDOUR.EditMode}]{\emph{ARDOUR.EditMode}}}

edit\_mode

bool

exclusive\_solo

float

export\_preroll

float

export\_silence\_threshold

unsigned int

feedback\_interval\_ms

bool

first\_midi\_bank\_is\_zero

std::string

freesound\_download\_dir

bool

hide\_dummy\_backend

bool

hiding\_groups\_deactivates\_groups

int

history\_depth

int

initial\_program\_change

{\hyperref[\detokenize{index:ARDOUR.AutoConnectOption}]{\emph{ARDOUR.AutoConnectOption}}}

input\_auto\_connect

int

inter\_scene\_gap\_frames

bool

latched\_record\_enable

{\hyperref[\detokenize{index:ARDOUR.LayerModel}]{\emph{ARDOUR.LayerModel}}}

layer\_model

bool

link\_send\_and\_route\_panner

std::string

linux\_pingback\_url

{\hyperref[\detokenize{index:ARDOUR.ListenPosition}]{\emph{ARDOUR.ListenPosition}}}

listen\_position

bool

locate\_while\_waiting\_for\_sync

bool

loop\_is\_mode

std::string

ltc\_output\_port

float

ltc\_output\_volume

bool

ltc\_send\_continuously

std::string

ltc\_source\_port

float

max\_gain

unsigned int

max\_recent\_sessions

unsigned int

max\_recent\_templates

float

meter\_falloff

{\hyperref[\detokenize{index:ARDOUR.MeterType}]{\emph{ARDOUR.MeterType}}}

meter\_type\_bus

{\hyperref[\detokenize{index:ARDOUR.MeterType}]{\emph{ARDOUR.MeterType}}}

meter\_type\_master

{\hyperref[\detokenize{index:ARDOUR.MeterType}]{\emph{ARDOUR.MeterType}}}

meter\_type\_track

std::string

midi\_audition\_synth\_uri

bool

midi\_feedback

bool

midi\_input\_follows\_selection

float

midi\_readahead

float

midi\_track\_buffer\_seconds

unsigned int

minimum\_disk\_read\_bytes

unsigned int

minimum\_disk\_write\_bytes

bool

mmc\_control

int

mmc\_receive\_device\_id

int

mmc\_send\_device\_id

std::string

monitor\_bus\_preferred\_bundle

{\hyperref[\detokenize{index:ARDOUR.MonitorModel}]{\emph{ARDOUR.MonitorModel}}}

monitoring\_model

int

mtc\_qf\_speed\_tolerance

bool

mute\_affects\_control\_outs

bool

mute\_affects\_main\_outs

bool

mute\_affects\_post\_fader

bool

mute\_affects\_pre\_fader

bool

new\_plugins\_active

unsigned int

osc\_port

std::string

osx\_pingback\_url

{\hyperref[\detokenize{index:ARDOUR.AutoConnectOption}]{\emph{ARDOUR.AutoConnectOption}}}

output\_auto\_connect

unsigned int

periodic\_safety\_backup\_interval

bool

periodic\_safety\_backups

{\hyperref[\detokenize{index:ARDOUR.PFLPosition}]{\emph{ARDOUR.PFLPosition}}}

pfl\_position

std::string

plugin\_path\_lxvst

std::string

plugin\_path\_vst

bool

plugins\_stop\_with\_transport

long

postroll

long

preroll

float

preroll\_seconds

int

processor\_usage

bool

quieten\_at\_speed

long

range\_location\_minimum

std::string

reference\_manual\_url

bool

region\_boundaries\_from\_onscreen\_tracks

bool

region\_boundaries\_from\_selected\_tracks

{\hyperref[\detokenize{index:ARDOUR.RegionSelectionAfterSplit}]{\emph{ARDOUR.RegionSelectionAfterSplit}}}

region\_selection\_after\_split

bool

replicate\_missing\_region\_channels

float

rf\_speed

bool

save\_history

int

saved\_history\_depth

bool

seamless\_loop

bool

send\_ltc

bool

send\_midi\_clock

bool

send\_mmc

bool

send\_mtc

bool

show\_solo\_mutes

bool

show\_video\_export\_info

bool

show\_video\_server\_dialog

{\hyperref[\detokenize{index:ARDOUR.ShuttleBehaviour}]{\emph{ARDOUR.ShuttleBehaviour}}}

shuttle\_behaviour

float

shuttle\_max\_speed

float

shuttle\_speed\_factor

float

shuttle\_speed\_threshold

{\hyperref[\detokenize{index:ARDOUR.ShuttleUnits}]{\emph{ARDOUR.ShuttleUnits}}}

shuttle\_units

bool

skip\_playback

bool

solo\_control\_is\_listen\_control

float

solo\_mute\_gain

bool

solo\_mute\_override

bool

stop\_at\_session\_end

bool

stop\_recording\_on\_xrun

bool

strict\_io

{\hyperref[\detokenize{index:ARDOUR.SyncSource}]{\emph{ARDOUR.SyncSource}}}

sync\_source

bool

tape\_machine\_mode

bool

timecode\_source\_2997

bool

timecode\_source\_is\_synced

bool

timecode\_sync\_frame\_rate

bool

trace\_midi\_input

bool

trace\_midi\_output

{\hyperref[\detokenize{index:ARDOUR.TracksAutoNamingRule}]{\emph{ARDOUR.TracksAutoNamingRule}}}

tracks\_auto\_naming

float

transient\_sensitivity

bool

try\_autostart\_engine

std::string

tutorial\_manual\_url

std::string

updates\_url

bool

use\_click\_emphasis

bool

use\_lxvst

bool

use\_macvst

bool

use\_monitor\_bus

bool

use\_osc

bool

use\_overlap\_equivalency

bool

use\_plugin\_own\_gui

bool

use\_tranzport

bool

use\_windows\_vst

bool

verbose\_plugin\_scan

bool

verify\_remove\_last\_capture

bool

video\_advanced\_setup

std::string

video\_server\_docroot

std::string

video\_server\_url

int

vst\_scan\_timeout

std::string

windows\_pingback\_url


\subsection{Inherited from PBD:Stateful}
\label{\detokenize{index:inherited-from-pbdstateful-5}}\label{\detokenize{index:id234}}
Methods

void

clear\_changes()



Forget about any changes to this object’s properties



{\hyperref[\detokenize{index:PBD:ID}]{\emph{ID}}}

id()

{\hyperref[\detokenize{index:ARDOUR:OwnedPropertyList}]{\emph{OwnedPropertyList}}}

properties()


\section{↠ ARDOUR:ReadOnlyControl}
\label{\detokenize{index:ardour-readonlycontrol}}\label{\detokenize{index:id235}}
\sphinxstyleemphasis{C‡}: boost::shared\_ptr\textless{} ARDOUR::ReadOnlyControl \textgreater{}, boost::weak\_ptr\textless{}
ARDOUR::ReadOnlyControl \textgreater{}

is-a: {\hyperref[\detokenize{index:PBD:StatefulDestructiblePtr}]{\emph{PBD:StatefulDestructiblePtr}}}





Methods

{\hyperref[\detokenize{index:ARDOUR:ParameterDescriptor}]{\emph{ParameterDescriptor}}}

desc()

std::string

describe\_parameter()

double

get\_parameter()

bool

isnil()


\subsection{Inherited from PBD:StatefulPtr}
\label{\detokenize{index:inherited-from-pbdstatefulptr-7}}\label{\detokenize{index:id236}}
Methods

void

clear\_changes()



Forget about any changes to this object’s properties



{\hyperref[\detokenize{index:PBD:ID}]{\emph{ID}}}

id()

{\hyperref[\detokenize{index:ARDOUR:OwnedPropertyList}]{\emph{OwnedPropertyList}}}

properties()


\section{↠ ARDOUR:Readable}
\label{\detokenize{index:ardour-readable}}\label{\detokenize{index:id237}}
\sphinxstyleemphasis{C‡}: boost::shared\_ptr\textless{} ARDOUR::Readable \textgreater{}, boost::weak\_ptr\textless{}
ARDOUR::Readable \textgreater{}





Methods

bool

isnil()

unsigned int

n\_channels()

long

read({\hyperref[\detokenize{index:C:FloatArray}]{\emph{FloatArray}}}, long, long, int)

long

readable\_length()


\section{↠ ARDOUR:Region}
\label{\detokenize{index:ardour-region}}\label{\detokenize{index:id238}}
\sphinxstyleemphasis{C‡}: boost::shared\_ptr\textless{} ARDOUR::Region \textgreater{}, boost::weak\_ptr\textless{}
ARDOUR::Region \textgreater{}

is-a: {\hyperref[\detokenize{index:ARDOUR:SessionObjectPtr}]{\emph{ARDOUR:SessionObjectPtr}}}







A named object associated with a Session. Objects derived from this
class are expected to be destroyed before the session calls
drop\_references().



Methods

bool

at\_natural\_position()

bool

automatic()

bool

can\_move()

bool

captured()

void

clear\_sync\_position()

{\hyperref[\detokenize{index:Evoral:Control}]{\emph{Control}}}

control({\hyperref[\detokenize{index:Evoral:Parameter}]{\emph{Parameter}}}, bool)

bool

covers(long)

void

cut\_end(long, int)

void

cut\_front(long, int)

{\hyperref[\detokenize{index:ARDOUR:DataType}]{\emph{DataType}}}

data\_type()

bool

external()

bool

has\_transients()

bool

hidden()

bool

import()

bool

is\_compound()

bool

isnil()

unsigned int

layer()

long

length()

bool

locked()

void

lower()

void

lower\_to\_bottom()

{\hyperref[\detokenize{index:C:StringVector}]{\emph{StringVector}}}

master\_source\_names()

{\hyperref[\detokenize{index:ARDOUR:SourceList}]{\emph{SourceList}}}

master\_sources()

void

move\_start(long, int)

void

move\_to\_natural\_position()

bool

muted()

unsigned int

n\_channels()

void

nudge\_position(long)

bool

opaque()

long

position()



How the region parameters play together:

POSITION: first frame of the region along the timeline START: first
frame of the region within its source(s) LENGTH: number of frames the
region represents



bool

position\_locked()

double

quarter\_note()

void

raise()

void

raise\_to\_top()

void

set\_hidden(bool)

void

set\_initial\_position(long)



A gui may need to create a region, then place it in an initial position
determined by the user. When this takes place within one gui operation,
we have to reset \_last\_position to prevent an implied move.



void

set\_length(long, int)

void

set\_locked(bool)

void

set\_muted(bool)

void

set\_opaque(bool)

void

set\_position(long, int)

void

set\_position\_locked(bool)

void

set\_start(long)

void

set\_sync\_position(long)



Set the region’s sync point.
\begin{description}
\item[{absolute\_pos}] \leavevmode
Session time.

\end{description}



void

set\_video\_locked(bool)

float

shift()

{\hyperref[\detokenize{index:ARDOUR:Source}]{\emph{Source}}}

source(unsigned int)

long

start()

float

stretch()

bool

sync\_marked()

\sphinxstyleemphasis{LuaTable}(long, …)

sync\_offset(int\&)

long

sync\_position()





Returns Sync position in session time





{\hyperref[\detokenize{index:C:Int64List}]{\emph{Int64List}}}

transients()

void

trim\_end(long, int)

void

trim\_front(long, int)

void

trim\_to(long, long, int)

bool

video\_locked()

bool

whole\_file()

Cast

{\hyperref[\detokenize{index:ARDOUR:AudioRegion}]{\emph{AudioRegion}}}

to\_audioregion()

{\hyperref[\detokenize{index:ARDOUR:MidiRegion}]{\emph{MidiRegion}}}

to\_midiregion()

{\hyperref[\detokenize{index:ARDOUR:Readable}]{\emph{Readable}}}

to\_readable()


\subsection{Inherited from ARDOUR:SessionObjectPtr}
\label{\detokenize{index:inherited-from-ardoursessionobjectptr-19}}\label{\detokenize{index:id239}}
Methods

std::string

name()

Cast

{\hyperref[\detokenize{index:PBD:Stateful}]{\emph{Stateful}}}

to\_stateful()

{\hyperref[\detokenize{index:PBD:StatefulDestructible}]{\emph{StatefulDestructible}}}

to\_statefuldestructible()


\section{∁ ARDOUR:RegionFactory}
\label{\detokenize{index:ardour-regionfactory}}\label{\detokenize{index:id240}}
\sphinxstyleemphasis{C‡}: ARDOUR::RegionFactory





Methods

{\hyperref[\detokenize{index:ARDOUR:Region}]{\emph{Region}}}

clone\_region({\hyperref[\detokenize{index:ARDOUR:Region}]{\emph{Region}}}, bool, bool)

{\hyperref[\detokenize{index:ARDOUR:Region}]{\emph{Region}}}

region\_by\_id({\hyperref[\detokenize{index:PBD:ID}]{\emph{ID}}})

{\hyperref[\detokenize{index:ARDOUR:RegionMap}]{\emph{RegionMap}}}

regions()


\section{∁ ARDOUR:RegionList}
\label{\detokenize{index:ardour-regionlist}}\label{\detokenize{index:id241}}
\sphinxstyleemphasis{C‡}: std::list\textless{}boost::shared\_ptr\textless{}ARDOUR::Region\textgreater{} \textgreater{}





Constructor

ℂ

ARDOUR.RegionList()

Methods

{\hyperref[\detokenize{index:ARDOUR:Region}]{\emph{Region}}}

back()

bool

empty()

{\hyperref[\detokenize{index:ARDOUR:Region}]{\emph{Region}}}

front()

\sphinxstyleemphasis{LuaIter}

iter()

void

reverse()

unsigned long

size()

\sphinxstyleemphasis{LuaTable}

table()


\section{∁ ARDOUR:RegionListPtr}
\label{\detokenize{index:ardour-regionlistptr}}\label{\detokenize{index:id242}}
\sphinxstyleemphasis{C‡}: boost::shared\_ptr\textless{}std::list\textless{}boost::shared\_ptr\textless{}ARDOUR::Region\textgreater{} \textgreater{} \textgreater{}





Constructor

ℂ

ARDOUR.RegionListPtr()

Methods

\sphinxstyleemphasis{LuaTable}

add(LuaTable \{{\hyperref[\detokenize{index:ARDOUR:Region}]{\emph{Region}}}\})

bool

empty()

\sphinxstyleemphasis{LuaIter}

iter()

void

push\_back({\hyperref[\detokenize{index:ARDOUR:Region}]{\emph{Region}}})

void

reverse()

unsigned long

size()

\sphinxstyleemphasis{LuaTable}

table()

void

unique()


\section{∁ ARDOUR:RegionMap}
\label{\detokenize{index:ardour-regionmap}}\label{\detokenize{index:id243}}
\sphinxstyleemphasis{C‡}: std::map\textless{}PBD::ID, boost::shared\_ptr\textless{}ARDOUR::Region\textgreater{} \textgreater{} \textgreater{}





Constructor

ℂ

ARDOUR.RegionMap()

Methods

\sphinxstyleemphasis{LuaTable}

add(LuaTable \{{\hyperref[\detokenize{index:ARDOUR:Region}]{\emph{Region}}}\})

\sphinxstyleemphasis{…}

at(\textendash{}lua\textendash{})

void

clear()

unsigned long

count({\hyperref[\detokenize{index:PBD:ID}]{\emph{ID}}})

bool

empty()

\sphinxstyleemphasis{LuaIter}

iter()

unsigned long

size()

\sphinxstyleemphasis{LuaTable}

table()


\section{∁ ARDOUR:RegionVector}
\label{\detokenize{index:ardour-regionvector}}\label{\detokenize{index:id244}}
\sphinxstyleemphasis{C‡}: std::vector\textless{}boost::shared\_ptr\textless{}ARDOUR::Region\textgreater{} \textgreater{}





Constructor

ℂ

ARDOUR.RegionVector()

ℂ

ARDOUR.RegionVector()

Methods

\sphinxstyleemphasis{LuaTable}

add(LuaTable \{{\hyperref[\detokenize{index:ARDOUR:Region}]{\emph{Region}}}\})

{\hyperref[\detokenize{index:ARDOUR:Region}]{\emph{Region}}}

at(unsigned long)

bool

empty()

\sphinxstyleemphasis{LuaIter}

iter()

void

push\_back({\hyperref[\detokenize{index:ARDOUR:Region}]{\emph{Region}}})

unsigned long

size()

\sphinxstyleemphasis{LuaTable}

table()


\section{↠ ARDOUR:Route}
\label{\detokenize{index:ardour-route}}\label{\detokenize{index:id245}}
\sphinxstyleemphasis{C‡}: boost::shared\_ptr\textless{} ARDOUR::Route \textgreater{}, boost::weak\_ptr\textless{} ARDOUR::Route
\textgreater{}

is-a: {\hyperref[\detokenize{index:ARDOUR:Stripable}]{\emph{ARDOUR:Stripable}}}







A named object associated with a Session. Objects derived from this
class are expected to be destroyed before the session calls
drop\_references().



Methods

bool

active()

int

add\_processor\_by\_index({\hyperref[\detokenize{index:ARDOUR:Processor}]{\emph{Processor}}},
int,{\hyperref[\detokenize{index:ARDOUR:Route:ProcessorStreams}]{\emph{ProcessorStreams}}}, bool)



Add a processor to a route such that it ends up with a given index into
the visible processors.
\begin{description}
\item[{index}] \leavevmode
Index to add the processor at, or -1 to add at the end of the list.

\end{description}



Returns 0 on success, non-0 on failure.





bool

add\_sidechain({\hyperref[\detokenize{index:ARDOUR:Processor}]{\emph{Processor}}})

{\hyperref[\detokenize{index:ARDOUR:Amp}]{\emph{Amp}}}

amp()

std::string

comment()

bool

customize\_plugin\_insert({\hyperref[\detokenize{index:ARDOUR:Processor}]{\emph{Processor}}}, unsigned
int,{\hyperref[\detokenize{index:ARDOUR:ChanCount}]{\emph{ChanCount}}},{\hyperref[\detokenize{index:ARDOUR:ChanCount}]{\emph{ChanCount}}})



enable custom plugin-insert configuration
\begin{description}
\item[{proc}] \leavevmode
Processor to customize

\item[{count}] \leavevmode
number of plugin instances to use (if zero, reset to default)

\item[{outs}] \leavevmode
output port customization

\item[{sinks}] \leavevmode
input pins for variable-I/O plugins

\end{description}



Returns true if successful





{\hyperref[\detokenize{index:ARDOUR:IO}]{\emph{IO}}}

input()

bool

isnil()

{\hyperref[\detokenize{index:ARDOUR:Delivery}]{\emph{Delivery}}}

main\_outs()



the signal processorat at end of the processing chain which produces
output



bool

muted()

{\hyperref[\detokenize{index:ARDOUR:ChanCount}]{\emph{ChanCount}}}

n\_inputs()

{\hyperref[\detokenize{index:ARDOUR:ChanCount}]{\emph{ChanCount}}}

n\_outputs()

{\hyperref[\detokenize{index:ARDOUR:Processor}]{\emph{Processor}}}

nth\_plugin(unsigned int)

{\hyperref[\detokenize{index:ARDOUR:Processor}]{\emph{Processor}}}

nth\_processor(unsigned int)

{\hyperref[\detokenize{index:ARDOUR:Processor}]{\emph{Processor}}}

nth\_send(unsigned int)

{\hyperref[\detokenize{index:ARDOUR:IO}]{\emph{IO}}}

output()

{\hyperref[\detokenize{index:ARDOUR:PannerShell}]{\emph{PannerShell}}}

panner\_shell()

{\hyperref[\detokenize{index:ARDOUR:PeakMeter}]{\emph{PeakMeter}}}

peak\_meter()



************************************************************* Pure
interface begins
here*************************************************************



int

remove\_processor({\hyperref[\detokenize{index:ARDOUR:Processor}]{\emph{Processor}}},{\hyperref[\detokenize{index:ARDOUR:Route:ProcessorStreams}]{\emph{ProcessorStreams}}},
bool)



remove plugin/processor
\begin{description}
\item[{proc}] \leavevmode
processor to remove

\item[{err}] \leavevmode
error report (index where removal vailed, channel-count why it
failed) may be nil

\item[{need\_process\_lock}] \leavevmode
if locking is required (set to true, unless called from RT context
with lock)

\end{description}



Returns 0 on success





int

remove\_processors({\hyperref[\detokenize{index:ARDOUR:ProcessorList}]{\emph{ProcessorList}}},{\hyperref[\detokenize{index:ARDOUR:Route:ProcessorStreams}]{\emph{ProcessorStreams}}})

bool

remove\_sidechain({\hyperref[\detokenize{index:ARDOUR:Processor}]{\emph{Processor}}})

int

reorder\_processors({\hyperref[\detokenize{index:ARDOUR:ProcessorList}]{\emph{ProcessorList}}},{\hyperref[\detokenize{index:ARDOUR:Route:ProcessorStreams}]{\emph{ProcessorStreams}}})

int

replace\_processor({\hyperref[\detokenize{index:ARDOUR:Processor}]{\emph{Processor}}},{\hyperref[\detokenize{index:ARDOUR:Processor}]{\emph{Processor}}},{\hyperref[\detokenize{index:ARDOUR:Route:ProcessorStreams}]{\emph{ProcessorStreams}}})



replace plugin/processor with another
\begin{description}
\item[{old}] \leavevmode
processor to remove

\item[{sub}] \leavevmode
processor to substitute the old one with

\item[{err}] \leavevmode
error report (index where removal vailed, channel-count why it
failed) may be nil

\end{description}



Returns 0 on success





bool

reset\_plugin\_insert({\hyperref[\detokenize{index:ARDOUR:Processor}]{\emph{Processor}}})



reset plugin-insert configuration to default, disable customizations.

This is equivalent to calling

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{customize\PYGZus{}plugin\PYGZus{}insert} \PYG{p}{(}\PYG{n}{proc}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{unused}\PYG{p}{)}
\end{sphinxVerbatim}
\begin{description}
\item[{proc}] \leavevmode
Processor to reset

\end{description}



Returns true if successful





void

set\_active(bool, void*)

void

set\_comment(std::string, void*)

void

set\_meter\_point({\hyperref[\detokenize{index:ARDOUR.MeterPoint}]{\emph{MeterPoint}}}, bool)

bool

set\_name(std::string)

bool

set\_strict\_io(bool)

bool

soloed()

bool

strict\_io()

{\hyperref[\detokenize{index:ARDOUR:Processor}]{\emph{Processor}}}

the\_instrument()



Return the first processor that accepts has at least one MIDI input and
at least one audio output. In the vast majority of cases, this will be
“the instrument”. This does not preclude other MIDI-\textgreater{}audio processors
later in the processing chain, but that would be a special case not
covered by this utility function.



{\hyperref[\detokenize{index:ARDOUR:Amp}]{\emph{Amp}}}

trim()

Cast

{\hyperref[\detokenize{index:ARDOUR:Automatable}]{\emph{Automatable}}}

to\_automatable()

{\hyperref[\detokenize{index:ARDOUR:Slavable}]{\emph{Slavable}}}

to\_slavable()

{\hyperref[\detokenize{index:ARDOUR:Track}]{\emph{Track}}}

to\_track()


\subsection{Inherited from ARDOUR:Stripable}
\label{\detokenize{index:inherited-from-ardourstripable-2}}\label{\detokenize{index:id246}}
Methods

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

comp\_enable\_control()

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

comp\_makeup\_control()

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

comp\_mode\_control()

std::string

comp\_mode\_name(unsigned int)

{\hyperref[\detokenize{index:ARDOUR:ReadOnlyControl}]{\emph{ReadOnlyControl}}}

comp\_redux\_control()

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

comp\_speed\_control()

std::string

comp\_speed\_name(unsigned int)

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

comp\_threshold\_control()

unsigned int

eq\_band\_cnt()

std::string

eq\_band\_name(unsigned int)

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

eq\_enable\_control()

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

eq\_freq\_control(unsigned int)

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

eq\_gain\_control(unsigned int)

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

eq\_q\_control(unsigned int)

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

eq\_shape\_control(unsigned int)

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

filter\_enable\_controllable(bool)

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

filter\_freq\_controllable(bool)

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

filter\_slope\_controllable(bool)

{\hyperref[\detokenize{index:ARDOUR:GainControl}]{\emph{GainControl}}}

gain\_control()

bool

is\_auditioner()

bool

is\_hidden()

bool

is\_master()

bool

is\_monitor()

bool

is\_selected()

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

master\_send\_enable\_control()

{\hyperref[\detokenize{index:ARDOUR:MonitorProcessor}]{\emph{MonitorProcessor}}}

monitor\_control()

{\hyperref[\detokenize{index:ARDOUR:MuteControl}]{\emph{MuteControl}}}

mute\_control()

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

pan\_azimuth\_control()

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

pan\_elevation\_control()

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

pan\_frontback\_control()

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

pan\_lfe\_control()

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

pan\_width\_control()

{\hyperref[\detokenize{index:ARDOUR:PhaseControl}]{\emph{PhaseControl}}}

phase\_control()

{\hyperref[\detokenize{index:ARDOUR:PresentationInfo}]{\emph{PresentationInfo}}}

presentation\_info\_ptr()

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

rec\_enable\_control()

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

rec\_safe\_control()

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

send\_enable\_control(unsigned int)

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

send\_level\_control(unsigned int)

std::string

send\_name(unsigned int)

void

set\_presentation\_order(unsigned int)

{\hyperref[\detokenize{index:ARDOUR:SoloControl}]{\emph{SoloControl}}}

solo\_control()

{\hyperref[\detokenize{index:ARDOUR:SoloIsolateControl}]{\emph{SoloIsolateControl}}}

solo\_isolate\_control()

{\hyperref[\detokenize{index:ARDOUR:SoloSafeControl}]{\emph{SoloSafeControl}}}

solo\_safe\_control()

{\hyperref[\detokenize{index:ARDOUR:GainControl}]{\emph{GainControl}}}

trim\_control()

Cast

{\hyperref[\detokenize{index:ARDOUR:Route}]{\emph{Route}}}

to\_route()

{\hyperref[\detokenize{index:ARDOUR:VCA}]{\emph{VCA}}}

to\_vca()


\subsection{Inherited from ARDOUR:SessionObjectPtr}
\label{\detokenize{index:inherited-from-ardoursessionobjectptr-20}}\label{\detokenize{index:id247}}
Methods

std::string

name()

Cast

{\hyperref[\detokenize{index:PBD:Stateful}]{\emph{Stateful}}}

to\_stateful()

{\hyperref[\detokenize{index:PBD:StatefulDestructible}]{\emph{StatefulDestructible}}}

to\_statefuldestructible()


\section{∁ ARDOUR:Route:ProcessorStreams}
\label{\detokenize{index:ardour-route-processorstreams}}\label{\detokenize{index:id248}}
\sphinxstyleemphasis{C‡}: ARDOUR::Route::ProcessorStreams







A record of the stream configuration at some point in the processor
list. Used to return where and why an processor list configuration
request failed.



Constructor

ℂ

ARDOUR.Route.ProcessorStreams()


\section{∁ ARDOUR:RouteGroup}
\label{\detokenize{index:ardour-routegroup}}\label{\detokenize{index:id249}}
\sphinxstyleemphasis{C‡}: ARDOUR::RouteGroup

is-a: {\hyperref[\detokenize{index:ARDOUR:SessionObject}]{\emph{ARDOUR:SessionObject}}}







A group identifier for routes.

RouteGroups permit to define properties which are shared among all
Routes that use the given identifier.

A route can at most be in one group.



Methods

int

add({\hyperref[\detokenize{index:ARDOUR:Route}]{\emph{Route}}})



Add a route to a group. Adding a route which is already in the group is
allowed; nothing will happen.
\begin{description}
\item[{r}] \leavevmode
Route to add.

\end{description}



void

clear()

void

destroy\_subgroup()

bool

empty()

int

group\_master\_number()

bool

has\_subgroup()

bool

is\_active()

bool

is\_color()

bool

is\_gain()

bool

is\_hidden()

bool

is\_monitoring()

bool

is\_mute()

bool

is\_recenable()

bool

is\_relative()

bool

is\_route\_active()

bool

is\_select()

bool

is\_solo()

void

make\_subgroup(bool,{\hyperref[\detokenize{index:ARDOUR.Placement}]{\emph{Placement}}})

int

remove({\hyperref[\detokenize{index:ARDOUR:Route}]{\emph{Route}}})

unsigned int

rgba()

{\hyperref[\detokenize{index:ARDOUR:RouteListPtr}]{\emph{RouteListPtr}}}

route\_list()

void

set\_active(bool, void*)

void

set\_color(bool)

void

set\_gain(bool)

void

set\_hidden(bool, void*)

void

set\_monitoring(bool)

void

set\_mute(bool)

void

set\_recenable(bool)

void

set\_relative(bool, void*)

void

set\_rgba(unsigned int)



set route-group color and notify UI about change



void

set\_route\_active(bool)

void

set\_select(bool)

void

set\_solo(bool)

unsigned long

size()


\subsection{Inherited from ARDOUR:SessionObject}
\label{\detokenize{index:inherited-from-ardour-sessionobject}}
Methods

std::string

name()

Cast

{\hyperref[\detokenize{index:PBD:Stateful}]{\emph{Stateful}}}

to\_stateful()


\section{∁ ARDOUR:RouteGroupList}
\label{\detokenize{index:ardour-routegrouplist}}\label{\detokenize{index:id250}}
\sphinxstyleemphasis{C‡}: std::list\textless{}ARDOUR::RouteGroup* \textgreater{}





Constructor

ℂ

ARDOUR.RouteGroupList()

Methods

{\hyperref[\detokenize{index:ARDOUR:RouteGroup}]{\emph{RouteGroup}}}

back()

bool

empty()

{\hyperref[\detokenize{index:ARDOUR:RouteGroup}]{\emph{RouteGroup}}}

front()

\sphinxstyleemphasis{LuaIter}

iter()

void

reverse()

unsigned long

size()

\sphinxstyleemphasis{LuaTable}

table()


\section{∁ ARDOUR:RouteList}
\label{\detokenize{index:ardour-routelist}}\label{\detokenize{index:id251}}
\sphinxstyleemphasis{C‡}: std::list\textless{}boost::shared\_ptr\textless{}ARDOUR::Route\textgreater{} \textgreater{}





Constructor

ℂ

ARDOUR.RouteList()

Methods

{\hyperref[\detokenize{index:ARDOUR:Route}]{\emph{Route}}}

back()

bool

empty()

{\hyperref[\detokenize{index:ARDOUR:Route}]{\emph{Route}}}

front()

\sphinxstyleemphasis{LuaIter}

iter()

void

reverse()

unsigned long

size()

\sphinxstyleemphasis{LuaTable}

table()


\section{∁ ARDOUR:RouteListPtr}
\label{\detokenize{index:ardour-routelistptr}}\label{\detokenize{index:id252}}
\sphinxstyleemphasis{C‡}: boost::shared\_ptr\textless{}std::list\textless{}boost::shared\_ptr\textless{}ARDOUR::Route\textgreater{} \textgreater{} \textgreater{}





Constructor

ℂ

ARDOUR.RouteListPtr()

Methods

\sphinxstyleemphasis{LuaTable}

add(LuaTable \{{\hyperref[\detokenize{index:ARDOUR:Route}]{\emph{Route}}}\})

bool

empty()

\sphinxstyleemphasis{LuaIter}

iter()

void

push\_back({\hyperref[\detokenize{index:ARDOUR:Route}]{\emph{Route}}})

void

reverse()

unsigned long

size()

\sphinxstyleemphasis{LuaTable}

table()

void

unique()


\section{∁ ARDOUR:Session}
\label{\detokenize{index:ardour-session}}\label{\detokenize{index:id253}}
\sphinxstyleemphasis{C‡}: ARDOUR::Session







Ardour Session



Methods

void

abort\_reversible\_command()



abort an open undo command This must only be called after
begin\_reversible\_command ()



bool

actively\_recording()

void

add\_command({\hyperref[\detokenize{index:PBD:Command}]{\emph{Command}}})

void

add\_internal\_sends({\hyperref[\detokenize{index:ARDOUR:Route}]{\emph{Route}}},{\hyperref[\detokenize{index:ARDOUR.Placement}]{\emph{Placement}}},{\hyperref[\detokenize{index:ARDOUR:RouteListPtr}]{\emph{RouteListPtr}}})

int

add\_master\_bus({\hyperref[\detokenize{index:ARDOUR:ChanCount}]{\emph{ChanCount}}})

void

add\_monitor\_section()

{\hyperref[\detokenize{index:PBD:StatefulDiffCommand}]{\emph{StatefulDiffCommand}}}

add\_stateful\_diff\_command({\hyperref[\detokenize{index:PBD:StatefulDestructiblePtr}]{\emph{StatefulDestructiblePtr}}})



create an StatefulDiffCommand from the given object and add it to the
stack.

This function must only be called after begin\_reversible\_command.
Failing to do so may lead to a crash.
\begin{description}
\item[{sfd}] \leavevmode
the object to diff

\end{description}



Returns the allocated StatefulDiffCommand (already added via
add\_command)





void

begin\_reversible\_command(std::string)



begin collecting undo information

This call must always be followed by either begin\_reversible\_command()
or commit\_reversible\_command()
\begin{description}
\item[{cmd\_name}] \leavevmode
human readable name for the undo operation

\end{description}



void

cancel\_all\_solo()

{\hyperref[\detokenize{index:ARDOUR:SessionConfiguration}]{\emph{SessionConfiguration}}}

cfg()

void

clear\_all\_solo\_state({\hyperref[\detokenize{index:ARDOUR:RouteListPtr}]{\emph{RouteListPtr}}})

void

commit\_reversible\_command({\hyperref[\detokenize{index:PBD:Command}]{\emph{Command}}})



finalize an undo command and commit pending transactions

This must only be called after begin\_reversible\_command ()
\begin{description}
\item[{cmd}] \leavevmode
(additional) command to add

\end{description}



{\hyperref[\detokenize{index:PBD:Controllable}]{\emph{Controllable}}}

controllable\_by\_id({\hyperref[\detokenize{index:PBD:ID}]{\emph{ID}}})

long

current\_end\_frame()

long

current\_start\_frame()

void

disable\_record(bool, bool)

bool

end\_is\_free()

{\hyperref[\detokenize{index:ARDOUR:AudioEngine}]{\emph{AudioEngine}}}

engine()

bool

export\_track\_state({\hyperref[\detokenize{index:ARDOUR:RouteListPtr}]{\emph{RouteListPtr}}},
std::string)

long

frame\_rate()



“actual” sample rate of session, set by current audioengine rate,
pullup/down etc.



unsigned int

get\_block\_size()

bool

get\_play\_loop()

{\hyperref[\detokenize{index:ARDOUR:Route}]{\emph{Route}}}

get\_remote\_nth\_route(unsigned int)

{\hyperref[\detokenize{index:ARDOUR:Stripable}]{\emph{Stripable}}}

get\_remote\_nth\_stripable(unsigned
int,{\hyperref[\detokenize{index:ARDOUR.PresentationInfo.Flag}]{\emph{Flag}}})

{\hyperref[\detokenize{index:ARDOUR:RouteListPtr}]{\emph{RouteListPtr}}}

get\_routes()

{\hyperref[\detokenize{index:ARDOUR:BufferSet}]{\emph{BufferSet}}}

get\_scratch\_buffers({\hyperref[\detokenize{index:ARDOUR:ChanCount}]{\emph{ChanCount}}}, bool)

{\hyperref[\detokenize{index:ARDOUR:BufferSet}]{\emph{BufferSet}}}

get\_silent\_buffers({\hyperref[\detokenize{index:ARDOUR:ChanCount}]{\emph{ChanCount}}})

{\hyperref[\detokenize{index:ARDOUR:StripableList}]{\emph{StripableList}}}

get\_stripables()

{\hyperref[\detokenize{index:ARDOUR:RouteListPtr}]{\emph{RouteListPtr}}}

get\_tracks()

void

goto\_end()

void

goto\_start(bool)

long

last\_transport\_start()

bool

listening()

{\hyperref[\detokenize{index:ARDOUR:Locations}]{\emph{Locations}}}

locations()

{\hyperref[\detokenize{index:ARDOUR:Route}]{\emph{Route}}}

master\_out()

void

maybe\_enable\_record(bool)

{\hyperref[\detokenize{index:ARDOUR:Route}]{\emph{Route}}}

monitor\_out()

std::string

name()

{\hyperref[\detokenize{index:ARDOUR:RouteList}]{\emph{RouteList}}}

new\_audio\_route(int, int,{\hyperref[\detokenize{index:ARDOUR:RouteGroup}]{\emph{RouteGroup}}},
unsigned int, std::string,{\hyperref[\detokenize{index:ARDOUR.PresentationInfo.Flag}]{\emph{Flag}}},
unsigned int)

{\hyperref[\detokenize{index:ARDOUR:AudioTrackList}]{\emph{AudioTrackList}}}

new\_audio\_track(int, int,{\hyperref[\detokenize{index:ARDOUR:RouteGroup}]{\emph{RouteGroup}}},
unsigned int, std::string, unsigned
int,{\hyperref[\detokenize{index:ARDOUR.TrackMode}]{\emph{TrackMode}}})

{\hyperref[\detokenize{index:ARDOUR:RouteList}]{\emph{RouteList}}}

new\_midi\_route({\hyperref[\detokenize{index:ARDOUR:RouteGroup}]{\emph{RouteGroup}}}, unsigned int,
std::string,
bool,{\hyperref[\detokenize{index:ARDOUR:PluginInfo}]{\emph{PluginInfo}}},{\hyperref[\detokenize{index:ARDOUR:PresetRecord}]{\emph{PresetRecord}}},{\hyperref[\detokenize{index:ARDOUR.PresentationInfo.Flag}]{\emph{Flag}}},
unsigned int)

{\hyperref[\detokenize{index:ARDOUR:MidiTrackList}]{\emph{MidiTrackList}}}

new\_midi\_track({\hyperref[\detokenize{index:ARDOUR:ChanCount}]{\emph{ChanCount}}},{\hyperref[\detokenize{index:ARDOUR:ChanCount}]{\emph{ChanCount}}},
bool,{\hyperref[\detokenize{index:ARDOUR:PluginInfo}]{\emph{PluginInfo}}},{\hyperref[\detokenize{index:ARDOUR:PresetRecord}]{\emph{PresetRecord}}},{\hyperref[\detokenize{index:ARDOUR:RouteGroup}]{\emph{RouteGroup}}},
unsigned int, std::string, unsigned
int,{\hyperref[\detokenize{index:ARDOUR.TrackMode}]{\emph{TrackMode}}})

{\hyperref[\detokenize{index:ARDOUR:RouteList}]{\emph{RouteList}}}

new\_route\_from\_template(unsigned int, unsigned int, std::string,
std::string,{\hyperref[\detokenize{index:ARDOUR.PlaylistDisposition}]{\emph{PlaylistDisposition}}})

{\hyperref[\detokenize{index:ARDOUR:RouteGroup}]{\emph{RouteGroup}}}

new\_route\_group(std::string)

long

nominal\_frame\_rate()



“native” sample rate of session, regardless of current audioengine rate,
pullup/down etc



std::string

path()

{\hyperref[\detokenize{index:ARDOUR:Processor}]{\emph{Processor}}}

processor\_by\_id({\hyperref[\detokenize{index:PBD:ID}]{\emph{ID}}})

{\hyperref[\detokenize{index:ARDOUR.Session.RecordState}]{\emph{RecordState}}}

record\_status()

void

remove\_monitor\_section()

void

remove\_route\_group({\hyperref[\detokenize{index:ARDOUR:RouteGroup}]{\emph{RouteGroup}}})

void

request\_locate(long, bool)

void

request\_play\_loop(bool, bool)

void

request\_stop(bool, bool)

void

request\_transport\_speed(double, bool)

{\hyperref[\detokenize{index:ARDOUR:Route}]{\emph{Route}}}

route\_by\_id({\hyperref[\detokenize{index:PBD:ID}]{\emph{ID}}})

{\hyperref[\detokenize{index:ARDOUR:Route}]{\emph{Route}}}

route\_by\_name(std::string)

{\hyperref[\detokenize{index:ARDOUR:Route}]{\emph{Route}}}

route\_by\_selected\_count(unsigned int)

{\hyperref[\detokenize{index:ARDOUR:RouteGroupList}]{\emph{RouteGroupList}}}

route\_groups()

\sphinxstyleemphasis{…}

sample\_to\_timecode\_lua(\textendash{}lua\textendash{})

double

samples\_per\_timecode\_frame()

int

save\_state(std::string, bool, bool, bool)



save session
\begin{description}
\item[{snapshot\_name}] \leavevmode
name of the session (use an empty string for the current name)

\item[{pending}] \leavevmode
save a ‘recovery’, not full state (default: false)

\item[{switch\_to\_snapshot}] \leavevmode
switch to given snapshot after saving (default: false)

\item[{template\_only}] \leavevmode
save a session template (default: false)

\end{description}



Returns zero on success





void

scripts\_changed()

void

set\_control({\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}},
double,{\hyperref[\detokenize{index:PBD.Controllable.GroupControlDisposition}]{\emph{GroupControlDisposition}}})

void

set\_controls({\hyperref[\detokenize{index:ARDOUR:ControlListPtr}]{\emph{ControlListPtr}}},
double,{\hyperref[\detokenize{index:PBD.Controllable.GroupControlDisposition}]{\emph{GroupControlDisposition}}})

void

set\_dirty()

void

set\_end\_is\_free(bool)

void

set\_exclusive\_input\_active({\hyperref[\detokenize{index:ARDOUR:RouteListPtr}]{\emph{RouteListPtr}}},
bool, bool)

std::string

snap\_name()

bool

solo\_isolated()

bool

soloing()

{\hyperref[\detokenize{index:ARDOUR:Source}]{\emph{Source}}}

source\_by\_id({\hyperref[\detokenize{index:PBD:ID}]{\emph{ID}}})

{\hyperref[\detokenize{index:ARDOUR:TempoMap}]{\emph{TempoMap}}}

tempo\_map()

bool

timecode\_drop\_frames()

long

timecode\_frames\_per\_hour()

double

timecode\_frames\_per\_second()

\sphinxstyleemphasis{…}

timecode\_to\_sample\_lua(\textendash{}lua\textendash{})

{\hyperref[\detokenize{index:ARDOUR:Track}]{\emph{Track}}}

track\_by\_diskstream\_id({\hyperref[\detokenize{index:PBD:ID}]{\emph{ID}}})

long

transport\_frame()

bool

transport\_rolling()

double

transport\_speed()

{\hyperref[\detokenize{index:C:StringList}]{\emph{StringList}}}

unknown\_processors()

{\hyperref[\detokenize{index:ARDOUR:VCAManager}]{\emph{VCAManager}}}

vca\_manager()

long

worst\_input\_latency()

long

worst\_output\_latency()

long

worst\_playback\_latency()

long

worst\_track\_latency()


\section{∁ ARDOUR:SessionConfiguration}
\label{\detokenize{index:ardour-sessionconfiguration}}\label{\detokenize{index:id254}}
\sphinxstyleemphasis{C‡}: ARDOUR::SessionConfiguration

is-a: {\hyperref[\detokenize{index:PBD:Configuration}]{\emph{PBD:Configuration}}}







Base class for objects with saveable and undoable state



Methods

std::string

get\_audio\_search\_path()

bool

get\_auto\_input()

bool

get\_auto\_play()

bool

get\_auto\_return()

bool

get\_count\_in()

unsigned int

get\_destructive\_xfade\_msecs()

bool

get\_external\_sync()

bool

get\_glue\_new\_markers\_to\_bars\_and\_beats()

bool

get\_glue\_new\_regions\_to\_bars\_and\_beats()

{\hyperref[\detokenize{index:ARDOUR.InsertMergePolicy}]{\emph{InsertMergePolicy}}}

get\_insert\_merge\_policy()

bool

get\_jack\_time\_master()

bool

get\_layered\_record\_mode()

unsigned int

get\_meterbridge\_label\_height()

bool

get\_midi\_copy\_is\_fork()

std::string

get\_midi\_search\_path()

long

get\_minitimeline\_span()

{\hyperref[\detokenize{index:ARDOUR.SampleFormat}]{\emph{SampleFormat}}}

get\_native\_file\_data\_format()

{\hyperref[\detokenize{index:ARDOUR.HeaderFormat}]{\emph{HeaderFormat}}}

get\_native\_file\_header\_format()

bool

get\_punch\_in()

bool

get\_punch\_out()

std::string

get\_raid\_path()

bool

get\_realtime\_export()

{\hyperref[\detokenize{index:ARDOUR.MonitorChoice}]{\emph{MonitorChoice}}}

get\_session\_monitoring()

bool

get\_show\_busses\_on\_meterbridge()

bool

get\_show\_group\_tabs()

bool

get\_show\_master\_on\_meterbridge()

bool

get\_show\_midi\_on\_meterbridge()

bool

get\_show\_monitor\_on\_meterbridge()

bool

get\_show\_mute\_on\_meterbridge()

bool

get\_show\_name\_on\_meterbridge()

bool

get\_show\_rec\_on\_meterbridge()

bool

get\_show\_region\_fades()

bool

get\_show\_solo\_on\_meterbridge()

bool

get\_show\_summary()

std::string

get\_slave\_timecode\_offset()

unsigned int

get\_subframes\_per\_frame()

std::string

get\_take\_name()

{\hyperref[\detokenize{index:Timecode.TimecodeFormat}]{\emph{TimecodeFormat}}}

get\_timecode\_format()

std::string

get\_timecode\_generator\_offset()

long

get\_timecode\_offset()

bool

get\_timecode\_offset\_negative()

bool

get\_track\_name\_number()

bool

get\_track\_name\_take()

bool

get\_use\_monitor\_fades()

bool

get\_use\_region\_fades()

bool

get\_use\_transport\_fades()

bool

get\_use\_video\_file\_fps()

bool

get\_use\_video\_sync()

float

get\_video\_pullup()

bool

get\_videotimeline\_pullup()

double

get\_wave\_amplitude\_zoom()

unsigned short

get\_wave\_zoom\_factor()

bool

set\_audio\_search\_path(std::string)

bool

set\_auto\_input(bool)

bool

set\_auto\_play(bool)

bool

set\_auto\_return(bool)

bool

set\_count\_in(bool)

bool

set\_destructive\_xfade\_msecs(unsigned int)

bool

set\_external\_sync(bool)

bool

set\_glue\_new\_markers\_to\_bars\_and\_beats(bool)

bool

set\_glue\_new\_regions\_to\_bars\_and\_beats(bool)

bool

set\_insert\_merge\_policy({\hyperref[\detokenize{index:ARDOUR.InsertMergePolicy}]{\emph{InsertMergePolicy}}})

bool

set\_jack\_time\_master(bool)

bool

set\_layered\_record\_mode(bool)

bool

set\_meterbridge\_label\_height(unsigned int)

bool

set\_midi\_copy\_is\_fork(bool)

bool

set\_midi\_search\_path(std::string)

bool

set\_minitimeline\_span(long)

bool

set\_native\_file\_data\_format({\hyperref[\detokenize{index:ARDOUR.SampleFormat}]{\emph{SampleFormat}}})

bool

set\_native\_file\_header\_format({\hyperref[\detokenize{index:ARDOUR.HeaderFormat}]{\emph{HeaderFormat}}})

bool

set\_punch\_in(bool)

bool

set\_punch\_out(bool)

bool

set\_raid\_path(std::string)

bool

set\_realtime\_export(bool)

bool

set\_session\_monitoring({\hyperref[\detokenize{index:ARDOUR.MonitorChoice}]{\emph{MonitorChoice}}})

bool

set\_show\_busses\_on\_meterbridge(bool)

bool

set\_show\_group\_tabs(bool)

bool

set\_show\_master\_on\_meterbridge(bool)

bool

set\_show\_midi\_on\_meterbridge(bool)

bool

set\_show\_monitor\_on\_meterbridge(bool)

bool

set\_show\_mute\_on\_meterbridge(bool)

bool

set\_show\_name\_on\_meterbridge(bool)

bool

set\_show\_rec\_on\_meterbridge(bool)

bool

set\_show\_region\_fades(bool)

bool

set\_show\_solo\_on\_meterbridge(bool)

bool

set\_show\_summary(bool)

bool

set\_slave\_timecode\_offset(std::string)

bool

set\_subframes\_per\_frame(unsigned int)

bool

set\_take\_name(std::string)

bool

set\_timecode\_format({\hyperref[\detokenize{index:Timecode.TimecodeFormat}]{\emph{TimecodeFormat}}})

bool

set\_timecode\_generator\_offset(std::string)

bool

set\_timecode\_offset(long)

bool

set\_timecode\_offset\_negative(bool)

bool

set\_track\_name\_number(bool)

bool

set\_track\_name\_take(bool)

bool

set\_use\_monitor\_fades(bool)

bool

set\_use\_region\_fades(bool)

bool

set\_use\_transport\_fades(bool)

bool

set\_use\_video\_file\_fps(bool)

bool

set\_use\_video\_sync(bool)

bool

set\_video\_pullup(float)

bool

set\_videotimeline\_pullup(bool)

bool

set\_wave\_amplitude\_zoom(double)

bool

set\_wave\_zoom\_factor(unsigned short)

Properties

std::string

audio\_search\_path

bool

auto\_input

bool

auto\_play

bool

auto\_return

bool

count\_in

unsigned int

destructive\_xfade\_msecs

bool

external\_sync

bool

glue\_new\_markers\_to\_bars\_and\_beats

bool

glue\_new\_regions\_to\_bars\_and\_beats

{\hyperref[\detokenize{index:ARDOUR.InsertMergePolicy}]{\emph{ARDOUR.InsertMergePolicy}}}

insert\_merge\_policy

bool

jack\_time\_master

bool

layered\_record\_mode

unsigned int

meterbridge\_label\_height

bool

midi\_copy\_is\_fork

std::string

midi\_search\_path

long

minitimeline\_span

{\hyperref[\detokenize{index:ARDOUR.SampleFormat}]{\emph{ARDOUR.SampleFormat}}}

native\_file\_data\_format

{\hyperref[\detokenize{index:ARDOUR.HeaderFormat}]{\emph{ARDOUR.HeaderFormat}}}

native\_file\_header\_format

bool

punch\_in

bool

punch\_out

std::string

raid\_path

bool

realtime\_export

{\hyperref[\detokenize{index:ARDOUR.MonitorChoice}]{\emph{ARDOUR.MonitorChoice}}}

session\_monitoring

bool

show\_busses\_on\_meterbridge

bool

show\_group\_tabs

bool

show\_master\_on\_meterbridge

bool

show\_midi\_on\_meterbridge

bool

show\_monitor\_on\_meterbridge

bool

show\_mute\_on\_meterbridge

bool

show\_name\_on\_meterbridge

bool

show\_rec\_on\_meterbridge

bool

show\_region\_fades

bool

show\_solo\_on\_meterbridge

bool

show\_summary

std::string

slave\_timecode\_offset

unsigned int

subframes\_per\_frame

std::string

take\_name

{\hyperref[\detokenize{index:Timecode.TimecodeFormat}]{\emph{Timecode.TimecodeFormat}}}

timecode\_format

std::string

timecode\_generator\_offset

long

timecode\_offset

bool

timecode\_offset\_negative

bool

track\_name\_number

bool

track\_name\_take

bool

use\_monitor\_fades

bool

use\_region\_fades

bool

use\_transport\_fades

bool

use\_video\_file\_fps

bool

use\_video\_sync

float

video\_pullup

bool

videotimeline\_pullup

double

wave\_amplitude\_zoom

unsigned short

wave\_zoom\_factor


\subsection{Inherited from PBD:Stateful}
\label{\detokenize{index:inherited-from-pbdstateful-6}}\label{\detokenize{index:id255}}
Methods

void

clear\_changes()



Forget about any changes to this object’s properties



{\hyperref[\detokenize{index:PBD:ID}]{\emph{ID}}}

id()

{\hyperref[\detokenize{index:ARDOUR:OwnedPropertyList}]{\emph{OwnedPropertyList}}}

properties()


\section{∁ ARDOUR:SessionObject}
\label{\detokenize{index:ardour-sessionobject}}\label{\detokenize{index:id256}}
\sphinxstyleemphasis{C‡}: ARDOUR::SessionObject







A named object associated with a Session. Objects derived from this
class are expected to be destroyed before the session calls
drop\_references().



Methods

std::string

name()

Cast

{\hyperref[\detokenize{index:PBD:Stateful}]{\emph{Stateful}}}

to\_stateful()


\section{↠ ARDOUR:SessionObjectPtr}
\label{\detokenize{index:ardour-sessionobjectptr}}\label{\detokenize{index:id257}}
\sphinxstyleemphasis{C‡}: boost::shared\_ptr\textless{} ARDOUR::SessionObject \textgreater{}, boost::weak\_ptr\textless{}
ARDOUR::SessionObject \textgreater{}







A named object associated with a Session. Objects derived from this
class are expected to be destroyed before the session calls
drop\_references().



Methods

bool

isnil()

std::string

name()

Cast

{\hyperref[\detokenize{index:PBD:Stateful}]{\emph{Stateful}}}

to\_stateful()

{\hyperref[\detokenize{index:PBD:StatefulDestructible}]{\emph{StatefulDestructible}}}

to\_statefuldestructible()


\section{↠ ARDOUR:SideChain}
\label{\detokenize{index:ardour-sidechain}}\label{\detokenize{index:id258}}
\sphinxstyleemphasis{C‡}: boost::shared\_ptr\textless{} ARDOUR::SideChain \textgreater{}, boost::weak\_ptr\textless{}
ARDOUR::SideChain \textgreater{}

is-a: {\hyperref[\detokenize{index:ARDOUR:IOProcessor}]{\emph{ARDOUR:IOProcessor}}}







A mixer strip element (Processor) with 1 or 2 IO elements.



Methods

bool

isnil()


\subsection{Inherited from ARDOUR:IOProcessor}
\label{\detokenize{index:inherited-from-ardourioprocessor-1}}\label{\detokenize{index:id259}}
Methods

{\hyperref[\detokenize{index:ARDOUR:IO}]{\emph{IO}}}

input()

{\hyperref[\detokenize{index:ARDOUR:ChanCount}]{\emph{ChanCount}}}

natural\_input\_streams()

{\hyperref[\detokenize{index:ARDOUR:ChanCount}]{\emph{ChanCount}}}

natural\_output\_streams()

{\hyperref[\detokenize{index:ARDOUR:IO}]{\emph{IO}}}

output()


\subsection{Inherited from ARDOUR:Processor}
\label{\detokenize{index:inherited-from-ardourprocessor-6}}\label{\detokenize{index:id260}}
Methods

void

activate()

bool

active()

void

deactivate()

std::string

display\_name()

bool

display\_to\_user()

{\hyperref[\detokenize{index:ARDOUR:ChanCount}]{\emph{ChanCount}}}

input\_streams()

{\hyperref[\detokenize{index:ARDOUR:ChanCount}]{\emph{ChanCount}}}

output\_streams()

Cast

{\hyperref[\detokenize{index:ARDOUR:Amp}]{\emph{Amp}}}

to\_amp()

{\hyperref[\detokenize{index:ARDOUR:Automatable}]{\emph{Automatable}}}

to\_automatable()

{\hyperref[\detokenize{index:ARDOUR:PluginInsert}]{\emph{PluginInsert}}}

to\_insert()

{\hyperref[\detokenize{index:ARDOUR:IOProcessor}]{\emph{IOProcessor}}}

to\_ioprocessor()

{\hyperref[\detokenize{index:ARDOUR:PeakMeter}]{\emph{PeakMeter}}}

to\_meter()

{\hyperref[\detokenize{index:ARDOUR:MonitorProcessor}]{\emph{MonitorProcessor}}}

to\_monitorprocessor()

{\hyperref[\detokenize{index:ARDOUR:PeakMeter}]{\emph{PeakMeter}}}

to\_peakmeter()

{\hyperref[\detokenize{index:ARDOUR:PluginInsert}]{\emph{PluginInsert}}}

to\_plugininsert()

{\hyperref[\detokenize{index:ARDOUR:SideChain}]{\emph{SideChain}}}

to\_sidechain()

{\hyperref[\detokenize{index:ARDOUR:UnknownProcessor}]{\emph{UnknownProcessor}}}

to\_unknownprocessor()


\subsection{Inherited from ARDOUR:SessionObjectPtr}
\label{\detokenize{index:inherited-from-ardoursessionobjectptr-21}}\label{\detokenize{index:id261}}
Methods

std::string

name()

Cast

{\hyperref[\detokenize{index:PBD:Stateful}]{\emph{Stateful}}}

to\_stateful()

{\hyperref[\detokenize{index:PBD:StatefulDestructible}]{\emph{StatefulDestructible}}}

to\_statefuldestructible()


\section{↠ ARDOUR:Slavable}
\label{\detokenize{index:ardour-slavable}}\label{\detokenize{index:id262}}
\sphinxstyleemphasis{C‡}: boost::shared\_ptr\textless{} ARDOUR::Slavable \textgreater{}, boost::weak\_ptr\textless{}
ARDOUR::Slavable \textgreater{}





Methods

void

assign({\hyperref[\detokenize{index:ARDOUR:VCA}]{\emph{VCA}}})

bool

isnil()

void

unassign({\hyperref[\detokenize{index:ARDOUR:VCA}]{\emph{VCA}}})


\section{↠ ARDOUR:SlavableAutomationControl}
\label{\detokenize{index:ardour-slavableautomationcontrol}}\label{\detokenize{index:id263}}
\sphinxstyleemphasis{C‡}: boost::shared\_ptr\textless{} ARDOUR::SlavableAutomationControl \textgreater{},
boost::weak\_ptr\textless{} ARDOUR::SlavableAutomationControl \textgreater{}

is-a: {\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{ARDOUR:AutomationControl}}}







A PBD::Controllable with associated automation data (AutomationList)



Methods

void

add\_master({\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}})

void

clear\_masters()

int

get\_boolean\_masters()

double

get\_masters\_value()

bool

isnil()

void

remove\_master({\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}})

bool

slaved()

bool

slaved\_to({\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}})


\subsection{Inherited from ARDOUR:AutomationControl}
\label{\detokenize{index:inherited-from-ardourautomationcontrol-4}}\label{\detokenize{index:id264}}
Methods

{\hyperref[\detokenize{index:ARDOUR:AutomationList}]{\emph{AutomationList}}}

alist()

{\hyperref[\detokenize{index:ARDOUR.AutoState}]{\emph{AutoState}}}

automation\_state()

double

get\_value()



Get the current effective {}`user’ value based on automation state



void

set\_automation\_state({\hyperref[\detokenize{index:ARDOUR.AutoState}]{\emph{AutoState}}})

void

set\_value(double,{\hyperref[\detokenize{index:PBD.Controllable.GroupControlDisposition}]{\emph{GroupControlDisposition}}})



Get and Set {}`internal’ value

All derived classes must implement this.

Basic derived classes will ignore
\begin{description}
\item[{group\_override,}] \leavevmode
but more sophisticated children, notably those that proxy the value
setting logic via an object that is aware of group relationships
between this control and others, will find it useful.

\end{description}



void

start\_touch(double)

void

stop\_touch(double)

bool

writable()

Cast

{\hyperref[\detokenize{index:Evoral:Control}]{\emph{Control}}}

to\_ctrl()

{\hyperref[\detokenize{index:ARDOUR:SlavableAutomationControl}]{\emph{SlavableAutomationControl}}}

to\_slavable()


\subsection{Inherited from PBD:Controllable}
\label{\detokenize{index:inherited-from-pbdcontrollable-5}}\label{\detokenize{index:id265}}
Methods

std::string

name()


\subsection{Inherited from PBD:StatefulPtr}
\label{\detokenize{index:inherited-from-pbdstatefulptr-8}}\label{\detokenize{index:id266}}
Methods

void

clear\_changes()



Forget about any changes to this object’s properties



{\hyperref[\detokenize{index:PBD:ID}]{\emph{ID}}}

id()

{\hyperref[\detokenize{index:ARDOUR:OwnedPropertyList}]{\emph{OwnedPropertyList}}}

properties()


\section{↠ ARDOUR:SoloControl}
\label{\detokenize{index:ardour-solocontrol}}\label{\detokenize{index:id267}}
\sphinxstyleemphasis{C‡}: boost::shared\_ptr\textless{} ARDOUR::SoloControl \textgreater{}, boost::weak\_ptr\textless{}
ARDOUR::SoloControl \textgreater{}

is-a:
{\hyperref[\detokenize{index:ARDOUR:SlavableAutomationControl}]{\emph{ARDOUR:SlavableAutomationControl}}}







A PBD::Controllable with associated automation data (AutomationList)



Methods

bool

can\_solo()

bool

isnil()

bool

self\_soloed()

bool

soloed()


\subsection{Inherited from ARDOUR:SlavableAutomationControl}
\label{\detokenize{index:inherited-from-ardourslavableautomationcontrol-2}}\label{\detokenize{index:id268}}
Methods

void

add\_master({\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}})

void

clear\_masters()

int

get\_boolean\_masters()

double

get\_masters\_value()

void

remove\_master({\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}})

bool

slaved()

bool

slaved\_to({\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}})


\subsection{Inherited from ARDOUR:AutomationControl}
\label{\detokenize{index:inherited-from-ardourautomationcontrol-5}}\label{\detokenize{index:id269}}
Methods

{\hyperref[\detokenize{index:ARDOUR:AutomationList}]{\emph{AutomationList}}}

alist()

{\hyperref[\detokenize{index:ARDOUR.AutoState}]{\emph{AutoState}}}

automation\_state()

double

get\_value()



Get the current effective {}`user’ value based on automation state



void

set\_automation\_state({\hyperref[\detokenize{index:ARDOUR.AutoState}]{\emph{AutoState}}})

void

set\_value(double,{\hyperref[\detokenize{index:PBD.Controllable.GroupControlDisposition}]{\emph{GroupControlDisposition}}})



Get and Set {}`internal’ value

All derived classes must implement this.

Basic derived classes will ignore
\begin{description}
\item[{group\_override,}] \leavevmode
but more sophisticated children, notably those that proxy the value
setting logic via an object that is aware of group relationships
between this control and others, will find it useful.

\end{description}



void

start\_touch(double)

void

stop\_touch(double)

bool

writable()

Cast

{\hyperref[\detokenize{index:Evoral:Control}]{\emph{Control}}}

to\_ctrl()

{\hyperref[\detokenize{index:ARDOUR:SlavableAutomationControl}]{\emph{SlavableAutomationControl}}}

to\_slavable()


\subsection{Inherited from PBD:Controllable}
\label{\detokenize{index:inherited-from-pbdcontrollable-6}}\label{\detokenize{index:id270}}
Methods

std::string

name()


\subsection{Inherited from PBD:StatefulPtr}
\label{\detokenize{index:inherited-from-pbdstatefulptr-9}}\label{\detokenize{index:id271}}
Methods

void

clear\_changes()



Forget about any changes to this object’s properties



{\hyperref[\detokenize{index:PBD:ID}]{\emph{ID}}}

id()

{\hyperref[\detokenize{index:ARDOUR:OwnedPropertyList}]{\emph{OwnedPropertyList}}}

properties()


\section{↠ ARDOUR:SoloIsolateControl}
\label{\detokenize{index:ardour-soloisolatecontrol}}\label{\detokenize{index:id272}}
\sphinxstyleemphasis{C‡}: boost::shared\_ptr\textless{} ARDOUR::SoloIsolateControl \textgreater{}, boost::weak\_ptr\textless{}
ARDOUR::SoloIsolateControl \textgreater{}

is-a:
{\hyperref[\detokenize{index:ARDOUR:SlavableAutomationControl}]{\emph{ARDOUR:SlavableAutomationControl}}}







A PBD::Controllable with associated automation data (AutomationList)



Methods

bool

isnil()

bool

self\_solo\_isolated()

bool

solo\_isolated()


\subsection{Inherited from ARDOUR:SlavableAutomationControl}
\label{\detokenize{index:inherited-from-ardourslavableautomationcontrol-3}}\label{\detokenize{index:id273}}
Methods

void

add\_master({\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}})

void

clear\_masters()

int

get\_boolean\_masters()

double

get\_masters\_value()

void

remove\_master({\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}})

bool

slaved()

bool

slaved\_to({\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}})


\subsection{Inherited from ARDOUR:AutomationControl}
\label{\detokenize{index:inherited-from-ardourautomationcontrol-6}}\label{\detokenize{index:id274}}
Methods

{\hyperref[\detokenize{index:ARDOUR:AutomationList}]{\emph{AutomationList}}}

alist()

{\hyperref[\detokenize{index:ARDOUR.AutoState}]{\emph{AutoState}}}

automation\_state()

double

get\_value()



Get the current effective {}`user’ value based on automation state



void

set\_automation\_state({\hyperref[\detokenize{index:ARDOUR.AutoState}]{\emph{AutoState}}})

void

set\_value(double,{\hyperref[\detokenize{index:PBD.Controllable.GroupControlDisposition}]{\emph{GroupControlDisposition}}})



Get and Set {}`internal’ value

All derived classes must implement this.

Basic derived classes will ignore
\begin{description}
\item[{group\_override,}] \leavevmode
but more sophisticated children, notably those that proxy the value
setting logic via an object that is aware of group relationships
between this control and others, will find it useful.

\end{description}



void

start\_touch(double)

void

stop\_touch(double)

bool

writable()

Cast

{\hyperref[\detokenize{index:Evoral:Control}]{\emph{Control}}}

to\_ctrl()

{\hyperref[\detokenize{index:ARDOUR:SlavableAutomationControl}]{\emph{SlavableAutomationControl}}}

to\_slavable()


\subsection{Inherited from PBD:Controllable}
\label{\detokenize{index:inherited-from-pbdcontrollable-7}}\label{\detokenize{index:id275}}
Methods

std::string

name()


\subsection{Inherited from PBD:StatefulPtr}
\label{\detokenize{index:inherited-from-pbdstatefulptr-10}}\label{\detokenize{index:id276}}
Methods

void

clear\_changes()



Forget about any changes to this object’s properties



{\hyperref[\detokenize{index:PBD:ID}]{\emph{ID}}}

id()

{\hyperref[\detokenize{index:ARDOUR:OwnedPropertyList}]{\emph{OwnedPropertyList}}}

properties()


\section{↠ ARDOUR:SoloSafeControl}
\label{\detokenize{index:ardour-solosafecontrol}}\label{\detokenize{index:id277}}
\sphinxstyleemphasis{C‡}: boost::shared\_ptr\textless{} ARDOUR::SoloSafeControl \textgreater{}, boost::weak\_ptr\textless{}
ARDOUR::SoloSafeControl \textgreater{}

is-a:
{\hyperref[\detokenize{index:ARDOUR:SlavableAutomationControl}]{\emph{ARDOUR:SlavableAutomationControl}}}







A PBD::Controllable with associated automation data (AutomationList)



Methods

bool

isnil()

bool

solo\_safe()


\subsection{Inherited from ARDOUR:SlavableAutomationControl}
\label{\detokenize{index:inherited-from-ardourslavableautomationcontrol-4}}\label{\detokenize{index:id278}}
Methods

void

add\_master({\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}})

void

clear\_masters()

int

get\_boolean\_masters()

double

get\_masters\_value()

void

remove\_master({\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}})

bool

slaved()

bool

slaved\_to({\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}})


\subsection{Inherited from ARDOUR:AutomationControl}
\label{\detokenize{index:inherited-from-ardourautomationcontrol-7}}\label{\detokenize{index:id279}}
Methods

{\hyperref[\detokenize{index:ARDOUR:AutomationList}]{\emph{AutomationList}}}

alist()

{\hyperref[\detokenize{index:ARDOUR.AutoState}]{\emph{AutoState}}}

automation\_state()

double

get\_value()



Get the current effective {}`user’ value based on automation state



void

set\_automation\_state({\hyperref[\detokenize{index:ARDOUR.AutoState}]{\emph{AutoState}}})

void

set\_value(double,{\hyperref[\detokenize{index:PBD.Controllable.GroupControlDisposition}]{\emph{GroupControlDisposition}}})



Get and Set {}`internal’ value

All derived classes must implement this.

Basic derived classes will ignore
\begin{description}
\item[{group\_override,}] \leavevmode
but more sophisticated children, notably those that proxy the value
setting logic via an object that is aware of group relationships
between this control and others, will find it useful.

\end{description}



void

start\_touch(double)

void

stop\_touch(double)

bool

writable()

Cast

{\hyperref[\detokenize{index:Evoral:Control}]{\emph{Control}}}

to\_ctrl()

{\hyperref[\detokenize{index:ARDOUR:SlavableAutomationControl}]{\emph{SlavableAutomationControl}}}

to\_slavable()


\subsection{Inherited from PBD:Controllable}
\label{\detokenize{index:inherited-from-pbdcontrollable-8}}\label{\detokenize{index:id280}}
Methods

std::string

name()


\subsection{Inherited from PBD:StatefulPtr}
\label{\detokenize{index:inherited-from-pbdstatefulptr-11}}\label{\detokenize{index:id281}}
Methods

void

clear\_changes()



Forget about any changes to this object’s properties



{\hyperref[\detokenize{index:PBD:ID}]{\emph{ID}}}

id()

{\hyperref[\detokenize{index:ARDOUR:OwnedPropertyList}]{\emph{OwnedPropertyList}}}

properties()


\section{↠ ARDOUR:Source}
\label{\detokenize{index:ardour-source}}\label{\detokenize{index:id282}}
\sphinxstyleemphasis{C‡}: boost::shared\_ptr\textless{} ARDOUR::Source \textgreater{}, boost::weak\_ptr\textless{}
ARDOUR::Source \textgreater{}

is-a: {\hyperref[\detokenize{index:ARDOUR:SessionObjectPtr}]{\emph{ARDOUR:SessionObjectPtr}}}







A named object associated with a Session. Objects derived from this
class are expected to be destroyed before the session calls
drop\_references().



Methods

std::string

ancestor\_name()

bool

can\_be\_analysed()

bool

destructive()

bool

empty()

bool

has\_been\_analysed()

bool

isnil()

long

length(long)

long

natural\_position()

long

timeline\_position()

long

timestamp()

int

use\_count()

bool

used()

bool

writable()

Cast

{\hyperref[\detokenize{index:ARDOUR:AudioSource}]{\emph{AudioSource}}}

to\_audiosource()

{\hyperref[\detokenize{index:ARDOUR:FileSource}]{\emph{FileSource}}}

to\_filesource()

{\hyperref[\detokenize{index:ARDOUR:MidiSource}]{\emph{MidiSource}}}

to\_midisource()


\subsection{Inherited from ARDOUR:SessionObjectPtr}
\label{\detokenize{index:inherited-from-ardoursessionobjectptr-22}}\label{\detokenize{index:id283}}
Methods

std::string

name()

Cast

{\hyperref[\detokenize{index:PBD:Stateful}]{\emph{Stateful}}}

to\_stateful()

{\hyperref[\detokenize{index:PBD:StatefulDestructible}]{\emph{StatefulDestructible}}}

to\_statefuldestructible()


\section{∁ ARDOUR:SourceList}
\label{\detokenize{index:ardour-sourcelist}}\label{\detokenize{index:id284}}
\sphinxstyleemphasis{C‡}: std::vector\textless{}boost::shared\_ptr\textless{}ARDOUR::Source\textgreater{} \textgreater{}





Constructor

ℂ

ARDOUR.SourceList()

ℂ

ARDOUR.SourceList()

Methods

\sphinxstyleemphasis{LuaTable}

add(LuaTable \{{\hyperref[\detokenize{index:ARDOUR:Source}]{\emph{Source}}}\})

{\hyperref[\detokenize{index:ARDOUR:Source}]{\emph{Source}}}

at(unsigned long)

bool

empty()

\sphinxstyleemphasis{LuaIter}

iter()

void

push\_back({\hyperref[\detokenize{index:ARDOUR:Source}]{\emph{Source}}})

unsigned long

size()

\sphinxstyleemphasis{LuaTable}

table()


\section{↠ ARDOUR:Stripable}
\label{\detokenize{index:ardour-stripable}}\label{\detokenize{index:id285}}
\sphinxstyleemphasis{C‡}: boost::shared\_ptr\textless{} ARDOUR::Stripable \textgreater{}, boost::weak\_ptr\textless{}
ARDOUR::Stripable \textgreater{}

is-a: {\hyperref[\detokenize{index:ARDOUR:SessionObjectPtr}]{\emph{ARDOUR:SessionObjectPtr}}}







A named object associated with a Session. Objects derived from this
class are expected to be destroyed before the session calls
drop\_references().



Methods

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

comp\_enable\_control()

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

comp\_makeup\_control()

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

comp\_mode\_control()

std::string

comp\_mode\_name(unsigned int)

{\hyperref[\detokenize{index:ARDOUR:ReadOnlyControl}]{\emph{ReadOnlyControl}}}

comp\_redux\_control()

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

comp\_speed\_control()

std::string

comp\_speed\_name(unsigned int)

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

comp\_threshold\_control()

unsigned int

eq\_band\_cnt()

std::string

eq\_band\_name(unsigned int)

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

eq\_enable\_control()

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

eq\_freq\_control(unsigned int)

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

eq\_gain\_control(unsigned int)

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

eq\_q\_control(unsigned int)

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

eq\_shape\_control(unsigned int)

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

filter\_enable\_controllable(bool)

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

filter\_freq\_controllable(bool)

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

filter\_slope\_controllable(bool)

{\hyperref[\detokenize{index:ARDOUR:GainControl}]{\emph{GainControl}}}

gain\_control()

bool

is\_auditioner()

bool

is\_hidden()

bool

is\_master()

bool

is\_monitor()

bool

is\_selected()

bool

isnil()

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

master\_send\_enable\_control()

{\hyperref[\detokenize{index:ARDOUR:MonitorProcessor}]{\emph{MonitorProcessor}}}

monitor\_control()

{\hyperref[\detokenize{index:ARDOUR:MuteControl}]{\emph{MuteControl}}}

mute\_control()

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

pan\_azimuth\_control()

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

pan\_elevation\_control()

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

pan\_frontback\_control()

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

pan\_lfe\_control()

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

pan\_width\_control()

{\hyperref[\detokenize{index:ARDOUR:PhaseControl}]{\emph{PhaseControl}}}

phase\_control()

{\hyperref[\detokenize{index:ARDOUR:PresentationInfo}]{\emph{PresentationInfo}}}

presentation\_info\_ptr()

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

rec\_enable\_control()

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

rec\_safe\_control()

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

send\_enable\_control(unsigned int)

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

send\_level\_control(unsigned int)

std::string

send\_name(unsigned int)

void

set\_presentation\_order(unsigned int)

{\hyperref[\detokenize{index:ARDOUR:SoloControl}]{\emph{SoloControl}}}

solo\_control()

{\hyperref[\detokenize{index:ARDOUR:SoloIsolateControl}]{\emph{SoloIsolateControl}}}

solo\_isolate\_control()

{\hyperref[\detokenize{index:ARDOUR:SoloSafeControl}]{\emph{SoloSafeControl}}}

solo\_safe\_control()

{\hyperref[\detokenize{index:ARDOUR:GainControl}]{\emph{GainControl}}}

trim\_control()

Cast

{\hyperref[\detokenize{index:ARDOUR:Route}]{\emph{Route}}}

to\_route()

{\hyperref[\detokenize{index:ARDOUR:VCA}]{\emph{VCA}}}

to\_vca()


\subsection{Inherited from ARDOUR:SessionObjectPtr}
\label{\detokenize{index:inherited-from-ardoursessionobjectptr-23}}\label{\detokenize{index:id286}}
Methods

std::string

name()

Cast

{\hyperref[\detokenize{index:PBD:Stateful}]{\emph{Stateful}}}

to\_stateful()

{\hyperref[\detokenize{index:PBD:StatefulDestructible}]{\emph{StatefulDestructible}}}

to\_statefuldestructible()


\section{∁ ARDOUR:StripableList}
\label{\detokenize{index:ardour-stripablelist}}\label{\detokenize{index:id287}}
\sphinxstyleemphasis{C‡}: std::list\textless{}boost::shared\_ptr\textless{}ARDOUR::Stripable\textgreater{} \textgreater{}





Constructor

ℂ

ARDOUR.StripableList()

Methods

{\hyperref[\detokenize{index:ARDOUR:Stripable}]{\emph{Stripable}}}

back()

bool

empty()

{\hyperref[\detokenize{index:ARDOUR:Stripable}]{\emph{Stripable}}}

front()

\sphinxstyleemphasis{LuaIter}

iter()

void

reverse()

unsigned long

size()

\sphinxstyleemphasis{LuaTable}

table()


\section{∁ ARDOUR:Tempo}
\label{\detokenize{index:ardour-tempo}}\label{\detokenize{index:id288}}
\sphinxstyleemphasis{C‡}: ARDOUR::Tempo







Tempo, the speed at which musical time progresses (BPM).



Constructor

ℂ

ARDOUR.Tempo(double, double, double)

Methods

double

frames\_per\_note\_type(long)



audio samples per note type. if you want an instantaneous value for
this, use TempoMap::frames\_per\_quarter\_note\_at() instead.
\begin{description}
\item[{sr}] \leavevmode
samplerate

\end{description}



double

frames\_per\_quarter\_note(long)



audio samples per quarter note. if you want an instantaneous value for
this, use TempoMap::frames\_per\_quarter\_note\_at() instead.
\begin{description}
\item[{sr}] \leavevmode
samplerate

\end{description}



double

note\_type()

double

note\_types\_per\_minute()

double

quarter\_notes\_per\_minute()


\section{∁ ARDOUR:TempoMap}
\label{\detokenize{index:ardour-tempomap}}\label{\detokenize{index:id289}}
\sphinxstyleemphasis{C‡}: ARDOUR::TempoMap







Tempo Map - mapping of timecode to musical time. convert audio-samples,
sample-rate to Bar/Beat/Tick, Meter/Tempo



Methods

{\hyperref[\detokenize{index:ARDOUR:MeterSection}]{\emph{MeterSection}}}

add\_meter({\hyperref[\detokenize{index:ARDOUR:Meter}]{\emph{Meter}}},{\hyperref[\detokenize{index:Timecode:BBT_TIME}]{\emph{BBT\_TIME}}},
long,{\hyperref[\detokenize{index:ARDOUR.PositionLockStyle}]{\emph{PositionLockStyle}}})

{\hyperref[\detokenize{index:ARDOUR:TempoSection}]{\emph{TempoSection}}}

add\_tempo({\hyperref[\detokenize{index:ARDOUR:Tempo}]{\emph{Tempo}}}, double,
long,{\hyperref[\detokenize{index:ARDOUR.PositionLockStyle}]{\emph{PositionLockStyle}}})

{\hyperref[\detokenize{index:Timecode:BBT_TIME}]{\emph{BBT\_TIME}}}

bbt\_at\_frame(long)



Returns the BBT time corresponding to the supplied frame position.
\begin{description}
\item[{frame}] \leavevmode
the position in audio samples.

\end{description}



Returns the BBT time at the frame position .





double

exact\_beat\_at\_frame(long, int)

double

exact\_qn\_at\_frame(long, int)

long

framepos\_plus\_qn(long,{\hyperref[\detokenize{index:Evoral:Beats}]{\emph{Beats}}})



Add some (fractional) Beats to a session frame position, and return the
result in frames. pos can be -ve, if required.



{\hyperref[\detokenize{index:Evoral:Beats}]{\emph{Beats}}}

framewalk\_to\_qn(long, long)



Count the number of beats that are equivalent to distance when going
forward, starting at pos.



{\hyperref[\detokenize{index:ARDOUR:MeterSection}]{\emph{MeterSection}}}

meter\_section\_at\_beat(double)

{\hyperref[\detokenize{index:ARDOUR:MeterSection}]{\emph{MeterSection}}}

meter\_section\_at\_frame(long)

{\hyperref[\detokenize{index:ARDOUR:TempoSection}]{\emph{TempoSection}}}

tempo\_section\_at\_frame(long)

{\hyperref[\detokenize{index:ARDOUR:TempoSection}]{\emph{TempoSection}}}

tempo\_section\_at\_frame(long)


\section{∁ ARDOUR:TempoSection}
\label{\detokenize{index:ardour-temposection}}\label{\detokenize{index:id290}}
\sphinxstyleemphasis{C‡}: ARDOUR::TempoSection

is-a: {\hyperref[\detokenize{index:ARDOUR:MetricSection}]{\emph{ARDOUR:MetricSection}}}







A section of timeline with a certain Tempo.



Methods

double

c()


\subsection{Inherited from ARDOUR:MetricSection}
\label{\detokenize{index:inherited-from-ardourmetricsection-1}}\label{\detokenize{index:id291}}
Methods

double

pulse()

void

set\_pulse(double)


\section{↠ ARDOUR:Track}
\label{\detokenize{index:ardour-track}}\label{\detokenize{index:id292}}
\sphinxstyleemphasis{C‡}: boost::shared\_ptr\textless{} ARDOUR::Track \textgreater{}, boost::weak\_ptr\textless{} ARDOUR::Track
\textgreater{}

is-a: {\hyperref[\detokenize{index:ARDOUR:Route}]{\emph{ARDOUR:Route}}}







A track is an route (bus) with a recordable diskstream and related
objects relevant to tracking, playback and editing.

Specifically a track has regions and playlist objects.



Methods

{\hyperref[\detokenize{index:ARDOUR:Region}]{\emph{Region}}}

bounce({\hyperref[\detokenize{index:ARDOUR:InterThreadInfo}]{\emph{InterThreadInfo\&}}})



bounce track from session start to session end to new region
\begin{description}
\item[{itt}] \leavevmode
asynchronous progress report and cancel

\end{description}



Returns a new audio region (or nil in case of error)





{\hyperref[\detokenize{index:ARDOUR:Region}]{\emph{Region}}}

bounce\_range(long,
long,{\hyperref[\detokenize{index:ARDOUR:InterThreadInfo}]{\emph{InterThreadInfo\&}}},{\hyperref[\detokenize{index:ARDOUR:Processor}]{\emph{Processor}}},
bool)



Bounce the given range to a new audio region.
\begin{description}
\item[{start}] \leavevmode
start time (in samples)

\item[{end}] \leavevmode
end time (in samples)

\item[{itt}] \leavevmode
asynchronous progress report and cancel

\item[{endpoint}] \leavevmode
the processor to tap the signal off (or nil for the top)

\item[{include\_endpoint}] \leavevmode
include the given processor in the bounced audio.

\end{description}



Returns a new audio region (or nil in case of error)





bool

bounceable({\hyperref[\detokenize{index:ARDOUR:Processor}]{\emph{Processor}}}, bool)



Test if the track can be bounced with the given settings. If
sends/inserts/returns are present in the signal path or the given track
has no audio outputs bouncing is not possible.
\begin{description}
\item[{endpoint}] \leavevmode
the processor to tap the signal off (or nil for the top)

\item[{include\_endpoint}] \leavevmode
include the given processor in the bounced audio.

\end{description}



Returns true if the track can be bounced, or false otherwise.





bool

can\_record()

bool

isnil()

{\hyperref[\detokenize{index:ARDOUR:Playlist}]{\emph{Playlist}}}

playlist()

bool

set\_name(std::string)

Cast

{\hyperref[\detokenize{index:ARDOUR:AudioTrack}]{\emph{AudioTrack}}}

to\_audio\_track()

{\hyperref[\detokenize{index:ARDOUR:MidiTrack}]{\emph{MidiTrack}}}

to\_midi\_track()


\subsection{Inherited from ARDOUR:Route}
\label{\detokenize{index:inherited-from-ardourroute-2}}\label{\detokenize{index:id293}}
Methods

bool

active()

int

add\_processor\_by\_index({\hyperref[\detokenize{index:ARDOUR:Processor}]{\emph{Processor}}},
int,{\hyperref[\detokenize{index:ARDOUR:Route:ProcessorStreams}]{\emph{ProcessorStreams}}}, bool)



Add a processor to a route such that it ends up with a given index into
the visible processors.
\begin{description}
\item[{index}] \leavevmode
Index to add the processor at, or -1 to add at the end of the list.

\end{description}



Returns 0 on success, non-0 on failure.





bool

add\_sidechain({\hyperref[\detokenize{index:ARDOUR:Processor}]{\emph{Processor}}})

{\hyperref[\detokenize{index:ARDOUR:Amp}]{\emph{Amp}}}

amp()

std::string

comment()

bool

customize\_plugin\_insert({\hyperref[\detokenize{index:ARDOUR:Processor}]{\emph{Processor}}}, unsigned
int,{\hyperref[\detokenize{index:ARDOUR:ChanCount}]{\emph{ChanCount}}},{\hyperref[\detokenize{index:ARDOUR:ChanCount}]{\emph{ChanCount}}})



enable custom plugin-insert configuration
\begin{description}
\item[{proc}] \leavevmode
Processor to customize

\item[{count}] \leavevmode
number of plugin instances to use (if zero, reset to default)

\item[{outs}] \leavevmode
output port customization

\item[{sinks}] \leavevmode
input pins for variable-I/O plugins

\end{description}



Returns true if successful





{\hyperref[\detokenize{index:ARDOUR:IO}]{\emph{IO}}}

input()

{\hyperref[\detokenize{index:ARDOUR:Delivery}]{\emph{Delivery}}}

main\_outs()



the signal processorat at end of the processing chain which produces
output



bool

muted()

{\hyperref[\detokenize{index:ARDOUR:ChanCount}]{\emph{ChanCount}}}

n\_inputs()

{\hyperref[\detokenize{index:ARDOUR:ChanCount}]{\emph{ChanCount}}}

n\_outputs()

{\hyperref[\detokenize{index:ARDOUR:Processor}]{\emph{Processor}}}

nth\_plugin(unsigned int)

{\hyperref[\detokenize{index:ARDOUR:Processor}]{\emph{Processor}}}

nth\_processor(unsigned int)

{\hyperref[\detokenize{index:ARDOUR:Processor}]{\emph{Processor}}}

nth\_send(unsigned int)

{\hyperref[\detokenize{index:ARDOUR:IO}]{\emph{IO}}}

output()

{\hyperref[\detokenize{index:ARDOUR:PannerShell}]{\emph{PannerShell}}}

panner\_shell()

{\hyperref[\detokenize{index:ARDOUR:PeakMeter}]{\emph{PeakMeter}}}

peak\_meter()



************************************************************* Pure
interface begins
here*************************************************************



int

remove\_processor({\hyperref[\detokenize{index:ARDOUR:Processor}]{\emph{Processor}}},{\hyperref[\detokenize{index:ARDOUR:Route:ProcessorStreams}]{\emph{ProcessorStreams}}},
bool)



remove plugin/processor
\begin{description}
\item[{proc}] \leavevmode
processor to remove

\item[{err}] \leavevmode
error report (index where removal vailed, channel-count why it
failed) may be nil

\item[{need\_process\_lock}] \leavevmode
if locking is required (set to true, unless called from RT context
with lock)

\end{description}



Returns 0 on success





int

remove\_processors({\hyperref[\detokenize{index:ARDOUR:ProcessorList}]{\emph{ProcessorList}}},{\hyperref[\detokenize{index:ARDOUR:Route:ProcessorStreams}]{\emph{ProcessorStreams}}})

bool

remove\_sidechain({\hyperref[\detokenize{index:ARDOUR:Processor}]{\emph{Processor}}})

int

reorder\_processors({\hyperref[\detokenize{index:ARDOUR:ProcessorList}]{\emph{ProcessorList}}},{\hyperref[\detokenize{index:ARDOUR:Route:ProcessorStreams}]{\emph{ProcessorStreams}}})

int

replace\_processor({\hyperref[\detokenize{index:ARDOUR:Processor}]{\emph{Processor}}},{\hyperref[\detokenize{index:ARDOUR:Processor}]{\emph{Processor}}},{\hyperref[\detokenize{index:ARDOUR:Route:ProcessorStreams}]{\emph{ProcessorStreams}}})



replace plugin/processor with another
\begin{description}
\item[{old}] \leavevmode
processor to remove

\item[{sub}] \leavevmode
processor to substitute the old one with

\item[{err}] \leavevmode
error report (index where removal vailed, channel-count why it
failed) may be nil

\end{description}



Returns 0 on success





bool

reset\_plugin\_insert({\hyperref[\detokenize{index:ARDOUR:Processor}]{\emph{Processor}}})



reset plugin-insert configuration to default, disable customizations.

This is equivalent to calling

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{customize\PYGZus{}plugin\PYGZus{}insert} \PYG{p}{(}\PYG{n}{proc}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{unused}\PYG{p}{)}
\end{sphinxVerbatim}
\begin{description}
\item[{proc}] \leavevmode
Processor to reset

\end{description}



Returns true if successful





void

set\_active(bool, void*)

void

set\_comment(std::string, void*)

void

set\_meter\_point({\hyperref[\detokenize{index:ARDOUR.MeterPoint}]{\emph{MeterPoint}}}, bool)

bool

set\_strict\_io(bool)

bool

soloed()

bool

strict\_io()

{\hyperref[\detokenize{index:ARDOUR:Processor}]{\emph{Processor}}}

the\_instrument()



Return the first processor that accepts has at least one MIDI input and
at least one audio output. In the vast majority of cases, this will be
“the instrument”. This does not preclude other MIDI-\textgreater{}audio processors
later in the processing chain, but that would be a special case not
covered by this utility function.



{\hyperref[\detokenize{index:ARDOUR:Amp}]{\emph{Amp}}}

trim()

Cast

{\hyperref[\detokenize{index:ARDOUR:Automatable}]{\emph{Automatable}}}

to\_automatable()

{\hyperref[\detokenize{index:ARDOUR:Slavable}]{\emph{Slavable}}}

to\_slavable()

{\hyperref[\detokenize{index:ARDOUR:Track}]{\emph{Track}}}

to\_track()


\subsection{Inherited from ARDOUR:Stripable}
\label{\detokenize{index:inherited-from-ardourstripable-3}}\label{\detokenize{index:id294}}
Methods

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

comp\_enable\_control()

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

comp\_makeup\_control()

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

comp\_mode\_control()

std::string

comp\_mode\_name(unsigned int)

{\hyperref[\detokenize{index:ARDOUR:ReadOnlyControl}]{\emph{ReadOnlyControl}}}

comp\_redux\_control()

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

comp\_speed\_control()

std::string

comp\_speed\_name(unsigned int)

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

comp\_threshold\_control()

unsigned int

eq\_band\_cnt()

std::string

eq\_band\_name(unsigned int)

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

eq\_enable\_control()

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

eq\_freq\_control(unsigned int)

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

eq\_gain\_control(unsigned int)

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

eq\_q\_control(unsigned int)

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

eq\_shape\_control(unsigned int)

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

filter\_enable\_controllable(bool)

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

filter\_freq\_controllable(bool)

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

filter\_slope\_controllable(bool)

{\hyperref[\detokenize{index:ARDOUR:GainControl}]{\emph{GainControl}}}

gain\_control()

bool

is\_auditioner()

bool

is\_hidden()

bool

is\_master()

bool

is\_monitor()

bool

is\_selected()

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

master\_send\_enable\_control()

{\hyperref[\detokenize{index:ARDOUR:MonitorProcessor}]{\emph{MonitorProcessor}}}

monitor\_control()

{\hyperref[\detokenize{index:ARDOUR:MuteControl}]{\emph{MuteControl}}}

mute\_control()

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

pan\_azimuth\_control()

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

pan\_elevation\_control()

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

pan\_frontback\_control()

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

pan\_lfe\_control()

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

pan\_width\_control()

{\hyperref[\detokenize{index:ARDOUR:PhaseControl}]{\emph{PhaseControl}}}

phase\_control()

{\hyperref[\detokenize{index:ARDOUR:PresentationInfo}]{\emph{PresentationInfo}}}

presentation\_info\_ptr()

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

rec\_enable\_control()

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

rec\_safe\_control()

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

send\_enable\_control(unsigned int)

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

send\_level\_control(unsigned int)

std::string

send\_name(unsigned int)

void

set\_presentation\_order(unsigned int)

{\hyperref[\detokenize{index:ARDOUR:SoloControl}]{\emph{SoloControl}}}

solo\_control()

{\hyperref[\detokenize{index:ARDOUR:SoloIsolateControl}]{\emph{SoloIsolateControl}}}

solo\_isolate\_control()

{\hyperref[\detokenize{index:ARDOUR:SoloSafeControl}]{\emph{SoloSafeControl}}}

solo\_safe\_control()

{\hyperref[\detokenize{index:ARDOUR:GainControl}]{\emph{GainControl}}}

trim\_control()

Cast

{\hyperref[\detokenize{index:ARDOUR:Route}]{\emph{Route}}}

to\_route()

{\hyperref[\detokenize{index:ARDOUR:VCA}]{\emph{VCA}}}

to\_vca()


\subsection{Inherited from ARDOUR:SessionObjectPtr}
\label{\detokenize{index:inherited-from-ardoursessionobjectptr-24}}\label{\detokenize{index:id295}}
Methods

std::string

name()

Cast

{\hyperref[\detokenize{index:PBD:Stateful}]{\emph{Stateful}}}

to\_stateful()

{\hyperref[\detokenize{index:PBD:StatefulDestructible}]{\emph{StatefulDestructible}}}

to\_statefuldestructible()


\section{↠ ARDOUR:UnknownProcessor}
\label{\detokenize{index:ardour-unknownprocessor}}\label{\detokenize{index:id296}}
\sphinxstyleemphasis{C‡}: boost::shared\_ptr\textless{} ARDOUR::UnknownProcessor \textgreater{}, boost::weak\_ptr\textless{}
ARDOUR::UnknownProcessor \textgreater{}

is-a: {\hyperref[\detokenize{index:ARDOUR:Processor}]{\emph{ARDOUR:Processor}}}







A stub Processor that can be used in place of a {}`real’ one that cannot
be created for some reason; usually because it requires a plugin which
is not present. UnknownProcessors are special-cased in a few places,
notably in route configuration and signal processing, so that on
encountering them configuration or processing stops.

When a Processor is missing from a Route, the following processors
cannot be configured, as the missing Processor’s output port
configuration is unknown.

The main utility of the UnknownProcessor is that it allows state to be
preserved, so that, for example, loading and re-saving a session on a
machine without a particular plugin will not corrupt the session.



Methods

bool

isnil()


\subsection{Inherited from ARDOUR:Processor}
\label{\detokenize{index:inherited-from-ardourprocessor-7}}\label{\detokenize{index:id297}}
Methods

void

activate()

bool

active()

void

deactivate()

std::string

display\_name()

bool

display\_to\_user()

{\hyperref[\detokenize{index:ARDOUR:ChanCount}]{\emph{ChanCount}}}

input\_streams()

{\hyperref[\detokenize{index:ARDOUR:ChanCount}]{\emph{ChanCount}}}

output\_streams()

Cast

{\hyperref[\detokenize{index:ARDOUR:Amp}]{\emph{Amp}}}

to\_amp()

{\hyperref[\detokenize{index:ARDOUR:Automatable}]{\emph{Automatable}}}

to\_automatable()

{\hyperref[\detokenize{index:ARDOUR:PluginInsert}]{\emph{PluginInsert}}}

to\_insert()

{\hyperref[\detokenize{index:ARDOUR:IOProcessor}]{\emph{IOProcessor}}}

to\_ioprocessor()

{\hyperref[\detokenize{index:ARDOUR:PeakMeter}]{\emph{PeakMeter}}}

to\_meter()

{\hyperref[\detokenize{index:ARDOUR:MonitorProcessor}]{\emph{MonitorProcessor}}}

to\_monitorprocessor()

{\hyperref[\detokenize{index:ARDOUR:PeakMeter}]{\emph{PeakMeter}}}

to\_peakmeter()

{\hyperref[\detokenize{index:ARDOUR:PluginInsert}]{\emph{PluginInsert}}}

to\_plugininsert()

{\hyperref[\detokenize{index:ARDOUR:SideChain}]{\emph{SideChain}}}

to\_sidechain()

{\hyperref[\detokenize{index:ARDOUR:UnknownProcessor}]{\emph{UnknownProcessor}}}

to\_unknownprocessor()


\subsection{Inherited from ARDOUR:SessionObjectPtr}
\label{\detokenize{index:inherited-from-ardoursessionobjectptr-25}}\label{\detokenize{index:id298}}
Methods

std::string

name()

Cast

{\hyperref[\detokenize{index:PBD:Stateful}]{\emph{Stateful}}}

to\_stateful()

{\hyperref[\detokenize{index:PBD:StatefulDestructible}]{\emph{StatefulDestructible}}}

to\_statefuldestructible()


\section{↠ ARDOUR:VCA}
\label{\detokenize{index:ardour-vca}}\label{\detokenize{index:id299}}
\sphinxstyleemphasis{C‡}: boost::shared\_ptr\textless{} ARDOUR::VCA \textgreater{}, boost::weak\_ptr\textless{} ARDOUR::VCA \textgreater{}

is-a: {\hyperref[\detokenize{index:ARDOUR:Stripable}]{\emph{ARDOUR:Stripable}}}







A named object associated with a Session. Objects derived from this
class are expected to be destroyed before the session calls
drop\_references().



Methods

std::string

full\_name()

{\hyperref[\detokenize{index:ARDOUR:GainControl}]{\emph{GainControl}}}

gain\_control()

bool

isnil()

{\hyperref[\detokenize{index:ARDOUR:MuteControl}]{\emph{MuteControl}}}

mute\_control()

int

number()

{\hyperref[\detokenize{index:ARDOUR:SoloControl}]{\emph{SoloControl}}}

solo\_control()


\subsection{Inherited from ARDOUR:Stripable}
\label{\detokenize{index:inherited-from-ardourstripable-4}}\label{\detokenize{index:id300}}
Methods

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

comp\_enable\_control()

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

comp\_makeup\_control()

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

comp\_mode\_control()

std::string

comp\_mode\_name(unsigned int)

{\hyperref[\detokenize{index:ARDOUR:ReadOnlyControl}]{\emph{ReadOnlyControl}}}

comp\_redux\_control()

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

comp\_speed\_control()

std::string

comp\_speed\_name(unsigned int)

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

comp\_threshold\_control()

unsigned int

eq\_band\_cnt()

std::string

eq\_band\_name(unsigned int)

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

eq\_enable\_control()

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

eq\_freq\_control(unsigned int)

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

eq\_gain\_control(unsigned int)

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

eq\_q\_control(unsigned int)

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

eq\_shape\_control(unsigned int)

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

filter\_enable\_controllable(bool)

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

filter\_freq\_controllable(bool)

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

filter\_slope\_controllable(bool)

bool

is\_auditioner()

bool

is\_hidden()

bool

is\_master()

bool

is\_monitor()

bool

is\_selected()

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

master\_send\_enable\_control()

{\hyperref[\detokenize{index:ARDOUR:MonitorProcessor}]{\emph{MonitorProcessor}}}

monitor\_control()

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

pan\_azimuth\_control()

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

pan\_elevation\_control()

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

pan\_frontback\_control()

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

pan\_lfe\_control()

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

pan\_width\_control()

{\hyperref[\detokenize{index:ARDOUR:PhaseControl}]{\emph{PhaseControl}}}

phase\_control()

{\hyperref[\detokenize{index:ARDOUR:PresentationInfo}]{\emph{PresentationInfo}}}

presentation\_info\_ptr()

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

rec\_enable\_control()

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

rec\_safe\_control()

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

send\_enable\_control(unsigned int)

{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{AutomationControl}}}

send\_level\_control(unsigned int)

std::string

send\_name(unsigned int)

void

set\_presentation\_order(unsigned int)

{\hyperref[\detokenize{index:ARDOUR:SoloIsolateControl}]{\emph{SoloIsolateControl}}}

solo\_isolate\_control()

{\hyperref[\detokenize{index:ARDOUR:SoloSafeControl}]{\emph{SoloSafeControl}}}

solo\_safe\_control()

{\hyperref[\detokenize{index:ARDOUR:GainControl}]{\emph{GainControl}}}

trim\_control()

Cast

{\hyperref[\detokenize{index:ARDOUR:Route}]{\emph{Route}}}

to\_route()

{\hyperref[\detokenize{index:ARDOUR:VCA}]{\emph{VCA}}}

to\_vca()


\subsection{Inherited from ARDOUR:SessionObjectPtr}
\label{\detokenize{index:inherited-from-ardoursessionobjectptr-26}}\label{\detokenize{index:id301}}
Methods

std::string

name()

Cast

{\hyperref[\detokenize{index:PBD:Stateful}]{\emph{Stateful}}}

to\_stateful()

{\hyperref[\detokenize{index:PBD:StatefulDestructible}]{\emph{StatefulDestructible}}}

to\_statefuldestructible()


\section{∁ ARDOUR:VCAList}
\label{\detokenize{index:ardour-vcalist}}\label{\detokenize{index:id302}}
\sphinxstyleemphasis{C‡}: std::list\textless{}boost::shared\_ptr\textless{}ARDOUR::VCA\textgreater{} \textgreater{}





Constructor

ℂ

ARDOUR.VCAList()

Methods

{\hyperref[\detokenize{index:ARDOUR:VCA}]{\emph{VCA}}}

back()

bool

empty()

{\hyperref[\detokenize{index:ARDOUR:VCA}]{\emph{VCA}}}

front()

\sphinxstyleemphasis{LuaIter}

iter()

void

reverse()

unsigned long

size()

\sphinxstyleemphasis{LuaTable}

table()


\section{∁ ARDOUR:VCAManager}
\label{\detokenize{index:ardour-vcamanager}}\label{\detokenize{index:id303}}
\sphinxstyleemphasis{C‡}: ARDOUR::VCAManager

is-a: {\hyperref[\detokenize{index:PBD:StatefulDestructible}]{\emph{PBD:StatefulDestructible}}}







Base class for objects with saveable and undoable state with destruction
notification



Methods

int

create\_vca(unsigned int, std::string)

unsigned long

n\_vcas()

void

remove\_vca({\hyperref[\detokenize{index:ARDOUR:VCA}]{\emph{VCA}}})

{\hyperref[\detokenize{index:ARDOUR:VCA}]{\emph{VCA}}}

vca\_by\_name(std::string)

{\hyperref[\detokenize{index:ARDOUR:VCA}]{\emph{VCA}}}

vca\_by\_number(int)

{\hyperref[\detokenize{index:ARDOUR:VCAList}]{\emph{VCAList}}}

vcas()


\subsection{Inherited from PBD:Stateful}
\label{\detokenize{index:inherited-from-pbdstateful-7}}\label{\detokenize{index:id304}}
Methods

void

clear\_changes()



Forget about any changes to this object’s properties



{\hyperref[\detokenize{index:PBD:ID}]{\emph{ID}}}

id()

{\hyperref[\detokenize{index:ARDOUR:OwnedPropertyList}]{\emph{OwnedPropertyList}}}

properties()


\section{∁ ARDOUR:WeakAudioSourceList}
\label{\detokenize{index:ardour-weakaudiosourcelist}}\label{\detokenize{index:id305}}
\sphinxstyleemphasis{C‡}: std::list\textless{}boost::weak\_ptr\textless{}ARDOUR::AudioSource\textgreater{} \textgreater{}





Constructor

ℂ

ARDOUR.WeakAudioSourceList()

Methods

{\hyperref[\detokenize{index:ARDOUR:AudioSource}]{\emph{AudioSource}}}

back()

bool

empty()

{\hyperref[\detokenize{index:ARDOUR:AudioSource}]{\emph{AudioSource}}}

front()

\sphinxstyleemphasis{LuaIter}

iter()

void

reverse()

unsigned long

size()

\sphinxstyleemphasis{LuaTable}

table()


\section{∁ ARDOUR:WeakRouteList}
\label{\detokenize{index:ardour-weakroutelist}}\label{\detokenize{index:id306}}
\sphinxstyleemphasis{C‡}: std::list\textless{}boost::weak\_ptr\textless{}ARDOUR::Route\textgreater{} \textgreater{}





Constructor

ℂ

ARDOUR.WeakRouteList()

Methods

{\hyperref[\detokenize{index:ARDOUR:Route}]{\emph{Route}}}

back()

bool

empty()

{\hyperref[\detokenize{index:ARDOUR:Route}]{\emph{Route}}}

front()

\sphinxstyleemphasis{LuaIter}

iter()

void

reverse()

unsigned long

size()

\sphinxstyleemphasis{LuaTable}

table()


\section{∁ ARDOUR:WeakSourceList}
\label{\detokenize{index:ardour-weaksourcelist}}\label{\detokenize{index:id307}}
\sphinxstyleemphasis{C‡}: std::list\textless{}boost::weak\_ptr\textless{}ARDOUR::Source\textgreater{} \textgreater{}





Constructor

ℂ

ARDOUR.WeakSourceList()

Methods

{\hyperref[\detokenize{index:ARDOUR:Source}]{\emph{Source}}}

back()

bool

empty()

{\hyperref[\detokenize{index:ARDOUR:Source}]{\emph{Source}}}

front()

\sphinxstyleemphasis{LuaIter}

iter()

void

reverse()

unsigned long

size()

\sphinxstyleemphasis{LuaTable}

table()


\section{ℕ ArdourUI}
\label{\detokenize{index:ardourui}}\label{\detokenize{index:id308}}




Methods

std::string

http\_get(std::string)

{\hyperref[\detokenize{index:ARDOUR:ProcessorVector}]{\emph{ProcessorVector}}}

processor\_selection()

unsigned int

translate\_order({\hyperref[\detokenize{index:RouteDialogs.InsertAt}]{\emph{InsertAt}}})


\section{∁ ArdourUI:ArdourMarker}
\label{\detokenize{index:ardourui-ardourmarker}}\label{\detokenize{index:id309}}
\sphinxstyleemphasis{C‡}: ArdourMarker







Location Marker

Editor ruler representation of a location marker or range on the
timeline.



Methods

std::string

name()

long

position()

{\hyperref[\detokenize{index:ArdourMarker.Type}]{\emph{Type}}}

type()


\section{∁ ArdourUI:ArdourMarkerList}
\label{\detokenize{index:ardourui-ardourmarkerlist}}\label{\detokenize{index:id310}}
\sphinxstyleemphasis{C‡}: std::list\textless{}ArdourMarker* \textgreater{}





Constructor

ℂ

ArdourUI.ArdourMarkerList()

Methods

\sphinxstyleemphasis{LuaTable}

add(ArdourMarker*)

{\hyperref[\detokenize{index:ArdourUI:ArdourMarker}]{\emph{ArdourMarker}}}

back()

bool

empty()

{\hyperref[\detokenize{index:ArdourUI:ArdourMarker}]{\emph{ArdourMarker}}}

front()

\sphinxstyleemphasis{LuaIter}

iter()

void

push\_back({\hyperref[\detokenize{index:ArdourUI:ArdourMarker}]{\emph{ArdourMarker}}})

void

reverse()

unsigned long

size()

\sphinxstyleemphasis{LuaTable}

table()

void

unique()


\section{∅ ArdourUI:AxisView}
\label{\detokenize{index:ardourui-axisview}}\label{\detokenize{index:id311}}
\sphinxstyleemphasis{C‡}: AxisView







AxisView defines the abstract base class for horizontal and vertical
presentations of Stripables.



This class object is only used indirectly as return-value and
function-parameter. It provides no methods by itself.


\section{∁ ArdourUI:Editor}
\label{\detokenize{index:ardourui-editor}}\label{\detokenize{index:id312}}
\sphinxstyleemphasis{C‡}: PublicEditor







This class contains just the public interface of the Editor class, in
order to decouple it from the private implementation, so that callers of
PublicEditor need not be recompiled if private methods or member
variables change.



Methods

void

access\_action(std::string, std::string)

void

add\_location\_from\_playhead\_cursor()

{\hyperref[\detokenize{index:ArdourUI:TrackViewList}]{\emph{TrackViewList}}}

axis\_views\_from\_routes({\hyperref[\detokenize{index:ARDOUR:RouteListPtr}]{\emph{RouteListPtr}}})

void

center\_screen(long)

void

clear\_playlist({\hyperref[\detokenize{index:ARDOUR:Playlist}]{\emph{Playlist}}})

void

clear\_playlists({\hyperref[\detokenize{index:ArdourUI:TimeAxisView}]{\emph{TimeAxisView}}})

void

consider\_auditioning({\hyperref[\detokenize{index:ARDOUR:Region}]{\emph{Region}}})



Possibly start the audition of a region. If
\begin{description}
\item[{r}] \leavevmode
is 0, or not an AudioRegion any current audition is cancelled. If we
are currently auditioning

\item[{r}] \leavevmode
will start.

\item[{r}] \leavevmode
Region to consider.

\item[{r,}] \leavevmode
the audition will be cancelled. Otherwise an audition of

\end{description}



void

copy\_playlists({\hyperref[\detokenize{index:ArdourUI:TimeAxisView}]{\emph{TimeAxisView}}})

{\hyperref[\detokenize{index:Editing.MouseMode}]{\emph{MouseMode}}}

current\_mouse\_mode()





Returns The current mouse mode (gain, object, range, timefx etc.)
(defined in editing\_syms.h)





long

current\_page\_samples()

void

deselect\_all()

\sphinxstyleemphasis{LuaTable}(…)

do\_embed({\hyperref[\detokenize{index:C:StringVector}]{\emph{StringVector}}},{\hyperref[\detokenize{index:Editing.ImportDisposition}]{\emph{ImportDisposition}}},{\hyperref[\detokenize{index:Editing.ImportMode}]{\emph{ImportMode}}},
long\&,{\hyperref[\detokenize{index:ARDOUR:PluginInfo}]{\emph{PluginInfo}}})

\sphinxstyleemphasis{LuaTable}(…)

do\_import({\hyperref[\detokenize{index:C:StringVector}]{\emph{StringVector}}},{\hyperref[\detokenize{index:Editing.ImportDisposition}]{\emph{ImportDisposition}}},{\hyperref[\detokenize{index:Editing.ImportMode}]{\emph{ImportMode}}},{\hyperref[\detokenize{index:ARDOUR.SrcQuality}]{\emph{SrcQuality}}},{\hyperref[\detokenize{index:ARDOUR.MidiTrackNameSource}]{\emph{MidiTrackNameSource}}},{\hyperref[\detokenize{index:ARDOUR.MidiTempoMapDisposition}]{\emph{MidiTempoMapDisposition}}},
long\&,{\hyperref[\detokenize{index:ARDOUR:PluginInfo}]{\emph{PluginInfo}}})



Import existing media



bool

dragging\_playhead()





Returns true if the playhead is currently being dragged, otherwise false





{\hyperref[\detokenize{index:Editing.MouseMode}]{\emph{MouseMode}}}

effective\_mouse\_mode()

void

export\_audio()



Open main export dialog



void

export\_range()



Open export dialog with current range pre-selected



void

export\_selection()



Open export dialog with current selection pre-selected



\sphinxstyleemphasis{LuaTable}({\hyperref[\detokenize{index:ARDOUR:Location}]{\emph{Location}}}, …)

find\_location\_from\_marker({\hyperref[\detokenize{index:ArdourUI:ArdourMarker}]{\emph{ArdourMarker}}},
bool\&)

{\hyperref[\detokenize{index:ArdourUI:ArdourMarker}]{\emph{ArdourMarker}}}

find\_marker\_from\_location\_id({\hyperref[\detokenize{index:PBD:ID}]{\emph{ID}}}, bool)

void

fit\_selection()

bool

follow\_playhead()





Returns true if the editor is following the playhead





long

get\_current\_zoom()

{\hyperref[\detokenize{index:ArdourUI:Selection}]{\emph{Selection}}}

get\_cut\_buffer()

unsigned int

get\_grid\_beat\_divisions(long)

\sphinxstyleemphasis{LuaTable}({\hyperref[\detokenize{index:Evoral:Beats}]{\emph{Beats}}}, …)

get\_grid\_type\_as\_beats(bool\&, long)

\sphinxstyleemphasis{LuaTable}(long, …)

get\_nudge\_distance(long, long\&)

long

get\_paste\_offset(long, unsigned int, long)

\sphinxstyleemphasis{LuaTable}(…)

get\_pointer\_position(double\&, double\&)

{\hyperref[\detokenize{index:ArdourUI:Selection}]{\emph{Selection}}}

get\_selection()

\sphinxstyleemphasis{LuaTable}(bool, …)

get\_selection\_extents(long\&, long\&)

bool

get\_smart\_mode()

{\hyperref[\detokenize{index:ArdourUI:StripableTimeAxisView}]{\emph{StripableTimeAxisView}}}

get\_stripable\_time\_axis\_by\_id({\hyperref[\detokenize{index:PBD:ID}]{\emph{ID}}})

{\hyperref[\detokenize{index:ArdourUI:TrackViewList}]{\emph{TrackViewList}}}

get\_track\_views()

int

get\_videotl\_bar\_height()

double

get\_y\_origin()

{\hyperref[\detokenize{index:Editing.ZoomFocus}]{\emph{ZoomFocus}}}

get\_zoom\_focus()

void

goto\_nth\_marker(int)

void

hide\_track\_in\_display({\hyperref[\detokenize{index:ArdourUI:TimeAxisView}]{\emph{TimeAxisView}}},
bool)

long

leftmost\_sample()

void

maximise\_editing\_space()

void

maybe\_locate\_with\_edit\_preroll(long)

void

mouse\_add\_new\_marker(long, bool)

void

new\_playlists({\hyperref[\detokenize{index:ArdourUI:TimeAxisView}]{\emph{TimeAxisView}}})

void

new\_region\_from\_selection()

void

override\_visible\_track\_count()

long

pixel\_to\_sample(double)

void

play\_selection()

void

play\_with\_preroll()

void

redo(unsigned int)



Redo some transactions.
\begin{description}
\item[{n}] \leavevmode
Number of transaction to redo.

\end{description}



{\hyperref[\detokenize{index:ArdourUI:RegionView}]{\emph{RegionView}}}

regionview\_from\_region({\hyperref[\detokenize{index:ARDOUR:Region}]{\emph{Region}}})

void

remove\_last\_capture()

void

remove\_location\_at\_playhead\_cursor()

void

remove\_tracks()

void

reset\_x\_origin(long)

void

reset\_y\_origin(double)

void

reset\_zoom(long)

void

restore\_editing\_space()

{\hyperref[\detokenize{index:ArdourUI:RouteTimeAxisView}]{\emph{RouteTimeAxisView}}}

rtav\_from\_route({\hyperref[\detokenize{index:ARDOUR:Route}]{\emph{Route}}})

double

sample\_to\_pixel(long)

bool

scroll\_down\_one\_track(bool)

void

scroll\_tracks\_down\_line()

void

scroll\_tracks\_up\_line()

bool

scroll\_up\_one\_track(bool)

void

select\_all\_tracks()

void

separate\_region\_from\_selection()

void

set\_follow\_playhead(bool, bool)



Set whether the editor should follow the playhead.
\begin{description}
\item[{yn}] \leavevmode
true to follow playhead, otherwise false.

\item[{catch\_up}] \leavevmode
true to reset the editor view to show the playhead (if yn == true),
otherwise false.

\end{description}



void

set\_loop\_range(long, long, std::string)

void

set\_mouse\_mode({\hyperref[\detokenize{index:Editing.MouseMode}]{\emph{MouseMode}}}, bool)



Set the mouse mode (gain, object, range, timefx etc.)
\begin{description}
\item[{m}] \leavevmode
Mouse mode (defined in editing\_syms.h)

\item[{force}] \leavevmode
Perform the effects of the change even if no change is required (ie
even if the current mouse mode is equal to

\end{description}



void

set\_punch\_range(long, long, std::string)

void

set\_selection({\hyperref[\detokenize{index:ArdourUI:SelectionList}]{\emph{SelectionList}}},{\hyperref[\detokenize{index:Selection.Operation}]{\emph{Operation}}})

void

set\_show\_measures(bool)

void

set\_snap\_mode({\hyperref[\detokenize{index:Editing.SnapMode}]{\emph{SnapMode}}})



Set the snap mode.
\begin{description}
\item[{m}] \leavevmode
Snap mode (defined in editing\_syms.h)

\end{description}



void

set\_snap\_threshold(double)



Set the snap threshold.
\begin{description}
\item[{t}] \leavevmode
Snap threshold in {}`units’.

\end{description}



void

set\_stationary\_playhead(bool)

void

set\_toggleaction(std::string, std::string, bool)

void

set\_video\_timeline\_height(int)

void

set\_visible\_track\_count(int)

void

set\_zoom\_focus({\hyperref[\detokenize{index:Editing.ZoomFocus}]{\emph{ZoomFocus}}})

bool

show\_measures()

void

show\_track\_in\_display({\hyperref[\detokenize{index:ArdourUI:TimeAxisView}]{\emph{TimeAxisView}}},
bool)

{\hyperref[\detokenize{index:Editing.SnapMode}]{\emph{SnapMode}}}

snap\_mode()

{\hyperref[\detokenize{index:Editing.SnapType}]{\emph{SnapType}}}

snap\_type()

bool

stationary\_playhead()

void

stem\_export()



Open stem export dialog



void

temporal\_zoom\_step(bool)

void

toggle\_meter\_updating()

void

toggle\_ruler\_video(bool)

void

toggle\_xjadeo\_proc(int)

void

undo(unsigned int)



Undo some transactions.
\begin{description}
\item[{n}] \leavevmode
Number of transactions to undo.

\end{description}



double

visible\_canvas\_height()


\section{∅ ArdourUI:MarkerSelection}
\label{\detokenize{index:ardourui-markerselection}}\label{\detokenize{index:id313}}
\sphinxstyleemphasis{C‡}: MarkerSelection

is-a: {\hyperref[\detokenize{index:ArdourUI:ArdourMarkerList}]{\emph{ArdourUI:ArdourMarkerList}}}





This class object is only used indirectly as return-value and
function-parameter. It provides no methods by itself.


\subsection{Inherited from ArdourUI:ArdourMarkerList}
\label{\detokenize{index:inherited-from-ardourui-ardourmarkerlist}}
Constructor

ℂ

ArdourUI.ArdourMarkerList()

Methods

\sphinxstyleemphasis{LuaTable}

add(ArdourMarker*)

{\hyperref[\detokenize{index:ArdourUI:ArdourMarker}]{\emph{ArdourMarker}}}

back()

bool

empty()

{\hyperref[\detokenize{index:ArdourUI:ArdourMarker}]{\emph{ArdourMarker}}}

front()

\sphinxstyleemphasis{LuaIter}

iter()

void

push\_back({\hyperref[\detokenize{index:ArdourUI:ArdourMarker}]{\emph{ArdourMarker}}})

void

reverse()

unsigned long

size()

\sphinxstyleemphasis{LuaTable}

table()

void

unique()


\section{∁ ArdourUI:RegionSelection}
\label{\detokenize{index:ardourui-regionselection}}\label{\detokenize{index:id314}}
\sphinxstyleemphasis{C‡}: RegionSelection







Class to represent list of selected regions.



Methods

long

end\_frame()

unsigned long

n\_midi\_regions()

{\hyperref[\detokenize{index:ARDOUR:RegionList}]{\emph{RegionList}}}

regionlist()

long

start()


\section{∅ ArdourUI:RegionView}
\label{\detokenize{index:ardourui-regionview}}\label{\detokenize{index:id315}}
\sphinxstyleemphasis{C‡}: RegionView

is-a: {\hyperref[\detokenize{index:ArdourUI:TimeAxisViewItem}]{\emph{ArdourUI:TimeAxisViewItem}}}







Base class for items that may appear upon a TimeAxisView.



This class object is only used indirectly as return-value and
function-parameter. It provides no methods by itself.


\section{∁ ArdourUI:RouteTimeAxisView}
\label{\detokenize{index:ardourui-routetimeaxisview}}\label{\detokenize{index:id316}}
\sphinxstyleemphasis{C‡}: RouteTimeAxisView

is-a: {\hyperref[\detokenize{index:ArdourUI:RouteUI}]{\emph{ArdourUI:RouteUI}}}







Base class for objects with auto-disconnection. trackable must be
inherited when objects shall automatically invalidate slots referring to
them on destruction. A slot built from a member function of a trackable
derived type installs a callback that is invoked when the trackable
object is destroyed or overwritten.

add\_destroy\_notify\_callback() and remove\_destroy\_notify\_callback() can
be used to manually install and remove callbacks when notification of
the object dying is needed.

notify\_callbacks() invokes and removes all previously installed
callbacks and can therefore be used to disconnect from all signals.

Note that there is no virtual destructor. Don’t use \sphinxcode{\sphinxupquote{trackable*}} as
pointer type for managing your data or the destructors of your derived
types won’t be called when deleting your objects.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{signal}
\end{sphinxVerbatim}



Cast

{\hyperref[\detokenize{index:ArdourUI:StripableTimeAxisView}]{\emph{StripableTimeAxisView}}}

to\_stripabletimeaxisview()

{\hyperref[\detokenize{index:ArdourUI:TimeAxisView}]{\emph{TimeAxisView}}}

to\_timeaxisview()


\section{∅ ArdourUI:RouteUI}
\label{\detokenize{index:ardourui-routeui}}\label{\detokenize{index:id317}}
\sphinxstyleemphasis{C‡}: RouteUI

is-a: {\hyperref[\detokenize{index:ArdourUI:Selectable}]{\emph{ArdourUI:Selectable}}}







Base class for objects with auto-disconnection. trackable must be
inherited when objects shall automatically invalidate slots referring to
them on destruction. A slot built from a member function of a trackable
derived type installs a callback that is invoked when the trackable
object is destroyed or overwritten.

add\_destroy\_notify\_callback() and remove\_destroy\_notify\_callback() can
be used to manually install and remove callbacks when notification of
the object dying is needed.

notify\_callbacks() invokes and removes all previously installed
callbacks and can therefore be used to disconnect from all signals.

Note that there is no virtual destructor. Don’t use \sphinxcode{\sphinxupquote{trackable*}} as
pointer type for managing your data or the destructors of your derived
types won’t be called when deleting your objects.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{signal}
\end{sphinxVerbatim}



This class object is only used indirectly as return-value and
function-parameter. It provides no methods by itself.


\section{∅ ArdourUI:Selectable}
\label{\detokenize{index:ardourui-selectable}}\label{\detokenize{index:id318}}
\sphinxstyleemphasis{C‡}: Selectable







Base class for objects with auto-disconnection. trackable must be
inherited when objects shall automatically invalidate slots referring to
them on destruction. A slot built from a member function of a trackable
derived type installs a callback that is invoked when the trackable
object is destroyed or overwritten.

add\_destroy\_notify\_callback() and remove\_destroy\_notify\_callback() can
be used to manually install and remove callbacks when notification of
the object dying is needed.

notify\_callbacks() invokes and removes all previously installed
callbacks and can therefore be used to disconnect from all signals.

Note that there is no virtual destructor. Don’t use \sphinxcode{\sphinxupquote{trackable*}} as
pointer type for managing your data or the destructors of your derived
types won’t be called when deleting your objects.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{signal}
\end{sphinxVerbatim}



This class object is only used indirectly as return-value and
function-parameter. It provides no methods by itself.


\section{∁ ArdourUI:Selection}
\label{\detokenize{index:ardourui-selection}}\label{\detokenize{index:id319}}
\sphinxstyleemphasis{C‡}: Selection







The Selection class holds lists of selected items (tracks, regions, etc.
etc.).



Methods

void

clear()



Clear everything from the Selection



void

clear\_all()

bool

empty(bool)



check if all selections are empty
\begin{description}
\item[{internal\_selection}] \leavevmode
also check object internals (e.g midi notes, automation points), when
false only check objects.

\end{description}



Returns true if nothing is selected.





Data Members

{\hyperref[\detokenize{index:ArdourUI:MarkerSelection}]{\emph{ArdourUI:MarkerSelection}}}

markers

{\hyperref[\detokenize{index:ArdourUI:RegionSelection}]{\emph{ArdourUI:RegionSelection}}}

regions

{\hyperref[\detokenize{index:ArdourUI:TimeSelection}]{\emph{ArdourUI:TimeSelection}}}

time

{\hyperref[\detokenize{index:ArdourUI:TrackSelection}]{\emph{ArdourUI:TrackSelection}}}

tracks


\section{∁ ArdourUI:SelectionList}
\label{\detokenize{index:ardourui-selectionlist}}\label{\detokenize{index:id320}}
\sphinxstyleemphasis{C‡}: std::list\textless{}Selectable* \textgreater{}





Constructor

ℂ

ArdourUI.SelectionList()

Methods

{\hyperref[\detokenize{index:ArdourUI:Selectable}]{\emph{Selectable}}}

back()

bool

empty()

{\hyperref[\detokenize{index:ArdourUI:Selectable}]{\emph{Selectable}}}

front()

\sphinxstyleemphasis{LuaIter}

iter()

void

push\_back({\hyperref[\detokenize{index:ArdourUI:Selectable}]{\emph{Selectable}}})

void

reverse()

unsigned long

size()

\sphinxstyleemphasis{LuaTable}

table()

void

unique()


\section{∅ ArdourUI:StripableTimeAxisView}
\label{\detokenize{index:ardourui-stripabletimeaxisview}}\label{\detokenize{index:id321}}
\sphinxstyleemphasis{C‡}: StripableTimeAxisView

is-a: {\hyperref[\detokenize{index:ArdourUI:TimeAxisView}]{\emph{ArdourUI:TimeAxisView}}}







Abstract base class for time-axis views (horizontal editor ‘strips’)

This class provides the basic LHS controls and display methods. This
should be extended to create functional time-axis based views.



This class object is only used indirectly as return-value and
function-parameter. It provides no methods by itself.


\section{∅ ArdourUI:TimeAxisView}
\label{\detokenize{index:ardourui-timeaxisview}}\label{\detokenize{index:id322}}
\sphinxstyleemphasis{C‡}: TimeAxisView

is-a: {\hyperref[\detokenize{index:ArdourUI:AxisView}]{\emph{ArdourUI:AxisView}}}







Abstract base class for time-axis views (horizontal editor ‘strips’)

This class provides the basic LHS controls and display methods. This
should be extended to create functional time-axis based views.



This class object is only used indirectly as return-value and
function-parameter. It provides no methods by itself.


\section{∅ ArdourUI:TimeAxisViewItem}
\label{\detokenize{index:ardourui-timeaxisviewitem}}\label{\detokenize{index:id323}}
\sphinxstyleemphasis{C‡}: TimeAxisViewItem

is-a: {\hyperref[\detokenize{index:ArdourUI:Selectable}]{\emph{ArdourUI:Selectable}}}







Base class for items that may appear upon a TimeAxisView.



This class object is only used indirectly as return-value and
function-parameter. It provides no methods by itself.


\section{∁ ArdourUI:TimeSelection}
\label{\detokenize{index:ardourui-timeselection}}\label{\detokenize{index:id324}}
\sphinxstyleemphasis{C‡}: TimeSelection

is-a: {\hyperref[\detokenize{index:ARDOUR:AudioRangeList}]{\emph{ARDOUR:AudioRangeList}}}





Methods

long

end\_frame()

long

length()

long

start()


\subsection{Inherited from ARDOUR:AudioRangeList}
\label{\detokenize{index:inherited-from-ardour-audiorangelist}}
Constructor

ℂ

ARDOUR.AudioRangeList()

Methods

{\hyperref[\detokenize{index:ARDOUR:AudioRange}]{\emph{AudioRange}}}

back()

bool

empty()

{\hyperref[\detokenize{index:ARDOUR:AudioRange}]{\emph{AudioRange}}}

front()

\sphinxstyleemphasis{LuaIter}

iter()

void

reverse()

unsigned long

size()

\sphinxstyleemphasis{LuaTable}

table()


\section{∅ ArdourUI:TrackSelection}
\label{\detokenize{index:ardourui-trackselection}}\label{\detokenize{index:id325}}
\sphinxstyleemphasis{C‡}: TrackSelection

is-a: {\hyperref[\detokenize{index:ArdourUI:TrackViewList}]{\emph{ArdourUI:TrackViewList}}}





This class object is only used indirectly as return-value and
function-parameter. It provides no methods by itself.


\subsection{Inherited from ArdourUI:TrackViewList}
\label{\detokenize{index:inherited-from-ardourui-trackviewlist}}
Methods

bool

contains({\hyperref[\detokenize{index:ArdourUI:TimeAxisView}]{\emph{TimeAxisView}}})

{\hyperref[\detokenize{index:ARDOUR:RouteList}]{\emph{RouteList}}}

routelist()


\subsection{Inherited from ArdourUI:TrackViewStdList}
\label{\detokenize{index:inherited-from-ardourui-trackviewstdlist}}
Constructor

ℂ

ArdourUI.TrackViewStdList()

Methods

{\hyperref[\detokenize{index:ArdourUI:TimeAxisView}]{\emph{TimeAxisView}}}

back()

bool

empty()

{\hyperref[\detokenize{index:ArdourUI:TimeAxisView}]{\emph{TimeAxisView}}}

front()

\sphinxstyleemphasis{LuaIter}

iter()

void

push\_back({\hyperref[\detokenize{index:ArdourUI:TimeAxisView}]{\emph{TimeAxisView}}})

void

reverse()

unsigned long

size()

\sphinxstyleemphasis{LuaTable}

table()

void

unique()


\section{∁ ArdourUI:TrackViewList}
\label{\detokenize{index:ardourui-trackviewlist}}\label{\detokenize{index:id326}}
\sphinxstyleemphasis{C‡}: TrackViewList

is-a: {\hyperref[\detokenize{index:ArdourUI:TrackViewStdList}]{\emph{ArdourUI:TrackViewStdList}}}





Methods

bool

contains({\hyperref[\detokenize{index:ArdourUI:TimeAxisView}]{\emph{TimeAxisView}}})

{\hyperref[\detokenize{index:ARDOUR:RouteList}]{\emph{RouteList}}}

routelist()


\subsection{Inherited from ArdourUI:TrackViewStdList}
\label{\detokenize{index:inherited-from-ardouruitrackviewstdlist-1}}\label{\detokenize{index:id327}}
Constructor

ℂ

ArdourUI.TrackViewStdList()

Methods

{\hyperref[\detokenize{index:ArdourUI:TimeAxisView}]{\emph{TimeAxisView}}}

back()

bool

empty()

{\hyperref[\detokenize{index:ArdourUI:TimeAxisView}]{\emph{TimeAxisView}}}

front()

\sphinxstyleemphasis{LuaIter}

iter()

void

push\_back({\hyperref[\detokenize{index:ArdourUI:TimeAxisView}]{\emph{TimeAxisView}}})

void

reverse()

unsigned long

size()

\sphinxstyleemphasis{LuaTable}

table()

void

unique()


\section{∁ ArdourUI:TrackViewStdList}
\label{\detokenize{index:ardourui-trackviewstdlist}}\label{\detokenize{index:id328}}
\sphinxstyleemphasis{C‡}: std::list\textless{}TimeAxisView* \textgreater{}





Constructor

ℂ

ArdourUI.TrackViewStdList()

Methods

{\hyperref[\detokenize{index:ArdourUI:TimeAxisView}]{\emph{TimeAxisView}}}

back()

bool

empty()

{\hyperref[\detokenize{index:ArdourUI:TimeAxisView}]{\emph{TimeAxisView}}}

front()

\sphinxstyleemphasis{LuaIter}

iter()

void

push\_back({\hyperref[\detokenize{index:ArdourUI:TimeAxisView}]{\emph{TimeAxisView}}})

void

reverse()

unsigned long

size()

\sphinxstyleemphasis{LuaTable}

table()

void

unique()


\section{⋯ C:ByteArray}
\label{\detokenize{index:c-bytearray}}\label{\detokenize{index:id329}}
\sphinxstyleemphasis{C‡}: unsigned char*





Methods

\sphinxstyleemphasis{LuaMetaTable}

array()

\sphinxstyleemphasis{LuaTable}

get\_table()

unsigned char*

offset(unsigned int)

\sphinxstyleemphasis{void}

set\_table(LuaTable \{unsigned char\})


\section{∁ C:DoubleVector}
\label{\detokenize{index:c-doublevector}}\label{\detokenize{index:id330}}
\sphinxstyleemphasis{C‡}: std::vector\textless{}double \textgreater{}





Constructor

ℂ

C.DoubleVector()

ℂ

C.DoubleVector()

Methods

\sphinxstyleemphasis{LuaTable}

add(LuaTable \{double\})

double

at(unsigned long)

bool

empty()

\sphinxstyleemphasis{LuaIter}

iter()

void

push\_back(double)

unsigned long

size()

\sphinxstyleemphasis{LuaTable}

table()


\section{⋯ C:FloatArray}
\label{\detokenize{index:c-floatarray}}\label{\detokenize{index:id331}}
\sphinxstyleemphasis{C‡}: float*





Methods

\sphinxstyleemphasis{LuaMetaTable}

array()

\sphinxstyleemphasis{LuaTable}

get\_table()

{\hyperref[\detokenize{index:C:FloatArray}]{\emph{FloatArray}}}

offset(unsigned int)

\sphinxstyleemphasis{void}

set\_table(LuaTable \{float\})


\section{∁ C:FloatArrayVector}
\label{\detokenize{index:c-floatarrayvector}}\label{\detokenize{index:id332}}
\sphinxstyleemphasis{C‡}: std::vector\textless{}float* \textgreater{}





Constructor

ℂ

C.FloatArrayVector()

ℂ

C.FloatArrayVector()

Methods

\sphinxstyleemphasis{LuaTable}

add(LuaTable \{{\hyperref[\detokenize{index:C:FloatArray}]{\emph{FloatArray}}}\})

{\hyperref[\detokenize{index:C:FloatArray}]{\emph{FloatArray}}}

at(unsigned long)

bool

empty()

\sphinxstyleemphasis{LuaIter}

iter()

void

push\_back({\hyperref[\detokenize{index:C:FloatArray}]{\emph{FloatArray}}})

unsigned long

size()

\sphinxstyleemphasis{LuaTable}

table()


\section{∁ C:FloatVector}
\label{\detokenize{index:c-floatvector}}\label{\detokenize{index:id333}}
\sphinxstyleemphasis{C‡}: std::vector\textless{}float \textgreater{}





Constructor

ℂ

C.FloatVector()

ℂ

C.FloatVector()

Methods

\sphinxstyleemphasis{LuaTable}

add(LuaTable \{float\})

float

at(unsigned long)

bool

empty()

\sphinxstyleemphasis{LuaIter}

iter()

void

push\_back(float)

unsigned long

size()

\sphinxstyleemphasis{LuaTable}

table()


\section{∁ C:Int64List}
\label{\detokenize{index:c-int64list}}\label{\detokenize{index:id334}}
\sphinxstyleemphasis{C‡}: std::list\textless{}long \textgreater{}





Constructor

ℂ

C.Int64List()

Methods

\sphinxstyleemphasis{LuaTable}

add(LuaTable \{long\})

long

back()

bool

empty()

long

front()

\sphinxstyleemphasis{LuaIter}

iter()

void

push\_back(long)

void

reverse()

unsigned long

size()

\sphinxstyleemphasis{LuaTable}

table()

void

unique()


\section{⋯ C:IntArray}
\label{\detokenize{index:c-intarray}}\label{\detokenize{index:id335}}
\sphinxstyleemphasis{C‡}: int*





Methods

\sphinxstyleemphasis{LuaMetaTable}

array()

\sphinxstyleemphasis{LuaTable}

get\_table()

{\hyperref[\detokenize{index:C:IntArray}]{\emph{IntArray}}}

offset(unsigned int)

\sphinxstyleemphasis{void}

set\_table(LuaTable \{int\})


\section{∁ C:StringList}
\label{\detokenize{index:c-stringlist}}\label{\detokenize{index:id336}}
\sphinxstyleemphasis{C‡}: std::list\textless{}std::string \textgreater{}





Constructor

ℂ

C.StringList()

Methods

\sphinxstyleemphasis{LuaTable}

add(LuaTable \{std::string\})

std::string

back()

bool

empty()

std::string

front()

\sphinxstyleemphasis{LuaIter}

iter()

void

push\_back(std::string)

void

reverse()

unsigned long

size()

\sphinxstyleemphasis{LuaTable}

table()

void

unique()


\section{∁ C:StringVector}
\label{\detokenize{index:c-stringvector}}\label{\detokenize{index:id337}}
\sphinxstyleemphasis{C‡}: std::vector\textless{}std::string \textgreater{}





Constructor

ℂ

C.StringVector()

ℂ

C.StringVector()

Methods

\sphinxstyleemphasis{LuaTable}

add(LuaTable \{std::string\})

std::string

at(unsigned long)

bool

empty()

\sphinxstyleemphasis{LuaIter}

iter()

void

push\_back(std::string)

unsigned long

size()

\sphinxstyleemphasis{LuaTable}

table()


\section{∁ Cairo:Context}
\label{\detokenize{index:cairo-context}}\label{\detokenize{index:id338}}
\sphinxstyleemphasis{C‡}: Cairo::Context







Context is the main class used to draw in cairomm. It contains the
current state of the rendering device, including coordinates of yet to
be drawn shapes.

In the simplest case, create a Context with its target Surface, set its
drawing options (line width, color, etc), create shapes with methods
like move\_to() and line\_to(), and then draw the shapes to the Surface
using methods such as stroke() or fill().

Context is a reference-counted object that should be used via
Cairo::RefPtr.



Methods

void

arc(double, double, double, double, double)



Adds a circular arc of the given radius to the current path. The arc is
centered at (\sphinxstyleemphasis{xc,} \sphinxstyleemphasis{yc),} begins at \sphinxstyleemphasis{angle1} and proceeds in the
direction of increasing angles to end at \sphinxstyleemphasis{angle2.} If \sphinxstyleemphasis{angle2} is less
than \sphinxstyleemphasis{angle1} it will be progressively increased by 2*M\_PI until it is
greater than \sphinxstyleemphasis{angle1.}

If there is a current point, an initial line segment will be added to
the path to connect the current point to the beginning of the arc. If
this initial line is undesired, it can be avoided by calling
begin\_new\_sub\_path() before calling arc().

Angles are measured in radians. An angle of 0 is in the direction of the
positive X axis (in user-space). An angle of M\_PI/2.0 radians (90
degrees) is in the direction of the positive Y axis (in user-space).
Angles increase in the direction from the positive X axis toward the
positive Y axis. So with the default transformation matrix, angles
increase in a clockwise direction.

( To convert from degrees to radians, use degrees * (M\_PI / 180.0). )

This function gives the arc in the direction of increasing angles; see
arc\_negative() to get the arc in the direction of decreasing angles.

The arc is circular in user-space. To achieve an elliptical arc, you can
scale the current transformation matrix by different amounts in the X
and Y directions. For example, to draw an ellipse in the box given by x,
y, width, height:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{context}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{save}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{context}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{translate}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{context}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{scale}\PYG{p}{(}\PYG{n}{width} \PYG{o}{/} \PYG{l+m+mf}{2.0}\PYG{p}{,} \PYG{n}{height} \PYG{o}{/} \PYG{l+m+mf}{2.0}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{context}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{arc}\PYG{p}{(}\PYG{l+m+mf}{0.0}\PYG{p}{,} \PYG{l+m+mf}{0.0}\PYG{p}{,} \PYG{l+m+mf}{1.0}\PYG{p}{,} \PYG{l+m+mf}{0.0}\PYG{p}{,} \PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{M\PYGZus{}PI}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{context}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{restore}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{description}
\item[{xc}] \leavevmode
X position of the center of the arc

\item[{yc}] \leavevmode
Y position of the center of the arc

\item[{radius}] \leavevmode
the radius of the arc

\item[{angle1}] \leavevmode
the start angle, in radians

\item[{angle2}] \leavevmode
the end angle, in radians

\end{description}



void

arc\_negative(double, double, double, double, double)



Adds a circular arc of the given \sphinxstyleemphasis{radius} to the current path. The arc
is centered at (\sphinxstyleemphasis{xc,} \sphinxstyleemphasis{yc),} begins at \sphinxstyleemphasis{angle1} and proceeds in the
direction of decreasing angles to end at \sphinxstyleemphasis{angle2.} If \sphinxstyleemphasis{angle2} is
greater than \sphinxstyleemphasis{angle1} it will be progressively decreased by 2*M\_PI until
it is greater than \sphinxstyleemphasis{angle1.}

See arc() for more details. This function differs only in the direction
of the arc between the two angles.
\begin{description}
\item[{xc}] \leavevmode
X position of the center of the arc

\item[{yc}] \leavevmode
Y position of the center of the arc

\item[{radius}] \leavevmode
the radius of the arc

\item[{angle1}] \leavevmode
the start angle, in radians

\item[{angle2}] \leavevmode
the end angle, in radians

\end{description}



void

begin\_new\_path()



Clears the current path. After this call there will be no current point.



void

begin\_new\_sub\_path()



Begin a new subpath. Note that the existing path is not affected. After
this call there will be no current point.

In many cases, this call is not needed since new subpaths are frequently
started with move\_to().

A call to begin\_new\_sub\_path() is particularly useful when beginning a
new subpath with one of the arc() calls. This makes things easier as it
is no longer necessary to manually compute the arc’s initial coordinates
for a call to move\_to().

1.2



void

clip()



Establishes a new clip region by intersecting the current clip region
with the current Path as it would be filled by fill() and according to
the current fill rule.

After clip(), the current path will be cleared from the cairo Context.

The current clip region affects all drawing operations by effectively
masking out any changes to the surface that are outside the current clip
region.

Calling clip() can only make the clip region smaller, never larger. But
the current clip is part of the graphics state, so a temporary
restriction of the clip region can be achieved by calling clip() within
a save()/restore() pair. The only other means of increasing the size of
the clip region is reset\_clip().

set\_fill\_rule()



void

clip\_preserve()



Establishes a new clip region by intersecting the current clip region
with the current path as it would be filled by fill() and according to
the current fill rule.

Unlike clip(), clip\_preserve preserves the path within the cairo
Context.

clip()

set\_fill\_rule()



void

close\_path()



Adds a line segment to the path from the current point to the beginning
of the current subpath, (the most recent point passed to move\_to()), and
closes this subpath. After this call the current point will be at the
joined endpoint of the sub-path.

The behavior of close\_path() is distinct from simply calling line\_to()
with the equivalent coordinate in the case of stroking. When a closed
subpath is stroked, there are no caps on the ends of the subpath.
Instead, there is a line join connecting the final and initial segments
of the subpath.

If there is no current point before the call to close\_path(), this
function will have no effect.



void

curve\_to(double, double, double, double, double, double)



Adds a cubic Bezier spline to the path from the current point to
position (x3, y3) in user-space coordinates, using (x1, y1) and (x2, y2)
as the control points. After this call the current point will be (x3,
y3).

If there is no current point before the call to curve\_to() this function
will behave as if preceded by a call to move\_to(x1, y1).
\begin{description}
\item[{x1}] \leavevmode
the X coordinate of the first control point

\item[{y1}] \leavevmode
the Y coordinate of the first control point

\item[{x2}] \leavevmode
the X coordinate of the second control point

\item[{y2}] \leavevmode
the Y coordinate of the second control point

\item[{x3}] \leavevmode
the X coordinate of the end of the curve

\item[{y3}] \leavevmode
the Y coordinate of the end of the curve

\end{description}



void

fill()



A drawing operator that fills the current path according to the current
fill rule, (each sub-path is implicitly closed before being filled).
After fill(), the current path will be cleared from the cairo context.

set\_fill\_rule()

fill\_preserve()



void

fill\_preserve()



A drawing operator that fills the current path according to the current
fill rule, (each sub-path is implicitly closed before being filled).
Unlike fill(), fill\_preserve() preserves the path within the cairo
Context.

set\_fill\_rule()

fill().



void

line\_to(double, double)



Adds a line to the path from the current point to position (x, y) in
user-space coordinates. After this call the current point will be (x,
y).

If there is no current point before the call to line\_to() this function
will behave as move\_to(x, y).
\begin{description}
\item[{x}] \leavevmode
the X coordinate of the end of the new line

\item[{y}] \leavevmode
the Y coordinate of the end of the new line

\end{description}



void

move\_to(double, double)



If the current subpath is not empty, begin a new subpath. After this
call the current point will be (x, y).
\begin{description}
\item[{x}] \leavevmode
the X coordinate of the new position

\item[{y}] \leavevmode
the Y coordinate of the new position

\end{description}



void

paint()



A drawing operator that paints the current source everywhere within the
current clip region.



void

paint\_with\_alpha(double)



A drawing operator that paints the current source everywhere within the
current clip region using a mask of constant alpha value alpha. The
effect is similar to paint(), but the drawing is faded out using the
alpha value.
\begin{description}
\item[{alpha}] \leavevmode
an alpha value, between 0 (transparent) and 1 (opaque)

\end{description}



void

rectangle(double, double, double, double)



Adds a closed-subpath rectangle of the given size to the current path at
position (x, y) in user-space coordinates.

This function is logically equivalent to:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{context}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{move\PYGZus{}to}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{context}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{rel\PYGZus{}line\PYGZus{}to}\PYG{p}{(}\PYG{n}{width}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{context}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{rel\PYGZus{}line\PYGZus{}to}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{height}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{context}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{rel\PYGZus{}line\PYGZus{}to}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{width}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{context}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{close\PYGZus{}path}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{description}
\item[{x}] \leavevmode
the X coordinate of the top left corner of the rectangle

\item[{y}] \leavevmode
the Y coordinate to the top left corner of the rectangle

\item[{width}] \leavevmode
the width of the rectangle

\item[{height}] \leavevmode
the height of the rectangle

\end{description}



void

rel\_curve\_to(double, double, double, double, double, double)



Relative-coordinate version of curve\_to(). All offsets are relative to
the current point. Adds a cubic Bezier spline to the path from the
current point to a point offset from the current point by (dx3, dy3),
using points offset by (dx1, dy1) and (dx2, dy2) as the control points.
After this call the current point will be offset by (dx3, dy3).

Given a current point of (x, y),

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{rel\PYGZus{}curve\PYGZus{}to}\PYG{p}{(}\PYG{n}{dx1}\PYG{p}{,} \PYG{n}{dy1}\PYG{p}{,} \PYG{n}{dx2}\PYG{p}{,} \PYG{n}{dy2}\PYG{p}{,} \PYG{n}{dx3}\PYG{p}{,} \PYG{n}{dy3}\PYG{p}{)}
\end{sphinxVerbatim}

is logically equivalent to

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{curve\PYGZus{}to}\PYG{p}{(}\PYG{n}{x} \PYG{o}{+} \PYG{n}{dx1}\PYG{p}{,} \PYG{n}{y} \PYG{o}{+} \PYG{n}{dy1}\PYG{p}{,} \PYG{n}{x} \PYG{o}{+} \PYG{n}{dx2}\PYG{p}{,} \PYG{n}{y} \PYG{o}{+} \PYG{n}{dy2}\PYG{p}{,} \PYG{n}{x} \PYG{o}{+} \PYG{n}{dx3}\PYG{p}{,} \PYG{n}{y} \PYG{o}{+} \PYG{n}{dy3}\PYG{p}{)}\PYG{o}{.}
\end{sphinxVerbatim}

It is an error to call this function with no current point. Doing so
will cause this to shutdown with a status of
CAIRO\_STATUS\_NO\_CURRENT\_POINT. Cairomm will then throw an exception.
\begin{description}
\item[{dx1}] \leavevmode
the X offset to the first control point

\item[{dy1}] \leavevmode
the Y offset to the first control point

\item[{dx2}] \leavevmode
the X offset to the second control point

\item[{dy2}] \leavevmode
the Y offset to the second control point

\item[{dx3}] \leavevmode
the X offset to the end of the curve

\item[{dy3}] \leavevmode
the Y offset to the end of the curve

\end{description}



void

rel\_line\_to(double, double)



Relative-coordinate version of line\_to(). Adds a line to the path from
the current point to a point that is offset from the current point by
(dx, dy) in user space. After this call the current point will be offset
by (dx, dy).

Given a current point of (x, y),

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{rel\PYGZus{}line\PYGZus{}to}\PYG{p}{(}\PYG{n}{dx}\PYG{p}{,} \PYG{n}{dy}\PYG{p}{)}
\end{sphinxVerbatim}

is logically equivalent to

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{line\PYGZus{}to}\PYG{p}{(}\PYG{n}{x} \PYG{o}{+} \PYG{n}{dx}\PYG{p}{,} \PYG{n}{y} \PYG{o}{+} \PYG{n}{dy}\PYG{p}{)}\PYG{o}{.}
\end{sphinxVerbatim}

It is an error to call this function with no current point. Doing so
will cause this to shutdown with a status of
CAIRO\_STATUS\_NO\_CURRENT\_POINT. Cairomm will then throw an exception.
\begin{description}
\item[{dx}] \leavevmode
the X offset to the end of the new line

\item[{dy}] \leavevmode
the Y offset to the end of the new line

\end{description}



void

rel\_move\_to(double, double)



If the current subpath is not empty, begin a new subpath. After this
call the current point will offset by (x, y).

Given a current point of (x, y),

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{rel\PYGZus{}move\PYGZus{}to}\PYG{p}{(}\PYG{n}{dx}\PYG{p}{,} \PYG{n}{dy}\PYG{p}{)}
\end{sphinxVerbatim}

is logically equivalent to

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{move\PYGZus{}to}\PYG{p}{(}\PYG{n}{x} \PYG{o}{+} \PYG{n}{dx}\PYG{p}{,} \PYG{n}{y} \PYG{o}{+} \PYG{n}{dy}\PYG{p}{)}
\end{sphinxVerbatim}

It is an error to call this function with no current point. Doing so
will cause this to shutdown with a status of
CAIRO\_STATUS\_NO\_CURRENT\_POINT. Cairomm will then throw an exception.
\begin{description}
\item[{dx}] \leavevmode
the X offset

\item[{dy}] \leavevmode
the Y offset

\end{description}



void

reset\_clip()



Reset the current clip region to its original, unrestricted state. That
is, set the clip region to an infinitely large shape containing the
target surface. Equivalently, if infinity is too hard to grasp, one can
imagine the clip region being reset to the exact bounds of the target
surface.

Note that code meant to be reusable should not call reset\_clip() as it
will cause results unexpected by higher-level code which calls clip().
Consider using save() and restore() around clip() as a more robust means
of temporarily restricting the clip region.



void

restore()



Restores cr to the state saved by a preceding call to save() and removes
that state from the stack of saved states.

save()



void

rotate(double)



Modifies the current transformation matrix (CTM) by rotating the
user-space axes by angle radians. The rotation of the axes takes places
after any existing transformation of user space. The rotation direction
for positive angles is from the positive X axis toward the positive Y
axis.
\begin{description}
\item[{angle}] \leavevmode
angle (in radians) by which the user-space axes will be rotated

\end{description}



void

save()



Makes a copy of the current state of the Context and saves it on an
internal stack of saved states. When restore() is called, it will be
restored to the saved state. Multiple calls to save() and restore() can
be nested; each call to restore() restores the state from the matching
paired save().

It isn’t necessary to clear all saved states before a cairo\_t is freed.
Any saved states will be freed when the Context is destroyed.

restore()



void

scale(double, double)



Modifies the current transformation matrix (CTM) by scaling the X and Y
user-space axes by sx and sy respectively. The scaling of the axes takes
place after any existing transformation of user space.
\begin{description}
\item[{sx}] \leavevmode
scale factor for the X dimension

\item[{sy}] \leavevmode
scale factor for the Y dimension

\end{description}



void

set\_dash({\hyperref[\detokenize{index:C:DoubleVector}]{\emph{DoubleVector}}}, double)



Sets the dash pattern to be used by stroke(). A dash pattern is
specified by dashes, an array of positive values. Each value provides
the user-space length of altenate “on” and “off” portions of the stroke.
The offset specifies an offset into the pattern at which the stroke
begins.

Each “on” segment will have caps applied as if the segment were a
separate sub-path. In particular, it is valid to use an “on” length of
0.0 with Cairo::LINE\_CAP\_ROUND or Cairo::LINE\_CAP\_SQUARE in order to
distributed dots or squares along a path.

Note: The length values are in user-space units as evaluated at the time
of stroking. This is not necessarily the same as the user space at the
time of set\_dash().

If dashes is empty dashing is disabled. If the size of dashes is 1, a
symmetric pattern is assumed with alternating on and off portions of the
size specified by the single value in dashes.

It is invalid for any value in dashes to be negative, or for all values
to be 0. If this is the case, an exception will be thrown
\begin{description}
\item[{dashes}] \leavevmode
an array specifying alternate lengths of on and off portions

\item[{offset}] \leavevmode
an offset into the dash pattern at which the stroke should start

\end{description}



void

set\_font\_size(double)



Sets the current font matrix to a scale by a factor of \sphinxstyleemphasis{size,} replacing
any font matrix previously set with set\_font\_size() or
set\_font\_matrix(). This results in a font size of \sphinxstyleemphasis{size} user space
units. (More precisely, this matrix will result in the font’s em-square
being a by \sphinxstyleemphasis{size} square in user space.)

If text is drawn without a call to set\_font\_size(), (nor
set\_font\_matrix() nor set\_scaled\_font()), the default font size is 10.0.
\begin{description}
\item[{size}] \leavevmode
the new font size, in user space units)

\end{description}



void

set\_line\_cap({\hyperref[\detokenize{index:Cairo.LineCap}]{\emph{LineCap}}})



Sets the current line cap style within the cairo Context. See LineCap
for details about how the available line cap styles are drawn.

As with the other stroke parameters, the current line cap style is
examined by stroke(), stroke\_extents(), and stroke\_to\_path(), but does
not have any effect during path construction.

The default line cap style is Cairo::LINE\_CAP\_BUTT.
\begin{description}
\item[{line\_cap}] \leavevmode
a line cap style, as a LineCap

\end{description}



void

set\_line\_join({\hyperref[\detokenize{index:Cairo.LineJoin}]{\emph{LineJoin}}})



Sets the current line join style within the cairo Context. See LineJoin
for details about how the available line join styles are drawn.

As with the other stroke parameters, the current line join style is
examined by stroke(), stroke\_extents(), and stroke\_to\_path(), but does
not have any effect during path construction.

The default line join style is Cairo::LINE\_JOIN\_MITER.
\begin{description}
\item[{line\_join}] \leavevmode
a line joint style, as a LineJoin

\end{description}



void

set\_line\_width(double)



Sets the current line width within the cairo Context. The line width
specifies the diameter of a pen that is circular in user-space, (though
device-space pen may be an ellipse in general due to
scaling/shear/rotation of the CTM).

Note: When the description above refers to user space and CTM it refers
to the user space and CTM in effect at the time of the stroking
operation, not the user space and CTM in effect at the time of the call
to set\_line\_width(). The simplest usage makes both of these spaces
identical. That is, if there is no change to the CTM between a call to
set\_line\_width() and the stroking operation, then one can just pass
user-space values to set\_line\_width() and ignore this note.

As with the other stroke parameters, the current line cap style is
examined by stroke(), stroke\_extents(), and stroke\_to\_path(), but does
not have any effect during path construction.

The default line width value is 2.0.
\begin{description}
\item[{width}] \leavevmode
a line width, as a user-space value

\end{description}



void

set\_operator({\hyperref[\detokenize{index:Cairo.Operator}]{\emph{Operator}}})



Sets the compositing operator to be used for all drawing operations. See
Operator for details on the semantics of each available compositing
operator.
\begin{description}
\item[{op}] \leavevmode
a compositing operator, specified as a Operator

\end{description}



void

set\_source\_rgb(double, double, double)



Sets the source pattern within the Context to an opaque color. This
opaque color will then be used for any subsequent drawing operation
until a new source pattern is set.

The color components are floating point numbers in the range 0 to 1. If
the values passed in are outside that range, they will be clamped.

set\_source\_rgba()

set\_source()
\begin{description}
\item[{red}] \leavevmode
red component of color

\item[{green}] \leavevmode
green component of color

\item[{blue}] \leavevmode
blue component of color

\end{description}



void

set\_source\_rgba(double, double, double, double)



Sets the source pattern within the Context to a translucent color. This
color will then be used for any subsequent drawing operation until a new
source pattern is set.

The color and alpha components are floating point numbers in the range 0
to 1. If the values passed in are outside that range, they will be
clamped.

set\_source\_rgb()

set\_source()
\begin{description}
\item[{red}] \leavevmode
red component of color

\item[{green}] \leavevmode
green component of color

\item[{blue}] \leavevmode
blue component of color

\item[{alpha}] \leavevmode
alpha component of color

\end{description}



void

show\_text(std::string)



A drawing operator that generates the shape from a string of UTF-8
characters, rendered according to the current font\_face, font\_size
(font\_matrix), and font\_options.

This function first computes a set of glyphs for the string of text. The
first glyph is placed so that its origin is at the current point. The
origin of each subsequent glyph is offset from that of the previous
glyph by the advance values of the previous glyph.

After this call the current point is moved to the origin of where the
next glyph would be placed in this same progression. That is, the
current point will be at the origin of the final glyph offset by its
advance values. This allows for easy display of a single logical string
with multiple calls to show\_text().

Note: The show\_text() function call is part of what the cairo designers
call the “toy” text API. It is convenient for short demos and simple
programs, but it is not expected to be adequate for serious text-using
applications. See show\_glyphs() for the “real” text display API in
cairo.
\begin{description}
\item[{utf8}] \leavevmode
a string containing text encoded in UTF-8

\end{description}



void

stroke()



A drawing operator that strokes the current Path according to the
current line width, line join, line cap, and dash settings. After
stroke(), the current Path will be cleared from the cairo Context.

set\_line\_width()

set\_line\_join()

set\_line\_cap()

set\_dash()

stroke\_preserve().

Note: Degenerate segments and sub-paths are treated specially and
provide a useful result. These can result in two different situations:

1. Zero-length “on” segments set in set\_dash(). If the cap style is
Cairo::LINE\_CAP\_ROUND or Cairo::LINE\_CAP\_SQUARE then these segments will
be drawn as circular dots or squares respectively. In the case of
Cairo::LINE\_CAP\_SQUARE, the orientation of the squares is determined by
the direction of the underlying path.

2. A sub-path created by move\_to() followed by either a close\_path() or
one or more calls to line\_to() to the same coordinate as the move\_to().
If the cap style is Cairo::LINE\_CAP\_ROUND then these sub-paths will be
drawn as circular dots. Note that in the case of Cairo::LINE\_CAP\_SQUARE
a degenerate sub-path will not be drawn at all, (since the correct
orientation is indeterminate).

In no case will a cap style of Cairo::LINE\_CAP\_BUTT cause anything to be
drawn in the case of either degenerate segments or sub-paths.



void

stroke\_preserve()



A drawing operator that strokes the current Path according to the
current line width, line join, line cap, and dash settings. Unlike
stroke(), stroke\_preserve() preserves the Path within the cairo Context.

set\_line\_width()

set\_line\_join()

set\_line\_cap()

set\_dash()

stroke\_preserve().



void

translate(double, double)



Modifies the current transformation matrix (CTM) by translating the
user-space origin by (tx, ty). This offset is interpreted as a
user-space coordinate according to the CTM in place before the new call
to translate. In other words, the translation of the user-space origin
takes place after any existing transformation.
\begin{description}
\item[{tx}] \leavevmode
amount to translate in the X direction

\item[{ty}] \leavevmode
amount to translate in the Y direction

\end{description}



void

unset\_dash()



This function disables a dash pattern that was set with set\_dash()




\section{∁ Cairo:ImageSurface}
\label{\detokenize{index:cairo-imagesurface}}\label{\detokenize{index:id339}}
\sphinxstyleemphasis{C‡}: LuaCairo::ImageSurface







wrap RefPtr\textless{} Cairo::ImageSurface \textgreater{}

Image surfaces provide the ability to render to memory buffers either
allocated by cairo or by the calling code. The supported image formats
are those defined in Cairo::Format.



Constructor

ℂ

Cairo.ImageSurface({\hyperref[\detokenize{index:Cairo.Format}]{\emph{Format}}}, int, int)

Methods

{\hyperref[\detokenize{index:Cairo:Context}]{\emph{Context}}}

context()



Returns a context object to perform operations on the surface



int

get\_height()



Gets the height of the ImageSurface in pixels



int

get\_stride()



Returns the stride of the image surface in bytes (or 0 if surface is not
an image surface). The stride is the distance in bytes from the
beginning of one row of the image data to the beginning of the next row.



int

get\_width()



Gets the width of the ImageSurface in pixels



void

set\_as\_source({\hyperref[\detokenize{index:Cairo:Context}]{\emph{Context}}}, int, int)


\section{∁ Cairo:PangoLayout}
\label{\detokenize{index:cairo-pangolayout}}\label{\detokenize{index:id340}}
\sphinxstyleemphasis{C‡}: LuaCairo::PangoLayout





Constructor

ℂ

Cairo.PangoLayout({\hyperref[\detokenize{index:Cairo:Context}]{\emph{Context}}}, std::string)

Methods

{\hyperref[\detokenize{index:Pango.EllipsizeMode}]{\emph{EllipsizeMode}}}

get\_ellipsize()



Gets the type of ellipsization being performed for \sphinxstyleemphasis{layout.} See
set\_ellipsize()

Use is\_ellipsized() to query whether any paragraphs were actually
ellipsized.



Returns The current ellipsization mode for \sphinxstyleemphasis{layout.}





\sphinxstyleemphasis{…}

get\_pixel\_size(\textendash{}lua\textendash{})



Determines the logical width and height of a Pango::Layout in device
units.



std::string

get\_text()



Gets the text in the layout. The returned text should not be freed or
modified.



Returns The text in the \sphinxstyleemphasis{layout.}





{\hyperref[\detokenize{index:Pango.WrapMode}]{\emph{WrapMode}}}

get\_wrap()



Gets the wrap mode for the layout.

Use is\_wrapped() to query whether any paragraphs were actually wrapped.



Returns Active wrap mode.





bool

is\_ellipsized()



Queries whether the layout had to ellipsize any paragraphs.

This returns \sphinxcode{\sphinxupquote{true}} if the ellipsization mode for \sphinxstyleemphasis{layout} is not
Pango::ELLIPSIZE\_NONE, a positive width is set on \sphinxstyleemphasis{layout,} and there
are paragraphs exceeding that width that have to be ellipsized.



Returns \sphinxcode{\sphinxupquote{true}} if any paragraphs had to be ellipsized, \sphinxcode{\sphinxupquote{false}}
otherwise.





bool

is\_wrapped()



Queries whether the layout had to wrap any paragraphs.

This returns \sphinxcode{\sphinxupquote{true}} if a positive width is set on \sphinxstyleemphasis{layout,}
ellipsization mode of \sphinxstyleemphasis{layout} is set to Pango::ELLIPSIZE\_NONE, and
there are paragraphs exceeding the layout width that have to be wrapped.



Returns \sphinxcode{\sphinxupquote{true}} if any paragraphs had to be wrapped, \sphinxcode{\sphinxupquote{false}}
otherwise.





void

layout\_cairo\_path({\hyperref[\detokenize{index:Cairo:Context}]{\emph{Context}}})

void

set\_ellipsize({\hyperref[\detokenize{index:Pango.EllipsizeMode}]{\emph{EllipsizeMode}}})



Sets the type of ellipsization being performed for \sphinxstyleemphasis{layout.} Depending
on the ellipsization mode \sphinxstyleemphasis{ellipsize} text is removed from the start,
middle, or end of text so they fit within the width and height of layout
set with set\_width() and set\_height().

If the layout contains characters such as newlines that force it to be
layed out in multiple paragraphs, then whether each paragraph is
ellipsized separately or the entire layout is ellipsized as a whole
depends on the set height of the layout. See set\_height() for details.
\begin{description}
\item[{ellipsize}] \leavevmode
The new ellipsization mode for \sphinxstyleemphasis{layout.}

\end{description}



void

set\_markup(std::string)



Sets the layout text and attribute list from marked-up text (see markup
format). Replaces the current text and attribute list.
\begin{description}
\item[{markup}] \leavevmode
Some marked-up text.

\end{description}



void

set\_text(std::string)



Set the text of the layout.
\begin{description}
\item[{text}] \leavevmode
The text for the layout.

\end{description}



void

set\_width(int)



Sets the width to which the lines of the Pango::Layout should wrap or
ellipsized. The default value is -1: no width set.
\begin{description}
\item[{width}] \leavevmode
The desired width in Pango units, or -1 to indicate that no wrapping
or ellipsization should be performed.

\end{description}



void

set\_wrap({\hyperref[\detokenize{index:Pango.WrapMode}]{\emph{WrapMode}}})



Sets the wrap mode; the wrap mode only has effect if a width is set on
the layout with set\_width(). To turn off wrapping, set the width to -1.
\begin{description}
\item[{wrap}] \leavevmode
The wrap mode.

\end{description}



void

show\_in\_cairo\_context({\hyperref[\detokenize{index:Cairo:Context}]{\emph{Context}}})


\section{∁ Evoral:Beats}
\label{\detokenize{index:evoral-beats}}\label{\detokenize{index:id341}}
\sphinxstyleemphasis{C‡}: Evoral::Beats







Musical time in beats.



Constructor

ℂ

Evoral.Beats(double)



Create from a real number of beats.



Methods

double

to\_double()


\section{↠ Evoral:Control}
\label{\detokenize{index:evoral-control}}\label{\detokenize{index:id342}}
\sphinxstyleemphasis{C‡}: boost::shared\_ptr\textless{} Evoral::Control \textgreater{}, boost::weak\_ptr\textless{}
Evoral::Control \textgreater{}







Base class representing some kind of (automatable) control; a fader’s
gain, for example, or a compressor plugin’s threshold.

The class knows the Evoral::Parameter that it is controlling, and has a
list of values for automation.



Methods

bool

isnil()

{\hyperref[\detokenize{index:Evoral:ControlList}]{\emph{ControlList}}}

list()


\section{∁ Evoral:ControlEvent}
\label{\detokenize{index:evoral-controlevent}}\label{\detokenize{index:id343}}
\sphinxstyleemphasis{C‡}: Evoral::ControlEvent







A single event (time-stamped value) for a control



Data Members

double

value

double

when


\section{↠ Evoral:ControlList}
\label{\detokenize{index:evoral-controllist}}\label{\detokenize{index:id344}}
\sphinxstyleemphasis{C‡}: boost::shared\_ptr\textless{} Evoral::ControlList \textgreater{}, boost::weak\_ptr\textless{}
Evoral::ControlList \textgreater{}







A list (sequence) of time-stamped values for a control



Methods

void

add(double, double, bool, bool)



add automation events
\begin{description}
\item[{when}] \leavevmode
absolute time in samples

\item[{value}] \leavevmode
parameter value

\item[{with\_guards}] \leavevmode
if true, add guard-points

\item[{with\_initial}] \leavevmode
if true, add an initial point if the list is empty

\end{description}



void

clear(double, double)



remove all automation events between the given time range
\begin{description}
\item[{start}] \leavevmode
start of range (inclusive) in audio samples

\item[{end}] \leavevmode
end of range (inclusive) in audio samples

\end{description}



void

clear\_list()

double

eval(double)



query value at given time (takes a read-lock, not safe while writing
automation)
\begin{description}
\item[{where}] \leavevmode
absolute time in samples

\end{description}



Returns parameter value





{\hyperref[\detokenize{index:ARDOUR:EventList}]{\emph{EventList}}}

events()

bool

in\_write\_pass()

{\hyperref[\detokenize{index:Evoral.ControlList.InterpolationStyle}]{\emph{InterpolationStyle}}}

interpolation()



query interpolation style of the automation data



Returns Interpolation Style





bool

isnil()

\sphinxstyleemphasis{LuaTable}(double, …)

rt\_safe\_eval(double, bool\&)



realtime safe version of eval, may fail if read-lock cannot be taken
\begin{description}
\item[{where}] \leavevmode
absolute time in samples

\item[{ok}] \leavevmode
boolean reference if returned value is valid

\end{description}



Returns parameter value





bool

set\_interpolation({\hyperref[\detokenize{index:Evoral.ControlList.InterpolationStyle}]{\emph{InterpolationStyle}}})



set the interpolation style of the automation data.

This will fail when asking for Logarithmic scale and min,max crosses 0
or Exponential scale with min != 0.
\begin{description}
\item[{is}] \leavevmode
interpolation style

\end{description}



Returns true if style change was successful





void

thin(double)



Thin the number of events in this list.

The thinning factor corresponds to the area of a triangle computed
between three points in the list (time-difference * value-difference).
If the area is large, it indicates significant non-linearity between the
points.

Time is measured in samples, value is usually normalized to 0..1.

During automation recording we thin the recorded points using this
value. If a point is sufficiently co-linear with its neighbours (as
defined by the area of the triangle formed by three of them), we will
not include it in the list. The larger the value, the more points are
excluded, so this effectively measures the amount of thinning to be
done.
\begin{description}
\item[{thinning\_factor}] \leavevmode
area-size (default: 20)

\end{description}



void

truncate\_end(double)



truncate the event list after the given time
\begin{description}
\item[{last\_coordinate}] \leavevmode
last event to include

\end{description}



void

truncate\_start(double)



truncate the event list to the given time
\begin{description}
\item[{overall\_length}] \leavevmode
overall length

\end{description}




\section{↠ Evoral:ControlSet}
\label{\detokenize{index:evoral-controlset}}\label{\detokenize{index:id345}}
\sphinxstyleemphasis{C‡}: boost::shared\_ptr\textless{} Evoral::ControlSet \textgreater{}, boost::weak\_ptr\textless{}
Evoral::ControlSet \textgreater{}





Methods

bool

isnil()


\section{∁ Evoral:Event}
\label{\detokenize{index:evoral-event}}\label{\detokenize{index:id346}}
\sphinxstyleemphasis{C‡}: Evoral::Event\textless{}long\textgreater{}





Methods

unsigned char*

buffer()

unsigned char

channel()

void

clear()

void

set\_buffer(unsigned int, unsigned char*, bool)

void

set\_channel(unsigned char)

void

set\_type(unsigned char)

unsigned int

size()

long

time()

unsigned char

type()


\section{↠ Evoral:NotePtr}
\label{\detokenize{index:evoral-noteptr}}\label{\detokenize{index:id347}}
\sphinxstyleemphasis{C‡}: boost::shared\_ptr\textless{} Evoral::Note\textless{}Evoral::Beats\textgreater{} \textgreater{}, boost::weak\_ptr\textless{}
Evoral::Note\textless{}Evoral::Beats\textgreater{} \textgreater{}





Methods

unsigned char

channel()

bool

isnil()

{\hyperref[\detokenize{index:Evoral:Beats}]{\emph{Beats}}}

length()

unsigned char

note()

unsigned char

off\_velocity()

{\hyperref[\detokenize{index:Evoral:Beats}]{\emph{Beats}}}

time()

unsigned char

velocity()


\section{∁ Evoral:Parameter}
\label{\detokenize{index:evoral-parameter}}\label{\detokenize{index:id348}}
\sphinxstyleemphasis{C‡}: Evoral::Parameter







ID of a {[}play\textbar{}record\textbar{}automate{]}able parameter.

A parameter is defined by (type, id, channel). Type is an integer which
can be used in any way by the application (e.g. cast to a custom enum,
map to/from a URI, etc). ID is type specific (e.g. MIDI controller \#).

This class defines a \textless{} operator which is a strict weak ordering, so
Parameter may be stored in a std::set, used as a std::map key, etc.



Constructor

ℂ

Evoral.Parameter(unsigned int, unsigned char, unsigned int)

Methods

unsigned char

channel()

unsigned int

id()

unsigned int

type()


\section{∁ Evoral:ParameterDescriptor}
\label{\detokenize{index:evoral-parameterdescriptor}}\label{\detokenize{index:id349}}
\sphinxstyleemphasis{C‡}: Evoral::ParameterDescriptor







Description of the value range of a parameter or control.



Constructor

ℂ

Evoral.ParameterDescriptor()

Data Members

bool

logarithmic



True for log-scale parameters



float

lower



Minimum value (in Hz, for frequencies)



float

normal



Default value



bool

toggled



True iff parameter is boolean



float

upper



Maximum value (in Hz, for frequencies)




\section{∁ Evoral:Range}
\label{\detokenize{index:evoral-range}}\label{\detokenize{index:id350}}
\sphinxstyleemphasis{C‡}: Evoral::Range\textless{}long\textgreater{}





Constructor

ℂ

Evoral.Range(long, long)

Data Members

long

from

long

to


\section{↠ Evoral:Sequence}
\label{\detokenize{index:evoral-sequence}}\label{\detokenize{index:id351}}
\sphinxstyleemphasis{C‡}: boost::shared\_ptr\textless{} Evoral::Sequence\textless{}Evoral::Beats\textgreater{} \textgreater{},
boost::weak\_ptr\textless{} Evoral::Sequence\textless{}Evoral::Beats\textgreater{} \textgreater{}

is-a: {\hyperref[\detokenize{index:Evoral:ControlSet}]{\emph{Evoral:ControlSet}}}





Methods

bool

isnil()


\section{∁ LuaDialog:Dialog}
\label{\detokenize{index:luadialog-dialog}}\label{\detokenize{index:id352}}
\sphinxstyleemphasis{C‡}: LuaDialog::Dialog





Constructor

ℂ

LuaDialog.Dialog(std::string, Lua-Function)

Methods

\sphinxstyleemphasis{…}

run(\textendash{}lua\textendash{})


\section{∁ LuaDialog:Message}
\label{\detokenize{index:luadialog-message}}\label{\detokenize{index:id353}}
\sphinxstyleemphasis{C‡}: LuaDialog::Message





Constructor

ℂ

LuaDialog.Message(std::string,
std::string,{\hyperref[\detokenize{index:LuaDialog.Message.MessageType}]{\emph{MessageType}}},{\hyperref[\detokenize{index:LuaDialog.Message.ButtonType}]{\emph{ButtonType}}})

Methods

int

run()


\section{∁ LuaSignal:Set}
\label{\detokenize{index:luasignal-set}}\label{\detokenize{index:id354}}
\sphinxstyleemphasis{C‡}: std::bitset\textless{}48ul\textgreater{}





Constructor

ℂ

LuaSignal.Set()

Methods

\sphinxstyleemphasis{LuaTable}

add(48ul)

bool

any()

unsigned long

count()

bool

none()

{\hyperref[\detokenize{index:LuaSignal:Set}]{\emph{Set}}}

reset()

{\hyperref[\detokenize{index:LuaSignal:Set}]{\emph{Set}}}

set(unsigned long, bool)

unsigned long

size()

\sphinxstyleemphasis{LuaTable}

table()

bool

test(unsigned long)


\section{ℕ PBD}
\label{\detokenize{index:pbd}}\label{\detokenize{index:id355}}




Methods

bool

open\_uri(std::string)

bool

open\_uri(std::string)


\section{∁ PBD:Command}
\label{\detokenize{index:pbd-command}}\label{\detokenize{index:id356}}
\sphinxstyleemphasis{C‡}: Command

is-a: {\hyperref[\detokenize{index:PBD:StatefulDestructible}]{\emph{PBD:StatefulDestructible}}}







Base class for Undo/Redo commands and changesets



Methods

std::string

name()

void

set\_name(std::string)


\subsection{Inherited from PBD:Stateful}
\label{\detokenize{index:inherited-from-pbdstateful-8}}\label{\detokenize{index:id357}}
Methods

void

clear\_changes()



Forget about any changes to this object’s properties



{\hyperref[\detokenize{index:PBD:ID}]{\emph{ID}}}

id()

{\hyperref[\detokenize{index:ARDOUR:OwnedPropertyList}]{\emph{OwnedPropertyList}}}

properties()


\section{∅ PBD:Configuration}
\label{\detokenize{index:pbd-configuration}}\label{\detokenize{index:id358}}
\sphinxstyleemphasis{C‡}: PBD::Configuration

is-a: {\hyperref[\detokenize{index:PBD:Stateful}]{\emph{PBD:Stateful}}}







Base class for objects with saveable and undoable state



This class object is only used indirectly as return-value and
function-parameter. It provides no methods by itself.


\subsection{Inherited from PBD:Stateful}
\label{\detokenize{index:inherited-from-pbdstateful-9}}\label{\detokenize{index:id359}}
Methods

void

clear\_changes()



Forget about any changes to this object’s properties



{\hyperref[\detokenize{index:PBD:ID}]{\emph{ID}}}

id()

{\hyperref[\detokenize{index:ARDOUR:OwnedPropertyList}]{\emph{OwnedPropertyList}}}

properties()


\section{↠ PBD:Controllable}
\label{\detokenize{index:pbd-controllable}}\label{\detokenize{index:id360}}
\sphinxstyleemphasis{C‡}: boost::shared\_ptr\textless{} PBD::Controllable \textgreater{}, boost::weak\_ptr\textless{}
PBD::Controllable \textgreater{}

is-a: {\hyperref[\detokenize{index:PBD:StatefulDestructiblePtr}]{\emph{PBD:StatefulDestructiblePtr}}}







This is a pure virtual class to represent a scalar control.

Note that it contains no storage/state for the controllable thing that
it represents. Derived classes must provide set\_value()/get\_value()
methods, which will involve (somehow) an actual location to store the
value.

In essence, this is an interface, not a class.

Without overriding upper() and lower(), a derived class will function as
a control whose value can range between 0 and 1.0.



Methods

double

get\_value()

bool

isnil()

std::string

name()


\subsection{Inherited from PBD:StatefulPtr}
\label{\detokenize{index:inherited-from-pbdstatefulptr-12}}\label{\detokenize{index:id361}}
Methods

void

clear\_changes()



Forget about any changes to this object’s properties



{\hyperref[\detokenize{index:PBD:ID}]{\emph{ID}}}

id()

{\hyperref[\detokenize{index:ARDOUR:OwnedPropertyList}]{\emph{OwnedPropertyList}}}

properties()


\section{∁ PBD:ID}
\label{\detokenize{index:pbd-id}}\label{\detokenize{index:id362}}
\sphinxstyleemphasis{C‡}: PBD::ID







a unique ID to identify objects numerically



Constructor

ℂ

PBD.ID(std::string)

Methods

std::string

to\_s()


\section{∁ PBD:IdVector}
\label{\detokenize{index:pbd-idvector}}\label{\detokenize{index:id363}}
\sphinxstyleemphasis{C‡}: std::vector\textless{}PBD::ID \textgreater{}





Constructor

ℂ

PBD.IdVector()

ℂ

PBD.IdVector()

Methods

\sphinxstyleemphasis{LuaTable}

add(LuaTable \{{\hyperref[\detokenize{index:PBD:ID}]{\emph{ID}}}\})

{\hyperref[\detokenize{index:PBD:ID}]{\emph{ID}}}

at(unsigned long)

bool

empty()

\sphinxstyleemphasis{LuaIter}

iter()

void

push\_back({\hyperref[\detokenize{index:PBD:ID}]{\emph{ID}}})

unsigned long

size()

\sphinxstyleemphasis{LuaTable}

table()


\section{∁ PBD:RingBuffer8}
\label{\detokenize{index:pbd-ringbuffer8}}\label{\detokenize{index:id364}}
\sphinxstyleemphasis{C‡}: PBD::RingBufferNPT\textless{}unsigned char\textgreater{}





Constructor

ℂ

PBD.RingBuffer8(unsigned long)

Methods

void

increment\_read\_ptr(unsigned long)

void

increment\_write\_ptr(unsigned long)

unsigned long

read(unsigned char*, unsigned long)

unsigned long

read\_space()

void

reset()

unsigned long

write(unsigned char*, unsigned long)

unsigned long

write\_one(unsigned char)

unsigned long

write\_space()


\section{∁ PBD:RingBufferF}
\label{\detokenize{index:pbd-ringbufferf}}\label{\detokenize{index:id365}}
\sphinxstyleemphasis{C‡}: PBD::RingBufferNPT\textless{}float\textgreater{}





Constructor

ℂ

PBD.RingBufferF(unsigned long)

Methods

void

increment\_read\_ptr(unsigned long)

void

increment\_write\_ptr(unsigned long)

unsigned long

read({\hyperref[\detokenize{index:C:FloatArray}]{\emph{FloatArray}}}, unsigned long)

unsigned long

read\_space()

void

reset()

unsigned long

write({\hyperref[\detokenize{index:C:FloatArray}]{\emph{FloatArray}}}, unsigned long)

unsigned long

write\_one(float)

unsigned long

write\_space()


\section{∁ PBD:RingBufferI}
\label{\detokenize{index:pbd-ringbufferi}}\label{\detokenize{index:id366}}
\sphinxstyleemphasis{C‡}: PBD::RingBufferNPT\textless{}int\textgreater{}





Constructor

ℂ

PBD.RingBufferI(unsigned long)

Methods

void

increment\_read\_ptr(unsigned long)

void

increment\_write\_ptr(unsigned long)

unsigned long

read({\hyperref[\detokenize{index:C:IntArray}]{\emph{IntArray}}}, unsigned long)

unsigned long

read\_space()

void

reset()

unsigned long

write({\hyperref[\detokenize{index:C:IntArray}]{\emph{IntArray}}}, unsigned long)

unsigned long

write\_one(int)

unsigned long

write\_space()


\section{∁ PBD:Stateful}
\label{\detokenize{index:pbd-stateful}}\label{\detokenize{index:id367}}
\sphinxstyleemphasis{C‡}: PBD::Stateful







Base class for objects with saveable and undoable state



Methods

void

clear\_changes()



Forget about any changes to this object’s properties



{\hyperref[\detokenize{index:PBD:ID}]{\emph{ID}}}

id()

{\hyperref[\detokenize{index:ARDOUR:OwnedPropertyList}]{\emph{OwnedPropertyList}}}

properties()


\section{∅ PBD:StatefulDestructible}
\label{\detokenize{index:pbd-statefuldestructible}}\label{\detokenize{index:id368}}
\sphinxstyleemphasis{C‡}: PBD::StatefulDestructible

is-a: {\hyperref[\detokenize{index:PBD:Stateful}]{\emph{PBD:Stateful}}}







Base class for objects with saveable and undoable state with destruction
notification



This class object is only used indirectly as return-value and
function-parameter. It provides no methods by itself.


\subsection{Inherited from PBD:Stateful}
\label{\detokenize{index:inherited-from-pbdstateful-10}}\label{\detokenize{index:id369}}
Methods

void

clear\_changes()



Forget about any changes to this object’s properties



{\hyperref[\detokenize{index:PBD:ID}]{\emph{ID}}}

id()

{\hyperref[\detokenize{index:ARDOUR:OwnedPropertyList}]{\emph{OwnedPropertyList}}}

properties()


\section{↠ PBD:StatefulDestructiblePtr}
\label{\detokenize{index:pbd-statefuldestructibleptr}}\label{\detokenize{index:id370}}
\sphinxstyleemphasis{C‡}: boost::shared\_ptr\textless{} PBD::StatefulDestructible \textgreater{}, boost::weak\_ptr\textless{}
PBD::StatefulDestructible \textgreater{}

is-a: {\hyperref[\detokenize{index:PBD:StatefulPtr}]{\emph{PBD:StatefulPtr}}}







Base class for objects with saveable and undoable state with destruction
notification



Methods

bool

isnil()


\subsection{Inherited from PBD:StatefulPtr}
\label{\detokenize{index:inherited-from-pbdstatefulptr-13}}\label{\detokenize{index:id371}}
Methods

void

clear\_changes()



Forget about any changes to this object’s properties



{\hyperref[\detokenize{index:PBD:ID}]{\emph{ID}}}

id()

{\hyperref[\detokenize{index:ARDOUR:OwnedPropertyList}]{\emph{OwnedPropertyList}}}

properties()


\section{∁ PBD:StatefulDiffCommand}
\label{\detokenize{index:pbd-statefuldiffcommand}}\label{\detokenize{index:id372}}
\sphinxstyleemphasis{C‡}: PBD::StatefulDiffCommand

is-a: {\hyperref[\detokenize{index:PBD:Command}]{\emph{PBD:Command}}}







A Command which stores its action as the differences between the before
and after state of a Stateful object.



Methods

bool

empty()

void

undo()


\subsection{Inherited from PBD:Command}
\label{\detokenize{index:inherited-from-pbdcommand-2}}\label{\detokenize{index:id373}}
Methods

std::string

name()

void

set\_name(std::string)


\subsection{Inherited from PBD:Stateful}
\label{\detokenize{index:inherited-from-pbdstateful-11}}\label{\detokenize{index:id374}}
Methods

void

clear\_changes()



Forget about any changes to this object’s properties



{\hyperref[\detokenize{index:PBD:ID}]{\emph{ID}}}

id()

{\hyperref[\detokenize{index:ARDOUR:OwnedPropertyList}]{\emph{OwnedPropertyList}}}

properties()


\section{↠ PBD:StatefulPtr}
\label{\detokenize{index:pbd-statefulptr}}\label{\detokenize{index:id375}}
\sphinxstyleemphasis{C‡}: boost::shared\_ptr\textless{} PBD::Stateful \textgreater{}, boost::weak\_ptr\textless{} PBD::Stateful
\textgreater{}







Base class for objects with saveable and undoable state



Methods

void

clear\_changes()



Forget about any changes to this object’s properties



{\hyperref[\detokenize{index:PBD:ID}]{\emph{ID}}}

id()

bool

isnil()

{\hyperref[\detokenize{index:ARDOUR:OwnedPropertyList}]{\emph{OwnedPropertyList}}}

properties()


\section{∁ PBD:XMLNode}
\label{\detokenize{index:pbd-xmlnode}}\label{\detokenize{index:id376}}
\sphinxstyleemphasis{C‡}: XMLNode





Methods

std::string

name()


\section{∁ Timecode:BBT\_TIME}
\label{\detokenize{index:timecode-bbt-time}}\label{\detokenize{index:id377}}
\sphinxstyleemphasis{C‡}: Timecode::BBT\_Time







Bar, Beat, Tick Time (i.e. Tempo-Based Time)



Constructor

ℂ

Timecode.BBT\_TIME(unsigned int, unsigned int, unsigned int)

Data Members

unsigned int

bars

unsigned int

beats

unsigned int

ticks


\section{∁ Timecode:Time}
\label{\detokenize{index:timecode-time}}\label{\detokenize{index:id378}}
\sphinxstyleemphasis{C‡}: Timecode::Time





Constructor

ℂ

Timecode.Time(double)

Data Members

bool

drop



Whether this Time uses dropframe Timecode



unsigned int

frames



Timecode frames (not audio samples)



unsigned int

hours

unsigned int

minutes

bool

negative

double

rate



Frame rate of this Time



unsigned int

seconds

unsigned int

subframes



Typically unused




\section{∁ Vamp:Plugin}
\label{\detokenize{index:vamp-plugin}}\label{\detokenize{index:id379}}
\sphinxstyleemphasis{C‡}: Vamp::Plugin

is-a: {\hyperref[\detokenize{index:Vamp:PluginBase}]{\emph{Vamp:PluginBase}}}







Vamp::Plugin is a base class for plugin instance classes that provide
feature extraction from audio or related data.

In most cases, the input will be audio and the output will be a stream
of derived data at a lower sampling resolution than the input.

Note that this class inherits several abstract methods from PluginBase.
These must be implemented by the subclass.

PLUGIN LIFECYCLE

Feature extraction plugins are managed differently from real-time
plugins (such as VST effects). The main difference is that the
parameters for a feature extraction plugin are configured before the
plugin is used, and do not change during use.

1. Host constructs the plugin, passing it the input sample rate. The
plugin may do basic initialisation, but should not do anything
computationally expensive at this point. You must make sure your plugin
is cheap to construct, otherwise you’ll seriously affect the startup
performance of almost all hosts. If you have serious initialisation to
do, the proper place is in initialise() (step 5).
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\setcounter{enumi}{1}
\item {} 
Host may query the plugin’s available outputs.

\end{enumerate}

3. Host queries programs and parameter descriptors, and may set some or
all of them. Parameters that are not explicitly set should take their
default values as specified in the parameter descriptor. When a program
is set, the parameter values may change and the host will re-query them
to check.

4. Host queries the preferred step size, block size and number of
channels. These may all vary depending on the parameter values. (Note
however that you cannot make the number of distinct outputs dependent on
parameter values.)

5. Plugin is properly initialised with a call to initialise. This fixes
the step size, block size, and number of channels, as well as all of the
parameter and program settings. If the values passed in to initialise do
not match the plugin’s advertised preferred values from step 4, the
plugin may refuse to initialise and return false (although if possible
it should accept the new values). Any computationally expensive setup
code should take place here.

6. Host finally checks the number of values, resolution, extents etc per
output (which may vary depending on the number of channels, step size
and block size as well as the parameter values).

7. Host will repeatedly call the process method to pass in blocks of
input data. This method may return features extracted from that data (if
the plugin is causal).

8. Host will call getRemainingFeatures exactly once, after all the input
data has been processed. This may return any non-causal or leftover
features.

9. At any point after initialise was called, the host may optionally
call the reset method and restart processing. (This does not mean it can
change the parameters, which are fixed from initialise until
destruction.)

A plugin does not need to handle the case where setParameter or
selectProgram is called after initialise has been called. It’s the
host’s responsibility not to do that. Similarly, the plugin may safely
assume that initialise is called no more than once.



Methods

{\hyperref[\detokenize{index:Vamp.Plugin.InputDomain}]{\emph{InputDomain}}}

getInputDomain()



Get the plugin’s required input domain.

If this is TimeDomain, the samples provided to the process() function
(below) will be in the time domain, as for a traditional audio
processing plugin.

If this is FrequencyDomain, the host will carry out a windowed FFT of
size equal to the negotiated block size on the data before passing the
frequency bin data in to process(). The input data for the FFT will be
rotated so as to place the origin in the centre of the block. The plugin
does not get to choose the window type \textendash{} the host will either let the
user do so, or will use a Hanning window.



unsigned long

getMaxChannelCount()



Get the maximum supported number of input channels.



unsigned long

getMinChannelCount()



Get the minimum supported number of input channels.



{\hyperref[\detokenize{index:Vamp:Plugin:OutputList}]{\emph{OutputList}}}

getOutputDescriptors()



Get the outputs of this plugin. An output’s index in this list is used
as its numeric index when looking it up in the FeatureSet returned from
the process() call.



unsigned long

getPreferredBlockSize()



Get the preferred block size (window size \textendash{} the number of sample frames
passed in each block to the process() function). This should be called
before initialise().

A plugin that can handle any block size may return 0. The final block
size will be set in the initialise() call.



unsigned long

getPreferredStepSize()



Get the preferred step size (window increment \textendash{} the distance in sample
frames between the start frames of consecutive blocks passed to the
process() function) for the plugin. This should be called before
initialise().

A plugin may return 0 if it has no particular interest in the step size.
In this case, the host should make the step size equal to the block size
if the plugin is accepting input in the time domain. If the plugin is
accepting input in the frequency domain, the host may use any step size.
The final step size will be set in the initialise() call.



{\hyperref[\detokenize{index:Vamp:Plugin:FeatureSet}]{\emph{FeatureSet}}}

getRemainingFeatures()



After all blocks have been processed, calculate and return any remaining
features derived from the complete input.



std::string

getType()



Used to distinguish between Vamp::Plugin and other potential sibling
subclasses of PluginBase. Do not reimplement this function in your
subclass.



bool

initialise(unsigned long, unsigned long, unsigned long)



Initialise a plugin to prepare it for use with the given number of input
channels, step size (window increment, in sample frames) and block size
(window size, in sample frames).

The input sample rate should have been already specified at construction
time.

Return true for successful initialisation, false if the number of input
channels, step size and/or block size cannot be supported.



void

reset()



Reset the plugin after use, to prepare it for another clean run. Not
called for the first initialisation (i.e. initialise must also do a
reset).




\subsection{Inherited from Vamp:PluginBase}
\label{\detokenize{index:inherited-from-vamp-pluginbase}}
Methods

std::string

getCopyright()



Get the copyright statement or licensing summary for the plugin. This
can be an informative text, without the same presentation constraints as
mentioned for getMaker above.



std::string

getCurrentProgram()



Get the current program.



std::string

getDescription()



Get a human-readable description for the plugin, typically a line of
text that may optionally be displayed in addition to the plugin’s
“name”. May be empty if the name has said it all already.

Example: “Detect and count zero crossing points”



std::string

getIdentifier()



Get the computer-usable name of the plugin. This should be reasonably
short and contain no whitespace or punctuation characters. It may only
contain the characters {[}{\color{red}\bfseries{}a-zA-Z0-9\_}-{]}. This is the authoritative way for
a program to identify a plugin within a given library.

This text may be visible to the user, but it should not be the main text
used to identify a plugin to the user (that will be the name, below).

Example: “zero\_crossings”



std::string

getMaker()



Get the name of the author or vendor of the plugin in human-readable
form. This should be a short identifying text, as it may be used to
label plugins from the same source in a menu or similar.



std::string

getName()



Get a human-readable name or title of the plugin. This should be brief
and self-contained, as it may be used to identify the plugin to the user
in isolation (i.e. without also showing the plugin’s “identifier”).

Example: “Zero Crossings”



float

getParameter(std::string)



Get the value of a named parameter. The argument is the identifier field
from that parameter’s descriptor.



{\hyperref[\detokenize{index:Vamp:PluginBase:ParameterList}]{\emph{ParameterList}}}

getParameterDescriptors()



Get the controllable parameters of this plugin.



int

getPluginVersion()



Get the version number of the plugin.



{\hyperref[\detokenize{index:C:StringVector}]{\emph{StringVector}}}

getPrograms()



Get the program settings available in this plugin. A program is a named
shorthand for a set of parameter values; changing the program may cause
the plugin to alter the values of its published parameters (and/or
non-public internal processing parameters). The host should re-read the
plugin’s parameter values after setting a new program.

The programs must have unique names.



void

selectProgram(std::string)



Select a program. (If the given program name is not one of the available
programs, do nothing.)



void

setParameter(std::string, float)



Set a named parameter. The first argument is the identifier field from
that parameter’s descriptor.




\section{∁ Vamp:Plugin:Feature}
\label{\detokenize{index:vamp-plugin-feature}}\label{\detokenize{index:id380}}
\sphinxstyleemphasis{C‡}: Vamp::Plugin::Feature





Data Members

{\hyperref[\detokenize{index:Vamp:RealTime}]{\emph{Vamp:RealTime}}}

duration



Duration of the output feature. This is mandatory if the output has
VariableSampleRate or FixedSampleRate and hasDuration is true, and
unused otherwise.



bool

hasDuration



True if an output feature has a specified duration. This is optional if
the output has VariableSampleRate or FixedSampleRate, and and unused if
the output has OneSamplePerStep.



bool

hasTimestamp



True if an output feature has its own timestamp. This is mandatory if
the output has VariableSampleRate, optional if the output has
FixedSampleRate, and unused if the output has OneSamplePerStep.



std::string

label



Label for the sample of this feature.



{\hyperref[\detokenize{index:Vamp:RealTime}]{\emph{Vamp:RealTime}}}

timestamp



Timestamp of the output feature. This is mandatory if the output has
VariableSampleRate or if the output has FixedSampleRate and hasTimestamp
is true, and unused otherwise.



{\hyperref[\detokenize{index:C:FloatVector}]{\emph{C:FloatVector}}}

values



Results for a single sample of this feature. If the output
hasFixedBinCount, there must be the same number of values as the
output’s binCount count.




\section{∁ Vamp:Plugin:FeatureList}
\label{\detokenize{index:vamp-plugin-featurelist}}\label{\detokenize{index:id381}}
\sphinxstyleemphasis{C‡}: std::vector\textless{}Vamp::Plugin::Feature \textgreater{}





Constructor

ℂ

Vamp.Plugin.FeatureList()

ℂ

Vamp.Plugin.FeatureList()

Methods

\sphinxstyleemphasis{LuaTable}

add(LuaTable \{{\hyperref[\detokenize{index:Vamp:Plugin:Feature}]{\emph{Feature}}}\})

{\hyperref[\detokenize{index:Vamp:Plugin:Feature}]{\emph{Feature}}}

at(unsigned long)

bool

empty()

\sphinxstyleemphasis{LuaIter}

iter()

void

push\_back({\hyperref[\detokenize{index:Vamp:Plugin:Feature}]{\emph{Feature}}})

unsigned long

size()

\sphinxstyleemphasis{LuaTable}

table()


\section{∁ Vamp:Plugin:FeatureSet}
\label{\detokenize{index:vamp-plugin-featureset}}\label{\detokenize{index:id382}}
\sphinxstyleemphasis{C‡}: std::map\textless{}int, std::vector\textless{}Vamp::Plugin::Feature \textgreater{} \textgreater{} \textgreater{} \textgreater{}





Constructor

ℂ

Vamp.Plugin.FeatureSet()

Methods

\sphinxstyleemphasis{LuaTable}

add(LuaTable \{{\hyperref[\detokenize{index:Vamp:Plugin:Feature}]{\emph{Feature}}}\})

\sphinxstyleemphasis{…}

at(\textendash{}lua\textendash{})

void

clear()

unsigned long

count(int)

bool

empty()

\sphinxstyleemphasis{LuaIter}

iter()

unsigned long

size()

\sphinxstyleemphasis{LuaTable}

table()


\section{∁ Vamp:Plugin:OutputDescriptor}
\label{\detokenize{index:vamp-plugin-outputdescriptor}}\label{\detokenize{index:id383}}
\sphinxstyleemphasis{C‡}: Vamp::Plugin::OutputDescriptor





Data Members

unsigned long

binCount



The number of values per result of the output. Undefined if
hasFixedBinCount is false. If this is zero, the output is point data
(i.e. only the time of each output is of interest, the value list will
be empty).



{\hyperref[\detokenize{index:C:StringVector}]{\emph{C:StringVector}}}

binNames



The (human-readable) names of each of the bins, if appropriate. This is
always optional.



std::string

description



A human-readable short text describing the output. May be empty if the
name has said it all already. Example: “The number of zero crossing
points per processing block”



bool

hasDuration



True if the returned results for this output are known to have a
duration field.



bool

hasFixedBinCount



True if the output has the same number of values per sample for every
output sample. Outputs for which this is false are unlikely to be very
useful in a general-purpose host.



bool

hasKnownExtents



True if the results in each output bin fall within a fixed numeric range
(minimum and maximum values). Undefined if binCount is zero.



std::string

identifier



The name of the output, in computer-usable form. Should be reasonably
short and without whitespace or punctuation, using the characters
{[}{\color{red}\bfseries{}a-zA-Z0-9\_}-{]} only. Example: “zero\_crossing\_count”



bool

isQuantized



True if the output values are quantized to a particular resolution.
Undefined if binCount is zero.



float

maxValue



Maximum value of the results in the output. Undefined if hasKnownExtents
is false or binCount is zero.



float

minValue



Minimum value of the results in the output. Undefined if hasKnownExtents
is false or binCount is zero.



float

quantizeStep



Quantization resolution of the output values (e.g. 1.0 if they are all
integers). Undefined if isQuantized is false or binCount is zero.



float

sampleRate



Sample rate of the output results, as samples per second. Undefined if
sampleType is OneSamplePerStep.

If sampleType is VariableSampleRate and this value is non-zero, then it
may be used to calculate a resolution for the output (i.e. the
“duration” of each sample, in time, will be 1/sampleRate seconds). It’s
recommended to set this to zero if that behaviour is not desired.



{\hyperref[\detokenize{index:Vamp.Plugin.OutputDescriptor.SampleType}]{\emph{Vamp.Plugin.OutputDescriptor.SampleType}}}

sampleType



Positioning in time of the output results.



std::string

unit



The unit of the output, in human-readable form.




\section{∁ Vamp:Plugin:OutputList}
\label{\detokenize{index:vamp-plugin-outputlist}}\label{\detokenize{index:id384}}
\sphinxstyleemphasis{C‡}: std::vector\textless{}Vamp::Plugin::OutputDescriptor \textgreater{}





Constructor

ℂ

Vamp.Plugin.OutputList()

ℂ

Vamp.Plugin.OutputList()

Methods

\sphinxstyleemphasis{LuaTable}

add(LuaTable \{{\hyperref[\detokenize{index:Vamp:Plugin:OutputDescriptor}]{\emph{OutputDescriptor}}}\})

{\hyperref[\detokenize{index:Vamp:Plugin:OutputDescriptor}]{\emph{OutputDescriptor}}}

at(unsigned long)

bool

empty()

\sphinxstyleemphasis{LuaIter}

iter()

void

push\_back({\hyperref[\detokenize{index:Vamp:Plugin:OutputDescriptor}]{\emph{OutputDescriptor}}})

unsigned long

size()

\sphinxstyleemphasis{LuaTable}

table()


\section{∁ Vamp:PluginBase}
\label{\detokenize{index:vamp-pluginbase}}\label{\detokenize{index:id385}}
\sphinxstyleemphasis{C‡}: Vamp::PluginBase







A base class for plugins with optional configurable parameters,
programs, etc. The Vamp::Plugin is derived from this, and individual
Vamp plugins should derive from that.

This class does not provide the necessary interfaces to instantiate or
run a plugin. It only specifies an interface for retrieving those
controls that the host may wish to show to the user for editing. It
could meaningfully be subclassed by real-time plugins or other sorts of
plugin as well as Vamp plugins.



Methods

std::string

getCopyright()



Get the copyright statement or licensing summary for the plugin. This
can be an informative text, without the same presentation constraints as
mentioned for getMaker above.



std::string

getCurrentProgram()



Get the current program.



std::string

getDescription()



Get a human-readable description for the plugin, typically a line of
text that may optionally be displayed in addition to the plugin’s
“name”. May be empty if the name has said it all already.

Example: “Detect and count zero crossing points”



std::string

getIdentifier()



Get the computer-usable name of the plugin. This should be reasonably
short and contain no whitespace or punctuation characters. It may only
contain the characters {[}{\color{red}\bfseries{}a-zA-Z0-9\_}-{]}. This is the authoritative way for
a program to identify a plugin within a given library.

This text may be visible to the user, but it should not be the main text
used to identify a plugin to the user (that will be the name, below).

Example: “zero\_crossings”



std::string

getMaker()



Get the name of the author or vendor of the plugin in human-readable
form. This should be a short identifying text, as it may be used to
label plugins from the same source in a menu or similar.



std::string

getName()



Get a human-readable name or title of the plugin. This should be brief
and self-contained, as it may be used to identify the plugin to the user
in isolation (i.e. without also showing the plugin’s “identifier”).

Example: “Zero Crossings”



float

getParameter(std::string)



Get the value of a named parameter. The argument is the identifier field
from that parameter’s descriptor.



{\hyperref[\detokenize{index:Vamp:PluginBase:ParameterList}]{\emph{ParameterList}}}

getParameterDescriptors()



Get the controllable parameters of this plugin.



int

getPluginVersion()



Get the version number of the plugin.



{\hyperref[\detokenize{index:C:StringVector}]{\emph{StringVector}}}

getPrograms()



Get the program settings available in this plugin. A program is a named
shorthand for a set of parameter values; changing the program may cause
the plugin to alter the values of its published parameters (and/or
non-public internal processing parameters). The host should re-read the
plugin’s parameter values after setting a new program.

The programs must have unique names.



std::string

getType()



Get the type of plugin. This is to be implemented by the immediate
subclass, not by actual plugins. Do not attempt to implement this in
plugin code.



void

selectProgram(std::string)



Select a program. (If the given program name is not one of the available
programs, do nothing.)



void

setParameter(std::string, float)



Set a named parameter. The first argument is the identifier field from
that parameter’s descriptor.




\section{∁ Vamp:PluginBase:ParameterDescriptor}
\label{\detokenize{index:vamp-pluginbase-parameterdescriptor}}\label{\detokenize{index:id386}}
\sphinxstyleemphasis{C‡}: Vamp::PluginBase::ParameterDescriptor





Data Members

float

defaultValue



The default value of the parameter. The plugin should ensure that
parameters have this value on initialisation (i.e. the host is not
required to explicitly set parameters if it wants to use their default
values).



std::string

description



A human-readable short text describing the parameter. May be empty if
the name has said it all already.



std::string

identifier



The name of the parameter, in computer-usable form. Should be reasonably
short, and may only contain the characters {[}{\color{red}\bfseries{}a-zA-Z0-9\_}-{]}.



bool

isQuantized



True if the parameter values are quantized to a particular resolution.



float

maxValue



The maximum value of the parameter.



float

minValue



The minimum value of the parameter.



std::string

name



The human-readable name of the parameter.



float

quantizeStep



Quantization resolution of the parameter values (e.g. 1.0 if they are
all integers). Undefined if isQuantized is false.



std::string

unit



The unit of the parameter, in human-readable form.



{\hyperref[\detokenize{index:C:StringVector}]{\emph{C:StringVector}}}

valueNames



Names for the quantized values. If isQuantized is true, this may either
be empty or contain one string for each of the quantize steps from
minValue up to maxValue inclusive. Undefined if isQuantized is false.

If these names are provided, they should be shown to the user in
preference to the values themselves. The user may never see the actual
numeric values unless they are also encoded in the names.




\section{∁ Vamp:PluginBase:ParameterList}
\label{\detokenize{index:vamp-pluginbase-parameterlist}}\label{\detokenize{index:id387}}
\sphinxstyleemphasis{C‡}: std::vector\textless{}Vamp::PluginBase::ParameterDescriptor \textgreater{}





Constructor

ℂ

Vamp.PluginBase.ParameterList()

ℂ

Vamp.PluginBase.ParameterList()

Methods

\sphinxstyleemphasis{LuaTable}

add(LuaTable
\{{\hyperref[\detokenize{index:Vamp:PluginBase:ParameterDescriptor}]{\emph{ParameterDescriptor}}}\})

{\hyperref[\detokenize{index:Vamp:PluginBase:ParameterDescriptor}]{\emph{ParameterDescriptor}}}

at(unsigned long)

bool

empty()

\sphinxstyleemphasis{LuaIter}

iter()

void

push\_back({\hyperref[\detokenize{index:Vamp:PluginBase:ParameterDescriptor}]{\emph{ParameterDescriptor}}})

unsigned long

size()

\sphinxstyleemphasis{LuaTable}

table()


\section{∁ Vamp:RealTime}
\label{\detokenize{index:vamp-realtime}}\label{\detokenize{index:id388}}
\sphinxstyleemphasis{C‡}: Vamp::RealTime







RealTime represents time values to nanosecond precision with accurate
arithmetic and frame-rate conversion functions.



Constructor

ℂ

Vamp.RealTime(int, int)

Methods

{\hyperref[\detokenize{index:Vamp:RealTime}]{\emph{RealTime}}}

frame2RealTime(long, unsigned int)

int

msec()

long

realTime2Frame({\hyperref[\detokenize{index:Vamp:RealTime}]{\emph{RealTime}}}, unsigned int)

std::string

toString()



Return a human-readable debug-type string to full precision (probably
not a format to show to a user directly)



int

usec()

Data Members

int

nsec

int

sec


\section{ℕ os}
\label{\detokenize{index:os}}\label{\detokenize{index:id389}}




Methods

int

execute(std::string)

LuaTable

forkexec()


\section{Enum/Constants}
\label{\detokenize{index:enum-constants}}\label{\detokenize{index:h-enum}}

\subsection{∈ PBD.Controllable.GroupControlDisposition}
\label{\detokenize{index:pbd-controllable-groupcontroldisposition}}\label{\detokenize{index:id390}}\begin{itemize}
\item {} 
PBD.GroupControlDisposition.InverseGroup

\item {} 
PBD.GroupControlDisposition.NoGroup

\item {} 
PBD.GroupControlDisposition.UseGroup

\end{itemize}


\subsection{∈ Timecode.TimecodeFormat}
\label{\detokenize{index:timecode-timecodeformat}}\label{\detokenize{index:id391}}\begin{itemize}
\item {} 
Timecode.TimecodeFormat.TC23976

\item {} 
Timecode.TimecodeFormat.TC24

\item {} 
Timecode.TimecodeFormat.TC24976

\item {} 
Timecode.TimecodeFormat.TC25

\item {} 
Timecode.TimecodeFormat.TC2997

\item {} 
Timecode.TimecodeFormat.TC2997DF

\item {} 
Timecode.TimecodeFormat.TC2997000

\item {} 
Timecode.TimecodeFormat.TC2997000DF

\item {} 
Timecode.TimecodeFormat.TC30

\item {} 
Timecode.TimecodeFormat.TC5994

\item {} 
Timecode.TimecodeFormat.TC60

\end{itemize}


\subsection{∈ Evoral.ControlList.InterpolationStyle}
\label{\detokenize{index:evoral-controllist-interpolationstyle}}\label{\detokenize{index:id392}}\begin{itemize}
\item {} 
Evoral.InterpolationStyle.Discrete

\item {} 
Evoral.InterpolationStyle.Linear

\item {} 
Evoral.InterpolationStyle.Curved

\end{itemize}


\subsection{∈ Vamp.Plugin.InputDomain}
\label{\detokenize{index:vamp-plugin-inputdomain}}\label{\detokenize{index:id393}}\begin{itemize}
\item {} 
Vamp.Plugin.InputDomain.TimeDomain

\item {} 
Vamp.Plugin.InputDomain.FrequencyDomain

\end{itemize}


\subsection{∈ Vamp.Plugin.OutputDescriptor.SampleType}
\label{\detokenize{index:vamp-plugin-outputdescriptor-sampletype}}\label{\detokenize{index:id394}}\begin{itemize}
\item {} 
Vamp.Plugin.OutputDescriptor.SampleType.OneSamplePerStep

\item {} 
Vamp.Plugin.OutputDescriptor.SampleType.FixedSampleRate

\item {} 
Vamp.Plugin.OutputDescriptor.SampleType.VariableSampleRate

\end{itemize}


\subsection{∈ ARDOUR.ChanMapping}
\label{\detokenize{index:id395}}\label{\detokenize{index:id396}}\begin{itemize}
\item {} 
ARDOUR.ChanMapping.Invalid

\end{itemize}


\subsection{∈ PBD.PropertyDescriptor\textless{}long\textgreater{}*}
\label{\detokenize{index:pbd-propertydescriptor-long}}\label{\detokenize{index:id397}}\begin{itemize}
\item {} 
ARDOUR.Properties.Start

\item {} 
ARDOUR.Properties.Length

\item {} 
ARDOUR.Properties.Position

\end{itemize}


\subsection{∈ ARDOUR.PresentationInfo}
\label{\detokenize{index:id398}}\label{\detokenize{index:id399}}\begin{itemize}
\item {} 
ARDOUR.PresentationInfo.max\_order

\end{itemize}


\subsection{∈ ARDOUR.PluginType}
\label{\detokenize{index:ardour-plugintype}}\label{\detokenize{index:id400}}\begin{itemize}
\item {} 
ARDOUR.PluginType.AudioUnit

\item {} 
ARDOUR.PluginType.LADSPA

\item {} 
ARDOUR.PluginType.LV2

\item {} 
ARDOUR.PluginType.Windows\_VST

\item {} 
ARDOUR.PluginType.LXVST

\item {} 
ARDOUR.PluginType.Lua

\end{itemize}


\subsection{∈ ARDOUR.PresentationInfo.Flag}
\label{\detokenize{index:ardour-presentationinfo-flag}}\label{\detokenize{index:id401}}\begin{itemize}
\item {} 
ARDOUR.PresentationInfo.Flag.AudioTrack

\item {} 
ARDOUR.PresentationInfo.Flag.MidiTrack

\item {} 
ARDOUR.PresentationInfo.Flag.AudioBus

\item {} 
ARDOUR.PresentationInfo.Flag.MidiBus

\item {} 
ARDOUR.PresentationInfo.Flag.VCA

\item {} 
ARDOUR.PresentationInfo.Flag.MasterOut

\item {} 
ARDOUR.PresentationInfo.Flag.MonitorOut

\item {} 
ARDOUR.PresentationInfo.Flag.Auditioner

\item {} 
ARDOUR.PresentationInfo.Flag.Hidden

\item {} 
ARDOUR.PresentationInfo.Flag.GroupOrderSet

\item {} 
ARDOUR.PresentationInfo.Flag.StatusMask

\end{itemize}


\subsection{∈ ARDOUR.AutoState}
\label{\detokenize{index:ardour-autostate}}\label{\detokenize{index:id402}}\begin{itemize}
\item {} 
ARDOUR.AutoState.Off

\item {} 
ARDOUR.AutoState.Write

\item {} 
ARDOUR.AutoState.Touch

\item {} 
ARDOUR.AutoState.Play

\end{itemize}


\subsection{∈ ARDOUR.AutomationType}
\label{\detokenize{index:ardour-automationtype}}\label{\detokenize{index:id403}}\begin{itemize}
\item {} 
ARDOUR.AutomationType.GainAutomation

\item {} 
ARDOUR.AutomationType.PluginAutomation

\item {} 
ARDOUR.AutomationType.SoloAutomation

\item {} 
ARDOUR.AutomationType.SoloIsolateAutomation

\item {} 
ARDOUR.AutomationType.SoloSafeAutomation

\item {} 
ARDOUR.AutomationType.MuteAutomation

\item {} 
ARDOUR.AutomationType.RecEnableAutomation

\item {} 
ARDOUR.AutomationType.RecSafeAutomation

\item {} 
ARDOUR.AutomationType.TrimAutomation

\item {} 
ARDOUR.AutomationType.PhaseAutomation

\item {} 
ARDOUR.AutomationType.MidiCCAutomation

\item {} 
ARDOUR.AutomationType.MidiPgmChangeAutomation

\item {} 
ARDOUR.AutomationType.MidiPitchBenderAutomation

\item {} 
ARDOUR.AutomationType.MidiChannelPressureAutomation

\item {} 
ARDOUR.AutomationType.MidiNotePressureAutomation

\item {} 
ARDOUR.AutomationType.MidiSystemExclusiveAutomation

\end{itemize}


\subsection{∈ ARDOUR.SrcQuality}
\label{\detokenize{index:ardour-srcquality}}\label{\detokenize{index:id404}}\begin{itemize}
\item {} 
ARDOUR.SrcQuality.SrcBest

\end{itemize}


\subsection{∈ ARDOUR.MeterType}
\label{\detokenize{index:ardour-metertype}}\label{\detokenize{index:id405}}\begin{itemize}
\item {} 
ARDOUR.MeterType.MeterMaxSignal

\item {} 
ARDOUR.MeterType.MeterMaxPeak

\item {} 
ARDOUR.MeterType.MeterPeak

\item {} 
ARDOUR.MeterType.MeterKrms

\item {} 
ARDOUR.MeterType.MeterK20

\item {} 
ARDOUR.MeterType.MeterK14

\item {} 
ARDOUR.MeterType.MeterIEC1DIN

\item {} 
ARDOUR.MeterType.MeterIEC1NOR

\item {} 
ARDOUR.MeterType.MeterIEC2BBC

\item {} 
ARDOUR.MeterType.MeterIEC2EBU

\item {} 
ARDOUR.MeterType.MeterVU

\item {} 
ARDOUR.MeterType.MeterK12

\item {} 
ARDOUR.MeterType.MeterPeak0dB

\item {} 
ARDOUR.MeterType.MeterMCP

\end{itemize}


\subsection{∈ ARDOUR.MeterPoint}
\label{\detokenize{index:ardour-meterpoint}}\label{\detokenize{index:id406}}\begin{itemize}
\item {} 
ARDOUR.MeterPoint.MeterInput

\item {} 
ARDOUR.MeterPoint.MeterPreFader

\item {} 
ARDOUR.MeterPoint.MeterPostFader

\item {} 
ARDOUR.MeterPoint.MeterOutput

\item {} 
ARDOUR.MeterPoint.MeterCustom

\end{itemize}


\subsection{∈ ARDOUR.Placement}
\label{\detokenize{index:ardour-placement}}\label{\detokenize{index:id407}}\begin{itemize}
\item {} 
ARDOUR.Placement.PreFader

\item {} 
ARDOUR.Placement.PostFader

\end{itemize}


\subsection{∈ ARDOUR.MonitorChoice}
\label{\detokenize{index:ardour-monitorchoice}}\label{\detokenize{index:id408}}\begin{itemize}
\item {} 
ARDOUR.MonitorChoice.MonitorAuto

\item {} 
ARDOUR.MonitorChoice.MonitorInput

\item {} 
ARDOUR.MonitorChoice.MonitorDisk

\item {} 
ARDOUR.MonitorChoice.MonitorCue

\end{itemize}


\subsection{∈ ARDOUR.NoteMode}
\label{\detokenize{index:ardour-notemode}}\label{\detokenize{index:id409}}\begin{itemize}
\item {} 
ARDOUR.NoteMode.Sustained

\item {} 
ARDOUR.NoteMode.Percussive

\end{itemize}


\subsection{∈ ARDOUR.PortFlags}
\label{\detokenize{index:ardour-portflags}}\label{\detokenize{index:id410}}\begin{itemize}
\item {} 
ARDOUR.PortFlags.IsInput

\item {} 
ARDOUR.PortFlags.IsOutput

\item {} 
ARDOUR.PortFlags.IsPhysical

\item {} 
ARDOUR.PortFlags.CanMonitor

\item {} 
ARDOUR.PortFlags.IsTerminal

\end{itemize}


\subsection{∈ ARDOUR.MidiPortFlags}
\label{\detokenize{index:ardour-midiportflags}}\label{\detokenize{index:id411}}\begin{itemize}
\item {} 
ARDOUR.MidiPortFlags.MidiPortMusic

\item {} 
ARDOUR.MidiPortFlags.MidiPortControl

\item {} 
ARDOUR.MidiPortFlags.MidiPortSelection

\item {} 
ARDOUR.MidiPortFlags.MidiPortVirtual

\end{itemize}


\subsection{∈ ARDOUR.PlaylistDisposition}
\label{\detokenize{index:ardour-playlistdisposition}}\label{\detokenize{index:id412}}\begin{itemize}
\item {} 
ARDOUR.PlaylistDisposition.CopyPlaylist

\item {} 
ARDOUR.PlaylistDisposition.NewPlaylist

\item {} 
ARDOUR.PlaylistDisposition.SharePlaylist

\end{itemize}


\subsection{∈ ARDOUR.MidiTrackNameSource}
\label{\detokenize{index:ardour-miditracknamesource}}\label{\detokenize{index:id413}}\begin{itemize}
\item {} 
ARDOUR.MidiTrackNameSource.SMFTrackNumber

\item {} 
ARDOUR.MidiTrackNameSource.SMFTrackName

\item {} 
ARDOUR.MidiTrackNameSource.SMFInstrumentName

\end{itemize}


\subsection{∈ ARDOUR.MidiTempoMapDisposition}
\label{\detokenize{index:ardour-miditempomapdisposition}}\label{\detokenize{index:id414}}\begin{itemize}
\item {} 
ARDOUR.MidiTempoMapDisposition.SMFTempoIgnore

\item {} 
ARDOUR.MidiTempoMapDisposition.SMFTempoUse

\end{itemize}


\subsection{∈ ARDOUR.RegionPoint}
\label{\detokenize{index:ardour-regionpoint}}\label{\detokenize{index:id415}}\begin{itemize}
\item {} 
ARDOUR.RegionPoint.Start

\item {} 
ARDOUR.RegionPoint.End

\item {} 
ARDOUR.RegionPoint.SyncPoint

\end{itemize}


\subsection{∈ ARDOUR.PositionLockStyle}
\label{\detokenize{index:ardour-positionlockstyle}}\label{\detokenize{index:id416}}\begin{itemize}
\item {} 
ARDOUR.TempoSection.PositionLockStyle.AudioTime

\item {} 
ARDOUR.TempoSection.PositionLockStyle.MusicTime

\end{itemize}


\subsection{∈ ARDOUR.TempoSection.Type}
\label{\detokenize{index:ardour-temposection-type}}\label{\detokenize{index:id417}}\begin{itemize}
\item {} 
ARDOUR.TempoSection.Type.Ramp

\item {} 
ARDOUR.TempoSection.Type.Constant

\end{itemize}


\subsection{∈ ARDOUR.TrackMode}
\label{\detokenize{index:ardour-trackmode}}\label{\detokenize{index:id418}}\begin{itemize}
\item {} 
ARDOUR.TrackMode.Normal

\item {} 
ARDOUR.TrackMode.NonLayered

\item {} 
ARDOUR.TrackMode.Destructive

\end{itemize}


\subsection{∈ ARDOUR.SampleFormat}
\label{\detokenize{index:ardour-sampleformat}}\label{\detokenize{index:id419}}\begin{itemize}
\item {} 
ARDOUR.SampleFormat.Float

\item {} 
ARDOUR.SampleFormat.Int24

\item {} 
ARDOUR.SampleFormat.Int16

\end{itemize}


\subsection{∈ ARDOUR.HeaderFormat}
\label{\detokenize{index:ardour-headerformat}}\label{\detokenize{index:id420}}\begin{itemize}
\item {} 
ARDOUR.HeaderFormat.BWF

\item {} 
ARDOUR.HeaderFormat.WAVE

\item {} 
ARDOUR.HeaderFormat.WAVE64

\item {} 
ARDOUR.HeaderFormat.CAF

\item {} 
ARDOUR.HeaderFormat.AIFF

\item {} 
ARDOUR.HeaderFormat.iXML

\item {} 
ARDOUR.HeaderFormat.RF64

\item {} 
ARDOUR.HeaderFormat.RF64\_WAV

\item {} 
ARDOUR.HeaderFormat.MBWF

\end{itemize}


\subsection{∈ ARDOUR.InsertMergePolicy}
\label{\detokenize{index:ardour-insertmergepolicy}}\label{\detokenize{index:id421}}\begin{itemize}
\item {} 
ARDOUR.InsertMergePolicy.Reject

\item {} 
ARDOUR.InsertMergePolicy.Relax

\item {} 
ARDOUR.InsertMergePolicy.Replace

\item {} 
ARDOUR.InsertMergePolicy.TruncateExisting

\item {} 
ARDOUR.InsertMergePolicy.TruncateAddition

\item {} 
ARDOUR.InsertMergePolicy.Extend

\end{itemize}


\subsection{∈ ARDOUR.AFLPosition}
\label{\detokenize{index:ardour-aflposition}}\label{\detokenize{index:id422}}\begin{itemize}
\item {} 
ARDOUR.AFLPosition.AFLFromBeforeProcessors

\item {} 
ARDOUR.AFLPosition.AFLFromAfterProcessors

\end{itemize}


\subsection{∈ ARDOUR.PFLPosition}
\label{\detokenize{index:ardour-pflposition}}\label{\detokenize{index:id423}}\begin{itemize}
\item {} 
ARDOUR.PFLPosition.PFLFromBeforeProcessors

\item {} 
ARDOUR.PFLPosition.PFLFromAfterProcessors

\end{itemize}


\subsection{∈ ARDOUR.AutoReturnTarget}
\label{\detokenize{index:ardour-autoreturntarget}}\label{\detokenize{index:id424}}\begin{itemize}
\item {} 
ARDOUR.AutoReturnTarget.LastLocate

\item {} 
ARDOUR.AutoReturnTarget.RangeSelectionStart

\item {} 
ARDOUR.AutoReturnTarget.Loop

\item {} 
ARDOUR.AutoReturnTarget.RegionSelectionStart

\end{itemize}


\subsection{∈ ARDOUR.FadeShape}
\label{\detokenize{index:ardour-fadeshape}}\label{\detokenize{index:id425}}\begin{itemize}
\item {} 
ARDOUR.FadeShape.FadeLinear

\item {} 
ARDOUR.FadeShape.FadeFast

\item {} 
ARDOUR.FadeShape.FadeSlow

\item {} 
ARDOUR.FadeShape.FadeConstantPower

\item {} 
ARDOUR.FadeShape.FadeSymmetric

\end{itemize}


\subsection{∈ ARDOUR.DenormalModel}
\label{\detokenize{index:ardour-denormalmodel}}\label{\detokenize{index:id426}}\begin{itemize}
\item {} 
ARDOUR.DenormalModel.DenormalNone

\item {} 
ARDOUR.DenormalModel.DenormalFTZ

\item {} 
ARDOUR.DenormalModel.DenormalDAZ

\item {} 
ARDOUR.DenormalModel.DenormalFTZDAZ

\end{itemize}


\subsection{∈ ARDOUR.BufferingPreset}
\label{\detokenize{index:ardour-bufferingpreset}}\label{\detokenize{index:id427}}\begin{itemize}
\item {} 
ARDOUR.BufferingPreset.Small

\item {} 
ARDOUR.BufferingPreset.Medium

\item {} 
ARDOUR.BufferingPreset.Large

\item {} 
ARDOUR.BufferingPreset.Custom

\end{itemize}


\subsection{∈ ARDOUR.EditMode}
\label{\detokenize{index:ardour-editmode}}\label{\detokenize{index:id428}}\begin{itemize}
\item {} 
ARDOUR.EditMode.Slide

\item {} 
ARDOUR.EditMode.Splice

\item {} 
ARDOUR.EditMode.Ripple

\item {} 
ARDOUR.EditMode.Lock

\end{itemize}


\subsection{∈ ARDOUR.AutoConnectOption}
\label{\detokenize{index:ardour-autoconnectoption}}\label{\detokenize{index:id429}}\begin{itemize}
\item {} 
ARDOUR.AutoConnectOption.ManualConnect

\item {} 
ARDOUR.AutoConnectOption.AutoConnectPhysical

\item {} 
ARDOUR.AutoConnectOption.AutoConnectMaster

\end{itemize}


\subsection{∈ ARDOUR.LayerModel}
\label{\detokenize{index:ardour-layermodel}}\label{\detokenize{index:id430}}\begin{itemize}
\item {} 
ARDOUR.LayerModel.LaterHigher

\item {} 
ARDOUR.LayerModel.Manual

\end{itemize}


\subsection{∈ ARDOUR.ListenPosition}
\label{\detokenize{index:ardour-listenposition}}\label{\detokenize{index:id431}}\begin{itemize}
\item {} 
ARDOUR.ListenPosition.AfterFaderListen

\item {} 
ARDOUR.ListenPosition.PreFaderListen

\end{itemize}


\subsection{∈ ARDOUR.MonitorModel}
\label{\detokenize{index:ardour-monitormodel}}\label{\detokenize{index:id432}}\begin{itemize}
\item {} 
ARDOUR.MonitorModel.HardwareMonitoring

\item {} 
ARDOUR.MonitorModel.SoftwareMonitoring

\item {} 
ARDOUR.MonitorModel.ExternalMonitoring

\end{itemize}


\subsection{∈ ARDOUR.RegionSelectionAfterSplit}
\label{\detokenize{index:ardour-regionselectionaftersplit}}\label{\detokenize{index:id433}}\begin{itemize}
\item {} 
ARDOUR.RegionSelectionAfterSplit.None

\item {} 
ARDOUR.RegionSelectionAfterSplit.NewlyCreatedLeft

\item {} 
ARDOUR.RegionSelectionAfterSplit.NewlyCreatedRight

\item {} 
ARDOUR.RegionSelectionAfterSplit.NewlyCreatedBoth

\item {} 
ARDOUR.RegionSelectionAfterSplit.Existing

\item {} 
ARDOUR.RegionSelectionAfterSplit.ExistingNewlyCreatedLeft

\item {} 
ARDOUR.RegionSelectionAfterSplit.ExistingNewlyCreatedRight

\item {} 
ARDOUR.RegionSelectionAfterSplit.ExistingNewlyCreatedBoth

\end{itemize}


\subsection{∈ ARDOUR.ShuttleBehaviour}
\label{\detokenize{index:ardour-shuttlebehaviour}}\label{\detokenize{index:id434}}\begin{itemize}
\item {} 
ARDOUR.ShuttleBehaviour.Sprung

\item {} 
ARDOUR.ShuttleBehaviour.Wheel

\end{itemize}


\subsection{∈ ARDOUR.ShuttleUnits}
\label{\detokenize{index:ardour-shuttleunits}}\label{\detokenize{index:id435}}\begin{itemize}
\item {} 
ARDOUR.ShuttleUnits.Percentage

\item {} 
ARDOUR.ShuttleUnits.Semitones

\end{itemize}


\subsection{∈ ARDOUR.SyncSource}
\label{\detokenize{index:ardour-syncsource}}\label{\detokenize{index:id436}}\begin{itemize}
\item {} 
ARDOUR.SyncSource.Engine

\item {} 
ARDOUR.SyncSource.MTC

\item {} 
ARDOUR.SyncSource.MIDIClock

\item {} 
ARDOUR.SyncSource.LTC

\end{itemize}


\subsection{∈ ARDOUR.TracksAutoNamingRule}
\label{\detokenize{index:ardour-tracksautonamingrule}}\label{\detokenize{index:id437}}\begin{itemize}
\item {} 
ARDOUR.TracksAutoNamingRule.UseDefaultNames

\item {} 
ARDOUR.TracksAutoNamingRule.NameAfterDriver

\end{itemize}


\subsection{∈ ARDOUR.Session.RecordState}
\label{\detokenize{index:ardour-session-recordstate}}\label{\detokenize{index:id438}}\begin{itemize}
\item {} 
ARDOUR.Session.RecordState.Disabled

\item {} 
ARDOUR.Session.RecordState.Enabled

\item {} 
ARDOUR.Session.RecordState.Recording

\end{itemize}


\subsection{∈ ARDOUR.Location.Flags}
\label{\detokenize{index:ardour-location-flags}}\label{\detokenize{index:id439}}\begin{itemize}
\item {} 
ARDOUR.LocationFlags.IsMark

\item {} 
ARDOUR.LocationFlags.IsAutoPunch

\item {} 
ARDOUR.LocationFlags.IsAutoLoop

\item {} 
ARDOUR.LocationFlags.IsHidden

\item {} 
ARDOUR.LocationFlags.IsCDMarker

\item {} 
ARDOUR.LocationFlags.IsRangeMarker

\item {} 
ARDOUR.LocationFlags.IsSessionRange

\item {} 
ARDOUR.LocationFlags.IsSkip

\item {} 
ARDOUR.LocationFlags.IsSkipping

\end{itemize}


\subsection{∈ ARDOUR.DSP.Biquad.Type}
\label{\detokenize{index:ardour-dsp-biquad-type}}\label{\detokenize{index:id440}}\begin{itemize}
\item {} 
ARDOUR.DSP.BiquadType.LowPass

\item {} 
ARDOUR.DSP.BiquadType.HighPass

\item {} 
ARDOUR.DSP.BiquadType.BandPassSkirt

\item {} 
ARDOUR.DSP.BiquadType.BandPass0dB

\item {} 
ARDOUR.DSP.BiquadType.Notch

\item {} 
ARDOUR.DSP.BiquadType.AllPass

\item {} 
ARDOUR.DSP.BiquadType.Peaking

\item {} 
ARDOUR.DSP.BiquadType.LowShelf

\item {} 
ARDOUR.DSP.BiquadType.HighShelf

\end{itemize}


\subsection{∈ Cairo.LineCap}
\label{\detokenize{index:cairo-linecap}}\label{\detokenize{index:id441}}\begin{itemize}
\item {} 
Cairo.LineCap.Butt

\item {} 
Cairo.LineCap.Round

\item {} 
Cairo.LineCap.Square

\end{itemize}


\subsection{∈ Cairo.LineJoin}
\label{\detokenize{index:cairo-linejoin}}\label{\detokenize{index:id442}}\begin{itemize}
\item {} 
Cairo.LineJoin.Miter

\item {} 
Cairo.LineJoin.Round

\item {} 
Cairo.LineJoin.Bevel

\end{itemize}


\subsection{∈ Cairo.Operator}
\label{\detokenize{index:cairo-operator}}\label{\detokenize{index:id443}}\begin{itemize}
\item {} 
Cairo.Operator.Clear

\item {} 
Cairo.Operator.Source

\item {} 
Cairo.Operator.Over

\item {} 
Cairo.Operator.Add

\end{itemize}


\subsection{∈ Cairo.Format}
\label{\detokenize{index:cairo-format}}\label{\detokenize{index:id444}}\begin{itemize}
\item {} 
Cairo.Format.ARGB32

\item {} 
Cairo.Format.RGB24

\end{itemize}


\subsection{∈ Pango.EllipsizeMode}
\label{\detokenize{index:pango-ellipsizemode}}\label{\detokenize{index:id445}}\begin{itemize}
\item {} 
Cairo.EllipsizeMode.None

\item {} 
Cairo.EllipsizeMode.Start

\item {} 
Cairo.EllipsizeMode.Middle

\item {} 
Cairo.EllipsizeMode.End

\end{itemize}


\subsection{∈ Pango.WrapMode}
\label{\detokenize{index:pango-wrapmode}}\label{\detokenize{index:id446}}\begin{itemize}
\item {} 
Cairo.WrapMode.Word

\item {} 
Cairo.WrapMode.Char

\item {} 
Cairo.WrapMode.WordChar

\end{itemize}


\subsection{∈ LuaDialog.Message.MessageType}
\label{\detokenize{index:luadialog-message-messagetype}}\label{\detokenize{index:id447}}\begin{itemize}
\item {} 
LuaDialog.MessageType.Info

\item {} 
LuaDialog.MessageType.Warning

\item {} 
LuaDialog.MessageType.Question

\item {} 
LuaDialog.MessageType.Error

\end{itemize}


\subsection{∈ LuaDialog.Message.ButtonType}
\label{\detokenize{index:luadialog-message-buttontype}}\label{\detokenize{index:id448}}\begin{itemize}
\item {} 
LuaDialog.ButtonType.OK

\item {} 
LuaDialog.ButtonType.Close

\item {} 
LuaDialog.ButtonType.Cancel

\item {} 
LuaDialog.ButtonType.Yes\_No

\item {} 
LuaDialog.ButtonType.OK\_Cancel

\end{itemize}


\subsection{∈ LuaDialog.Response}
\label{\detokenize{index:luadialog-response}}\label{\detokenize{index:id449}}\begin{itemize}
\item {} 
LuaDialog.Response.OK

\item {} 
LuaDialog.Response.Cancel

\item {} 
LuaDialog.Response.Close

\item {} 
LuaDialog.Response.Yes

\item {} 
LuaDialog.Response.No

\item {} 
LuaDialog.Response.None

\end{itemize}


\subsection{∈ RouteDialogs.InsertAt}
\label{\detokenize{index:routedialogs-insertat}}\label{\detokenize{index:id450}}\begin{itemize}
\item {} 
ArdourUI.InsertAt.BeforeSelection

\item {} 
ArdourUI.InsertAt.AfterSelection

\item {} 
ArdourUI.InsertAt.First

\item {} 
ArdourUI.InsertAt.Last

\end{itemize}


\subsection{∈ ArdourMarker.Type}
\label{\detokenize{index:ardourmarker-type}}\label{\detokenize{index:id451}}\begin{itemize}
\item {} 
ArdourUI.MarkerType.Mark

\item {} 
ArdourUI.MarkerType.Tempo

\item {} 
ArdourUI.MarkerType.Meter

\item {} 
ArdourUI.MarkerType.SessionStart

\item {} 
ArdourUI.MarkerType.SessionEnd

\item {} 
ArdourUI.MarkerType.RangeStart

\item {} 
ArdourUI.MarkerType.RangeEnd

\item {} 
ArdourUI.MarkerType.LoopStart

\item {} 
ArdourUI.MarkerType.LoopEnd

\item {} 
ArdourUI.MarkerType.PunchIn

\item {} 
ArdourUI.MarkerType.PunchOut

\end{itemize}


\subsection{∈ Selection.Operation}
\label{\detokenize{index:selection-operation}}\label{\detokenize{index:id452}}\begin{itemize}
\item {} 
ArdourUI.SelectionOp.Toggle

\item {} 
ArdourUI.SelectionOp.Set

\item {} 
ArdourUI.SelectionOp.Extend

\item {} 
ArdourUI.SelectionOp.Add

\end{itemize}


\subsection{∈ Editing.SnapType}
\label{\detokenize{index:editing-snaptype}}\label{\detokenize{index:id453}}\begin{itemize}
\item {} 
Editing.SnapToCDFrame

\item {} 
Editing.SnapToTimecodeFrame

\item {} 
Editing.SnapToTimecodeSeconds

\item {} 
Editing.SnapToTimecodeMinutes

\item {} 
Editing.SnapToSeconds

\item {} 
Editing.SnapToMinutes

\item {} 
Editing.SnapToBeatDiv128

\item {} 
Editing.SnapToBeatDiv64

\item {} 
Editing.SnapToBeatDiv32

\item {} 
Editing.SnapToBeatDiv28

\item {} 
Editing.SnapToBeatDiv24

\item {} 
Editing.SnapToBeatDiv20

\item {} 
Editing.SnapToBeatDiv16

\item {} 
Editing.SnapToBeatDiv14

\item {} 
Editing.SnapToBeatDiv12

\item {} 
Editing.SnapToBeatDiv10

\item {} 
Editing.SnapToBeatDiv8

\item {} 
Editing.SnapToBeatDiv7

\item {} 
Editing.SnapToBeatDiv6

\item {} 
Editing.SnapToBeatDiv5

\item {} 
Editing.SnapToBeatDiv4

\item {} 
Editing.SnapToBeatDiv3

\item {} 
Editing.SnapToBeatDiv2

\item {} 
Editing.SnapToBeat

\item {} 
Editing.SnapToBar

\item {} 
Editing.SnapToMark

\item {} 
Editing.SnapToRegionStart

\item {} 
Editing.SnapToRegionEnd

\item {} 
Editing.SnapToRegionSync

\item {} 
Editing.SnapToRegionBoundary

\end{itemize}


\subsection{∈ Editing.SnapMode}
\label{\detokenize{index:editing-snapmode}}\label{\detokenize{index:id454}}\begin{itemize}
\item {} 
Editing.SnapOff

\item {} 
Editing.SnapNormal

\item {} 
Editing.SnapMagnetic

\end{itemize}


\subsection{∈ Editing.MouseMode}
\label{\detokenize{index:editing-mousemode}}\label{\detokenize{index:id455}}\begin{itemize}
\item {} 
Editing.MouseObject

\item {} 
Editing.MouseRange

\item {} 
Editing.MouseCut

\item {} 
Editing.MouseTimeFX

\item {} 
Editing.MouseAudition

\item {} 
Editing.MouseDraw

\item {} 
Editing.MouseContent

\end{itemize}


\subsection{∈ Editing.ZoomFocus}
\label{\detokenize{index:editing-zoomfocus}}\label{\detokenize{index:id456}}\begin{itemize}
\item {} 
Editing.ZoomFocusLeft

\item {} 
Editing.ZoomFocusRight

\item {} 
Editing.ZoomFocusCenter

\item {} 
Editing.ZoomFocusPlayhead

\item {} 
Editing.ZoomFocusMouse

\item {} 
Editing.ZoomFocusEdit

\end{itemize}


\subsection{∈ Editing.DisplayControl}
\label{\detokenize{index:editing-displaycontrol}}\label{\detokenize{index:id457}}\begin{itemize}
\item {} 
Editing.FollowPlayhead

\item {} 
Editing.ShowMeasures

\item {} 
Editing.ShowWaveforms

\item {} 
Editing.ShowWaveformsRecording

\end{itemize}


\subsection{∈ Editing.ImportMode}
\label{\detokenize{index:editing-importmode}}\label{\detokenize{index:id458}}\begin{itemize}
\item {} 
Editing.ImportAsRegion

\item {} 
Editing.ImportToTrack

\item {} 
Editing.ImportAsTrack

\item {} 
Editing.ImportAsTapeTrack

\end{itemize}


\subsection{∈ Editing.ImportPosition}
\label{\detokenize{index:editing-importposition}}\label{\detokenize{index:id459}}\begin{itemize}
\item {} 
Editing.ImportAtTimestamp

\item {} 
Editing.ImportAtEditPoint

\item {} 
Editing.ImportAtPlayhead

\item {} 
Editing.ImportAtStart

\end{itemize}


\subsection{∈ Editing.ImportDisposition}
\label{\detokenize{index:editing-importdisposition}}\label{\detokenize{index:id460}}\begin{itemize}
\item {} 
Editing.ImportDistinctFiles

\item {} 
Editing.ImportMergeFiles

\item {} 
Editing.ImportSerializeFiles

\item {} 
Editing.ImportDistinctChannels

\end{itemize}


\subsection{∈ LuaSignal.LuaSignal}
\label{\detokenize{index:luasignal-luasignal}}\label{\detokenize{index:id461}}\begin{itemize}
\item {} 
LuaSignal.ConfigChanged

\item {} 
LuaSignal.EngineRunning

\item {} 
LuaSignal.EngineStopped

\item {} 
LuaSignal.EngineHalted

\item {} 
LuaSignal.EngineDeviceListChanged

\item {} 
LuaSignal.BufferSizeChanged

\item {} 
LuaSignal.SampleRateChanged

\item {} 
LuaSignal.FeedbackDetected

\item {} 
LuaSignal.SuccessfulGraphSort

\item {} 
LuaSignal.StartTimeChanged

\item {} 
LuaSignal.EndTimeChanged

\item {} 
LuaSignal.Exported

\item {} 
LuaSignal.Change

\item {} 
LuaSignal.SessionConfigChanged

\item {} 
LuaSignal.TransportStateChange

\item {} 
LuaSignal.DirtyChanged

\item {} 
LuaSignal.StateSaved

\item {} 
LuaSignal.Xrun

\item {} 
LuaSignal.TransportLooped

\item {} 
LuaSignal.SoloActive

\item {} 
LuaSignal.SoloChanged

\item {} 
LuaSignal.IsolatedChanged

\item {} 
LuaSignal.MonitorChanged

\item {} 
LuaSignal.RecordStateChanged

\item {} 
LuaSignal.RecordArmStateChanged

\item {} 
LuaSignal.AudioLoopLocationChanged

\item {} 
LuaSignal.AudioPunchLocationChanged

\item {} 
LuaSignal.LocationsModified

\item {} 
LuaSignal.AuditionActive

\item {} 
LuaSignal.BundleAddedOrRemoved

\item {} 
LuaSignal.PositionChanged

\item {} 
LuaSignal.Located

\item {} 
LuaSignal.RoutesReconnected

\item {} 
LuaSignal.RouteAdded

\item {} 
LuaSignal.RouteGroupPropertyChanged

\item {} 
LuaSignal.RouteAddedToRouteGroup

\item {} 
LuaSignal.RouteRemovedFromRouteGroup

\item {} 
LuaSignal.StepEditStatusChange

\item {} 
LuaSignal.RouteGroupAdded

\item {} 
LuaSignal.RouteGroupRemoved

\item {} 
LuaSignal.RouteGroupsReordered

\item {} 
LuaSignal.PluginListChanged

\item {} 
LuaSignal.PluginStatusesChanged

\item {} 
LuaSignal.DiskOverrun

\item {} 
LuaSignal.DiskUnderrun

\item {} 
LuaSignal.RegionPropertyChanged

\item {} 
LuaSignal.LuaTimerDS

\item {} 
LuaSignal.SetSession

\end{itemize}


\section{Class Index}
\label{\detokenize{index:class-index}}\label{\detokenize{index:h-index}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{index:ARDOUR}]{\emph{ARDOUR}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:Amp}]{\emph{ARDOUR:Amp}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:AudioBackend}]{\emph{ARDOUR:AudioBackend}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:AudioBackendInfo}]{\emph{ARDOUR:AudioBackendInfo}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:AudioBuffer}]{\emph{ARDOUR:AudioBuffer}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:AudioEngine}]{\emph{ARDOUR:AudioEngine}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:AudioPlaylist}]{\emph{ARDOUR:AudioPlaylist}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:AudioPort}]{\emph{ARDOUR:AudioPort}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:AudioRange}]{\emph{ARDOUR:AudioRange}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:AudioRangeList}]{\emph{ARDOUR:AudioRangeList}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:AudioRegion}]{\emph{ARDOUR:AudioRegion}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:AudioSource}]{\emph{ARDOUR:AudioSource}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:AudioTrack}]{\emph{ARDOUR:AudioTrack}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:AudioTrackList}]{\emph{ARDOUR:AudioTrackList}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:Automatable}]{\emph{ARDOUR:Automatable}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:AutomatableSequence}]{\emph{ARDOUR:AutomatableSequence}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:AutomationControl}]{\emph{ARDOUR:AutomationControl}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:AutomationList}]{\emph{ARDOUR:AutomationList}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:BackendVector}]{\emph{ARDOUR:BackendVector}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:BeatsFramesConverter}]{\emph{ARDOUR:BeatsFramesConverter}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:BufferSet}]{\emph{ARDOUR:BufferSet}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:ChanCount}]{\emph{ARDOUR:ChanCount}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:ChanMapping}]{\emph{ARDOUR:ChanMapping}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:ControlList}]{\emph{ARDOUR:ControlList}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:ControlListPtr}]{\emph{ARDOUR:ControlListPtr}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:DSP}]{\emph{ARDOUR.DSP}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:DSP:Biquad}]{\emph{ARDOUR:DSP:Biquad}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:DSP:DspShm}]{\emph{ARDOUR:DSP:DspShm}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:DSP:FFTSpectrum}]{\emph{ARDOUR:DSP:FFTSpectrum}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:DSP:LowPass}]{\emph{ARDOUR:DSP:LowPass}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:DataType}]{\emph{ARDOUR:DataType}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:Delivery}]{\emph{ARDOUR:Delivery}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:DeviceStatus}]{\emph{ARDOUR:DeviceStatus}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:DeviceStatusVector}]{\emph{ARDOUR:DeviceStatusVector}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:DoubleBeatsFramesConverter}]{\emph{ARDOUR:DoubleBeatsFramesConverter}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:EventList}]{\emph{ARDOUR:EventList}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:FileSource}]{\emph{ARDOUR:FileSource}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:FluidSynth}]{\emph{ARDOUR:FluidSynth}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:GainControl}]{\emph{ARDOUR:GainControl}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:IO}]{\emph{ARDOUR:IO}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:IOProcessor}]{\emph{ARDOUR:IOProcessor}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:InterThreadInfo}]{\emph{ARDOUR:InterThreadInfo}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:Location}]{\emph{ARDOUR:Location}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:LocationList}]{\emph{ARDOUR:LocationList}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:Locations}]{\emph{ARDOUR:Locations}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:LuaAPI}]{\emph{ARDOUR.LuaAPI}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:LuaAPI:Vamp}]{\emph{ARDOUR:LuaAPI:Vamp}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:LuaOSC:Address}]{\emph{ARDOUR:LuaOSC:Address}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:LuaProc}]{\emph{ARDOUR:LuaProc}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:LuaTableRef}]{\emph{ARDOUR:LuaTableRef}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:Meter}]{\emph{ARDOUR:Meter}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:MeterSection}]{\emph{ARDOUR:MeterSection}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:MetricSection}]{\emph{ARDOUR:MetricSection}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:MidiBuffer}]{\emph{ARDOUR:MidiBuffer}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:MidiModel}]{\emph{ARDOUR:MidiModel}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:MidiModel:DiffCommand}]{\emph{ARDOUR:MidiModel:DiffCommand}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:MidiModel:NoteDiffCommand}]{\emph{ARDOUR:MidiModel:NoteDiffCommand}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:MidiPlaylist}]{\emph{ARDOUR:MidiPlaylist}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:MidiPort}]{\emph{ARDOUR:MidiPort}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:MidiRegion}]{\emph{ARDOUR:MidiRegion}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:MidiSource}]{\emph{ARDOUR:MidiSource}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:MidiTrack}]{\emph{ARDOUR:MidiTrack}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:MidiTrackList}]{\emph{ARDOUR:MidiTrackList}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:MonitorProcessor}]{\emph{ARDOUR:MonitorProcessor}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:MusicFrame}]{\emph{ARDOUR:MusicFrame}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:MuteControl}]{\emph{ARDOUR:MuteControl}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:NotePtrList}]{\emph{ARDOUR:NotePtrList}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:OwnedPropertyList}]{\emph{ARDOUR:OwnedPropertyList}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:PannerShell}]{\emph{ARDOUR:PannerShell}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:ParameterDescriptor}]{\emph{ARDOUR:ParameterDescriptor}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:PeakMeter}]{\emph{ARDOUR:PeakMeter}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:PhaseControl}]{\emph{ARDOUR:PhaseControl}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:Playlist}]{\emph{ARDOUR:Playlist}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:Plugin}]{\emph{ARDOUR:Plugin}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:Plugin:IOPortDescription}]{\emph{ARDOUR:Plugin:IOPortDescription}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:PluginControl}]{\emph{ARDOUR:PluginControl}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:PluginInfo}]{\emph{ARDOUR:PluginInfo}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:PluginInsert}]{\emph{ARDOUR:PluginInsert}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:Port}]{\emph{ARDOUR:Port}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:PortEngine}]{\emph{ARDOUR:PortEngine}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:PortList}]{\emph{ARDOUR:PortList}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:PortManager}]{\emph{ARDOUR:PortManager}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:PortSet}]{\emph{ARDOUR:PortSet}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:PresentationInfo}]{\emph{ARDOUR:PresentationInfo}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:PresetRecord}]{\emph{ARDOUR:PresetRecord}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:PresetVector}]{\emph{ARDOUR:PresetVector}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:Processor}]{\emph{ARDOUR:Processor}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:ProcessorList}]{\emph{ARDOUR:ProcessorList}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:ProcessorVector}]{\emph{ARDOUR:ProcessorVector}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:Progress}]{\emph{ARDOUR:Progress}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:Properties:BoolProperty}]{\emph{ARDOUR:Properties:BoolProperty}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:Properties:FloatProperty}]{\emph{ARDOUR:Properties:FloatProperty}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:Properties:FrameposProperty}]{\emph{ARDOUR:Properties:FrameposProperty}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:PropertyChange}]{\emph{ARDOUR:PropertyChange}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:PropertyList}]{\emph{ARDOUR:PropertyList}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:RCConfiguration}]{\emph{ARDOUR:RCConfiguration}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:ReadOnlyControl}]{\emph{ARDOUR:ReadOnlyControl}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:Readable}]{\emph{ARDOUR:Readable}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:Region}]{\emph{ARDOUR:Region}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:RegionFactory}]{\emph{ARDOUR:RegionFactory}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:RegionList}]{\emph{ARDOUR:RegionList}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:RegionListPtr}]{\emph{ARDOUR:RegionListPtr}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:RegionMap}]{\emph{ARDOUR:RegionMap}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:RegionVector}]{\emph{ARDOUR:RegionVector}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:Route}]{\emph{ARDOUR:Route}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:Route:ProcessorStreams}]{\emph{ARDOUR:Route:ProcessorStreams}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:RouteGroup}]{\emph{ARDOUR:RouteGroup}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:RouteGroupList}]{\emph{ARDOUR:RouteGroupList}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:RouteList}]{\emph{ARDOUR:RouteList}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:RouteListPtr}]{\emph{ARDOUR:RouteListPtr}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:Session}]{\emph{ARDOUR:Session}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:SessionConfiguration}]{\emph{ARDOUR:SessionConfiguration}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:SessionObject}]{\emph{ARDOUR:SessionObject}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:SessionObjectPtr}]{\emph{ARDOUR:SessionObjectPtr}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:SideChain}]{\emph{ARDOUR:SideChain}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:Slavable}]{\emph{ARDOUR:Slavable}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:SlavableAutomationControl}]{\emph{ARDOUR:SlavableAutomationControl}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:SoloControl}]{\emph{ARDOUR:SoloControl}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:SoloIsolateControl}]{\emph{ARDOUR:SoloIsolateControl}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:SoloSafeControl}]{\emph{ARDOUR:SoloSafeControl}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:Source}]{\emph{ARDOUR:Source}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:SourceList}]{\emph{ARDOUR:SourceList}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:Stripable}]{\emph{ARDOUR:Stripable}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:StripableList}]{\emph{ARDOUR:StripableList}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:Tempo}]{\emph{ARDOUR:Tempo}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:TempoMap}]{\emph{ARDOUR:TempoMap}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:TempoSection}]{\emph{ARDOUR:TempoSection}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:Track}]{\emph{ARDOUR:Track}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:UnknownProcessor}]{\emph{ARDOUR:UnknownProcessor}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:VCA}]{\emph{ARDOUR:VCA}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:VCAList}]{\emph{ARDOUR:VCAList}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:VCAManager}]{\emph{ARDOUR:VCAManager}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:WeakAudioSourceList}]{\emph{ARDOUR:WeakAudioSourceList}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:WeakRouteList}]{\emph{ARDOUR:WeakRouteList}}}

\item {} 
{\hyperref[\detokenize{index:ARDOUR:WeakSourceList}]{\emph{ARDOUR:WeakSourceList}}}

\item {} 
{\hyperref[\detokenize{index:ArdourUI}]{\emph{ArdourUI}}}

\item {} 
{\hyperref[\detokenize{index:ArdourUI:ArdourMarker}]{\emph{ArdourUI:ArdourMarker}}}

\item {} 
{\hyperref[\detokenize{index:ArdourUI:ArdourMarkerList}]{\emph{ArdourUI:ArdourMarkerList}}}

\item {} 
{\hyperref[\detokenize{index:ArdourUI:AxisView}]{\emph{ArdourUI:AxisView}}}

\item {} 
{\hyperref[\detokenize{index:ArdourUI:Editor}]{\emph{ArdourUI:Editor}}}

\item {} 
{\hyperref[\detokenize{index:ArdourUI:MarkerSelection}]{\emph{ArdourUI:MarkerSelection}}}

\item {} 
{\hyperref[\detokenize{index:ArdourUI:RegionSelection}]{\emph{ArdourUI:RegionSelection}}}

\item {} 
{\hyperref[\detokenize{index:ArdourUI:RegionView}]{\emph{ArdourUI:RegionView}}}

\item {} 
{\hyperref[\detokenize{index:ArdourUI:RouteTimeAxisView}]{\emph{ArdourUI:RouteTimeAxisView}}}

\item {} 
{\hyperref[\detokenize{index:ArdourUI:RouteUI}]{\emph{ArdourUI:RouteUI}}}

\item {} 
{\hyperref[\detokenize{index:ArdourUI:Selectable}]{\emph{ArdourUI:Selectable}}}

\item {} 
{\hyperref[\detokenize{index:ArdourUI:Selection}]{\emph{ArdourUI:Selection}}}

\item {} 
{\hyperref[\detokenize{index:ArdourUI:SelectionList}]{\emph{ArdourUI:SelectionList}}}

\item {} 
{\hyperref[\detokenize{index:ArdourUI:StripableTimeAxisView}]{\emph{ArdourUI:StripableTimeAxisView}}}

\item {} 
{\hyperref[\detokenize{index:ArdourUI:TimeAxisView}]{\emph{ArdourUI:TimeAxisView}}}

\item {} 
{\hyperref[\detokenize{index:ArdourUI:TimeAxisViewItem}]{\emph{ArdourUI:TimeAxisViewItem}}}

\item {} 
{\hyperref[\detokenize{index:ArdourUI:TimeSelection}]{\emph{ArdourUI:TimeSelection}}}

\item {} 
{\hyperref[\detokenize{index:ArdourUI:TrackSelection}]{\emph{ArdourUI:TrackSelection}}}

\item {} 
{\hyperref[\detokenize{index:ArdourUI:TrackViewList}]{\emph{ArdourUI:TrackViewList}}}

\item {} 
{\hyperref[\detokenize{index:ArdourUI:TrackViewStdList}]{\emph{ArdourUI:TrackViewStdList}}}

\item {} 
{\hyperref[\detokenize{index:C:ByteArray}]{\emph{C:ByteArray}}}

\item {} 
{\hyperref[\detokenize{index:C:DoubleVector}]{\emph{C:DoubleVector}}}

\item {} 
{\hyperref[\detokenize{index:C:FloatArray}]{\emph{C:FloatArray}}}

\item {} 
{\hyperref[\detokenize{index:C:FloatArrayVector}]{\emph{C:FloatArrayVector}}}

\item {} 
{\hyperref[\detokenize{index:C:FloatVector}]{\emph{C:FloatVector}}}

\item {} 
{\hyperref[\detokenize{index:C:Int64List}]{\emph{C:Int64List}}}

\item {} 
{\hyperref[\detokenize{index:C:IntArray}]{\emph{C:IntArray}}}

\item {} 
{\hyperref[\detokenize{index:C:StringList}]{\emph{C:StringList}}}

\item {} 
{\hyperref[\detokenize{index:C:StringVector}]{\emph{C:StringVector}}}

\item {} 
{\hyperref[\detokenize{index:Cairo:Context}]{\emph{Cairo:Context}}}

\item {} 
{\hyperref[\detokenize{index:Cairo:ImageSurface}]{\emph{Cairo:ImageSurface}}}

\item {} 
{\hyperref[\detokenize{index:Cairo:PangoLayout}]{\emph{Cairo:PangoLayout}}}

\item {} 
{\hyperref[\detokenize{index:Evoral:Beats}]{\emph{Evoral:Beats}}}

\item {} 
{\hyperref[\detokenize{index:Evoral:Control}]{\emph{Evoral:Control}}}

\item {} 
{\hyperref[\detokenize{index:Evoral:ControlEvent}]{\emph{Evoral:ControlEvent}}}

\item {} 
{\hyperref[\detokenize{index:Evoral:ControlList}]{\emph{Evoral:ControlList}}}

\item {} 
{\hyperref[\detokenize{index:Evoral:ControlSet}]{\emph{Evoral:ControlSet}}}

\item {} 
{\hyperref[\detokenize{index:Evoral:Event}]{\emph{Evoral:Event}}}

\item {} 
{\hyperref[\detokenize{index:Evoral:NotePtr}]{\emph{Evoral:NotePtr}}}

\item {} 
{\hyperref[\detokenize{index:Evoral:Parameter}]{\emph{Evoral:Parameter}}}

\item {} 
{\hyperref[\detokenize{index:Evoral:ParameterDescriptor}]{\emph{Evoral:ParameterDescriptor}}}

\item {} 
{\hyperref[\detokenize{index:Evoral:Range}]{\emph{Evoral:Range}}}

\item {} 
{\hyperref[\detokenize{index:Evoral:Sequence}]{\emph{Evoral:Sequence}}}

\item {} 
{\hyperref[\detokenize{index:LuaDialog:Dialog}]{\emph{LuaDialog:Dialog}}}

\item {} 
{\hyperref[\detokenize{index:LuaDialog:Message}]{\emph{LuaDialog:Message}}}

\item {} 
{\hyperref[\detokenize{index:LuaSignal:Set}]{\emph{LuaSignal:Set}}}

\item {} 
{\hyperref[\detokenize{index:PBD}]{\emph{PBD}}}

\item {} 
{\hyperref[\detokenize{index:PBD:Command}]{\emph{PBD:Command}}}

\item {} 
{\hyperref[\detokenize{index:PBD:Configuration}]{\emph{PBD:Configuration}}}

\item {} 
{\hyperref[\detokenize{index:PBD:Controllable}]{\emph{PBD:Controllable}}}

\item {} 
{\hyperref[\detokenize{index:PBD:ID}]{\emph{PBD:ID}}}

\item {} 
{\hyperref[\detokenize{index:PBD:IdVector}]{\emph{PBD:IdVector}}}

\item {} 
{\hyperref[\detokenize{index:PBD:RingBuffer8}]{\emph{PBD:RingBuffer8}}}

\item {} 
{\hyperref[\detokenize{index:PBD:RingBufferF}]{\emph{PBD:RingBufferF}}}

\item {} 
{\hyperref[\detokenize{index:PBD:RingBufferI}]{\emph{PBD:RingBufferI}}}

\item {} 
{\hyperref[\detokenize{index:PBD:Stateful}]{\emph{PBD:Stateful}}}

\item {} 
{\hyperref[\detokenize{index:PBD:StatefulDestructible}]{\emph{PBD:StatefulDestructible}}}

\item {} 
{\hyperref[\detokenize{index:PBD:StatefulDestructiblePtr}]{\emph{PBD:StatefulDestructiblePtr}}}

\item {} 
{\hyperref[\detokenize{index:PBD:StatefulDiffCommand}]{\emph{PBD:StatefulDiffCommand}}}

\item {} 
{\hyperref[\detokenize{index:PBD:StatefulPtr}]{\emph{PBD:StatefulPtr}}}

\item {} 
{\hyperref[\detokenize{index:PBD:XMLNode}]{\emph{PBD:XMLNode}}}

\item {} 
{\hyperref[\detokenize{index:Timecode:BBT_TIME}]{\emph{Timecode:BBT\_TIME}}}

\item {} 
{\hyperref[\detokenize{index:Timecode:Time}]{\emph{Timecode:Time}}}

\item {} 
{\hyperref[\detokenize{index:Vamp:Plugin}]{\emph{Vamp:Plugin}}}

\item {} 
{\hyperref[\detokenize{index:Vamp:Plugin:Feature}]{\emph{Vamp:Plugin:Feature}}}

\item {} 
{\hyperref[\detokenize{index:Vamp:Plugin:FeatureList}]{\emph{Vamp:Plugin:FeatureList}}}

\item {} 
{\hyperref[\detokenize{index:Vamp:Plugin:FeatureSet}]{\emph{Vamp:Plugin:FeatureSet}}}

\item {} 
{\hyperref[\detokenize{index:Vamp:Plugin:OutputDescriptor}]{\emph{Vamp:Plugin:OutputDescriptor}}}

\item {} 
{\hyperref[\detokenize{index:Vamp:Plugin:OutputList}]{\emph{Vamp:Plugin:OutputList}}}

\item {} 
{\hyperref[\detokenize{index:Vamp:PluginBase}]{\emph{Vamp:PluginBase}}}

\item {} 
{\hyperref[\detokenize{index:Vamp:PluginBase:ParameterDescriptor}]{\emph{Vamp:PluginBase:ParameterDescriptor}}}

\item {} 
{\hyperref[\detokenize{index:Vamp:PluginBase:ParameterList}]{\emph{Vamp:PluginBase:ParameterList}}}

\item {} 
{\hyperref[\detokenize{index:Vamp:RealTime}]{\emph{Vamp:RealTime}}}

\item {} 
{\hyperref[\detokenize{index:os}]{\emph{os}}}

\end{itemize}



Ardour 5.12  -  Sat, 16 Sep 2017 16:18:16 +0200




\chapter{Part XIII - Appendix}
\label{\detokenize{index:part-xiii-appendix}}\label{\detokenize{index:appendix}}

\chapter{84 - List of Menu Actions}
\label{\detokenize{index:list-of-menu-actions}}

\section{Menu actions}
\label{\detokenize{index:menu-actions-3}}\label{\detokenize{index:id462}}
Every single menu item in Ardour’s GUI is accessible by control surfaces
or scripts.

The list below shows all available values of \sphinxstyleemphasis{action-name} as of Ardour
5.12. You can get the current list at any time by running Ardour with
the -A flag.


\begin{savenotes}\sphinxatlongtablestart\begin{longtable}{|l|l|}
\hline
\sphinxstyletheadfamily 
Action Name
&\sphinxstyletheadfamily 
Menu Name
\\
\hline
\endfirsthead

\multicolumn{2}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} -- continued from previous page}}}\\
\hline
\sphinxstyletheadfamily 
Action Name
&\sphinxstyletheadfamily 
Menu Name
\\
\hline
\endhead

\hline
\multicolumn{2}{r}{\makebox[0pt][r]{\sphinxtablecontinued{Continued on next page}}}\\
\endfoot

\endlastfoot

ProcessorMenu/ab\_plugins
&
A/B Plugins
\\
\hline
ProcessorMenu/activate\_all
&
Activate All
\\
\hline
ProcessorMenu/backspace
&
Delete
\\
\hline
ProcessorMenu/clear
&
Clear (all)
\\
\hline
ProcessorMenu/clear\_post
&
Clear (post-fader)
\\
\hline
ProcessorMenu/clear\_pre
&
Clear (pre-fader)
\\
\hline
ProcessorMenu/controls
&
Controls
\\
\hline
ProcessorMenu/copy
&
Copy
\\
\hline
ProcessorMenu/cut
&
Cut
\\
\hline
ProcessorMenu/deactivate\_all
&
Deactivate All
\\
\hline
ProcessorMenu/delete
&
Delete
\\
\hline
ProcessorMenu/deselectall
&
Deselect All
\\
\hline
ProcessorMenu/edit
&
Edit…
\\
\hline
ProcessorMenu/edit-generic
&
Edit with generic controls…
\\
\hline
ProcessorMenu/manage-pins
&
Pin Connections…
\\
\hline
ProcessorMenu/newaux
&
New Aux Send …
\\
\hline
ProcessorMenu/newinsert
&
New Insert
\\
\hline
ProcessorMenu/newplugin
&
New Plugin
\\
\hline
ProcessorMenu/newsend
&
New External Send …
\\
\hline
ProcessorMenu/paste
&
Paste
\\
\hline
ProcessorMenu/rename
&
Rename
\\
\hline
ProcessorMenu/selectall
&
Select All
\\
\hline
ProcessorMenu/send\_options
&
Send Options
\\
\hline
Common/Hide
&
Hide
\\
\hline
Common/NewMIDITracer
&
MIDI Tracer
\\
\hline
Common/Quit
&
Quit
\\
\hline
Common/Save
&
Save
\\
\hline
Common/ToggleMaximalEditor
&
Maximise Editor Space
\\
\hline
Common/ToggleMaximalMixer
&
Maximise Mixer Space
\\
\hline
Common/ToggleMixerList
&
Toggle Mixer List
\\
\hline
Common/ToggleMonitorSection
&
Toggle Monitor Section Visibility
\\
\hline
Common/ToggleRecordEnableTrack1
&
Toggle Record Enable Track 1
\\
\hline
Common/ToggleRecordEnableTrack10
&
Toggle Record Enable Track 10
\\
\hline
Common/ToggleRecordEnableTrack11
&
Toggle Record Enable Track 11
\\
\hline
Common/ToggleRecordEnableTrack12
&
Toggle Record Enable Track 12
\\
\hline
Common/ToggleRecordEnableTrack13
&
Toggle Record Enable Track 13
\\
\hline
Common/ToggleRecordEnableTrack14
&
Toggle Record Enable Track 14
\\
\hline
Common/ToggleRecordEnableTrack15
&
Toggle Record Enable Track 15
\\
\hline
Common/ToggleRecordEnableTrack16
&
Toggle Record Enable Track 16
\\
\hline
Common/ToggleRecordEnableTrack17
&
Toggle Record Enable Track 17
\\
\hline
Common/ToggleRecordEnableTrack18
&
Toggle Record Enable Track 18
\\
\hline
Common/ToggleRecordEnableTrack19
&
Toggle Record Enable Track 19
\\
\hline
Common/ToggleRecordEnableTrack2
&
Toggle Record Enable Track 2
\\
\hline
Common/ToggleRecordEnableTrack20
&
Toggle Record Enable Track 20
\\
\hline
Common/ToggleRecordEnableTrack21
&
Toggle Record Enable Track 21
\\
\hline
Common/ToggleRecordEnableTrack22
&
Toggle Record Enable Track 22
\\
\hline
Common/ToggleRecordEnableTrack23
&
Toggle Record Enable Track 23
\\
\hline
Common/ToggleRecordEnableTrack24
&
Toggle Record Enable Track 24
\\
\hline
Common/ToggleRecordEnableTrack25
&
Toggle Record Enable Track 25
\\
\hline
Common/ToggleRecordEnableTrack26
&
Toggle Record Enable Track 26
\\
\hline
Common/ToggleRecordEnableTrack27
&
Toggle Record Enable Track 27
\\
\hline
Common/ToggleRecordEnableTrack28
&
Toggle Record Enable Track 28
\\
\hline
Common/ToggleRecordEnableTrack29
&
Toggle Record Enable Track 29
\\
\hline
Common/ToggleRecordEnableTrack3
&
Toggle Record Enable Track 3
\\
\hline
Common/ToggleRecordEnableTrack30
&
Toggle Record Enable Track 30
\\
\hline
Common/ToggleRecordEnableTrack31
&
Toggle Record Enable Track 31
\\
\hline
Common/ToggleRecordEnableTrack32
&
Toggle Record Enable Track 32
\\
\hline
Common/ToggleRecordEnableTrack4
&
Toggle Record Enable Track 4
\\
\hline
Common/ToggleRecordEnableTrack5
&
Toggle Record Enable Track 5
\\
\hline
Common/ToggleRecordEnableTrack6
&
Toggle Record Enable Track 6
\\
\hline
Common/ToggleRecordEnableTrack7
&
Toggle Record Enable Track 7
\\
\hline
Common/ToggleRecordEnableTrack8
&
Toggle Record Enable Track 8
\\
\hline
Common/ToggleRecordEnableTrack9
&
Toggle Record Enable Track 9
\\
\hline
Common/add-location-from-playhead
&
Add Mark from Playhead
\\
\hline
Common/addExistingAudioFiles
&
Import
\\
\hline
Common/alt-finish-range
&
Finish Range
\\
\hline
Common/alt-start-range
&
Start Range
\\
\hline
Common/alternate-add-location-fro
m-playhead
&
Add Mark from Playhead
\\
\hline
Common/alternate-jump-backward-to
-mark
&
Jump to Previous Mark
\\
\hline
Common/alternate-jump-forward-to-
mark
&
Jump to Next Mark
\\
\hline
Common/alternate-remove-location-
from-playhead
&
Remove Mark at Playhead
\\
\hline
Common/attach-editor
&
Attach
\\
\hline
Common/attach-mixer
&
Attach
\\
\hline
Common/attach-preferences
&
Attach
\\
\hline
Common/change-editor-visibility
&
Change
\\
\hline
Common/change-mixer-visibility
&
Change
\\
\hline
Common/change-preferences-visibil
ity
&
Change
\\
\hline
Common/chat
&
Chat
\\
\hline
Common/cheat-sheet
&
Cheat Sheet
\\
\hline
Common/detach-editor
&
Detach
\\
\hline
Common/detach-mixer
&
Detach
\\
\hline
Common/detach-preferences
&
Detach
\\
\hline
Common/finish-loop-range
&
Finish Loop Range
\\
\hline
Common/finish-punch-range
&
Finish Punch Range
\\
\hline
Common/finish-range
&
Finish Range
\\
\hline
Common/finish-range-from-playhead
&
Finish Range from Playhead
\\
\hline
Common/forums
&
User Forums
\\
\hline
Common/hide-editor
&
Hide
\\
\hline
Common/hide-mixer
&
Hide
\\
\hline
Common/hide-preferences
&
Hide
\\
\hline
Common/howto-report
&
How to Report a Bug
\\
\hline
Common/jump-backward-to-mark
&
Jump to Previous Mark
\\
\hline
Common/jump-forward-to-mark
&
Jump to Next Mark
\\
\hline
Common/key-change-editor-visibili
ty
&
Change
\\
\hline
Common/key-change-mixer-visibilit
y
&
Change
\\
\hline
Common/key-change-preferences-vis
ibility
&
Change
\\
\hline
Common/manual
&
Manual
\\
\hline
Common/menu-show-preferences
&
Preferences
\\
\hline
Common/next-tab
&
Next Tab
\\
\hline
Common/nudge-next-backward
&
Nudge Next Earlier
\\
\hline
Common/nudge-next-forward
&
Nudge Next Later
\\
\hline
Common/nudge-playhead-backward
&
Nudge Playhead Backward
\\
\hline
Common/nudge-playhead-forward
&
Nudge Playhead Forward
\\
\hline
Common/playhead-backward-to-grid
&
Playhead to Previous Grid
\\
\hline
Common/playhead-forward-to-grid
&
Playhead to Next Grid
\\
\hline
Common/previous-tab
&
Previous Tab
\\
\hline
Common/reference
&
Reference
\\
\hline
Common/remove-location-from-playh
ead
&
Remove Mark at Playhead
\\
\hline
Common/set-session-end-from-playh
ead
&
Set Session End from Playhead
\\
\hline
Common/set-session-start-from-pla
yhead
&
Set Session Start from Playhead
\\
\hline
Common/show-preferences
&
Show
\\
\hline
Common/start-loop-range
&
Start Loop Range
\\
\hline
Common/start-punch-range
&
Start Punch Range
\\
\hline
Common/start-range
&
Start Range
\\
\hline
Common/start-range-from-playhead
&
Start Range from Playhead
\\
\hline
Common/toggle-editor-and-mixer
&
Toggle Editor \& Mixer
\\
\hline
Common/toggle-location-at-playhea
d
&
Toggle Mark at Playhead
\\
\hline
Common/toggle-luawindow
&
Scripting
\\
\hline
Common/toggle-meterbridge
&
Meterbridge
\\
\hline
Common/tracker
&
Report a Bug
\\
\hline
Common/website
&
Ardour Website
\\
\hline
Common/website-dev
&
Ardour Development
\\
\hline
MIDI/panic
&
Panic (Send MIDI all-notes-off)
\\
\hline
Main/AddTrackBus
&
Add Track, Bus or VCA…
\\
\hline
Main/Archive
&
Archive…
\\
\hline
Main/CleanupPeakFiles
&
Reset Peak Files
\\
\hline
Main/CleanupUnused
&
Clean-up Unused Sources…
\\
\hline
Main/Close
&
Close
\\
\hline
Main/CloseVideo
&
Remove Video
\\
\hline
Main/EditMetadata
&
Edit Metadata…
\\
\hline
Main/Escape
&
Escape (deselect all)
\\
\hline
Main/Export
&
Export
\\
\hline
Main/ExportAudio
&
Export to Audio File(s)…
\\
\hline
Main/ExportVideo
&
Export to Video File…
\\
\hline
Main/FlushWastebasket
&
Flush Wastebasket
\\
\hline
Main/ImportMetadata
&
Import Metadata…
\\
\hline
Main/ManageTemplates
&
Templates
\\
\hline
Main/Metadata
&
Metadata
\\
\hline
Main/New
&
New…
\\
\hline
Main/Open
&
Open…
\\
\hline
Main/OpenVideo
&
Open Video…
\\
\hline
Main/QuickSnapshotStay
&
Quick Snapshot (\& keep working on
current version) …
\\
\hline
Main/QuickSnapshotSwitch
&
Quick Snapshot (\& switch to new
version) …
\\
\hline
Main/Recent
&
Recent…
\\
\hline
Main/Rename
&
Rename…
\\
\hline
Main/SaveAs
&
Save As…
\\
\hline
Main/SaveTemplate
&
Save Template…
\\
\hline
Main/Scripting
&
Scripting
\\
\hline
Main/SnapshotStay
&
Snapshot (\& keep working on
current version) …
\\
\hline
Main/SnapshotSwitch
&
Snapshot (\& switch to new
version) …
\\
\hline
Main/StemExport
&
Stem export…
\\
\hline
Main/cancel-solo
&
Cancel Solo
\\
\hline
Main/close-current-dialog
&
Close Current Dialog
\\
\hline
Main/duplicate-routes
&
Duplicate Tracks/Busses…
\\
\hline
Main\_menu/AudioFileFormat
&
Audio File Format
\\
\hline
Main\_menu/AudioFileFormatData
&
Sample Format
\\
\hline
Main\_menu/AudioFileFormatHeader
&
File Type
\\
\hline
Main\_menu/Cleanup
&
Clean-up
\\
\hline
Main\_menu/ControlSurfaces
&
Control Surfaces
\\
\hline
Main\_menu/Denormals
&
Denormal Handling
\\
\hline
Main\_menu/DetachMenu
&
Detach
\\
\hline
Main\_menu/EditorMenu
&
Editor
\\
\hline
Main\_menu/Help
&
Help
\\
\hline
Main\_menu/KeyMouseActions
&
Misc. Shortcuts
\\
\hline
Main\_menu/Metering
&
Metering
\\
\hline
Main\_menu/MeteringFallOffRate
&
Fall Off Rate
\\
\hline
Main\_menu/MeteringHoldTime
&
Hold Time
\\
\hline
Main\_menu/MixerMenu
&
Mixer
\\
\hline
Main\_menu/Plugins
&
Plugins
\\
\hline
Main\_menu/PrefsMenu
&
Preferences
\\
\hline
Main\_menu/Session
&
Session
\\
\hline
Main\_menu/Sync
&
Sync
\\
\hline
Main\_menu/TransportOptions
&
Options
\\
\hline
Main\_menu/WindowMenu
&
Window
\\
\hline
Options/SendMMC
&
Send MMC
\\
\hline
Options/SendMTC
&
Send MTC
\\
\hline
Options/SendMidiClock
&
Send MIDI Clock
\\
\hline
Options/UseMMC
&
Use MMC
\\
\hline
Transport/Forward
&
Forward
\\
\hline
Transport/ForwardFast
&
Forward (Fast)
\\
\hline
Transport/ForwardSlow
&
Forward (Slow)
\\
\hline
Transport/GotoEnd
&
Go to End
\\
\hline
Transport/GotoStart
&
Go to Start
\\
\hline
Transport/GotoWallClock
&
Go to Wall Clock
\\
\hline
Transport/GotoZero
&
Go to Zero
\\
\hline
Transport/Loop
&
Play Loop Range
\\
\hline
Transport/PlayPreroll
&
Play w/Preroll
\\
\hline
Transport/PlaySelection
&
Play Selection
\\
\hline
Transport/Record
&
Enable Record
\\
\hline
Transport/RecordCountIn
&
Record w/Count-In
\\
\hline
Transport/RecordPreroll
&
Record w/Preroll
\\
\hline
Transport/Rewind
&
Rewind
\\
\hline
Transport/RewindFast
&
Rewind (Fast)
\\
\hline
Transport/RewindSlow
&
Rewind (Slow)
\\
\hline
Transport/Roll
&
Roll
\\
\hline
Transport/SessionMonitorDisk
&
All Disk
\\
\hline
Transport/SessionMonitorIn
&
All Input
\\
\hline
Transport/Stop
&
Stop
\\
\hline
Transport/ToggleAutoInput
&
Auto Input
\\
\hline
Transport/ToggleAutoPlay
&
Auto Play
\\
\hline
Transport/ToggleAutoReturn
&
Auto Return
\\
\hline
Transport/ToggleClick
&
Click
\\
\hline
Transport/ToggleExternalSync
&
Use External Positional Sync
Source
\\
\hline
Transport/ToggleFollowEdits
&
Follow Range
\\
\hline
Transport/TogglePunch
&
Punch In/Out
\\
\hline
Transport/TogglePunchIn
&
Punch In
\\
\hline
Transport/TogglePunchOut
&
Punch Out
\\
\hline
Transport/ToggleRoll
&
Start/Stop
\\
\hline
Transport/ToggleRollForgetCapture
&
Stop and Forget Capture
\\
\hline
Transport/ToggleRollMaybe
&
Start/Continue/Stop
\\
\hline
Transport/ToggleTimeMaster
&
Time Master
\\
\hline
Transport/ToggleVideoSync
&
Sync Startup to Video
\\
\hline
Transport/TransitionToReverse
&
Transition to Reverse
\\
\hline
Transport/TransitionToRoll
&
Transition to Roll
\\
\hline
Transport/Transport
&
Transport
\\
\hline
Transport/alternate-GotoStart
&
Go to Start
\\
\hline
Transport/alternate-ToggleRoll
&
Start/Stop
\\
\hline
Transport/alternate-numpad-decima
l
&
Numpad Decimal
\\
\hline
Transport/alternate-record-roll
&
Start Recording
\\
\hline
Transport/focus-on-clock
&
Focus On Clock
\\
\hline
Transport/numpad-0
&
Numpad 0
\\
\hline
Transport/numpad-1
&
Numpad 1
\\
\hline
Transport/numpad-2
&
Numpad 2
\\
\hline
Transport/numpad-3
&
Numpad 3
\\
\hline
Transport/numpad-4
&
Numpad 4
\\
\hline
Transport/numpad-5
&
Numpad 5
\\
\hline
Transport/numpad-6
&
Numpad 6
\\
\hline
Transport/numpad-7
&
Numpad 7
\\
\hline
Transport/numpad-8
&
Numpad 8
\\
\hline
Transport/numpad-9
&
Numpad 9
\\
\hline
Transport/numpad-decimal
&
Numpad Decimal
\\
\hline
Transport/primary-clock-bbt
&
Bars \& Beats
\\
\hline
Transport/primary-clock-minsec
&
Minutes \& Seconds
\\
\hline
Transport/primary-clock-samples
&
Samples
\\
\hline
Transport/primary-clock-timecode
&
Timecode
\\
\hline
Transport/record-roll
&
Start Recording
\\
\hline
Transport/secondary-clock-bbt
&
Bars \& Beats
\\
\hline
Transport/secondary-clock-minsec
&
Minutes \& Seconds
\\
\hline
Transport/secondary-clock-samples
&
Samples
\\
\hline
Transport/secondary-clock-timecod
e
&
Timecode
\\
\hline
Window/show-mixer
&
Show Mixer
\\
\hline
Window/toggle-about
&
About
\\
\hline
Window/toggle-add-routes
&
Add Tracks/Busses
\\
\hline
Window/toggle-add-video
&
Add Video
\\
\hline
Window/toggle-audio-connection-ma
nager
&
Audio Connections
\\
\hline
Window/toggle-audio-midi-setup
&
Audio/MIDI Setup
\\
\hline
Window/toggle-big-clock
&
Big Clock
\\
\hline
Window/toggle-bundle-manager
&
Bundle Manager
\\
\hline
Window/toggle-idle-o-meter
&
Idle’o’Meter
\\
\hline
Window/toggle-inspector
&
Tracks and Busses
\\
\hline
Window/toggle-key-editor
&
Keyboard Shortcuts
\\
\hline
Window/toggle-locations
&
Locations
\\
\hline
Window/toggle-midi-connection-man
ager
&
MIDI Connections
\\
\hline
Window/toggle-script-manager
&
Script Manager
\\
\hline
Window/toggle-session-options-edi
tor
&
Properties
\\
\hline
Window/toggle-speaker-config
&
Speaker Configuration
\\
\hline
Window/toggle-video-export
&
Video Export Dialog
\\
\hline
Editor/SnapMode
&
Snap Mode
\\
\hline
Editor/SnapTo
&
Snap to
\\
\hline
Editor/ToggleGroupTabs
&
Show Group Tabs
\\
\hline
Editor/ToggleJadeo
&
Video Monitor
\\
\hline
Editor/ToggleMeasureVisibility
&
Show Measure Lines
\\
\hline
Editor/ToggleSummary
&
Show Summary
\\
\hline
Editor/addExistingPTFiles
&
Import PT session
\\
\hline
Editor/addExternalAudioToRegionLi
st
&
Import to Region List…
\\
\hline
Editor/alternate-alternate-redo
&
Redo
\\
\hline
Editor/alternate-editor-delete
&
Delete
\\
\hline
Editor/alternate-redo
&
Redo
\\
\hline
Editor/alternate-select-all-after
-edit-cursor
&
Select All After Edit Point
\\
\hline
Editor/alternate-select-all-befor
e-edit-cursor
&
Select All Before Edit Point
\\
\hline
Editor/alternate-tab-to-transient
-backwards
&
Move to Previous Transient
\\
\hline
Editor/alternate-tab-to-transient
-forwards
&
Move to Next Transient
\\
\hline
Editor/bring-into-session
&
Bring all media into session
folder
\\
\hline
Editor/center-edit-cursor
&
Center Edit Point
\\
\hline
Editor/center-playhead
&
Center Playhead
\\
\hline
Editor/crop
&
Crop
\\
\hline
Editor/cycle-edit-mode
&
Cycle Edit Mode
\\
\hline
Editor/cycle-edit-point
&
Change Edit Point
\\
\hline
Editor/cycle-edit-point-with-mark
er
&
Change Edit Point Including
Marker
\\
\hline
Editor/cycle-snap-mode
&
Next Snap Mode
\\
\hline
Editor/cycle-zoom-focus
&
Next Zoom Focus
\\
\hline
Editor/deselect-all
&
Deselect All
\\
\hline
Editor/duplicate
&
Duplicate
\\
\hline
Editor/edit-at-mouse
&
Mouse
\\
\hline
Editor/edit-at-playhead
&
Playhead
\\
\hline
Editor/edit-at-selected-marker
&
Marker
\\
\hline
Editor/edit-current-meter
&
Edit Current Meter
\\
\hline
Editor/edit-current-tempo
&
Edit Current Tempo
\\
\hline
Editor/edit-cursor-to-next-region
-end
&
To Next Region End
\\
\hline
Editor/edit-cursor-to-next-region
-start
&
To Next Region Start
\\
\hline
Editor/edit-cursor-to-next-region
-sync
&
To Next Region Sync
\\
\hline
Editor/edit-cursor-to-previous-re
gion-end
&
To Previous Region End
\\
\hline
Editor/edit-cursor-to-previous-re
gion-start
&
To Previous Region Start
\\
\hline
Editor/edit-cursor-to-previous-re
gion-sync
&
To Previous Region Sync
\\
\hline
Editor/edit-cursor-to-range-end
&
To Range End
\\
\hline
Editor/edit-cursor-to-range-start
&
To Range Start
\\
\hline
Editor/edit-to-playhead
&
Active Mark to Playhead
\\
\hline
Editor/editor-copy
&
Copy
\\
\hline
Editor/editor-crop
&
Crop
\\
\hline
Editor/editor-cut
&
Cut
\\
\hline
Editor/editor-delete
&
Delete
\\
\hline
Editor/editor-fade-range
&
Fade Range Selection
\\
\hline
Editor/editor-paste
&
Paste
\\
\hline
Editor/editor-separate
&
Separate
\\
\hline
Editor/expand-tracks
&
Expand Track Height
\\
\hline
Editor/export-audio
&
Export Audio
\\
\hline
Editor/export-range
&
Export Range
\\
\hline
Editor/fit-selection
&
Fit Selection (Vertical)
\\
\hline
Editor/fit\_16\_tracks
&
Fit 16 Tracks
\\
\hline
Editor/fit\_1\_track
&
Fit 1 Track
\\
\hline
Editor/fit\_2\_tracks
&
Fit 2 Tracks
\\
\hline
Editor/fit\_32\_tracks
&
Fit 32 Tracks
\\
\hline
Editor/fit\_4\_tracks
&
Fit 4 Tracks
\\
\hline
Editor/fit\_8\_tracks
&
Fit 8 Tracks
\\
\hline
Editor/fit\_all\_tracks
&
Fit All Tracks
\\
\hline
Editor/goto-mark-1
&
Locate to Mark 1
\\
\hline
Editor/goto-mark-2
&
Locate to Mark 2
\\
\hline
Editor/goto-mark-3
&
Locate to Mark 3
\\
\hline
Editor/goto-mark-4
&
Locate to Mark 4
\\
\hline
Editor/goto-mark-5
&
Locate to Mark 5
\\
\hline
Editor/goto-mark-6
&
Locate to Mark 6
\\
\hline
Editor/goto-mark-7
&
Locate to Mark 7
\\
\hline
Editor/goto-mark-8
&
Locate to Mark 8
\\
\hline
Editor/goto-mark-9
&
Locate to Mark 9
\\
\hline
Editor/goto-visual-state-1
&
Go to View 1
\\
\hline
Editor/goto-visual-state-10
&
Go to View 10
\\
\hline
Editor/goto-visual-state-11
&
Go to View 11
\\
\hline
Editor/goto-visual-state-12
&
Go to View 12
\\
\hline
Editor/goto-visual-state-2
&
Go to View 2
\\
\hline
Editor/goto-visual-state-3
&
Go to View 3
\\
\hline
Editor/goto-visual-state-4
&
Go to View 4
\\
\hline
Editor/goto-visual-state-5
&
Go to View 5
\\
\hline
Editor/goto-visual-state-6
&
Go to View 6
\\
\hline
Editor/goto-visual-state-7
&
Go to View 7
\\
\hline
Editor/goto-visual-state-8
&
Go to View 8
\\
\hline
Editor/goto-visual-state-9
&
Go to View 9
\\
\hline
Editor/importFromSession
&
Import from Session
\\
\hline
Editor/insert-time
&
Insert Time
\\
\hline
Editor/invert-selection
&
Invert Selection
\\
\hline
Editor/lock
&
Lock
\\
\hline
Editor/main-menu-play-selected-re
gions
&
Play Selected Regions
\\
\hline
Editor/move-range-end-to-next-reg
ion-boundary
&
Move Range End to Next Region
Boundary
\\
\hline
Editor/move-range-end-to-previous
-region-boundary
&
Move Range End to Previous Region
Boundary
\\
\hline
Editor/move-range-start-to-next-r
egion-boundary
&
Move Range Start to Next Region
Boundary
\\
\hline
Editor/move-range-start-to-previo
us-region-boundary
&
Move Range Start to Previous
Region Boundary
\\
\hline
Editor/move-selected-tracks-down
&
Move Selected Tracks Down
\\
\hline
Editor/move-selected-tracks-up
&
Move Selected Tracks Up
\\
\hline
Editor/multi-duplicate
&
Multi-Duplicate…
\\
\hline
Editor/next-snap-choice
&
Next Snap Choice
\\
\hline
Editor/next-snap-choice-music-onl
y
&
Next Musical Snap Choice
\\
\hline
Editor/play-edit-range
&
Play Edit Range
\\
\hline
Editor/play-from-edit-point
&
Play from Edit Point
\\
\hline
Editor/play-from-edit-point-and-r
eturn
&
Play from Edit Point and Return
\\
\hline
Editor/playhead-to-edit
&
Playhead to Active Mark
\\
\hline
Editor/playhead-to-next-region-bo
undary
&
Playhead to Next Region Boundary
\\
\hline
Editor/playhead-to-next-region-bo
undary-noselection
&
Playhead to Next Region Boundary
(No Track Selection)
\\
\hline
Editor/playhead-to-next-region-en
d
&
Playhead to Next Region End
\\
\hline
Editor/playhead-to-next-region-st
art
&
Playhead to Next Region Start
\\
\hline
Editor/playhead-to-next-region-sy
nc
&
Playhead to Next Region Sync
\\
\hline
Editor/playhead-to-previous-regio
n-boundary
&
Playhead to Previous Region
Boundary
\\
\hline
Editor/playhead-to-previous-regio
n-boundary-noselection
&
Playhead to Previous Region
Boundary (No Track Selection)
\\
\hline
Editor/playhead-to-previous-regio
n-end
&
Playhead to Previous Region End
\\
\hline
Editor/playhead-to-previous-regio
n-start
&
Playhead to Previous Region Start
\\
\hline
Editor/playhead-to-previous-regio
n-sync
&
Playhead to Previous Region Sync
\\
\hline
Editor/playhead-to-range-end
&
Playhead to Range End
\\
\hline
Editor/playhead-to-range-start
&
Playhead to Range Start
\\
\hline
Editor/prev-snap-choice
&
Previous Snap Choice
\\
\hline
Editor/prev-snap-choice-music-onl
y
&
Previous Musical Snap Choice
\\
\hline
Editor/quantize
&
Quantize
\\
\hline
Editor/redo
&
Redo
\\
\hline
Editor/redo-last-selection-op
&
Redo Selection Change
\\
\hline
Editor/remove-last-capture
&
Remove Last Capture
\\
\hline
Editor/remove-time
&
Remove Time
\\
\hline
Editor/remove-track
&
Remove
\\
\hline
Editor/save-visual-state-1
&
Save View 1
\\
\hline
Editor/save-visual-state-10
&
Save View 10
\\
\hline
Editor/save-visual-state-11
&
Save View 11
\\
\hline
Editor/save-visual-state-12
&
Save View 12
\\
\hline
Editor/save-visual-state-2
&
Save View 2
\\
\hline
Editor/save-visual-state-3
&
Save View 3
\\
\hline
Editor/save-visual-state-4
&
Save View 4
\\
\hline
Editor/save-visual-state-5
&
Save View 5
\\
\hline
Editor/save-visual-state-6
&
Save View 6
\\
\hline
Editor/save-visual-state-7
&
Save View 7
\\
\hline
Editor/save-visual-state-8
&
Save View 8
\\
\hline
Editor/save-visual-state-9
&
Save View 9
\\
\hline
Editor/script-action-1
&
Unset \#1
\\
\hline
Editor/script-action-2
&
Unset \#2
\\
\hline
Editor/script-action-3
&
Unset \#3
\\
\hline
Editor/script-action-4
&
Unset \#4
\\
\hline
Editor/script-action-5
&
Unset \#5
\\
\hline
Editor/script-action-6
&
Unset \#6
\\
\hline
Editor/script-action-7
&
Unset \#7
\\
\hline
Editor/script-action-8
&
Unset \#8
\\
\hline
Editor/script-action-9
&
Unset \#9
\\
\hline
Editor/scroll-backward
&
Scroll Backward
\\
\hline
Editor/scroll-forward
&
Scroll Forward
\\
\hline
Editor/scroll-playhead-backward
&
Playhead Backward
\\
\hline
Editor/scroll-playhead-forward
&
Playhead Forward
\\
\hline
Editor/scroll-tracks-down
&
Scroll Tracks Down
\\
\hline
Editor/scroll-tracks-up
&
Scroll Tracks Up
\\
\hline
Editor/select-all-after-edit-curs
or
&
Select All After Edit Point
\\
\hline
Editor/select-all-before-edit-cur
sor
&
Select All Before Edit Point
\\
\hline
Editor/select-all-between-cursors
&
Select All Overlapping Edit Range
\\
\hline
Editor/select-all-in-loop-range
&
Select All in Loop Range
\\
\hline
Editor/select-all-in-punch-range
&
Select All in Punch Range
\\
\hline
Editor/select-all-objects
&
Select All Objects
\\
\hline
Editor/select-all-tracks
&
Select All Tracks
\\
\hline
Editor/select-all-within-cursors
&
Select All Inside Edit Range
\\
\hline
Editor/select-from-regions
&
Set Range to Selected Regions
\\
\hline
Editor/select-loop-range
&
Set Range to Loop Range
\\
\hline
Editor/select-next-route
&
Select Next Track or Bus
\\
\hline
Editor/select-next-stripable
&
Select Next Strip
\\
\hline
Editor/select-prev-route
&
Select Previous Track or Bus
\\
\hline
Editor/select-prev-stripable
&
Select Previous Strip
\\
\hline
Editor/select-punch-range
&
Set Range to Punch Range
\\
\hline
Editor/select-range-between-curso
rs
&
Select Edit Range
\\
\hline
Editor/select-topmost
&
Select Topmost Track
\\
\hline
Editor/selected-marker-to-next-re
gion-boundary
&
To Next Region Boundary
\\
\hline
Editor/selected-marker-to-next-re
gion-boundary-noselection
&
To Next Region Boundary (No Track
Selection)
\\
\hline
Editor/selected-marker-to-previou
s-region-boundary
&
To Previous Region Boundary
\\
\hline
Editor/selected-marker-to-previou
s-region-boundary-noselection
&
To Previous Region Boundary (No
Track Selection)
\\
\hline
Editor/separate-from-loop
&
Separate Using Loop Range
\\
\hline
Editor/separate-from-punch
&
Separate Using Punch Range
\\
\hline
Editor/set-auto-punch-range
&
Set Auto Punch In/Out from
Playhead
\\
\hline
Editor/set-edit-lock
&
Lock
\\
\hline
Editor/set-edit-point
&
Active Marker to Mouse
\\
\hline
Editor/set-edit-ripple
&
Ripple
\\
\hline
Editor/set-edit-slide
&
Slide
\\
\hline
Editor/set-loop-from-edit-range
&
Set Loop from Selection
\\
\hline
Editor/set-playhead
&
Playhead to Mouse
\\
\hline
Editor/set-punch-from-edit-range
&
Set Punch from Selection
\\
\hline
Editor/set-session-from-edit-rang
e
&
Set Session Start/End from
Selection
\\
\hline
Editor/set-tempo-from-edit-range
&
Set Tempo from Edit Range = Bar
\\
\hline
Editor/show-editor-list
&
Show Editor List
\\
\hline
Editor/show-editor-mixer
&
Show Editor Mixer
\\
\hline
Editor/show-marker-lines
&
Show Marker Lines
\\
\hline
Editor/shrink-tracks
&
Shrink Track Height
\\
\hline
Editor/snap-magnetic
&
Magnetic
\\
\hline
Editor/snap-normal
&
Grid
\\
\hline
Editor/snap-off
&
No Grid
\\
\hline
Editor/sound-midi-notes
&
Sound Selected MIDI Notes
\\
\hline
Editor/split-region
&
Split/Separate
\\
\hline
Editor/step-mouse-mode
&
Step Mouse Mode
\\
\hline
Editor/step-tracks-down
&
Step Tracks Down
\\
\hline
Editor/step-tracks-up
&
Step Tracks Up
\\
\hline
Editor/tab-to-transient-backwards
&
Move to Previous Transient
\\
\hline
Editor/tab-to-transient-forwards
&
Move to Next Transient
\\
\hline
Editor/temporal-zoom-in
&
Zoom In
\\
\hline
Editor/temporal-zoom-out
&
Zoom Out
\\
\hline
Editor/toggle-follow-playhead
&
Follow Playhead
\\
\hline
Editor/toggle-log-window
&
Log
\\
\hline
Editor/toggle-midi-input-active
&
Toggle MIDI Input Active for
Editor-Selected Tracks/Busses
\\
\hline
Editor/toggle-skip-playback
&
Use Skip Ranges
\\
\hline
Editor/toggle-stationary-playhead
&
Stationary Playhead
\\
\hline
Editor/toggle-track-active
&
Toggle Active
\\
\hline
Editor/toggle-vmon-frame
&
Frame number
\\
\hline
Editor/toggle-vmon-fullscreen
&
Fullscreen
\\
\hline
Editor/toggle-vmon-letterbox
&
Letterbox
\\
\hline
Editor/toggle-vmon-ontop
&
Always on Top
\\
\hline
Editor/toggle-vmon-osdbg
&
Timecode Background
\\
\hline
Editor/toggle-vmon-timecode
&
Timecode
\\
\hline
Editor/toggle-zoom
&
Toggle Zoom State
\\
\hline
Editor/track-height-large
&
Large
\\
\hline
Editor/track-height-larger
&
Larger
\\
\hline
Editor/track-height-largest
&
Largest
\\
\hline
Editor/track-height-normal
&
Normal
\\
\hline
Editor/track-height-small
&
Small
\\
\hline
Editor/track-mute-toggle
&
Toggle Mute
\\
\hline
Editor/track-record-enable-toggle
&
Toggle Record Enable
\\
\hline
Editor/track-solo-isolate-toggle
&
Toggle Solo Isolate
\\
\hline
Editor/track-solo-toggle
&
Toggle Solo
\\
\hline
Editor/undo
&
Undo
\\
\hline
Editor/undo-last-selection-op
&
Undo Selection Change
\\
\hline
Editor/zoom-to-extents
&
Zoom to Extents
\\
\hline
Editor/zoom-to-selection
&
Zoom to Selection
\\
\hline
Editor/zoom-to-selection-horiz
&
Zoom to Selection (Horizontal)
\\
\hline
Editor/zoom-to-session
&
Zoom to Session
\\
\hline
Editor/zoom-vmon-100
&
Original Size
\\
\hline
Editor/zoom\_100\_ms
&
Zoom to 100 ms
\\
\hline
Editor/zoom\_10\_min
&
Zoom to 10 min
\\
\hline
Editor/zoom\_10\_ms
&
Zoom to 10 ms
\\
\hline
Editor/zoom\_10\_sec
&
Zoom to 10 sec
\\
\hline
Editor/zoom\_1\_min
&
Zoom to 1 min
\\
\hline
Editor/zoom\_1\_sec
&
Zoom to 1 sec
\\
\hline
Editor/zoom\_5\_min
&
Zoom to 5 min
\\
\hline
EditorMenu/AlignMenu
&
Align
\\
\hline
EditorMenu/Autoconnect
&
Autoconnect
\\
\hline
EditorMenu/Crossfades
&
Crossfades
\\
\hline
EditorMenu/Edit
&
Edit
\\
\hline
EditorMenu/EditCursorMovementOpti
ons
&
Move Selected Marker
\\
\hline
EditorMenu/EditPointMenu
&
Edit Point
\\
\hline
EditorMenu/EditSelectRangeOptions
&
Select Range Operations
\\
\hline
EditorMenu/EditSelectRegionOption
s
&
Select Regions
\\
\hline
EditorMenu/FadeMenu
&
Fade
\\
\hline
EditorMenu/LatchMenu
&
Latch
\\
\hline
EditorMenu/Link
&
Link
\\
\hline
EditorMenu/LocateToMarker
&
Locate to Markers
\\
\hline
EditorMenu/LuaScripts
&
Lua Scripts
\\
\hline
EditorMenu/MIDI
&
MIDI Options
\\
\hline
EditorMenu/MarkerMenu
&
Markers
\\
\hline
EditorMenu/MeterFalloff
&
Meter falloff
\\
\hline
EditorMenu/MeterHold
&
Meter hold
\\
\hline
EditorMenu/MiscOptions
&
Misc Options
\\
\hline
EditorMenu/Monitoring
&
Monitoring
\\
\hline
EditorMenu/MoveActiveMarkMenu
&
Active Mark
\\
\hline
EditorMenu/MovePlayHeadMenu
&
Playhead
\\
\hline
EditorMenu/PlayMenu
&
Play
\\
\hline
EditorMenu/PrimaryClockMenu
&
Primary Clock
\\
\hline
EditorMenu/Pullup
&
Pullup / Pulldown
\\
\hline
EditorMenu/RegionEditOps
&
Region operations
\\
\hline
EditorMenu/RegionGainMenu
&
Gain
\\
\hline
EditorMenu/RegionMenu
&
Region
\\
\hline
EditorMenu/RegionMenuDuplicate
&
Duplicate
\\
\hline
EditorMenu/RegionMenuEdit
&
Edit
\\
\hline
EditorMenu/RegionMenuFades
&
Fades
\\
\hline
EditorMenu/RegionMenuGain
&
Gain
\\
\hline
EditorMenu/RegionMenuLayering
&
Layering
\\
\hline
EditorMenu/RegionMenuMIDI
&
MIDI
\\
\hline
EditorMenu/RegionMenuPosition
&
Position
\\
\hline
EditorMenu/RegionMenuRanges
&
Ranges
\\
\hline
EditorMenu/RegionMenuTrim
&
Trim
\\
\hline
EditorMenu/RulerMenu
&
Rulers
\\
\hline
EditorMenu/SavedViewMenu
&
Views
\\
\hline
EditorMenu/ScrollMenu
&
Scroll
\\
\hline
EditorMenu/SecondaryClockMenu
&
Secondary Clock
\\
\hline
EditorMenu/Select
&
Select
\\
\hline
EditorMenu/SelectMenu
&
Select
\\
\hline
EditorMenu/SeparateMenu
&
Separate
\\
\hline
EditorMenu/SetLoopMenu
&
Loop
\\
\hline
EditorMenu/SetPunchMenu
&
Punch
\\
\hline
EditorMenu/Solo
&
Solo
\\
\hline
EditorMenu/Subframes
&
Subframes
\\
\hline
EditorMenu/SyncMenu
&
Sync
\\
\hline
EditorMenu/TempoMenu
&
Tempo
\\
\hline
EditorMenu/Timecode
&
Timecode fps
\\
\hline
EditorMenu/Tools
&
Tools
\\
\hline
EditorMenu/TrackHeightMenu
&
Height
\\
\hline
EditorMenu/TrackMenu
&
Track
\\
\hline
EditorMenu/VideoMonitorMenu
&
Video Monitor
\\
\hline
EditorMenu/View
&
View
\\
\hline
EditorMenu/ZoomFocus
&
Zoom Focus
\\
\hline
EditorMenu/ZoomFocusMenu
&
Zoom Focus
\\
\hline
EditorMenu/ZoomMenu
&
Zoom
\\
\hline
MouseMode/set-mouse-mode-audition
&
Audition Tool
\\
\hline
MouseMode/set-mouse-mode-content
&
Content Tool
\\
\hline
MouseMode/set-mouse-mode-cut
&
Cut Tool
\\
\hline
MouseMode/set-mouse-mode-draw
&
Note Drawing Tool
\\
\hline
MouseMode/set-mouse-mode-object
&
Object Tool
\\
\hline
MouseMode/set-mouse-mode-object-r
ange
&
Smart Object Mode
\\
\hline
MouseMode/set-mouse-mode-range
&
Range Tool
\\
\hline
MouseMode/set-mouse-mode-timefx
&
Time FX Tool
\\
\hline
Region/add-range-marker-from-regi
on
&
Add Single Range Marker
\\
\hline
Region/add-range-markers-from-reg
ion
&
Add Range Marker Per Region
\\
\hline
Region/align-regions-end
&
Align End
\\
\hline
Region/align-regions-end-relative
&
Align End Relative
\\
\hline
Region/align-regions-start
&
Align Start
\\
\hline
Region/align-regions-start-relati
ve
&
Align Start Relative
\\
\hline
Region/align-regions-sync
&
Align Sync
\\
\hline
Region/align-regions-sync-relativ
e
&
Align Sync Relative
\\
\hline
Region/alternate-nudge-backward
&
Nudge Earlier
\\
\hline
Region/alternate-nudge-forward
&
Nudge Later
\\
\hline
Region/alternate-set-fade-in-leng
th
&
Set Fade In Length
\\
\hline
Region/alternate-set-fade-out-len
gth
&
Set Fade Out Length
\\
\hline
Region/boost-region-gain
&
Boost Gain
\\
\hline
Region/bounce-regions-processed
&
Bounce (with processing)
\\
\hline
Region/bounce-regions-unprocessed
&
Bounce (without processing)
\\
\hline
Region/choose-top-region
&
Choose Top…
\\
\hline
Region/choose-top-region-context-
menu
&
Choose Top…
\\
\hline
Region/close-region-gaps
&
Close Gaps
\\
\hline
Region/combine-regions
&
Combine
\\
\hline
Region/cut-region-gain
&
Cut Gain
\\
\hline
Region/duplicate-region
&
Duplicate
\\
\hline
Region/export-region
&
Export…
\\
\hline
Region/fork-region
&
Unlink from other copies
\\
\hline
Region/insert-patch-change
&
Insert Patch Change…
\\
\hline
Region/insert-patch-change-contex
t
&
Insert Patch Change…
\\
\hline
Region/insert-region-from-region-
list
&
Insert Region from Region List
\\
\hline
Region/legatize-region
&
Legatize
\\
\hline
Region/loop-region
&
Loop
\\
\hline
Region/loudness-analyze-region
&
Loudness Analysis…
\\
\hline
Region/lower-region
&
Lower
\\
\hline
Region/lower-region-to-bottom
&
Lower to Bottom
\\
\hline
Region/multi-duplicate-region
&
Multi-Duplicate…
\\
\hline
Region/naturalize-region
&
Move to Original Position
\\
\hline
Region/normalize-region
&
Normalize…
\\
\hline
Region/nudge-backward
&
Nudge Earlier
\\
\hline
Region/nudge-backward-by-capture-
offset
&
Nudge Earlier by Capture Offset
\\
\hline
Region/nudge-forward
&
Nudge Later
\\
\hline
Region/nudge-forward-by-capture-o
ffset
&
Nudge Later by Capture Offset
\\
\hline
Region/pitch-shift-region
&
Pitch Shift…
\\
\hline
Region/place-transient
&
Place Transient
\\
\hline
Region/play-selected-regions
&
Play selected Regions
\\
\hline
Region/quantize-region
&
Quantize…
\\
\hline
Region/raise-region
&
Raise
\\
\hline
Region/raise-region-to-top
&
Raise to Top
\\
\hline
Region/region-fill-track
&
Fill Track
\\
\hline
Region/remove-overlap
&
Remove Overlap
\\
\hline
Region/remove-region
&
Remove
\\
\hline
Region/remove-region-sync
&
Remove Sync
\\
\hline
Region/rename-region
&
Rename…
\\
\hline
Region/reset-region-gain
&
Reset Gain
\\
\hline
Region/reset-region-gain-envelope
s
&
Reset Envelope
\\
\hline
Region/reset-region-scale-amplitu
de
&
Reset Gain
\\
\hline
Region/reverse-region
&
Reverse
\\
\hline
Region/separate-under-region
&
Separate Under
\\
\hline
Region/sequence-regions
&
Sequence Regions
\\
\hline
Region/set-fade-in-length
&
Set Fade In Length
\\
\hline
Region/set-fade-out-length
&
Set Fade Out Length
\\
\hline
Region/set-loop-from-region
&
Set Loop Range
\\
\hline
Region/set-punch-from-region
&
Set Punch
\\
\hline
Region/set-region-sync-position
&
Set Sync Position
\\
\hline
Region/set-selection-from-region
&
Set Range Selection
\\
\hline
Region/set-tempo-from-region
&
Set Tempo from Region = Bar
\\
\hline
Region/show-region-list-editor
&
List Editor…
\\
\hline
Region/show-region-properties
&
Properties…
\\
\hline
Region/show-rhythm-ferret
&
Rhythm Ferret…
\\
\hline
Region/snap-regions-to-grid
&
Snap Position to Grid
\\
\hline
Region/spectral-analyze-region
&
Spectral Analysis…
\\
\hline
Region/split-multichannel-region
&
Make Mono Regions
\\
\hline
Region/split-region-at-transients
&
Split at Percussion Onsets
\\
\hline
Region/strip-region-silence
&
Strip Silence…
\\
\hline
Region/toggle-opaque-region
&
Opaque
\\
\hline
Region/toggle-region-fade-in
&
Fade In
\\
\hline
Region/toggle-region-fade-out
&
Fade Out
\\
\hline
Region/toggle-region-fades
&
Fades
\\
\hline
Region/toggle-region-gain-envelop
e-active
&
Envelope Active
\\
\hline
Region/toggle-region-lock
&
Lock
\\
\hline
Region/toggle-region-lock-style
&
Glue to Bars and Beats
\\
\hline
Region/toggle-region-mute
&
Mute
\\
\hline
Region/toggle-region-video-lock
&
Lock to Video
\\
\hline
Region/transform-region
&
Transform…
\\
\hline
Region/transpose-region
&
Transpose…
\\
\hline
Region/trim-back
&
Trim End at Edit Point
\\
\hline
Region/trim-front
&
Trim Start at Edit Point
\\
\hline
Region/trim-region-to-loop
&
Trim to Loop
\\
\hline
Region/trim-region-to-punch
&
Trim to Punch
\\
\hline
Region/trim-to-next-region
&
Trim to Next
\\
\hline
Region/trim-to-previous-region
&
Trim to Previous
\\
\hline
Region/uncombine-regions
&
Uncombine
\\
\hline
RegionList/RegionListSort
&
Sort
\\
\hline
RegionList/SortAscending
&
Ascending
\\
\hline
RegionList/SortByRegionEndinFile
&
By Region End in File
\\
\hline
RegionList/SortByRegionLength
&
By Region Length
\\
\hline
RegionList/SortByRegionName
&
By Region Name
\\
\hline
RegionList/SortByRegionPosition
&
By Region Position
\\
\hline
RegionList/SortByRegionStartinFil
e
&
By Region Start in File
\\
\hline
RegionList/SortByRegionTimestamp
&
By Region Timestamp
\\
\hline
RegionList/SortBySourceFileCreati
onDate
&
By Source File Creation Date
\\
\hline
RegionList/SortBySourceFileLength
&
By Source File Length
\\
\hline
RegionList/SortBySourceFileName
&
By Source File Name
\\
\hline
RegionList/SortBySourceFilesystem
&
By Source Filesystem
\\
\hline
RegionList/SortDescending
&
Descending
\\
\hline
RegionList/removeUnusedRegions
&
Remove Unused
\\
\hline
RegionList/rlAudition
&
Audition
\\
\hline
RegionList/rlHide
&
Hide
\\
\hline
RegionList/rlShow
&
Show
\\
\hline
RegionList/rlShowAll
&
Show All
\\
\hline
RegionList/rlShowAuto
&
Show Automatic Regions
\\
\hline
Rulers/toggle-bbt-ruler
&
Bars \& Beats
\\
\hline
Rulers/toggle-cd-marker-ruler
&
CD Markers
\\
\hline
Rulers/toggle-loop-punch-ruler
&
Loop/Punch
\\
\hline
Rulers/toggle-marker-ruler
&
Markers
\\
\hline
Rulers/toggle-meter-ruler
&
Meter
\\
\hline
Rulers/toggle-minsec-ruler
&
Min:Sec
\\
\hline
Rulers/toggle-range-ruler
&
Ranges
\\
\hline
Rulers/toggle-samples-ruler
&
Samples
\\
\hline
Rulers/toggle-tempo-ruler
&
Tempo
\\
\hline
Rulers/toggle-timecode-ruler
&
Timecode
\\
\hline
Rulers/toggle-video-ruler
&
Video
\\
\hline
Snap/snap-to-asixteenthbeat
&
Snap to Sixteenths
\\
\hline
Snap/snap-to-bar
&
Snap to Bar
\\
\hline
Snap/snap-to-beat
&
Snap to Beat
\\
\hline
Snap/snap-to-cd-frame
&
Snap to CD Frame
\\
\hline
Snap/snap-to-eighths
&
Snap to Eighths
\\
\hline
Snap/snap-to-fifths
&
Snap to Fifths
\\
\hline
Snap/snap-to-fourteenths
&
Snap to Fourteenths
\\
\hline
Snap/snap-to-halves
&
Snap to Halves
\\
\hline
Snap/snap-to-mark
&
Snap to Mark
\\
\hline
Snap/snap-to-minutes
&
Snap to Minutes
\\
\hline
Snap/snap-to-onetwentyeighths
&
Snap to One Twenty Eighths
\\
\hline
Snap/snap-to-quarters
&
Snap to Quarters
\\
\hline
Snap/snap-to-region-boundary
&
Snap to Region Boundary
\\
\hline
Snap/snap-to-region-end
&
Snap to Region End
\\
\hline
Snap/snap-to-region-start
&
Snap to Region Start
\\
\hline
Snap/snap-to-region-sync
&
Snap to Region Sync
\\
\hline
Snap/snap-to-seconds
&
Snap to Seconds
\\
\hline
Snap/snap-to-sevenths
&
Snap to Sevenths
\\
\hline
Snap/snap-to-sixths
&
Snap to Sixths
\\
\hline
Snap/snap-to-sixtyfourths
&
Snap to Sixty Fourths
\\
\hline
Snap/snap-to-tenths
&
Snap to Tenths
\\
\hline
Snap/snap-to-thirds
&
Snap to Thirds
\\
\hline
Snap/snap-to-thirtyseconds
&
Snap to Thirty Seconds
\\
\hline
Snap/snap-to-timecode-frame
&
Snap to Timecode Frame
\\
\hline
Snap/snap-to-timecode-minutes
&
Snap to Timecode Minutes
\\
\hline
Snap/snap-to-timecode-seconds
&
Snap to Timecode Seconds
\\
\hline
Snap/snap-to-twelfths
&
Snap to Twelfths
\\
\hline
Snap/snap-to-twentieths
&
Snap to Twentieths
\\
\hline
Snap/snap-to-twentyeighths
&
Snap to Twenty Eighths
\\
\hline
Snap/snap-to-twentyfourths
&
Snap to Twenty Fourths
\\
\hline
Zoom/zoom-focus-center
&
Zoom Focus Center
\\
\hline
Zoom/zoom-focus-edit
&
Zoom Focus Edit Point
\\
\hline
Zoom/zoom-focus-left
&
Zoom Focus Left
\\
\hline
Zoom/zoom-focus-mouse
&
Zoom Focus Mouse
\\
\hline
Zoom/zoom-focus-playhead
&
Zoom Focus Playhead
\\
\hline
Zoom/zoom-focus-right
&
Zoom Focus Right
\\
\hline
Mixer/ab-plugins
&
Toggle Selected Plugins
\\
\hline
Mixer/copy-processors
&
Copy Selected Processors
\\
\hline
Mixer/cut-processors
&
Cut Selected Processors
\\
\hline
Mixer/decrement-gain
&
Increase Gain on Mixer-Selected
Tracks/Busses
\\
\hline
Mixer/delete-processors
&
Delete Selected Processors
\\
\hline
Mixer/increment-gain
&
Decrease Gain on Mixer-Selected
Tracks/Busses
\\
\hline
Mixer/mute
&
Toggle Mute on Mixer-Selected
Tracks/Busses
\\
\hline
Mixer/paste-processors
&
Paste Selected Processors
\\
\hline
Mixer/recenable
&
Toggle Rec-enable on
Mixer-Selected Tracks/Busses
\\
\hline
Mixer/scroll-left
&
Scroll Mixer Window to the left
\\
\hline
Mixer/scroll-right
&
Scroll Mixer Window to the right
\\
\hline
Mixer/select-all-processors
&
Select All (visible) Processors
\\
\hline
Mixer/select-all-tracks
&
Select All Tracks
\\
\hline
Mixer/select-none
&
Deselect all strips and
processors
\\
\hline
Mixer/show-editor
&
Show Editor
\\
\hline
Mixer/solo
&
Toggle Solo on Mixer-Selected
Tracks/Busses
\\
\hline
Mixer/toggle-midi-input-active
&
Toggle MIDI Input Active for
Mixer-Selected Tracks/Busses
\\
\hline
Mixer/toggle-processors
&
Toggle Selected Processors
\\
\hline
Mixer/unity-gain
&
Set Gain to 0dB on Mixer-Selected
Tracks/Busses
\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}


\chapter{85 - Ardour Monitor Modes}
\label{\detokenize{index:ardour-monitor-modes}}
The table below details what will be seen on the meter and heard on the
monitor according to Ardour’s settings.


\begin{savenotes}\sphinxatlongtablestart\begin{longtable}{|l|l|l|l|l|l|l|l|l|}
\hline
\sphinxstyletheadfamily 
Ref
&\sphinxstyletheadfamily 
Monit
oring
Mode
(Syst
em
Prefs
)
&\sphinxstyletheadfamily 
Tape
Machi
ne
Mode
(Syst
em
Prefs
)
&\sphinxstyletheadfamily 
Track
Rec
Enabl
e
&\sphinxstyletheadfamily 
Maste
r
Rec
Enabl
e
&\sphinxstyletheadfamily 
Trans
port
&\sphinxstyletheadfamily 
Auto
Input
(Sess
ion
Props
)
&\sphinxstyletheadfamily 
Meter
(What
you
see)
&\sphinxstyletheadfamily 
Monit
or
(What
you
hear)
\\
\hline
\endfirsthead

\multicolumn{9}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} -- continued from previous page}}}\\
\hline
\sphinxstyletheadfamily 
Ref
&\sphinxstyletheadfamily 
Monit
oring
Mode
(Syst
em
Prefs
)
&\sphinxstyletheadfamily 
Tape
Machi
ne
Mode
(Syst
em
Prefs
)
&\sphinxstyletheadfamily 
Track
Rec
Enabl
e
&\sphinxstyletheadfamily 
Maste
r
Rec
Enabl
e
&\sphinxstyletheadfamily 
Trans
port
&\sphinxstyletheadfamily 
Auto
Input
(Sess
ion
Props
)
&\sphinxstyletheadfamily 
Meter
(What
you
see)
&\sphinxstyletheadfamily 
Monit
or
(What
you
hear)
\\
\hline
\endhead

\hline
\multicolumn{9}{r}{\makebox[0pt][r]{\sphinxtablecontinued{Continued on next page}}}\\
\endfoot

\endlastfoot

1
&
Ardou
r
&
Off
&
Off
&
Off
&
◼
&
On
&
Input
&
Input
\\
\hline
2
&
Ardou
r
&
Off
&
Off
&
Off
&
◼
&
Off
&
Disk
(Sile
nce)
&
Disk
(Sile
nce)
\\
\hline
3
&
Ardou
r
&
Off
&
Off
&
Off
&
▶
&
On
&
Disk
(Audi
o)
&
Disk
(Audi
o)
\\
\hline
4
&
Ardou
r
&
Off
&
Off
&
Off
&
▶
&
Off
&
Disk
(Audi
o)
&
Disk
(Audi
o)
\\
\hline
5
&
Ardou
r
&
Off
&
Off
&
On
&
◼
&
On
&
Input
&
Input
\\
\hline
6
&
Ardou
r
&
Off
&
Off
&
On
&
◼
&
Off
&
Disk
(Sile
nce)
&
Disk
(Sile
nce)
\\
\hline
7
&
Ardou
r
&
Off
&
Off
&
On
&
▶
&
On
&
Disk
(Audi
o)
&
Disk
(Audi
o)
\\
\hline
8
&
Ardou
r
&
Off
&
Off
&
On
&
▶
&
Off
&
Disk
(Audi
o)
&
Disk
(Audi
o)
\\
\hline
9
&
Ardou
r
&
Off
&
On
&
Off
&
◼
&
On
&
Input
&
Input
\\
\hline
10
&
Ardou
r
&
Off
&
On
&
Off
&
◼
&
Off
&
Input
&
Input
\\
\hline
11
&
Ardou
r
&
Off
&
On
&
Off
&
▶
&
On
&
Input
&
Disk
(Audi
o)
\\
\hline
12
&
Ardou
r
&
Off
&
On
&
Off
&
▶
&
Off
&
Input
&
Input
\\
\hline
13
&
Ardou
r
&
Off
&
On
&
On
&
◼
&
On
&
Input
&
Input
\\
\hline
14
&
Ardou
r
&
Off
&
On
&
On
&
◼
&
Off
&
Input
&
Input
\\
\hline
15
&
Ardou
r
&
Off
&
On
&
On
&
▶
&
On
&
Input
&
Input
\\
\hline
16
&
Ardou
r
&
Off
&
On
&
On
&
▶
&
Off
&
Input
&
Input
\\
\hline
17
&
Ardou
r
&
On
&
Off
&
Off
&
◼
&
On
&
Disk
(Sile
nce)
&
Disk
(Sile
nce)
\\
\hline
18
&
Ardou
r
&
On
&
Off
&
Off
&
◼
&
Off
&
Disk
(Sile
nce)
&
Disk
(Sile
nce)
\\
\hline
19
&
Ardou
r
&
On
&
Off
&
Off
&
▶
&
On
&
Disk
(Audi
o)
&
Disk
(Audi
o)
\\
\hline
20
&
Ardou
r
&
On
&
Off
&
Off
&
▶
&
Off
&
Disk
(Audi
o)
&
Disk
(Audi
o)
\\
\hline
21
&
Ardou
r
&
On
&
Off
&
On
&
◼
&
On
&
Disk
(Sile
nce)
&
Disk
(Sile
nce)
\\
\hline
22
&
Ardou
r
&
On
&
Off
&
On
&
◼
&
Off
&
Disk
(Sile
nce)
&
Disk
(Sile
nce)
\\
\hline
23
&
Ardou
r
&
On
&
Off
&
On
&
▶
&
On
&
Disk
(Audi
o)
&
Disk
(Audi
o)
\\
\hline
24
&
Ardou
r
&
On
&
Off
&
On
&
▶
&
Off
&
Disk
(Audi
o)
&
Disk
(Audi
o)
\\
\hline
25
&
Ardou
r
&
On
&
On
&
Off
&
◼
&
On
&
Input
&
Input
\\
\hline
26
&
Ardou
r
&
On
&
On
&
Off
&
◼
&
Off
&
Input
&
Input
\\
\hline
27
&
Ardou
r
&
On
&
On
&
Off
&
▶
&
On
&
Input
&
Disk
(Audi
o)
\\
\hline
28
&
Ardou
r
&
On
&
On
&
Off
&
▶
&
Off
&
Input
&
Input
\\
\hline
29
&
Ardou
r
&
On
&
On
&
On
&
◼
&
On
&
Input
&
Input
\\
\hline
30
&
Ardou
r
&
On
&
On
&
On
&
◼
&
Off
&
Input
&
Input
\\
\hline
31
&
Ardou
r
&
On
&
On
&
On
&
▶
&
On
&
Input
&
Input
\\
\hline
32
&
Ardou
r
&
On
&
On
&
On
&
▶
&
Off
&
Input
&
Input
\\
\hline
33
&
Audio
Hardw
are
&
Off
&
Off
&
Off
&
◼
&
On
&
Input
&
Silen
ce
\\
\hline
34
&
Audio
Hardw
are
&
Off
&
Off
&
Off
&
◼
&
Off
&
Disk
(Sile
nce)
&
Disk
(Sile
nce)
\\
\hline
35
&
Audio
Hardw
are
&
Off
&
Off
&
Off
&
▶
&
On
&
Disk
(Audi
o)
&
Disk
(Audi
o)
\\
\hline
36
&
Audio
Hardw
are
&
Off
&
Off
&
Off
&
▶
&
Off
&
Disk
(Audi
o)
&
Disk
(Audi
o)
\\
\hline
37
&
Audio
Hardw
are
&
Off
&
Off
&
On
&
◼
&
On
&
Input
&
Silen
ce
\\
\hline
38
&
Audio
Hardw
are
&
Off
&
Off
&
On
&
◼
&
Off
&
Disk
(Sile
nce)
&
Disk
(Sile
nce)
\\
\hline
39
&
Audio
Hardw
are
&
Off
&
Off
&
On
&
▶
&
On
&
Disk
(Audi
o)
&
Disk
(Audi
o)
\\
\hline
40
&
Audio
Hardw
are
&
Off
&
Off
&
On
&
▶
&
Off
&
Disk
(Audi
o)
&
Disk
(Audi
o)
\\
\hline
41
&
Audio
Hardw
are
&
Off
&
On
&
Off
&
◼
&
On
&
Input
&
HW
Pass
Throu
gh
\\
\hline
42
&
Audio
Hardw
are
&
Off
&
On
&
Off
&
◼
&
Off
&
Input
&
HW
Pass
Throu
gh
\\
\hline
43
&
Audio
Hardw
are
&
Off
&
On
&
Off
&
▶
&
On
&
Input
&
Disk
(Audi
o)
\\
\hline
44
&
Audio
Hardw
are
&
Off
&
On
&
Off
&
▶
&
Off
&
Input
&
HW
Pass
Throu
gh
\\
\hline
45
&
Audio
Hardw
are
&
Off
&
On
&
On
&
◼
&
On
&
Input
&
HW
Pass
Throu
gh
\\
\hline
46
&
Audio
Hardw
are
&
Off
&
On
&
On
&
◼
&
Off
&
Input
&
HW
Pass
Throu
gh
\\
\hline
47
&
Audio
Hardw
are
&
Off
&
On
&
On
&
▶
&
On
&
Input
&
HW
Pass
Throu
gh
\\
\hline
48
&
Audio
Hardw
are
&
Off
&
On
&
On
&
▶
&
Off
&
Input
&
HW
Pass
Throu
gh
\\
\hline
49
&
Audio
Hardw
are
&
On
&
Off
&
Off
&
◼
&
On
&
Disk
(Sile
nce)
&
Disk
(Sile
nce)
\\
\hline
50
&
Audio
Hardw
are
&
On
&
Off
&
Off
&
◼
&
Off
&
Disk
(Sile
nce)
&
Disk
(Sile
nce)
\\
\hline
51
&
Audio
Hardw
are
&
On
&
Off
&
Off
&
▶
&
On
&
Disk
(Audi
o)
&
Disk
(Audi
o)
\\
\hline
52
&
Audio
Hardw
are
&
On
&
Off
&
Off
&
▶
&
Off
&
Disk
(Audi
o)
&
Disk
(Audi
o)
\\
\hline
53
&
Audio
Hardw
are
&
On
&
Off
&
On
&
◼
&
On
&
Disk
(Sile
nce)
&
Disk
(Sile
nce)
\\
\hline
54
&
Audio
Hardw
are
&
On
&
Off
&
On
&
◼
&
Off
&
Disk
(Sile
nce)
&
Disk
(Sile
nce)
\\
\hline
55
&
Audio
Hardw
are
&
On
&
Off
&
On
&
▶
&
On
&
Disk
(Audi
o)
&
Disk
(Audi
o)
\\
\hline
56
&
Audio
Hardw
are
&
On
&
Off
&
On
&
▶
&
Off
&
Disk
(Audi
o)
&
Disk
(Audi
o)
\\
\hline
57
&
Audio
Hardw
are
&
On
&
On
&
Off
&
◼
&
On
&
Input
&
HW
Pass
Throu
gh
\\
\hline
58
&
Audio
Hardw
are
&
On
&
On
&
Off
&
◼
&
Off
&
Input
&
HW
Pass
Throu
gh
\\
\hline
59
&
Audio
Hardw
are
&
On
&
On
&
Off
&
▶
&
On
&
Input
&
Disk
(Audi
o)
\\
\hline
60
&
Audio
Hardw
are
&
On
&
On
&
Off
&
▶
&
Off
&
Input
&
HW
Pass
Throu
gh
\\
\hline
61
&
Audio
Hardw
are
&
On
&
On
&
On
&
◼
&
On
&
Input
&
HW
Pass
Throu
gh
\\
\hline
62
&
Audio
Hardw
are
&
On
&
On
&
On
&
◼
&
Off
&
Input
&
HW
Pass
Throu
gh
\\
\hline
63
&
Audio
Hardw
are
&
On
&
On
&
On
&
▶
&
On
&
Input
&
HW
Pass
Throu
gh
\\
\hline
64
&
Audio
Hardw
are
&
On
&
On
&
On
&
▶
&
Off
&
Input
&
HW
Pass
Throu
gh
\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}


\chapter{86 - Files and Directories Ardour Knows About}
\label{\detokenize{index:files-and-directories-ardour-knows-about}}

\section{Configuration Directory}
\label{\detokenize{index:configuration-directory}}
Ardour stores configuration files in two places. The system
configuration directory and the user configuration directory. The system
configuration directory is used for stock configuration files at install
time. The user configuration directory is used by Ardour to store
configuration changes made in the GUI as well as being a place the user
can add control surface device files, scripts etc.

Ardour tries to use standard places for these directories for the
platform it is running on.


\subsection{Linux}
\label{\detokenize{index:linux-2}}\label{\detokenize{index:id463}}
The user configuration directory will be somewhere inside the user’s
home directory. The home directory on a linux system is normally
\sphinxcode{\sphinxupquote{/home/\$USER/}}, but should also be returned by \sphinxcode{\sphinxupquote{\$HOME}} or \sphinxcode{\sphinxupquote{\textasciitilde{}}}. A
normal place to find this is \sphinxcode{\sphinxupquote{\$HOME/.config/ardour*/}} where \sphinxcode{\sphinxupquote{*}} is
the major version. However this can be set by the system with the
\sphinxcode{\sphinxupquote{\$XDG\_CONFIG\_HOME}} environment variable to something else. If you
cannot find \sphinxcode{\sphinxupquote{\$HOME/.config/}} on your system try
\sphinxcode{\sphinxupquote{echo \$\{XDG\_CONFIG\_HOME\}}} to see if your distro is using something
else. In any case Ardour appends the \sphinxcode{\sphinxupquote{ardour*}} directory to the result
where \sphinxcode{\sphinxupquote{*}} is the major version number. For example, \sphinxcode{\sphinxupquote{ardour5}} where
the Ardour version is 5.6.

In Linux, all path names are lowercase and case-sensitive.


\subsection{macOS}
\label{\detokenize{index:macos}}
The user configuration directory on macOS is
\sphinxcode{\sphinxupquote{\$HOME/Library/Preferences/Ardour*/}} where \sphinxcode{\sphinxupquote{*}} is the major version
number. For example, \sphinxcode{\sphinxupquote{Ardour5}} where the Ardour version is 5.6.


\subsection{Windows}
\label{\detokenize{index:windows}}
Windows users are not expected to hand edit configuration files at all.
It is expected configuration options are changed with some sort of GUI
tool. For the most part all of Ardour’s configuration is taken care of
by the GUI in preferences. However, there are devices that may need a
custom file and that would be in the users configuration directory.

Ardour asks the system for this directory and then appends \sphinxcode{\sphinxupquote{Ardour*}}
to the path where \sphinxcode{\sphinxupquote{*}} is the major version number. For example,
\sphinxcode{\sphinxupquote{Ardour5}} where the Ardour version is 5.6. The official path would
look like: \sphinxcode{\sphinxupquote{\%localappdata\%\textbackslash{}Ardour5\textbackslash{}}} Windows expands
\sphinxcode{\sphinxupquote{\%localappdata\%}} to a real path.

An example of a configuration path in Window 10 would be:
\sphinxcode{\sphinxupquote{C:\textbackslash{}\textless{}User\textgreater{}\textbackslash{}AppData\textbackslash{}Local\textbackslash{}Ardour5\textbackslash{}}} The user in the path would be the
user’s account name.

The above is only an example and may not even be true for all
installations of Windows 10.


\section{Plugins}
\label{\detokenize{index:plugins-1}}\label{\detokenize{index:id464}}
Plugins will be installed in various places, some by standard and some
by developer whim. Some are installed incorrectly by distro policy.


\subsection{Linux}
\label{\detokenize{index:linux-3}}\label{\detokenize{index:id465}}
In linux there are 3 kinds of plugins Ardour can use. LADSPA, LV2
(LADSPA version 2) or lxvst (VSTs compiled as native linux binaries).
While it is possible with some strange magic to run {\hyperref[\detokenize{index:using-windows-vst-plugins-on-linux}]{\emph{Windows
VSTs}}} on linux, their
whereabouts would follow the Windows info below.


\subsubsection{LADSPA}
\label{\detokenize{index:id466}}
LADSPA plugins should be found in \sphinxcode{\sphinxupquote{/usr/lib/ladspa/}},
\sphinxcode{\sphinxupquote{/usr/local/lib/ladspa/}} or in a directory mentioned in your
LADSPA\_PATH environment variable. The most common mistake made by distro
packagers, is to use a path like \sphinxcode{\sphinxupquote{/usr/lib/\$ARCH/ladspa/}} and find
that Ardour will not find that by default. The user can either add a
link from this actual directory to the standard directory or add this
path to LADSPA\_PATH.


\subsubsection{LV2}
\label{\detokenize{index:id467}}
LADSPA plugins should be found in \sphinxcode{\sphinxupquote{/usr/lib/lv2/}},
\sphinxcode{\sphinxupquote{/usr/local/lib/lv2/}} or in a directory mentioned in your LV2\_PATH
environment variable. The most common mistake made by distro packagers,
is to use a path like \sphinxcode{\sphinxupquote{/usr/lib/\$ARCH/lv2/}} and find that Ardour will
not find that by default. The user can either add a link from this
actual directory to the standard directory or add this path to LV2\_PATH.


\subsubsection{Linux VST or lxvst}
\label{\detokenize{index:linux-vst-or-lxvst}}
They are typically installed in \sphinxcode{\sphinxupquote{/usr/lib/lxvst}},
\sphinxcode{\sphinxupquote{/usr/local/lib/lxvst}} or a directory mentioned in your LXVST\_PATH
environment variable. However, this is not a standard and the VST plugin
developer may install the plugin just about anywhere. Therefore Ardour
allows the user to set extra VST paths in the preferences GUI under
Plugins\textgreater{}VST.


\subsection{macOS}
\label{\detokenize{index:macos-1}}\label{\detokenize{index:id468}}
On the Mac, plugins are expected to be installed correctly Ardour uses
the system tool to scan for AU style plugins and LV2s should be in the
right place. LV2 should be in \sphinxcode{\sphinxupquote{\$HOME/Library/Audio/Plug-Ins/LV2/}}
\sphinxcode{\sphinxupquote{/Library/Audio/Plug-Ins/LV2/}} \sphinxcode{\sphinxupquote{/usr/local/lib/lv2/}}
\sphinxcode{\sphinxupquote{/usr/lib/lv2/}} If an AU or LV2 plugin does not show up on a Mac it is
probably a development fault with the plugin and the plugin will not
work with anything. Ardour in Ardour 5.6 has support for native VST
plugins. That is VST plugins built for OSX. I am not sure if these have
a standard place to be, but as with other VSTs the search path can be
edited at Plugins\textgreater{}VST.


\subsection{Windows}
\label{\detokenize{index:windows-1}}\label{\detokenize{index:id469}}
The most common plugins on Windows are VSTs. However, LADSPA and LV2
plugins are available for windows as well. In fact Ardour’s built in
plugins are LV2s. The biggest advantage of LV2 plugins is that they are
the most likely to be cross platform and therefore allow the same Ardour
project to be worked on in Windows, OSX and Linux.


\subsubsection{VST}
\label{\detokenize{index:vst-1}}\label{\detokenize{index:id470}}
As with other platforms, VSTs on Windows do not have a standard place to
reside. Ardour Preferences\textgreater{}Plugins\textgreater{}VST allows setting the VST path from
the GUI.


\subsubsection{LV2}
\label{\detokenize{index:lv2-1}}\label{\detokenize{index:id471}}
The LV2 standard for Windows is \sphinxcode{\sphinxupquote{\%APPDATA\%/LV2/}} (On Windows 10:
\sphinxcode{\sphinxupquote{C:\textbackslash{}\textless{}User\textgreater{}\textbackslash{}AppData\textbackslash{}Roaming\textbackslash{}LV2\textbackslash{}}})\%COMMONPROGRAMFILES\%/LV2/ (On Windows
10: \sphinxcode{\sphinxupquote{C:\textbackslash{}Program Files\textbackslash{}LV2\textbackslash{}}}).


\section{Project Directory}
\label{\detokenize{index:project-directory}}
Ardour places a project directory where the user tells it to. This
directory is chosen when creating a project. In most cases the user does
not need to know about the files inside of the project directory.
However there are a few sub-directories worth noting.


\subsection{export}
\label{\detokenize{index:export-1}}\label{\detokenize{index:id472}}
This is the sub-directory where exported files end up.


\chapter{87 - MIDI notes reference}
\label{\detokenize{index:midi-notes-reference}}\label{\detokenize{index:midi-notes-ref}}
The table below lists the MIDI notes, numbers and frequency. Ardour uses
the \sphinxstyleemphasis{middle C = C4 (note 60)} convention, meaning that the first
(lowest) octave is −1.

Frequency calculations are based on \sphinxstyleemphasis{A4 = 440 Hz}.


\begin{savenotes}\sphinxatlongtablestart\begin{longtable}{|l|l|l|l|l|l|}
\hline

\endfirsthead

\multicolumn{6}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} -- continued from previous page}}}\\
\hline

\endhead

\hline
\multicolumn{6}{r}{\makebox[0pt][r]{\sphinxtablecontinued{Continued on next page}}}\\
\endfoot

\endlastfoot

MIDI
number
&
MIDI
(english)
Note Name
&
German
Note Name
&
Neo-Latin
Note Name
&
Octave
&
Frequency
(Hz)
\sphinxstyleemphasis{Rounded
at
10-3}
\\
\hline
0
&
C
&
C
&
Do
&
-1
&
8.176
\\
\hline
1
&
C\#/D♭
&
C\#/D♭
&
Do\#/Re♭
&
-1
&
8.662
\\
\hline
2
&
D
&
D
&
Re
&
-1
&
9.177
\\
\hline
3
&
D\#/E♭
&
D\#/E♭
&
Re\#/Mi♭
&
-1
&
9.723
\\
\hline
4
&
E
&
E
&
Mi
&
-1
&
10.301
\\
\hline
5
&
F
&
F
&
Fa
&
-1
&
10.913
\\
\hline
6
&
F\#/G♭
&
F\#/G♭
&
Fa\#/Sol♭
&
-1
&
11.562
\\
\hline
7
&
G
&
G
&
Sol
&
-1
&
12.250
\\
\hline
8
&
G\#/A♭
&
G\#/A♭
&
Sol\#/La♭
&
-1
&
12.978
\\
\hline
9
&
A
&
A
&
La
&
-1
&
13.750
\\
\hline
10
&
A\#/B♭
&
A\#/B
&
La\#/Si♭
&
-1
&
14.568
\\
\hline
11
&
B
&
H
&
Si
&
-1
&
15.434
\\
\hline
12
&
C
&
C
&
Do
&
0
&
16.352
\\
\hline
13
&
C\#/D♭
&
C\#/D♭
&
Do\#/Re♭
&
0
&
17.324
\\
\hline
14
&
D
&
D
&
Re
&
0
&
18.354
\\
\hline
15
&
D\#/E♭
&
D\#/E♭
&
Re\#/Mi♭
&
0
&
19.445
\\
\hline
16
&
E
&
E
&
Mi
&
0
&
20.602
\\
\hline
17
&
F
&
F
&
Fa
&
0
&
21.827
\\
\hline
18
&
F\#/G♭
&
F\#/G♭
&
Fa\#/Sol♭
&
0
&
23.125
\\
\hline
19
&
G
&
G
&
Sol
&
0
&
24.500
\\
\hline
20
&
G\#/A♭
&
G\#/A♭
&
Sol\#/La♭
&
0
&
25.957
\\
\hline
21
&
A
&
A
&
La
&
0
&
27.500
\\
\hline
22
&
A\#/B♭
&
A\#/B
&
La\#/Si♭
&
0
&
29.135
\\
\hline
23
&
B
&
H
&
Si
&
0
&
30.868
\\
\hline
24
&
C
&
C
&
Do
&
1
&
32.703
\\
\hline
25
&
C\#/D♭
&
C\#/D♭
&
Do\#/Re♭
&
1
&
34.648
\\
\hline
26
&
D
&
D
&
Re
&
1
&
36.708
\\
\hline
27
&
D\#/E♭
&
D\#/E♭
&
Re\#/Mi♭
&
1
&
38.891
\\
\hline
28
&
E
&
E
&
Mi
&
1
&
41.203
\\
\hline
29
&
F
&
F
&
Fa
&
1
&
43.654
\\
\hline
30
&
F\#/G♭
&
F\#/G♭
&
Fa\#/Sol♭
&
1
&
46.249
\\
\hline
31
&
G
&
G
&
Sol
&
1
&
48.999
\\
\hline
32
&
G\#/A♭
&
G\#/A♭
&
Sol\#/La♭
&
1
&
51.913
\\
\hline
33
&
A
&
A
&
La
&
1
&
55.000
\\
\hline
34
&
A\#/B♭
&
A\#/B
&
La\#/Si♭
&
1
&
58.270
\\
\hline
35
&
B
&
H
&
Si
&
1
&
61.735
\\
\hline
36
&
C
&
C
&
Do
&
2
&
65.406
\\
\hline
37
&
C\#/D♭
&
C\#/D♭
&
Do\#/Re♭
&
2
&
69.296
\\
\hline
38
&
D
&
D
&
Re
&
2
&
73.416
\\
\hline
39
&
D\#/E♭
&
D\#/E♭
&
Re\#/Mi♭
&
2
&
77.782
\\
\hline
40
&
E
&
E
&
Mi
&
2
&
82.407
\\
\hline
41
&
F
&
F
&
Fa
&
2
&
87.307
\\
\hline
42
&
F\#/G♭
&
F\#/G♭
&
Fa\#/Sol♭
&
2
&
92.499
\\
\hline
43
&
G
&
G
&
Sol
&
2
&
97.999
\\
\hline
44
&
G\#/A♭
&
G\#/A♭
&
Sol\#/La♭
&
2
&
103.826
\\
\hline
45
&
A
&
A
&
La
&
2
&
110.000
\\
\hline
46
&
A\#/B♭
&
A\#/B
&
La\#/Si♭
&
2
&
116.541
\\
\hline
47
&
B
&
H
&
Si
&
2
&
123.471
\\
\hline
48
&
C
&
C
&
Do
&
3
&
130.813
\\
\hline
49
&
C\#/D♭
&
C\#/D♭
&
Do\#/Re♭
&
3
&
138.591
\\
\hline
50
&
D
&
D
&
Re
&
3
&
146.832
\\
\hline
51
&
D\#/E♭
&
D\#/E♭
&
Re\#/Mi♭
&
3
&
155.563
\\
\hline
52
&
E
&
E
&
Mi
&
3
&
164.814
\\
\hline
53
&
F
&
F
&
Fa
&
3
&
174.614
\\
\hline
54
&
F\#/G♭
&
F\#/G♭
&
Fa\#/Sol♭
&
3
&
184.997
\\
\hline
55
&
G
&
G
&
Sol
&
3
&
195.998
\\
\hline
56
&
G\#/A♭
&
G\#/A♭
&
Sol\#/La♭
&
3
&
207.652
\\
\hline
57
&
A
&
A
&
La
&
3
&
220.000
\\
\hline
58
&
A\#/B♭
&
A\#/B
&
La\#/Si♭
&
3
&
233.082
\\
\hline
59
&
B
&
H
&
Si
&
3
&
246.942
\\
\hline
60
&
C
&
C
&
Do
&
4
&
261.626
\\
\hline
61
&
C\#/D♭
&
C\#/D♭
&
Do\#/Re♭
&
4
&
277.183
\\
\hline
62
&
D
&
D
&
Re
&
4
&
293.665
\\
\hline
63
&
D\#/E♭
&
D\#/E♭
&
Re\#/Mi♭
&
4
&
311.127
\\
\hline
64
&
E
&
E
&
Mi
&
4
&
329.628
\\
\hline
65
&
F
&
F
&
Fa
&
4
&
349.228
\\
\hline
66
&
F\#/G♭
&
F\#/G♭
&
Fa\#/Sol♭
&
4
&
369.994
\\
\hline
67
&
G
&
G
&
Sol
&
4
&
391.995
\\
\hline
68
&
G\#/A♭
&
G\#/A♭
&
Sol\#/La♭
&
4
&
415.305
\\
\hline
69
&
A
&
A
&
La
&
4
&
440.000
\\
\hline
70
&
A\#/B♭
&
A\#/B
&
La\#/Si♭
&
4
&
466.164
\\
\hline
71
&
B
&
H
&
Si
&
4
&
493.883
\\
\hline
72
&
C
&
C
&
Do
&
5
&
523.251
\\
\hline
73
&
C\#/D♭
&
C\#/D♭
&
Do\#/Re♭
&
5
&
554.365
\\
\hline
74
&
D
&
D
&
Re
&
5
&
587.330
\\
\hline
75
&
D\#/E♭
&
D\#/E♭
&
Re\#/Mi♭
&
5
&
622.254
\\
\hline
76
&
E
&
E
&
Mi
&
5
&
659.255
\\
\hline
77
&
F
&
F
&
Fa
&
5
&
698.456
\\
\hline
78
&
F\#/G♭
&
F\#/G♭
&
Fa\#/Sol♭
&
5
&
739.989
\\
\hline
79
&
G
&
G
&
Sol
&
5
&
783.991
\\
\hline
80
&
G\#/A♭
&
G\#/A♭
&
Sol\#/La♭
&
5
&
830.609
\\
\hline
81
&
A
&
A
&
La
&
5
&
880.000
\\
\hline
82
&
A\#/B♭
&
A\#/B
&
La\#/Si♭
&
5
&
932.328
\\
\hline
83
&
B
&
H
&
Si
&
5
&
987.767
\\
\hline
84
&
C
&
C
&
Do
&
6
&
1 046.502
\\
\hline
85
&
C\#/D♭
&
C\#/D♭
&
Do\#/Re♭
&
6
&
1 108.731
\\
\hline
86
&
D
&
D
&
Re
&
6
&
1 174.659
\\
\hline
87
&
D\#/E♭
&
D\#/E♭
&
Re\#/Mi♭
&
6
&
1 244.508
\\
\hline
88
&
E
&
E
&
Mi
&
6
&
1 318.510
\\
\hline
89
&
F
&
F
&
Fa
&
6
&
1 396.913
\\
\hline
90
&
F\#/G♭
&
F\#/G♭
&
Fa\#/Sol♭
&
6
&
1 479.978
\\
\hline
91
&
G
&
G
&
Sol
&
6
&
1 567.982
\\
\hline
92
&
G\#/A♭
&
G\#/A♭
&
Sol\#/La♭
&
6
&
1 661.219
\\
\hline
93
&
A
&
A
&
La
&
6
&
1 760.000
\\
\hline
94
&
A\#/B♭
&
A\#/B
&
La\#/Si♭
&
6
&
1 864.655
\\
\hline
95
&
B
&
H
&
Si
&
6
&
1 975.533
\\
\hline
96
&
C
&
C
&
Do
&
7
&
2 093.005
\\
\hline
97
&
C\#/D♭
&
C\#/D♭
&
Do\#/Re♭
&
7
&
2 217.461
\\
\hline
98
&
D
&
D
&
Re
&
7
&
2 349.318
\\
\hline
99
&
D\#/E♭
&
D\#/E♭
&
Re\#/Mi♭
&
7
&
2 489.016
\\
\hline
100
&
E
&
E
&
Mi
&
7
&
2 637.020
\\
\hline
101
&
F
&
F
&
Fa
&
7
&
2 793.826
\\
\hline
102
&
F\#/G♭
&
F\#/G♭
&
Fa\#/Sol♭
&
7
&
2 959.955
\\
\hline
103
&
G
&
G
&
Sol
&
7
&
3 135.963
\\
\hline
104
&
G\#/A♭
&
G\#/A♭
&
Sol\#/La♭
&
7
&
3 322.438
\\
\hline
105
&
A
&
A
&
La
&
7
&
3 520.000
\\
\hline
106
&
A\#/B♭
&
A\#/B
&
La\#/Si♭
&
7
&
3 729.310
\\
\hline
107
&
B
&
H
&
Si
&
7
&
3 951.066
\\
\hline
108
&
C
&
C
&
Do
&
8
&
4 186.009
\\
\hline
109
&
C\#/D♭
&
C\#/D♭
&
Do\#/Re♭
&
8
&
4 434.922
\\
\hline
110
&
D
&
D
&
Re
&
8
&
4 698.636
\\
\hline
111
&
D\#/E♭
&
D\#/E♭
&
Re\#/Mi♭
&
8
&
4 978.032
\\
\hline
112
&
E
&
E
&
Mi
&
8
&
5 274.041
\\
\hline
113
&
F
&
F
&
Fa
&
8
&
5 587.652
\\
\hline
114
&
F\#/G♭
&
F\#/G♭
&
Fa\#/Sol♭
&
8
&
5 919.911
\\
\hline
115
&
G
&
G
&
Sol
&
8
&
6 271.927
\\
\hline
116
&
G\#/A♭
&
G\#/A♭
&
Sol\#/La♭
&
8
&
6 644.875
\\
\hline
117
&
A
&
A
&
La
&
8
&
7 040.000
\\
\hline
118
&
A\#/B♭
&
A\#/B
&
La\#/Si♭
&
8
&
7 458.620
\\
\hline
119
&
B
&
H
&
Si
&
8
&
7 902.133
\\
\hline
120
&
C
&
C
&
Do
&
9
&
8 372.018
\\
\hline
121
&
C\#/D♭
&
C\#/D♭
&
Do\#/Re♭
&
9
&
8 869.844
\\
\hline
122
&
D
&
D
&
Re
&
9
&
9 397.273
\\
\hline
123
&
D\#/E♭
&
D\#/E♭
&
Re\#/Mi♭
&
9
&
9 956.063
\\
\hline
124
&
E
&
E
&
Mi
&
9
&
10
548.082
\\
\hline
125
&
F
&
F
&
Fa
&
9
&
11
175.303
\\
\hline
126
&
F\#/G♭
&
F\#/G♭
&
Fa\#/Sol♭
&
9
&
11
839.822
\\
\hline
127
&
G
&
G
&
Sol
&
9
&
12
543.854
\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}



\renewcommand{\indexname}{Index}
\printindex
\end{document}